@extends "ruby/method_sample.snip"
@extends "ruby/common.snip"
@extends "ruby/initcode.snip"

@snippet generate(apiTest)
  {@header(apiTest.fileHeader)}

  {@helpers()}

  @join testClass : apiTest.testClasses
    describe {@testClass.fullyQualifiedApiClassName} do
      error = CustomError.new "Test error"
      @join test : testClass.testCases
        @if testCase(test)

          {@testCase(test)}
        @end
      @end
    end
  @end
@end

@private header(fileHeader)
  {@license(fileHeader)}

  {@importList(fileHeader.importSection.standardImports)}

  {@importList(fileHeader.importSection.appImports)}
@end

@private helpers()
  class CustomError < StandardError; end
@end

@private testCase(test)
  @switch test.grpcStreamingType
  @case "NonStreaming"
    @switch test.clientMethodType
    @case "RequestObjectMethod"
      {@requestObjectTestCase(test)}
    @case "PagedRequestObjectMethod"
    @case "OperationCallableMethod"
    @default
      $unhandled case: {@test.clientMethodType.toString}$
    @end
  @case "ServerStreaming"
  @case "BidiStreaming"
  @default
    $unhandled case: {@test.grpcStreamingType.toString}$
  @end
@end

@private requestObjectTestCase(test)
  describe '{@test.clientMethodName}' do

    @if {@aliasSection(test.initCode.importSection)}
      {@aliasSection(test.initCode.importSection)}

    @end
    it 'invokes {@test.clientMethodName} without error' do
      @# Create request parameters and expected request
      {@initCode(test.initCode)}
      @if test.hasReturnValue

        @# Create expected grpc response
        {@initCode(test.mockResponse.initCode)}
      @end

      @# Mock Grpc layer
      client = {@test.serviceConstructorName}.new
      {@mockUnaryRequest(test)}

      @# Call method
      {@methodCallWithResponse(test)}

      @# Verify the response
      @if test.hasReturnValue
        assert_equal(expected_response, response)
      @else
        assert_nil(response)
      @end
    end

    {@simpleTestWithError(test)}
  end
@end

@private mockUnaryRequest(test)
  client.instance_variable_set(
    "@@{@test.clientMethodName}",
    proc do |request|
      {@requestAsserts(test)}
      @if test.hasReturnValue
        expected_response
      @else
        nil
      @end
    end
  )
@end

@private mockUnaryError(test)
  client.instance_variable_set(
    "@@{@test.clientMethodName}",
    proc do |request|
      {@requestAsserts(test)}
      raise error
    end
  )
@end

@private requestAsserts(test)
   @join assert : test.asserts
     @if assert.hasExpectedValueTransformFunction
       assert_equal(\
         {@assert.expectedValueTransformFunction}(\
             {@assert.expectedValueIdentifier}), \
         request.{@assert.actualValueGetter})
     @else
       assert_equal(\
         {@assert.expectedValueIdentifier}, \
         request.{@assert.actualValueGetter})
     @end
   @end
@end

@private simpleTestWithError(test)
  it 'invokes {@test.clientMethodName} with error' do
    @# Create request parameters and expected request
    {@initCode(test.initCode)}

    @# Mock Grpc layer
    client = {@test.serviceConstructorName}.new
    {@mockUnaryError(test)}

    @# Call method
    assert_raises CustomError do
      {@methodCall(test)}
    end
  end
@end

@private methodCallWithResponse(test)
  @if @test.initCode.hasManyFieldSettings
    response = client.{@test.clientMethodName}(
      {@multilineArgList(test.initCode.fieldSettings)}
    )
  @else
    response = client.{@test.clientMethodName}({@argList(test.initCode.fieldSettings)})
  @end
@end

@private methodCall(test)
  @if @test.initCode.hasManyFieldSettings
    client.{@test.clientMethodName}(
      {@multilineArgList(test.initCode.fieldSettings)}
    )
  @else
    client.{@test.clientMethodName}({@argList(test.initCode.fieldSettings)})
  @end
@end

@private argList(fieldSettings)
  @join fieldSetting : fieldSettings on ", "
    {@fieldSetting.identifier}
  @end
@end

@private multilineArgList(fieldSettings)
  @join fieldSetting : fieldSettings on ",".add(BREAK)
    {@fieldSetting.identifier}
  @end
@end
