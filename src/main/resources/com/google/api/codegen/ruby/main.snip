@extends "ruby/common.snip"
# Replace old method sample when all views migrated
@extends "ruby/method_sample2.snip"

@snippet generate(apiView)
  {@renderFileHeader(apiView)}

  {@serviceClass(apiView)}

@end

@private renderFileHeader(apiView)
  {@license(apiView)}
  @#
  @# EDITING INSTRUCTIONS
  @# This file was generated from the file
  @# https://github.com/googleapis/googleapis/blob/master/{@apiView.protoFilename},
  @# and updates to that file get reflected here through a refresh process.
  @# For the short term, the refresh process will only be runnable by Google
  @# engineers.

  require "json"
  require "pathname"

  require "google/gax"
  @if apiView.hasLongRunningOperations
    require "google/gax/operation"
    require "google/longrunning/operations_client"
  @end
  @if apiView.isLongrunningClient
    require "googleauth"
  @end

  @join import : apiView.appImports
    require "{@import}"
  @end
@end

@private serviceClass(apiView)
  @let body = serviceClassBody(apiView)
    {@module(apiView.modules.iterator, body) }
  @end
@end

@private serviceClassBody(apiView)
  @if apiView.docLines
    {@toComments(apiView.docLines)}
    @#

  @end
  {@stubComments(apiView.stubs)}
  class {@apiView.name.toUpperCamel}
    attr_reader {@listStubNames(apiView.stubs)}

    {@constantSection(apiView)}
    @if apiView.pathTemplates
      {@pathTemplateSection(apiView)}
    @end

    {@initMethodSection(apiView)}

    {@serviceMethodsSection(apiView)}
  end
@end

@private stubComments(stubs)
  @join stub : stubs
    @# @@!attribute [r] {@stub.getValue}
    @#   @@return [{@stub.getKey}]
  @end
@end

@private listStubNames(stubs)
  @join stub : stubs on ", "
    :{@stub.getValue}
  @end
@end

@private constantSection(apiView)
  @# The default address of the service.
  SERVICE_ADDRESS = "{@apiView.serviceAddress}".freeze

  @# The default port of the service.
  DEFAULT_SERVICE_PORT = {@apiView.servicePort}

  DEFAULT_TIMEOUT = 30
  @if apiView.pageStreamingDescriptors

    PAGE_DESCRIPTORS = {
      @join descriptor : apiView.pageStreamingDescriptors on {@", "}.add(BREAK)
        "{@descriptor.methodName}" => Google::Gax::PageDescriptor.new(
          "{@descriptor.requestTokenFieldName}",
          "{@descriptor.responseTokenFieldName}",
          "{@descriptor.resourcesFieldName}")
      @end
    }.freeze

    private_constant :PAGE_DESCRIPTORS
  @end
  @if apiView.batchingDescriptors

    BUNDLE_DESCRIPTORS = {
      @join descriptor : apiView.batchingDescriptors on {@", "}.add(BREAK)
        "{@descriptor.methodName}" => Google::Gax::BundleDescriptor.new(
          {@batchDescriptorBody(descriptor)})
      @end
    }.freeze

    private_constant :BUNDLE_DESCRIPTORS
  @end

  @# The scopes needed to make gRPC calls to all of the methods defined in
  @# this service.
  ALL_SCOPES = [
    @join authScopes : apiView.authScopes on ",".add(BREAK)
      "{@authScopes}"
    @end
  ].freeze

  @if apiView.hasLongRunningOperations
    class OperationsClient < Google::Longrunning::OperationsClient
      self::SERVICE_ADDRESS = {@apiView.name.toUpperCamel}::SERVICE_ADDRESS
    end
  @end
@end

@private constructDefaults(apiView)
  client_config_file = Pathname.new(__dir__).join(
    "{@apiView.clientConfigPath}"
  )
  defaults = client_config_file.open do |f|
    Google::Gax.construct_settings(
      "{@apiView.interfaceKey}",
      JSON.parse(f.read),
      client_config,
      Google::Gax::Grpc::STATUS_CODE_NAMES,
      timeout,
      @if apiView.batchingDescriptors
        bundle_descriptors: BUNDLE_DESCRIPTORS,
      @end
      @if apiView.pageStreamingDescriptors
        page_descriptors: PAGE_DESCRIPTORS,
      @end
      errors: Google::Gax::Grpc::API_ERRORS,
      metadata: headers
    )
  end
@end

@private initMethodSection(apiView)
  {@toComments(util.getDocLines(initMethodComments()))}
  def initialize @\
      credentials: nil,
      scopes: ALL_SCOPES,
      client_config: {},
      timeout: DEFAULT_TIMEOUT,
      metadata: nil,
      exception_transformer: nil,
      lib_name: nil,
      lib_version: ""
    @# These require statements are intentionally placed here to initialize
    @# the gRPC module only when it's required.
    @# See https://github.com/googleapis/toolkit/issues/446
    @join import : apiView.serviceImports
      require "{@import}"
    @end

    credentials ||= {@apiView.fullyQualifiedCredentialsClassName}.{@apiView.defaultCredentialsInitializerCall}

    @if apiView.hasLongRunningOperations
      @@operations_client = OperationsClient.new(
        credentials: credentials,
        scopes: scopes,
        client_config: client_config,
        timeout: timeout,
        lib_name: lib_name,
        lib_version: lib_version,
      )

    @end
    if credentials.is_a?(String) || credentials.is_a?(Hash)
      updater_proc = {@apiView.fullyQualifiedCredentialsClassName}.new(credentials).updater_proc
    end
    if credentials.is_a?(GRPC::Core::Channel)
      channel = credentials
    end
    if credentials.is_a?(GRPC::Core::ChannelCredentials)
      chan_creds = credentials
    end
    if credentials.is_a?(Proc)
      updater_proc = credentials
    end
    if credentials.is_a?(Google::Auth::Credentials)
      updater_proc = credentials.updater_proc
    end

    package_version = Gem.loaded_specs['{@apiView.gapicPackageName}'].version.version

    google_api_client = "gl-ruby/#{RUBY_VERSION}"
    google_api_client << " #{lib_name}/#{lib_version}" if lib_name
    google_api_client << " gapic/#{package_version} gax/#{Google::Gax::VERSION}"
    google_api_client << " grpc/#{GRPC::VERSION}"
    google_api_client.freeze

    headers = { :"x-goog-api-client" => google_api_client }
    headers.merge!(metadata) unless metadata.nil?
    {@constructDefaults(apiView)}

    @# Allow overriding the service path/port in subclasses.
    service_path = self.class::SERVICE_ADDRESS
    port = self.class::DEFAULT_SERVICE_PORT
    @join stub : apiView.stubs
      @@{@stub.getValue} = Google::Gax::Grpc.create_stub(
        service_path,
        port,
        chan_creds: chan_creds,
        channel: channel,
        updater_proc: updater_proc,
        scopes: scopes,
        &{@stub.getKey}.method(:new)
      )
    @end

    @join apiMethod : apiView.apiMethods
      @@{@apiMethod.name} = Google::Gax.create_api_call(
        @@{@apiMethod.stubName}.method(:{@apiMethod.name}),
        @if apiMethod.headerRequestParams
          defaults["{@apiMethod.name}"],
          exception_transformer: exception_transformer,
          params_extractor: proc do |request|
            {{@extractedRequestParams(apiMethod.headerRequestParams)}}
          end
        @else
          defaults["{@apiMethod.name}"],
          exception_transformer: exception_transformer
        @end
      )
    @end
  end
@end

@private extractedRequestParams(params)
  @join param : params on ", "
    '{@param}' => request.{@param}
  @end
@end

@private batchDescriptorBody(descriptor)
  "{@descriptor.batchedFieldName}",
  [
    @join name : descriptor.discriminatorFieldNames on {@","}.add(BREAK)
      "{@name}"
    @end
  @if {@descriptor.subresponseFieldName}
    ],
    subresponse_field: "{@descriptor.subresponseFieldName}"
  @else
    ]
  @end
@end

@private pathTemplateSection(apiView)
  @join pathTemplate : apiView.pathTemplates

    {@pathTemplate.name} = Google::Gax::PathTemplate.new(
      "{@pathTemplate.pattern}"
    )

    private_constant :{@pathTemplate.name}
  @end

  @join pathTemplate : apiView.pathTemplates

    {@createResourceFunction(pathTemplate)}
  @end
@end

@private createResourceFunction(pathTemplate)
  @# Returns a fully-qualified {@pathTemplate.entityName} resource name string.
  @join param : pathTemplate.resourceIdParams
    @# @@param {@util.wrapReserved(param)} [String]
  @end
  @# @@return [String]
  def self.{@pathTemplate.formatFunctionName} {@createResourceFunctionParams(pathTemplate.resourceIdParams)}
    {@pathTemplate.name}.render(
      {@createRenderDictionary(pathTemplate.resourceIdParams)}
    )
  end
@end

@private createResourceFunctionParams(params)
  @join param : params on ", "
    {@util.wrapReserved(param)}
  @end
@end

@private createRenderDictionary(params)
  @join param: params on {@","}.add(BREAK)
    :"{@param}" => {@util.wrapReserved(param)}
  @end
@end

@private serviceMethodsSection(apiView)
  @# Service calls
  @join apiMethod : apiView.apiMethods

    {@flattenedMethod(apiMethod)}
  @end
@end

@private flattenedMethod(apiMethod)
  {@methodComments(apiMethod)}
  @if apiMethod.grpcStreaming.isRequestStreaming
    @#
    @# @@note
    @#   EXPERIMENTAL:
    @#     Streaming requests are still undergoing review.
    @#     This method interface might change in the future.
    @#
  @end
  @# @@example
  {@toComments(util.getDocLines(sampleCode(apiMethod.sample)), 3)}

  @if apiMethod.grpcStreaming.isRequestStreaming
    def {@apiMethod.name} reqs, options: nil
      request_protos = reqs.lazy.map do |req|
        Google::Gax::to_proto(req, {@apiMethod.requestTypeName})
      end
      @@{@apiMethod.name}.call(request_protos, options)
      @if apiMethod.hasEmptyReturn
        nil
      @end
    end
  @else
    @if apiMethod.methodParams
      {@serviceDefStatement(apiMethod)}
        req = {
          {@namedParameters(apiMethod.methodParams)}
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, {@apiMethod.requestTypeName})
        {@makeApiCall(apiMethod)}
      end
    @else
      @if or(apiMethod.grpcStreaming.isStreaming, apiMethod.isLongRunningOperation)
        def {@apiMethod.name} options: nil
      @else
        def {@apiMethod.name} options: nil, &block
      @end

        req = {@apiMethod.requestTypeName}.new
        {@makeApiCall(apiMethod)}
      end
    @end
  @end
@end

@private methodComments(apiMethod)
  @if apiMethod.docLines
    {@toComments(apiMethod.docLines)}
    @#

  @end
  @if apiMethod.grpcStreaming.isSingularRequest
    @if apiMethod.methodParams
      @join param : apiMethod.methodParams
        @# @@param {@util.wrapReserved(param.name)} [{@param.typeName}]
        @join line : param.docLines
          @#   {@line}
        @end
      @end


    @end
  @else
    @# @@param reqs [Enumerable<{@apiMethod.requestTypeName}>]
    @#   The input requests.

  @end
  @# @@param options [Google::Gax::CallOptions]
  @#   Overrides the default settings for this call, e.g, timeout,
  @#   retries, etc.
  @if or(apiMethod.grpcStreaming.isStreaming, apiMethod.isLongRunningOperation)
  @else
    @# @@yield [result, operation] Access the result along with the RPC operation
    @# @@yieldparam result [{@apiMethod.returnTypeName}]
    @# @@yieldparam operation [GRPC::ActiveCall::Operation]
  @end
  @if apiMethod.returnTypeName
    @# @@return [{@apiMethod.returnTypeName}]
    @join line : apiMethod.returnsDocLines
      @#   {@line}
    @end
  @end
  @# @@raise [Google::Gax::GaxError] if the RPC is aborted.
@end

@private makeApiCall(apiMethod)
  @if apiMethod.isLongRunningOperation
    operation = Google::Gax::Operation.new(
      @@{@apiMethod.name}.call({@apiMethod.requestVariableName}, options),
      @@operations_client,
      {@apiMethod.lroPayloadTypeName},
      {@apiMethod.lroMetadataTypeName},
      call_options: options
    )
    operation.on_done { |operation| yield(operation) } if block_given?
    operation
  @else
    @if apiMethod.grpcStreaming.isStreaming
      @@{@apiMethod.name}.call({@apiMethod.requestVariableName}, options)
    @else
      @@{@apiMethod.name}.call({@apiMethod.requestVariableName}, options, &block)
    @end

    @if apiMethod.hasEmptyReturn
      nil
    @end
  @end
@end

@private serviceDefStatement(apiMethod)
  @if or(apiMethod.grpcStreaming.isStreaming, apiMethod.isLongRunningOperation)
    def {@apiMethod.name} @\
        {@paramList(apiMethod.methodParams)},
        options: nil
  @else
    def {@apiMethod.name} @\
        {@paramList(apiMethod.methodParams)},
        options: nil,
        &block
  @end
@end

@private paramList(params)
  @join param : params on ",".add(BREAK)
    @if param.defaultValue
      {@util.wrapReserved(param.name)}: {@param.defaultValue}
    @else
      {@util.wrapReserved(param.name)}
    @end
  @end
@end

@private namedParameters(params)
  @join param : params on ",".add(BREAK)
    {@param.name}: {@util.wrapReserved(@param.name)}
  @end
@end
