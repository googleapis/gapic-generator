@extends "readme.snip"
@extends "ruby/common.snip"
@extends "ruby/method_sample.snip"

@snippet generate(index)
  {@license(index.fileHeader)}

  @switch index.type.toString
  @case "VersionIndex"
    @join requireView : {@index.requireViews}
        require "{@requireView.fileName}"
    @end


  @default
  @end
  @if index.modules
    {@modules(index.modules.iterator, index.type, clients(index))}
  @end
@end

@private modules(iterator, indexType, content)
  @let module = iterator.next
    @switch module.type
    @case "ReadmeMetadataView"
      {@readmeModule(indexType, module, iterator, content)}
    @case "TocModuleView"
      {@tocModule(indexType, module, iterator, content)}
    @case "SimpleModuleView"
      {@simpleModule(indexType, module, iterator, content)}
    @end
  @end
@end

@private readmeModule(indexType, module, iterator, content)
  @##
  {@toComments(util.getDocLines(generateReadme(indexType, module)))}
  @#
  {@simpleModule(indexType, module, iterator, content)}
@end

@private tocModule(indexType, module, iterator, content)
  @##
  @# # {@module.fullName} Contents
  @#
  @# | Class | Description |
  @# | ----- | ----------- |
  @join class : module.contents
    @# | [{@class.name}][] | {@class.description} |
  @end
  @#
  @join class : module.contents
    @# [{@class.name}]: {@class.link}
  @end
  @#
  {@simpleModule(indexType, module, iterator, content)}
@end

@private simpleModule(indexType, module, iterator, content)
  module {@module.moduleName}
    @if iterator.hasNext
      {@modules(iterator, indexType, content)}
    @else
      {@content}
    @end
  end
@end

@private generateReadme(indexType, metadata)
  {@readme(metadata, exampleMethods(indexType, metadata.exampleMethods), installationLines(metadata))}
@end

@private exampleMethods(indexType, methods)
  @join method : methods on BREAK
    @#### {@method.apiClassName}
    ```rb
    @switch indexType.toString
    @case "VersionIndex"
      {@sampleCodeWithVersionImport(method)}
    @case "TopLevelIndex"
      {@sampleCodeWithTopLevelImport(method)}
    @default
    @end
    ```
  @end
@end

@private installationLines(metadata)
  $ gem install {@metadata.identifier}
@end

@private clients(index)
  @join requireView : index.requireViews on BREAK.add(BREAK)
    @if index.hasMultipleServices
      module {@requireView.serviceName}
        {@client(index, requireView)}
      end
    @else
      {@client(index, requireView)}
    @end
  @end
@end

@private client(index, requireView)
  @switch index.type.toString
  @case "VersionIndex"
    {@versionIndexClient(requireView)}
  @case "TopLevelIndex"
    {@topLevelClient(index, requireView)}
  @default
  @end
@end

@private versionIndexClient(requireView)
  @##
  @if @requireView.doc.lines
    {@toComments(@requireView.doc.lines)}
  @#
  @end
  {@initMethodComments()}
  def self.new(*args, **kwargs)
    {@requireView.clientName}.new(*args, **kwargs)
  end
@end

@private topLevelClient(index, requireView)
  @##
  @if @requireView.doc.lines
    {@toComments(@requireView.doc.lines)}
  @#
  @end
  @# @@param version [Symbol, String]
  @#   The major version of the service to be used. By default :{@index.apiVersion}
  @#   is used.
  {@initMethodComments()}
  def self.new(*args, version: :{@index.apiVersion}, **kwargs)
    case version.to_s.downcase
    when "{@index.apiVersion}"
      require "{@requireView.fileName}"
      {@requireView.clientName}.new(*args, **kwargs)
    else
      raise ArgumentError.new "The version #{version}, was not is not supported. " @\
        "The version that is supported is '{@index.apiVersion}'."
    end
  end
@end
