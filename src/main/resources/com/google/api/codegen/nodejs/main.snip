@extends "nodejs/common.snip"
@extends "nodejs/method_sample.snip"

@snippet generate(xapi)
  {@header(xapi.fileHeader, xapi.protoFilename)}

  {@serviceClass(xapi)}
@end

@private header(fileHeader, protoFilename)
  /*
   {@comments(fileHeader.copyrightLines)}
   *
   {@comments(fileHeader.licenseLines)}
   */

  'use strict';

  {@importSection(fileHeader.importSection)}
@end

@private importSection(imports)
  {@importGroup(imports.externalImports)}
@end

@private importGroup(group)
  @join import : group
    # Currently there is only one type per import.
    # This will need to be refactored if changed.
    @join type : import.types
      const {@type.nickname} = require('{@import.moduleName}');
    @end
  @end
@end


@private serviceClass(xapi)
  /**
   @if xapi.doc.lines
     {@comments(xapi.doc.lines)}
     *
   @end
   *
   * @@class
   */
  class {@xapi.name} {
    constructor(opts) {
      // Ensure that options include the service address and port.
      opts = Object.assign({
        clientConfig: {},
        port: this.constructor.port,
        servicePath: this.constructor.servicePath,
      }, opts);

      // Create a `gaxGrpc` object, with any grpc-specific options
      // sent to the client.
      Object.assign(opts, {scopes: this.constructor.scopes});
      var gaxGrpc = gax.grpc(opts);

      // Save the auth object to the client, for use by other methods.
      this.auth = gaxGrpc.auth;

      // Determine the client header string.
      var clientHeader = [
        `gl-node/${process.version.node}`,
        `grpc/${gaxGrpc.grpcVersion}`,
        `gax/${gax.version}`,
        `gapic/${this.version}`,
      ];
      if (opts.libName && opts.libVersion) {
        clientHeader.push(`${opts.libName}/${opts.libVersion}`);
      }

      @if xapi.hasPageStreamingMethods

        // Some of the methods on this service return "paged" results,
        // (e.g. 50 results at a time, with tokens to get subsequent
        // pages). Denote the keys used for pagination and results.
        this._pageDescriptors = {
          @join descriptor : xapi.pageStreamingDescriptors on BREAK.add(BREAK)
            {@descriptor.methodName}: new gax.PageDescriptor(
              '{@descriptor.requestTokenFieldName}',
              '{@descriptor.responseTokenFieldName}',
              '{@descriptor.resourcesFieldName}'
            ),
          @end
        };
      @end
      @if xapi.hasGrpcStreamingMethods

        // Some of the methods on this service provide streaming responses.
        // Provide descriptors for these.
        this._streamDescriptors = {
          @join descriptor : xapi.grpcStreamingDescriptors on BREAK.add(BREAK)
            {@descriptor.methodName}: new gax.StreamDescriptor({@descriptor.streamTypeName}),
          @end
        };
      @end
      @if xapi.hasBatchingMethods

        // Some methods on this API support automatically batching
        // requests; denote this.
        var batchingDescriptors = {
          @join descriptor : xapi.batchingDescriptors on BREAK.add(BREAK)
            {@descriptor.methodName}: new gax.BundleDescriptor(
              '{@descriptor.batchedFieldName}',
              [
                @join fieldName : descriptor.discriminatorFieldNames() on BREAK.add(BREAK)
                  '{@fieldName}',
                @end
              ],
              @if descriptor.hasSubresponseField()
                '{@descriptor.subresponseFieldName}',
              @else
                null,
              @end
              {@descriptor.byteLengthFunctionName},
            ),
          @end
        };
      @end
      @if xapi.hasLongRunningOperations

        // This API contains "long-running operations", which return a
        // an Operation object that allows for tracking of the operation,
        // rather than holding a request open.
        this.operationsClient = new gax.lro({
          auth: gaxGrpc.auth,
          grpc: gaxGrpc.grpc,
        }).operationsClient(opts);

        var protoFilesRoot = new gax.grpc.GoogleProtoFilesRoot();
        @join stub : xapi.stubs
          protoFilesRoot = protobuf.loadSync(
            @if xapi.fileHeader.hasVersion
              path.join(__dirname, '..', '..', 'protos', '{@stub.protoFileName}'),
            @else
              path.join(__dirname, '..', 'protos', '{@stub.protoFileName}'),
            @end
            protoFilesRoot
          );
        @end

        @join descriptor : xapi.longRunningDescriptors
          var {@descriptor.methodName}Response = protoFilesRoot.lookup(
            '{@descriptor.operationPayloadTypeName}'
          );
          var {@descriptor.methodName}Metadata = protoFilesRoot.lookup(
            '{@descriptor.metadataTypeName}'
          );
        @end

        this.longrunningDescriptors = {
          @join descriptor : xapi.longRunningDescriptors on BREAK.add(BREAK)
            {@descriptor.methodName}: new gax.LongrunningDescriptor(
              this.operationsClient,
              {@descriptor.methodName}Response.decode.bind({@descriptor.methodName}Response),
              {@descriptor.methodName}Metadata.decode.bind({@descriptor.methodName}Metadata)
            ),
          @end
        };
      @end

      // Put together the default options sent with requests.
      var defaults = gaxGrpc.constructSettings(
        '{@xapi.interfaceKey}',
        gapicConfig,
        opts.clientConfig,
        {'x-goog-api-client': clientHeader.join(' ')},
      );

      // Save a dictionary of "inner API calls"; the core implementation
      // of calling the API is handled in `google-gax`, with this code
      // merely providing the destination and request information.
      this._innerApiCalls = {};

      @join stub : xapi.stubs on BREAK.add(BREAK)
        // Put together the "service stub" for
        // {@stub.fullyQualifiedType}.
        var {@stub.name} = gaxGrpc.createStub(
          loadedProtos.{@stub.fullyQualifiedType},
          opts
        );

        // Iterate over each of the methods that the service provides
        // and create an API call method for each.
        var {@stub.stubMethodsArrayName} = [
          @join method : {@stub.methodNames} on BREAK.add(BREAK)
              '{@method}',
          @end
        ];
        for (let methodName of {@stub.stubMethodsArrayName}) {
          this._innerApiCalls[methodName] = gax.createApiCall(
            {@stub.name}.then(stub => function() {
              var args = Array.prototype.slice.call(arguments, 0);
              return stub[methodName].apply(stub, args);
            }),
            defaults[methodName],
            {@getDescriptors(xapi)}
          );
        }
      @end
    }

    /**
     * The DNS address for this API service.
     */
    static get servicePath() {
      return '{@xapi.serviceAddress}';
    }

    /**
     * The port for this API service.
     */
    static get port() {
      return {@xapi.servicePort};
    }

    /**
     * The scopes needed to make gRPC calls for every method defined
     * in this service.
     */
    static get scopes() {
      return [
        @join auth_scope : xapi.authScopes on BREAK.add(BREAK)
          '{@auth_scope}',
        @end
      ];
    }


  @if xapi.pathTemplates
    // Path templates

    {@pathTemplateSection(xapi)}
  @end

    /**
     * Return the project ID used by this class.
     * @@param {function(Error, string)} callback - the callback to
     *   be called with the current project Id.
     */
    getProjectId(callback) {
      return this.auth.getProjectId(callback);
    }

    {@serviceMethodsSection(xapi)}
  }


  module.exports = {@xapi.constructorName};

@end

@private clientsParamName(stubs)
  @switch stubs.size.toString
    @case "1"
      {@stubs.iterator.next.name}Protos
    @default
      protos
    @end
@end

@private getDescriptors(xapi)
  @if xapi.validDescriptorsNames
    @join name : xapi.validDescriptorsNames() on {@" || "}
      {@name}[methodName]
    @end
  @else
    null
  @end
@end

@private pathTemplateSection(xapi)
  @join pathTemplate : xapi.pathTemplates on BREAK
    var {@pathTemplate.name} = new gax.PathTemplate(
        '{@pathTemplate.pattern}');

  @end
  @join function : xapi.formatResourceFunctions

    {@createResourceFunction(function, xapi.name)}
  @end

  @join function : xapi.parseResourceFunctions

    {@createMatchFunction(function, xapi.name)}
  @end
@end

@private createResourceFunction(function, apiName)
  /**
   * Returns a fully-qualified {@function.entityName} resource name string.
   @join param : function.resourceIdParams
     * @@param {String} {@param.name}
   @end
   * @@returns {String}
   */
  {@apiName}.prototype.{@function.name} = \
  function({@createResourceFunctionParams(function.resourceIdParams)}) {
    return {@function.pathTemplateName}.render({
      {@createRenderDictionary(function.resourceIdParams)}
    });
  };
@end

@private createMatchFunction(function, apiName)
  /**
   * Parses the {@function.entityNameParamName} from a {@function.entityName} resource.
   * @@param {String} {@function.entityNameParamName}
   *   A fully-qualified path representing a {@function.entityName} resources.
   * @@returns {String} - A string representing the {@function.outputResourceId}.
   */
  {@apiName}.prototype.{@function.name} = function({@function.entityNameParamName}) {
    return {@function.pathTemplateName}.match({@function.entityNameParamName}).{@function.outputResourceId};
  };
@end

@private createResourceFunctionParams(resourceIdParams)
  @join param : resourceIdParams on ", "
    {@param.name}
  @end
@end

@private createRenderDictionary(resourceIdParams)
  @join param: resourceIdParams on {@","}.add(BREAK)
    {@param.templateKey}: {@param.name}
  @end
@end

@private serviceMethodsSection(xapi)
  // Service calls
  @join method : xapi.apiMethods

    {@flattenedMethod(method)}
  @end
@end

@private decorateSampleCodeSegment(method)
  @let coreSampleCode = sampleCode(method), \
      finalSampleCode = decorateSampleCode(method, coreSampleCode)
    @if finalSampleCode
      {@finalSampleCode}
    @end
  @end
@end

@private flattenedMethod(method)
  {@methodComments(method)}
  {@method.apiClassName}.prototype.{@method.name} = function({@methodRequestParameters(method)}options{@callbackParams(method)}) {
    @switch method.grpcStreamingType.toString
    @case "ClientStreaming"
      {@handleCallback()}
    @case "NonStreaming"
      {@handleCallback()}
    @default
    @end
    if (options === undefined) {
      options = {};
    }
    {@maybeHandleRequest(method)}
    return this._{@method.name}({@requestObject(method)}options{@callbackParams(method)});
  };
  @switch method.type.toString
  @case "PagedOptionalArrayMethod"

    {@pagedOptionalArrayMethod(method)}
  @default
  @end
@end

@private methodComments(method)
  @let doc = method.doc
    /**
     @if comments(doc.mainDocLines)
       {@comments(doc.mainDocLines)}
       *
     @end
     {@createParamTypesComment(doc.paramDocs)}
     {@createReturnTypeComment(doc.returnTypeName, doc.returnsDocLines)}
     *
     * @@example
     *
     {@comments(util.getDocLines(decorateSampleCodeSegment(method)))}
     */
  @end
@end

@private createParamTypesComment(paramDocs)
  @join doc : paramDocs
    {@paramDoc(doc)}
  @end
@end

@private paramDoc(doc)
  * @@param {{@doc.typeName}} {@doc.paramName}
  @join line : doc.lines
    *   {@line}
  @end
@end

@private createReturnTypeComment(typeName, lines)
  @join line : lines
    * {@line}
  @end
@end

@private pagedOptionalArrayMethod(method)
  /**
   * Equivalent to {@@link {@method.name}}, but returns a NodeJS Stream object.
   *
   * This fetches the paged responses for {@@link {@method.name}} continuously
   * and invokes the callback registered for 'data' event for each element in the
   * responses.
   *
   * The returned object has 'end' method when no more elements are required.
   *
   * autoPaginate option will be ignored.
   *
   * @@see {@@link https://nodejs.org/api/stream.html}
   *
   {@createParamTypesComment(method.doc.paramDocs)}
   * @@returns {Stream}
   *   An object stream which emits {@method.doc.pageStreamingResourceTypeName} on 'data' event.
   *
   * @@example
   *
   {@comments(util.getDocLines(decorateSampleCode(method, sampleCodePageStreaming(method))))}
   */
  {@method.apiClassName}.prototype.{@method.name}Stream = function({@methodRequestParameters(method)}options) {
    if (options === undefined) {
      options = {};
    }
    {@maybeHandleRequest(method)}
    return PAGE_DESCRIPTORS.{@method.name}.createStream(this._{@method.name}, {@requestObject(method)}options);
  };
@end

@private handleCallback()
  if (options instanceof Function && callback === undefined) {
    callback = options;
    options = {};
  }
@end

@private maybeHandleRequest(method)
  @switch method.grpcStreamingType.toString
  @case "ClientStreaming"
  @case "BidiStreaming"
  @default
    @if and(method.requiredRequestObjectParams.isEmpty, \
            method.optionalRequestObjectParamsNoPageToken.isEmpty)
      if (request === undefined) {
        request = {};
      }
    @end
  @end
@end

@private callbackParams(method)
  @switch method.grpcStreamingType.toString
  @case "ClientStreaming"
    , callback
  @case "NonStreaming"
    , callback
  @default
  @end
@end

@private requestObject(method)
  @switch method.grpcStreamingType.toString
  @case "ServerStreaming"
    request, {@""}
  @case "NonStreaming"
    request, {@""}
  @default
  @end
@end

@private methodRequestParameters(method)
  @switch method.grpcStreamingType.toString
  @case "ServerStreaming"
    request, {@""}
  @case "NonStreaming"
    request, {@""}
  @default
  @end
@end
