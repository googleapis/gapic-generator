@extends "csharp/common.snip"

@snippet generate(snippets)
    {@renderFileHeader(snippets.fileHeader)}

    namespace {@snippets.fileHeader.examplePackageName}
    {
        {@renderSnippets(snippets)}
    }

@end

@private renderSnippets(snippets)
    public class {@snippets.name}
    {
        @join snippetMethod : snippets.snippetMethods
            {@method(snippetMethod)}

        @end
    }
@end

@private method(snippetMethod)
    @switch snippetMethod.method.type.toString
    @case "FlattenedMethod"
        {@flattenedMethodSync(snippetMethod)}
    @case "FlattenedAsyncCallSettingsMethod"
        {@flattenedMethodAsyncCallSettings(snippetMethod)}
    @case "PagedFlattenedMethod"
        {@pagedFlattenedMethodSync(snippetMethod)}
    @case "PagedFlattenedAsyncMethod" 
        {@pagedFlattenedMethodAsync(snippetMethod)}
    @default
        $unhandledCase: {@snippetMethod.method.type.toString}$
    @end
@end

@private flattenedMethodSync(snippetMethod)
    public void {@snippetMethod.snippetMethodName}()
    {
        // Snippet: {@snippetMethod.method.name}({@snippetArgTypes(snippetMethod.method.methodParams)},CallSettings)
        {@preparations(snippetMethod)}
        @if snippetMethod.method.hasReturnValue
            {@snippetMethod.callerResponseTypeName} response = {@sampleMethodCall(snippetMethod)};
        @else
            {@sampleMethodCall(snippetMethod)};
        @end
        // End snippet
    }
@end

@private flattenedMethodAsyncCallSettings(snippetMethod)
    public async Task {@snippetMethod.snippetMethodName}()
    {
        // Snippet: {@snippetMethod.method.name}({@snippetArgTypes(snippetMethod.method.methodParams)},CallSettings)
        // Additional: {@snippetMethod.method.name}({@snippetArgTypes(snippetMethod.method.methodParams)},CancellationToken)
        {@preparations(snippetMethod)}
        @if snippetMethod.method.hasReturnValue
            {@snippetMethod.callerResponseTypeName} response = await {@sampleMethodCall(snippetMethod)};
        @else
            await {@sampleMethodCall(snippetMethod)};
        @end
        // End snippet
    }
@end

@private pagedFlattenedMethodSync(snippetMethod)
    public void {@snippetMethod.snippetMethodName}()
    {
        // Snippet: {@snippetMethod.method.name}({@snippetArgTypes(snippetMethod.method.methodParams)},CallSettings)
        {@preparations(snippetMethod)}
        {@snippetMethod.callerResponseTypeName} response =
            {@sampleMethodCall(snippetMethod)};

        // Iterate over all response items, lazily performing RPCs as required
        foreach ({@snippetMethod.method.listMethod.resourceTypeName} item in response)
        {
            // Do something with each item
            Console.WriteLine(item);
        }
        
        // Or iterate over fixed-sized pages, lazily performing RPCs as required
        int pageSize = 10;
        foreach (FixedSizePage<{@snippetMethod.method.listMethod.resourceTypeName}> page in response.AsPages().WithFixedSize(pageSize))
        {
            // Do something with each page of items
            Console.WriteLine("A page of results:");
            foreach ({@snippetMethod.method.listMethod.resourceTypeName} item in page)
            {
                Console.WriteLine(item);
            }
        }
        // End snippet
    }
@end

# snippetMethod: StaticLangApiMethodSnippetView
@private pagedFlattenedMethodAsync(snippetMethod)
    public async Task {@snippetMethod.snippetMethodName}()
    {
        // Snippet: {@snippetMethod.method.name}({@snippetArgTypes(snippetMethod.method.methodParams)},CallSettings)
        {@preparations(snippetMethod)}
        {@snippetMethod.callerResponseTypeName} response =
            {@sampleMethodCall(snippetMethod)};

        // Iterate over all response items, lazily performing RPCs as required
        await response.ForEachAsync(({@snippetMethod.method.listMethod.resourceTypeName} item) =>
        {
            // Do something with each item
            Console.WriteLine(item);
        });
        
        // Or iterate over fixed-sized pages, lazily performing RPCs as required
        int pageSize = 10;
        IAsyncEnumerable<FixedSizePage<{@snippetMethod.method.listMethod.resourceTypeName}>> fixedSizePages = response.AsPages().WithFixedSize(pageSize);
        await fixedSizePages.ForEachAsync((FixedSizePage<{@snippetMethod.method.listMethod.resourceTypeName}> page) =>
        {
            // Do something with each page of items
            Console.WriteLine("A page of results:");
            foreach ({@snippetMethod.method.listMethod.resourceTypeName} item in page)
            {
                Console.WriteLine(item);
            }
        });
        // End snippet
    }
@end

@private preparations(snippetMethod)
    // Create client
    {@snippetMethod.apiClassName} {@snippetMethod.apiVariableName} = {@snippetMethod.apiClassName}.Create();
    // Initialize request argument(s)
    {@topLevelInitCode(snippetMethod.method.initCode)}
    // Make the request
@end

@private snippetArgTypes(params)
    @join param : params on ","
        {@param.typeName}
    @end
@end

@private sampleMethodCall(snippetMethod)
    {@snippetMethod.method.apiVariableName}.{@snippetMethod.method.name}({@sampleMethodCallArgList(snippetMethod.method.initCode.fieldSettings)})
@end

@private sampleMethodCallArgList(fieldSettings)
    @join fieldSetting : fieldSettings on ", "
        {@fieldSetting.identifier}
    @end
@end

@private topLevelInitCode(initCodeSpec)
    @join line : initCodeSpec.topLevelLines
        {@initCode(TRUE, line)};
    @end
@end

@private initCode(includeAssignment, line)
    @switch line.lineType.toString
    @case "StructureInitLine"
        @if includeAssignment
            {@line.typeName} {@line.identifier} = new {@line.typeName}
        @else
            new {@line.typeName}
        @end

        {
            @join fieldSetting : line.fieldSettings
                {@fieldSetting.fieldSetFunction} = {@initCode(FALSE, fieldSetting.initCodeLine)},
            @end
        }
    @case "ListInitLine"
        @if includeAssignment
            IEnumerable<{@line.elementTypeName}> {@line.identifier} = new[]
        @else
            new[]
        @end

        {
            @join child : line.elements
                {@initCode(FALSE, child)},
            @end
        }
    @case "MapInitLine"
        @if includeAssignment
            IDictionary<{@line.keyTypeName}, {@line.valueTypeName}> {@line.identifier} = \
                new Dictionary<{@line.keyTypeName}, {@line.valueTypeName}>
        @else
            new Dictionary<{@line.keyTypeName}, {@line.valueTypeName}>
        @end

        {
            @join mapEntry : line.initEntries
                { {@mapEntry.key}, {@initCode(FALSE, mapEntry.value)} },
            @end
        }
    @case "SimpleInitLine"
        @if includeAssignment
            {@line.typeName} {@line.identifier} = {@renderInitValue(line.initValue)}
        @else
            {@renderInitValue(line.initValue)}
        @end
    @default
        $unhandledCase: {@line.lineType.toString}$
    @end
@end

@private renderInitValue(initValue)
    @switch initValue.type
    @case "SimpleInitValueView"
        {@initValue.initialValue}
    @case "FormattedInitValueView"
        {@initValue.apiWrapperName}.{@initValue.formatFunctionName}({@argList(initValue.formatArgs)})
    @case "ResourceNameInitValueView"
        {@renderResourceName(initValue)}
    @case "ResourceNameOneofInitValueView"
        {@initValue.resourceOneofTypeName}.From({@renderResourceName(initValue.specificResourceNameView)})
    @default
        $unhandledCase: {@initValue.type}$
    @end
@end

@private renderResourceName(initValue)
    new {@initValue.resourceTypeName}({@formatResourceNameArgs(initValue.formatArgs)})
@end

@private formatResourceNameArgs(args)
    @join arg : args on ", "
        {@arg}
    @end
@end
