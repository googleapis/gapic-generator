@extends "csharp/common.snip"

@snippet generate(resourceNames)
    {@renderFileHeader(resourceNames.fileHeader)}

    namespace {@resourceNames.fileHeader.packageName}
    {
        public interface IResourceName{}// TODO: This will be in GAX
        public interface ISingleResourceName:IResourceName{} // TODO: Is this required?

        public sealed class UnknownResourceName : IResourceName // TODO: This will be in GAX
        {
            public static UnknownResourceName Parse(string value) => new UnknownResourceName(value);
            
            public static bool TryParse(string value, out UnknownResourceName result)
            {
                result = new UnknownResourceName(value);
                return true;
            } 

            public UnknownResourceName(string value)
            {
                Value = GaxPreconditions.CheckNotNull(value, nameof(value));
            }

            public string Value { get; }

            public override string ToString() => Value;
        }

        public sealed class ResourceNameList<TResource> : IList<TResource> where TResource : IResourceName // TODO: This will be in GAX
        {
            public ResourceNameList(IList<string> underlyingList, Func<TResource, string> nameToString, Func<string, TResource> stringToName)
            {
                _underlyingList = GaxPreconditions.CheckNotNull(underlyingList, nameof(underlyingList));
                _nameToString = GaxPreconditions.CheckNotNull(nameToString, nameof(nameToString));
                _stringToName = GaxPreconditions.CheckNotNull(stringToName, nameof(stringToName));
            }

            private IList<string> _underlyingList;
            private Func<TResource, string> _nameToString;
            private Func<string, TResource> _stringToName;

            public int Count => _underlyingList.Count;
            public bool IsReadOnly => _underlyingList.IsReadOnly;
            public TResource this[int i]
            {
                get { return _stringToName(_underlyingList[i]); }
                set { _underlyingList[i] = _nameToString(value); }
            }
            public void Add(TResource value) => _underlyingList.Add(_nameToString(value));
            public void Clear() => _underlyingList.Clear();
            public bool Contains(TResource value) => _underlyingList.Contains(_nameToString(value));
            public void CopyTo(TResource[] array, int arrayIndex)
            {
                // TODO: Improve exceptions
                if (array == null) throw new ArgumentNullException();
                if (arrayIndex < 0) throw new ArgumentOutOfRangeException();
                if (Count > array.Length - arrayIndex) throw new ArgumentException();
                for (int i = 0; i < Count; i++)
                {
                    array[arrayIndex + i] = _stringToName(_underlyingList[i]);
                }
            }
            public IEnumerator<TResource> GetEnumerator() => _underlyingList.Select(_stringToName).GetEnumerator();
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();
            public int IndexOf(TResource value) => _underlyingList.IndexOf(_nameToString(value));
            public void Insert(int index, TResource item) => _underlyingList.Insert(index, _nameToString(item));
            public bool Remove(TResource item) => _underlyingList.Remove(_nameToString(item));
            public void RemoveAt(int index) => _underlyingList.RemoveAt(index);
        }

        {@resourceClasses(resourceNames.resourceNames)}

        {@partialProtoClasses(resourceNames.resourceProtos)}
    }
@end

@private resourceClasses(resources)
    @join resource : resources
        @switch resource.type.toString
        @case "SINGLE"
            {@resourceClassSingle(resource)}
        @case "ONEOF"
            {@resourceClassOneof(resource)}
        @case "FIXED"
            {@resourceClassFixed(resource)}
        @end


    @end
@end

@private resourceClassSingle(resource)
    /// <summary>
    /// Resource name for a {@resource.docName}.
    /// </summary>
    public sealed partial class {@resource.typeName} : ISingleResourceName
    {
        private static readonly PathTemplate s_template = new PathTemplate("{@resource.pattern}");

        /// <summary>
        /// Parses a {@resource.docName} resource name in string form into a <see cref="{@resource.typeName}"/>.
        /// </summary>
        /// <param name="{@resource.paramName}">The {@resource.docName} resource name in string form. Must not be <c>null</c>.</param>
        public static {@resource.typeName} Parse(string {@resource.paramName})
        {
            GaxPreconditions.CheckNotNull({@resource.paramName}, nameof({@resource.paramName}));
            ResourceName resourceName = s_template.ParseName({@resource.paramName});
            return new {@resource.typeName}({@formatResourceNameArgs(resource.params)});
        }
        
        public static bool TryParse(string {@resource.paramName}, out {@resource.typeName} result)
        {
            GaxPreconditions.CheckNotNull({@resource.paramName}, nameof({@resource.paramName}));
            ResourceName resourceName;
            if (s_template.TryParseName({@resource.paramName}, out resourceName))
            {
                result = new {@resource.typeName}({@formatResourceNameArgs(resource.params)});
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>
        /// Constructs a {@resource.docName} name from its component parts.
        /// </summary>
        @join param : resource.params
            /// <param name="{@param.nameAsParam}">The {@param.docName} ID. Must not be <c>null</c>.</param>
        @end
        public {@resource.typeName}({@formatParams(resource.params)})
        {
            @join param : resource.params
                {@param.nameAsProperty} = GaxPreconditions.CheckNotNull({@param.nameAsParam}, nameof({@param.nameAsParam}));
            @end
        }

        @join param : resource.params
            /// <summary>
            /// The {@param.docName} ID. Never <c>null</c>.
            /// </summary>
            public string {@param.nameAsProperty} { get; }

        @end
        /// <inheritdoc />
        public override string ToString() => s_template.Expand({@formatArgs(resource.params)});
    }
@end

@private resourceClassOneof(resource)
    public sealed partial class {@resource.typeName} : IResourceName
    {
        public enum OneofType
        {
            @join child : resource.children
                {@child.enumName} = {@child.index},
            @end
        }

        public static {@resource.typeName} Parse(string name)
        {
            {@resource.typeName} result;
            if (TryParse(name, out result))
            {
                return result;
            }
            throw new ArgumentException("Invalid name", "name");
        }

        public static bool TryParse(string name, out {@resource.typeName} result)
        {
            @join child : resource.children
                {@child.typeName} {@child.paramName};
                if ({@child.typeName}.TryParse(name, out {@child.paramName}))
                {
                    result = new {@resource.typeName}(OneofType.{@child.enumName}, {@child.paramName});
                    return true;
                }
            @end
            result = null;
            return false;
        }

        @join child : resource.children
            public static {@resource.typeName} From({@child.typeName} {@child.paramName}) => new {@resource.typeName}(OneofType.{@child.enumName}, {@child.paramName});

        @end
        public {@resource.typeName}(OneofType type, IResourceName value)
        {
            Type = GaxPreconditions.CheckEnumValue<OneofType>(type, nameof(value));
            Value = GaxPreconditions.CheckNotNull(value, nameof(value));
        }

        public OneofType Type { get; }
        public IResourceName Value { get; }

        private T CheckAndReturn<T>(OneofType type)
        {
            if (Type != type)
            {
                throw new InvalidOperationException($"Requested type {type}, but this one-of contains type {Type}");
            }
            return (T)Value;
        }

        @join child : resource.children
            public {@child.typeName} {@child.propertyName} => CheckAndReturn<{@child.typeName}>(OneofType.{@child.enumName});

        @end
        public override string ToString() => Value.ToString();
    }
@end

@private resourceClassFixed(resource)
    public sealed partial class {@resource.typeName} : IResourceName
    {
        private const string FixedValue = "{@resource.value}";
    
        public static {@resource.typeName} Instance => new {@resource.typeName}();

        public static {@resource.typeName} Parse(string {@resource.paramName})
        {
            {@resource.typeName} result;
            if (!TryParse({@resource.paramName}, out result))
            {
                throw new ArgumentException($"Invalid resource name, must be \"{FixedValue}\"", nameof({@resource.paramName}));
            }
            return result;
        }

        public static bool TryParse(string {@resource.paramName}, out {@resource.typeName} result)
        {
            GaxPreconditions.CheckNotNull({@resource.paramName}, nameof({@resource.paramName}));
            if ({@resource.paramName} == FixedValue)
            {
                result = Instance;
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        private {@resource.typeName}() { }

        public override string ToString() => FixedValue;
    }
@end

@private formatParams(params)
    @join param : params on ", "
        string {@param.nameAsParam}
    @end
@end

@private formatArgs(params)
    @join param : params on ", "
        {@param.nameAsProperty}
    @end
@end

@private formatResourceNameArgs(params)
    @join param : params on ", "
        resourceName[{@param.index}]
    @end
@end

@private partialProtoClasses(protos)
    @join proto : protos
        public partial class {@proto.protoClassName}
        {
            @join field : proto.fields
                /// <summary>
                /// A <see cref="{@field.typeName}"/>-typed view over the <see cref="{@field.underlyingPropertyName}"/> resource-name property.
                /// </summary>
                @if field.isRepeated
                    public {@field.typeName} {@field.propertyName} =>
                        new ResourceNameList<{@field.elementTypeName}>({@field.underlyingPropertyName},
                            name => name.ToString(),
                            @if field.isAny
                                str => UnknownResourceName.Parse(str));
                            @else
                                str => {@field.elementTypeName}.Parse(str));
                            @end
                @else
                    public {@field.typeName} {@field.propertyName}
                    {
                        @if field.isAny
                            get { return UnknownResourceName.Parse({@field.underlyingPropertyName}); }
                        @else
                            get { return {@field.typeName}.Parse({@field.underlyingPropertyName}); }
                        @end
                        set { {@field.underlyingPropertyName} = GaxPreconditions.CheckNotNull(value, nameof(value)).ToString(); }
                    }
                @end

            @end
        }

    @end
@end
