@extends "java/common.snip"

@snippet generate(classFile)
  {@renderFileHeader(classFile.fileHeader)}

  {@classDoc(classFile.classView.doc)}
  @if classFile.fileHeader.hasGeneratorVersion
    @@Generated("by GAPIC v{@classFile.fileHeader.generatorVersion}")
  @else
    @@Generated("by GAPIC")
  @end
  @if classFile.classView.releaseLevelAnnotation
    {@classFile.classView.releaseLevelAnnotation}
  @end
  {@renderClass(classFile.classView)}
@end

@private renderClass(classView)
  public class {@classView.name} extends ClientSettings<{@classView.name}> {
    {@constants(classView)}
    {@members(classView)}
    {@constructors(classView)}
    {@descriptors(classView)}
    {@innerBuilderClass(classView)}
  }
@end

@private classDoc(doc)
  // AUTO-GENERATED DOCUMENTATION AND CLASS
  /**
   * Settings class to configure an instance of {@@link {@doc.apiClassName}}.
  @if doc.hasDefaultInstance
    {@""} *
     * <p>The default instance has everything set to sensible defaults:
     *
     * <ul>
     * <li>The default service address ({@doc.serviceAddress}) and default port ({@doc.servicePort})
     * are used.
     * <li>Credentials are acquired automatically through Application Default Credentials.
     * <li>Retries are configured for idempotent methods but not for non-idempotent methods.
     * </ul>
     *
     * <p>The builder of this class is recursive, so contained classes are themselves builders.
     * When build() is called, the tree of builders is called to create the complete settings
     * object. For example, to set the total timeout of {@doc.exampleApiMethodName} to 30 seconds:
     *
     * <pre>
     * <code>
     * {@doc.settingsClassName}.Builder {@doc.settingsBuilderVarName} =
     *     {@doc.settingsClassName}.newBuilder();
     * {@doc.settingsBuilderVarName}.{@doc.exampleApiMethodSettingsGetter}().getRetrySettingsBuilder()
     *     .setTotalTimeout(Duration.ofSeconds(30));
     * {@doc.settingsClassName} {@doc.settingsVarName} = {@doc.settingsBuilderVarName}.build();
     * </code>
     * </pre>
  @end
   */
@end

@private constants(xsettingsClass)
  @if xsettingsClass.hasDefaultServiceScopes
    /**
     * The default scopes of the service.
     */
    private static final ImmutableList<String> DEFAULT_SERVICE_SCOPES = ImmutableList.<String>builder()
        @join scope : {@xsettingsClass.authScopes}
          .add("{@scope}")
        @end
        .build();
    {@""}
  @end
  {@""}
@end

@private members(xsettingsClass)
  {@stubSettingsConfig(xsettingsClass)}
  {@methodGetters(xsettingsClass)}

  @@BetaApi("A restructuring of stub classes is planned, so this may break in the future")
  public {@xsettingsClass.stubInterfaceName} createStub() throws IOException {
    return stubSettings.createStub();
  }

  /**
   * Returns a new builder for this class.
   */
  public static Builder newBuilder() {
    return Builder.createDefault();
  }

  /**
   * Returns a new builder for this class.
   */
  public static Builder newBuilder(ClientContext clientContext) {
    return new Builder(clientContext);
  }

  /**
   * Returns a builder containing all the values of this settings class.
   */
  public Builder toBuilder() {
    return new Builder(this);
  }
  {@""}
@end

@private stubSettingsConfig(xsettingsClass)
  private final {@xsettingsClass.stubSettingsName} stubSettings;

  public static final {@xsettingsClass.name} create({@xsettingsClass.stubSettingsName} stub) throws IOException {
    return new {@xsettingsClass.name}.Builder(stub).build();
  }

  public {@xsettingsClass.stubSettingsName} getStubSettings() {
    return stubSettings;
  }
  {@""}
@end

@private methodGetters(xsettingsClass)
  @join settings : xsettingsClass.callSettings
    /**
     * Returns the object with the settings used for calls to {@settings.methodName}.
     */
    @switch settings.type
    @case "SimpleApiCallable"
        public UnaryCallSettings<{@settings.requestTypeName}, \
            {@settings.responseTypeName}> {@settings.settingsGetFunction}() {
          return stubSettings.{@settings.memberName}();
       }
    @case "PagedApiCallable"
      public PagedCallSettings<{@settings.requestTypeName}, \
          {@settings.responseTypeName}, \
          {@settings.pagedListResponseTypeName}> {@settings.settingsGetFunction}() {
        return stubSettings.{@settings.memberName}();
      }
    @case "BatchingApiCallable"
      public BatchingCallSettings<{@settings.requestTypeName}, \
          {@settings.responseTypeName}> {@settings.settingsGetFunction}() {
        return stubSettings.{@settings.memberName}();
      }
    @case "OperationApiCallable"
      public OperationCallSettings<{@settings.requestTypeName}, \
            {@settings.operationMethod.operationPayloadTypeName}, \
            {@settings.operationMethod.metadataTypeName}> \
            {@settings.settingsGetFunction}() {
        return stubSettings.{@settings.memberName}();
      }
    @case "ServerStreamingApiCallable"
        public ServerStreamingCallSettings<{@settings.requestTypeName}, \
              {@settings.responseTypeName}> {@settings.settingsGetFunction}() {
          return stubSettings.{@settings.memberName}();
        }
    @default
      @if settings.isStreaming
        public StreamingCallSettings<{@settings.requestTypeName}, \
              {@settings.responseTypeName}> {@settings.settingsGetFunction}() {
          return stubSettings.{@settings.memberName}();
        }
      @else
        $unhandledCase: stubSettings.{@settings.type}()$
      @end
    @end
    {@""}
  @end
@end

@private constructors(xsettingsClass)
  protected {@xsettingsClass.name}(Builder settingsBuilder) throws IOException {
    super(settingsBuilder);
    stubSettings = settingsBuilder.stubBuilder.build();
  }
  {@""}
@end

@private descriptors(xsettingsClass)
  {@pagedListResponseFactories(xsettingsClass)}
  {@batchingDescriptors(xsettingsClass)}
@end

@private pagedListResponseFactories(xsettingsClass)
  @join factory : xsettingsClass.pagedListResponseFactories
    private static final PagedListResponseFactory<{@factory.requestTypeName}, {@factory.responseTypeName}, {@factory.pagedListResponseTypeName}> {@factory.name} =
        new PagedListResponseFactory<{@factory.requestTypeName}, {@factory.responseTypeName}, {@factory.pagedListResponseTypeName}>() {
          @@Override
          public ApiFuture<{@factory.pagedListResponseTypeName}> getFuturePagedResponse(
              UnaryCallable<{@factory.requestTypeName}, {@factory.responseTypeName}> callable,
              {@factory.requestTypeName} request,
              ApiCallContext context,
              ApiFuture<{@factory.responseTypeName}> futureResponse) {
            PageContext<{@factory.requestTypeName}, {@factory.responseTypeName}, {@factory.resourceTypeName}> pageContext =
                PageContext.create(callable, {@factory.pageStreamingDescriptorName}, request, context);
            return {@factory.pagedListResponseTypeName}.createAsync(pageContext, futureResponse);
          }
        };
    {@""}
  @end
@end

@private batchingDescriptors(xsettingsClass)
  @join desc : xsettingsClass.batchingDescriptors
    private static final BatchingDescriptor<{@desc.requestTypeName}, {@desc.responseTypeName}> {@desc.name} =
        new BatchingDescriptor<{@desc.requestTypeName}, {@desc.responseTypeName}>() {
          @@Override
          public PartitionKey getBatchPartitionKey({@desc.requestTypeName} request) {
            return new PartitionKey({@partitionKeyCode(desc)});
          }

          @@Override
          public RequestBuilder<{@desc.requestTypeName}> getRequestBuilder() {
            return new RequestBuilder<{@desc.requestTypeName}>() {
              private {@desc.requestTypeName}.Builder builder;
              @@Override
              public void appendRequest({@desc.requestTypeName} request) {
                if (builder == null) {
                  builder = request.toBuilder();
                } else {
                  builder.{@desc.batchedFieldSetFunction}(request.{@desc.batchedFieldGetFunction}());
                }
              }
              @@Override
              public {@desc.requestTypeName} build() {
                return builder.build();
              }
            };
          }

          @@Override
          public void splitResponse(
              {@desc.responseTypeName} batchResponse,
              Collection<? extends BatchedRequestIssuer<{@desc.responseTypeName}>> batch) {
            int batchMessageIndex = 0;
            for (BatchedRequestIssuer<{@desc.responseTypeName}> responder : batch) {
              @if desc.hasSubresponse
                {@desc.subresponseTypeName} subresponseElements = new ArrayList<>();
                long subresponseCount = responder.getMessageCount();
                for (int i = 0; i < subresponseCount; i++) {
                  subresponseElements.add(batchResponse.{@desc.subresponseByIndexGetFunction}(batchMessageIndex));
                  batchMessageIndex += 1;
                }
                {@desc.responseTypeName} response =
                    {@desc.responseTypeName}.newBuilder().{@desc.subresponseSetFunction}(subresponseElements).build();
              @else
                {@desc.responseTypeName} response =
                    {@desc.responseTypeName}.newBuilder().build();
              @end
              responder.setResponse(response);
            }
          }

          @@Override
          public void splitException(
              Throwable throwable,
              Collection<? extends BatchedRequestIssuer<{@desc.responseTypeName}>> batch) {
            for (BatchedRequestIssuer<{@desc.responseTypeName}> responder : batch) {
              responder.setException(throwable);
            }
          }

          @@Override
          public long countElements({@desc.requestTypeName} request) {
            return request.{@desc.batchedFieldCountGetFunction}();
          }

          @@Override
          public long countBytes({@desc.requestTypeName} request) {
            return request.getSerializedSize();
          }
        };
    {@""}
  @end
@end

@private partitionKeyCode(batchingDesc)
  @join partitionKey : batchingDesc.partitionKeys on ", "
    request.{@partitionKey.fieldGetFunction}()
  @end
@end

@private fieldCopyCalls(fieldCopies)
  @join fieldCopy : fieldCopies
    .{@fieldCopy.fieldSetFunction}(firstRequest.{@fieldCopy.fieldGetFunction}())
  @end
@end

@private innerBuilderClass(xsettingsClass)
  /**
   * Builder for {@xsettingsClass.name}.
   */
  public static class Builder extends ClientSettings.Builder<{@xsettingsClass.name}, Builder> {
    private PublisherStubSettings.Builder stubBuilder;

    {@builderConstructors(xsettingsClass)}

    {@builderMethods(xsettingsClass)}
  }
@end

@private statusCodes(codes)
  @join code : codes on ", "
    StatusCode.Code.{@code}
  @end
@end

@private builderConstructors(xsettingsClass)
  protected Builder() {
    this((ClientContext) null);
  }

  protected Builder(ClientContext clientContext) {
    super(clientContext);

    stubBuilder = {@xsettingsClass.stubSettingsName}.newBuilder(clientContext);
  }

  private static Builder createDefault() {
    Builder builder = new Builder((ClientContext) null);
    @if xsettingsClass.hasDefaultInstance
      builder.setTransportChannelProvider({@xsettingsClass.stubSettingsName}.defaultTransportChannelProvider());
      builder.setCredentialsProvider({@xsettingsClass.stubSettingsName}.defaultCredentialsProviderBuilder().build());
      builder.setInternalHeaderProvider({@xsettingsClass.stubSettingsName}.defaultApiClientHeaderProviderBuilder().build());
      builder.setEndpoint({@xsettingsClass.stubSettingsName}.getDefaultEndpoint());
      builder.stubBuilder = {@xsettingsClass.stubSettingsName}.newBuilder();
    @end
    return builder;
  }

  protected Builder({@xsettingsClass.name} settings) {
    super(settings);

    @join settings : xsettingsClass.callSettings
      {@settings.memberName} = settings.{@settings.memberName}.toBuilder();
    @end

    unaryMethodSettingsBuilders = ImmutableList.<UnaryCallSettings.Builder<?, ?>>of(
        @join settings : xsettingsClass.unaryCallSettings vertical on ",".add(BREAK)
          {@settings.memberName}
        @end
    );
  }
@end

@private builderMethods(xsettingsClass)
  /**
   * Applies the given settings updater function to all of the unary API methods in this service.
   *
   * Note: This method does not support applying settings to streaming methods.
   */
  public Builder applyToAllUnaryMethods(ApiFunction<UnaryCallSettings.Builder<?, ?>, Void> settingsUpdater) throws Exception {
    super.applyToAllUnaryMethods(unaryMethodSettingsBuilders, settingsUpdater);
    return this;
  }

  @join settings : xsettingsClass.callSettings
    /**
     * Returns the builder for the settings used for calls to {@settings.methodName}.
     */
    @switch settings.type
    @case "SimpleApiCallable"
      public UnaryCallSettings.Builder<{@settings.requestTypeName}, \
          {@settings.responseTypeName}> {@settings.settingsGetFunction}() {
        return {@settings.memberName};
      }
    @case "PagedApiCallable"
      public PagedCallSettings.Builder<{@settings.requestTypeName}, \
          {@settings.responseTypeName}, {@settings.pagedListResponseTypeName}> {@settings.settingsGetFunction}() {
        return {@settings.memberName};
      }
    @case "BatchingApiCallable"
      public BatchingCallSettings.Builder<{@settings.requestTypeName}, \
          {@settings.responseTypeName}> {@settings.settingsGetFunction}() {
        return {@settings.memberName};
      }
    @case "OperationApiCallable"
      public OperationCallSettings.Builder<{@settings.requestTypeName}, \
          {@settings.operationMethod.operationPayloadTypeName}, \
          {@settings.operationMethod.metadataTypeName}> \
          {@settings.settingsGetFunction}() {
        return {@settings.memberName};
      }
    @case "ServerStreamingApiCallable"
      public ServerStreamingCallSettings.Builder<{@settings.requestTypeName}, \
          {@settings.responseTypeName}> {@settings.settingsGetFunction}() {
        return {@settings.memberName};
      }
    @default
      @if settings.isStreaming
        public StreamingCallSettings.Builder<{@settings.requestTypeName}, \
            {@settings.responseTypeName}> {@settings.settingsGetFunction}() {
          return {@settings.memberName};
        }
      @else
        $unhandledCase: {@settings.type}$
      @end
    @end
    {@""}
  @end
  @@Override
  public {@xsettingsClass.name} build() throws IOException {
    return new {@xsettingsClass.name}(this);
  }
@end
