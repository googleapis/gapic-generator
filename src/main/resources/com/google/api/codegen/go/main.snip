@extends "go/header.snip"

@snippet generateFilename(service)
    {@context.getApiConfig.getPackageName}/{@context.getReducedServiceName(service)}_client.go
@end

@snippet generateClass(service, body)
    {@headerComment()}

    // AUTO-GENERATED CODE. DO NOT EDIT.

    package {@context.getPackageName}

    {@importSection(service)}

    {@body}
@end

@private importSection(service)
    import (
    @join import : context.getImports(service)
    {@import}
    @end
    )
@end

@snippet generateBody(service)
    {@globals(service)}

    @let clientName = context.getClientName(service)
        // {@clientName} is a client for interacting with {@service.getSimpleName}.
        type {@clientName} struct {
            // The connection to the service.
            conn *grpc.ClientConn

            // The gRPC API client.
            client {@context.getServiceClientName(service)}

            // The call options for this service.
            CallOptions *{@context.getClientPrefix(service)}CallOptions

    @end
        // The metadata to be sent with each request.
        metadata map[string][]string
    }

    {@constructor(service)}
    {@pathTemplateMethods(service)}
    {@methods(service)}

    {@iterators(service)}
@end

@private globals(service)
    @if context.getApiConfig.getInterfaceConfig(service).getCollectionConfigs
        var (
            @join collectionConfig : context.getApiConfig.getInterfaceConfig(service).getCollectionConfigs
                {@pathTemplateVarName(service, collectionConfig)} = gax.MustCompilePathTemplate("{@collectionConfig.getNamePattern}")
            @end
        )

    @end

    // {@context.getClientPrefix(service)}CallOptions contains the retry settings for each method of this client.
    type {@context.getClientPrefix(service)}CallOptions struct {
        @join method : context.getNonStreamingMethods(service)
            @let methodName = method.getSimpleName
                {@methodName} []gax.CallOption
            @end
        @end
    }

    func default{@context.getClientName(service)}Options() []option.ClientOption {
        return []option.ClientOption{
            option.WithEndpoint("{@context.getServiceConfig.getServiceAddress(service)}:{@context.getServiceConfig.getServicePort()}"),
            option.WithScopes(
                @join scope : context.getServiceConfig.getAuthScopes(service)
                    "{@scope}",
                @end
            ),
        }
    }

    func default{@context.getClientPrefix(service)}CallOptions() *{@context.getClientPrefix(service)}CallOptions {
        retry := map[[2]string][]gax.CallOption{
            @let interfaceConf = context.getApiConfig.getInterfaceConfig(service)
                @join retryName : context.getRetryConfigNames(service) if interfaceConf.getRetryCodesDefinition.get(retryName.getCodesName)
                    @let retryCodes = interfaceConf.getRetryCodesDefinition.get(retryName.getCodesName), \
                         retrySettings = interfaceConf.getRetrySettingsDefinition.get(retryName.getSettingsName)
                        {"{@retryName.getSettingsName}", "{@retryName.getCodesName}"}: {
                            gax.WithRetry(func() gax.Retryer {
                                return gax.OnCodes([]codes.Code{
                                    @join code : retryCodes
                                        codes.{@context.upperUnderscoreToUpperCamel(code.toString())},
                                    @end
                                }, gax.Backoff{
                                    Initial: {@retrySettings.getInitialRetryDelay.getMillis}*time.Millisecond,
                                    Max: {@retrySettings.getMaxRetryDelay.getMillis}*time.Millisecond,
                                    Multiplier: {@retrySettings.getRetryDelayMultiplier},
                                })
                            }),
                        },
                    @end
                @end
            @end
        }

        return &{@context.getClientPrefix(service)}CallOptions{
            @join method : context.getNonStreamingMethods(service)
                @let methodName = method.getSimpleName, \
                     methodConfig = context.getApiConfig.getInterfaceConfig(service).getMethodConfig(method), \
                     retryParamsName = methodConfig.getRetrySettingsConfigName, \
                     retryCodesName = methodConfig.getRetryCodesConfigName
                    {@methodName}: retry[[2]string{"{@retryParamsName}", "{@retryCodesName}"}],
                @end
            @end
        }
    }
@end

@private constructor(service)
    @let clientName = context.getClientName(service)
        // New{@clientName} creates a new {@context.getReducedServiceName(service)} service client.
        //
        @join commentLine : context.comments(service)
            {@commentLine}
        @end
        func New{@clientName}(ctx context.Context, opts ...option.ClientOption) (*{@clientName}, error) {
            conn, err := transport.DialGRPC(ctx, append(default{@clientName}Options(), opts...)...)
            if err != nil {
                return nil, err
            }
            c := &{@clientName} {
                conn: conn,
                client: {@context.getServiceClientConstructorName(service)}(conn),
                CallOptions: default{@context.getClientPrefix(service)}CallOptions(),
            }
            c.SetGoogleClientInfo("gax", gax.Version)
            return c, nil
        }

        // Connection returns the client's connection to the API service.
        func (c *{@clientName}) Connection() *grpc.ClientConn {
            return c.conn
        }

        // Close closes the connection to the API service. The user should invoke this when
        // the client is no longer required.
        func (c *{@clientName}) Close() error {
            return c.conn.Close()
        }

        // SetGoogleClientInfo sets the name and version of the application in
        // the `x-goog-api-client` header passed on each request. Intended for
        // use by Google-written clients.
        func (c *{@clientName}) SetGoogleClientInfo(name, version string) {
            c.metadata = map[string][]string{
                "x-goog-api-client": {fmt.Sprintf("%s/%s %s gax/%s go/%s", name, version, gapicNameVersion, gax.Version, runtime.Version())},
            }
        }
    @end
@end

@private pathTemplateVarName(service, collectionConfig)
    @let prefix = context.lowerUnderscoreToLowerCamel(context.getReducedServiceName(service)), \
         entityName = @context.lowerUnderscoreToUpperCamel(collectionConfig.getEntityName)
        {@prefix}{@entityName}PathTemplate
    @end
@end

@private createResourceDocParams(collectionConfig)
    @join param : collectionConfig.getNameTemplate.vars() on " and "
        the {@context.lowerUnderscoreToLowerCamel(param)}
    @end
@end

@private pathParams(params)
    @join param : params on ", "
        {@context.lowerUnderscoreToLowerCamel(param)} string
    @end
@end

# PathTemplates are currently methods of the service. They don't have to be, but
# this would be good to shorten the method names, and normally the users of these
# methods would have the service instance already.
@private pathTemplateMethods(service)

    @join collectionConfig : context.getApiConfig.getInterfaceConfig(service).getCollectionConfigs()
        @let pathTypeName = context.lowerUnderscoreToUpperCamel(collectionConfig.getEntityName), \
             humanReadableName = collectionConfig.getEntityName.replaceAll("_", " "), \
             methodReceiver = context.lowerUnderscoreToLowerCamel(collectionConfig.getEntityName), \
             prefix = context.lowerUnderscoreToUpperCamel(context.getReducedServiceName(service))

            // {@pathTypeName}Path returns the path for the {@humanReadableName} resource.
            func {@prefix}{@pathTypeName}Path({@pathParams(collectionConfig.getNameTemplate.vars())}) string {
                path, err := {@pathTemplateVarName(service, collectionConfig)}.Render(map[string]string{
                    @join param : collectionConfig.getNameTemplate.vars()
                    "{@param}": {@context.lowerUnderscoreToLowerCamel(param)},
                    @end
                })
                if err != nil {
                    panic(err)
                }
                return path
            }
        @end
    @end
@end

@private methods(service)
    @join method : context.getNonStreamingMethods(service)
        @let methodName = method.getSimpleName, \
             inTypeName = context.typeName(method.getInputType), \
             outTypeName = context.typeName(method.getOutputType), \
             methodConfig = context.getApiConfig.getInterfaceConfig(service).getMethodConfig(method), \
             isPageStreaming = methodConfig.isPageStreaming, \
             clientName = context.getClientName(service)
            @if {@isPageStreaming}
                @let pageStreaming = methodConfig.getPageStreaming(), \
                     iteratorTypeName = context.getIteratorTypeName(pageStreaming), \
                     resourceFieldName = context.lowerUnderscoreToUpperCamel(pageStreaming.getResourcesField().getSimpleName), \
                     hasPageSizeField = pageStreaming.hasPageSizeField(), \
                     requestTokenFieldName = context.lowerUnderscoreToUpperCamel(pageStreaming.getRequestTokenField().getSimpleName), \
                     responseTokenFieldName = context.lowerUnderscoreToUpperCamel(pageStreaming.getResponseTokenField().getSimpleName), \
                     tokenZeroValue = context.zeroValue(pageStreaming.getRequestTokenField().getType)

                    {@methodComment(method, methodName)}
                    func (c *{@clientName}) {@methodName}(ctx context.Context, req {@inTypeName}) *{@iteratorTypeName} {
                        ctx = metadata.NewContext(ctx, c.metadata)
                        it := &{@iteratorTypeName}{}
                        it.apiCall = func() error {
                            var resp {@outTypeName}
                            err := gax.Invoke(ctx, func (ctx context.Context) error {
                                var err error
                                req.{@requestTokenFieldName} = it.nextPageToken
                                @if hasPageSizeField
                                    req.{@context.lowerUnderscoreToUpperCamel(pageStreaming.getPageSizeField().getSimpleName())} = it.pageSize
                                @end
                                resp, err = c.client.{@methodName}(ctx, req)
                                return err
                            }, c.CallOptions.{@methodName}...)
                            if err != nil {
                                return err
                            }
                            if resp.{@responseTokenFieldName} == {@tokenZeroValue} {
                                it.atLastPage = true
                            }
                            it.nextPageToken = resp.{@responseTokenFieldName}
                            it.items = resp.{@resourceFieldName}
                            return nil
                        }
                        return it
                    }

                @end
            @else

                {@methodComment(method, methodName)}
                @if {@context.isEmpty(method.getOutputType)}
                    func (c *{@clientName}) {@methodName}(ctx context.Context, req {@inTypeName}) error {
                        ctx = metadata.NewContext(ctx, c.metadata)
                        err := gax.Invoke(ctx, func (ctx context.Context) error {
                            var err error
                            _, err = c.client.{@methodName}(ctx, req)
                            return err
                        }, c.CallOptions.{@methodName}...)
                        return err
                    }
                @else
                    func (c *{@clientName}) {@methodName}(ctx context.Context, req {@inTypeName}) ({@outTypeName}, error) {
                        ctx = metadata.NewContext(ctx, c.metadata)
                        var resp {@outTypeName}
                        err := gax.Invoke(ctx, func (ctx context.Context) error {
                            var err error
                            resp, err = c.client.{@methodName}(ctx, req)
                            return err
                        }, c.CallOptions.{@methodName}...)
                        if err != nil {
                            return nil, err
                        }
                        return resp, nil
                    }
                @end

            @end
        @end
    @end
@end

@private methodComment(method, methodName)
    @join commentLine : context.getMethodComments(method, methodName)
        {@commentLine}
    @end
@end

@private iterators(service)
    @join pageStreaming : context.getPageStreamingConfigs(service)
        @let iteratorTypeName = context.getIteratorTypeName(pageStreaming), \
             tokenType = context.getNextPageTokenType(service, pageStreaming), \
             resourceFieldType = context.getResourceType(pageStreaming.getResourcesField), \
             resourceFieldTypeName = context.getResourceTypeName(pageStreaming.getResourcesField), \
             hasPageSizeField = pageStreaming.hasPageSizeField()

            // {@iteratorTypeName} manages a stream of {@resourceFieldTypeName}.
            type {@iteratorTypeName} struct {
                // The current page data.
                items         []{@resourceFieldTypeName}
                atLastPage    bool
                currentIndex  int
                @if hasPageSizeField
                    pageSize      int32
                @end
                nextPageToken {@tokenType}
                apiCall       func() error
            }

            // NextPage returns the next page of results.
            @if hasPageSizeField
              // It will return at most the number of results specified by the last call to SetPageSize.
              // If SetPageSize was never called or was called with a value less than 1,
              // the page size is determined by the underlying service.
            @end
            //
            // NextPage may return a second return value of Done along with the last page of results. After
            // NextPage returns Done, all subsequent calls to NextPage will return (nil, Done).
            //
            // Next and NextPage should not be used with the same iterator.
            func (it *{@iteratorTypeName}) NextPage() ([]{@resourceFieldTypeName}, error) {
                if it.atLastPage {
                    // We already returned Done with the last page of items. Continue to
                    // return Done, but with no items.
                    return nil, Done
                }
                if err := it.apiCall(); err != nil {
                    return nil, err
                }
                if it.atLastPage {
                    return it.items, Done
                }
                return it.items, nil
            }

            // Next returns the next result. Its second return value is Done if there are no more results.
            // Once next returns Done, all subsequent calls will return Done.
            @if hasPageSizeField
              //
              // Internally, Next retrieves results in bulk. You can call SetPageSize as a performance hint to
              // affect how many results are retrieved in a single RPC.
            @end
            //
            // SetPageToken should not be called when using Next.
            //
            // Next and NextPage should not be used with the same iterator.
            func (it *{@iteratorTypeName}) Next() ({@resourceFieldTypeName}, error) {
                for it.currentIndex >= len(it.items) {
                    if it.atLastPage {
                        return {@context.zeroValue(resourceFieldType)}, Done
                    }
                    if err := it.apiCall(); err != nil {
                        return {@context.zeroValue(resourceFieldType)}, err
                    }
                    it.currentIndex = 0
                }
                result := it.items[it.currentIndex]
                it.currentIndex++
                return result, nil
            }

            @if hasPageSizeField
                // PageSize returns the page size for all subsequent calls to NextPage.
                func (it *{@iteratorTypeName}) PageSize() int {
                    return int(it.pageSize)
                }

                // SetPageSize sets the page size for all subsequent calls to NextPage.
                func (it *{@iteratorTypeName}) SetPageSize(pageSize int) {
                    if pageSize > math.MaxInt32 {
                        pageSize = math.MaxInt32
                    }
                    it.pageSize = int32(pageSize)
                }

            @end
            // SetPageToken sets the page token for the next call to NextPage, to resume the iteration from
            // a previous point.
            func (it *{@iteratorTypeName}) SetPageToken(token {@tokenType}) {
                it.nextPageToken = token
            }

            // NextPageToken returns a page token that can be used with SetPageToken to resume
            // iteration from the next page. It returns the empty string if there are no more pages.
            func (it *{@iteratorTypeName}) NextPageToken() {@tokenType} {
                return it.nextPageToken
            }
        @end
    @end
@end
