@extends "go/header.snip"

@snippet generate(view)
    {@headerComment(view.fileHeader)}

    package {@view.fileHeader.localPackageName}

    import (
        {@imports(view.fileHeader.imports)}
    )

    @if view.pathTemplates
        var (
            @join pathTemplate : view.pathTemplates
                {@pathTemplate.name} = gax.MustCompilePathTemplate("{@pathTemplate.pattern}")
            @end
        )
    @end

    // {@view.callOptionsTypeName} contains the retry settings for each method of {@view.clientTypeName}.
    type {@view.callOptionsTypeName} struct {
        @join settings : view.callSettings
            {@settings.methodName} []gax.CallOption
        @end
    }

    func {@view.defaultClientOptionFunctionName}() []option.ClientOption {
        return []option.ClientOption{
            option.WithEndpoint("{@view.serviceAddress}:{@view.servicePort}"),
            option.WithScopes(
                @join scope : view.authScopes
                    "{@scope}",
                @end
            ),
        }
    }

    func {@view.defaultCallOptionFunctionName}() *{@view.callOptionsTypeName} {
        retry := map[[2]string][]gax.CallOption{
            @join def : view.retryPairDefinitions
              {"{@def.name.retrySettingsConfigName}", "{@def.name.retryCodesConfigName}"}: {
                  gax.WithRetry(func() gax.Retryer {
                      return gax.OnCodes([]codes.Code{
                          @join code : def.retryCodes
                              codes.{@code},
                          @end
                      }, gax.Backoff{
                          Initial: {@def.params.getInitialRetryDelay.getMillis}*time.Millisecond,
                          Max: {@def.params.getMaxRetryDelay.getMillis}*time.Millisecond,
                          Multiplier: {@def.params.getRetryDelayMultiplier},
                      })
                  }),
              },
            @end
        }
        return &{@view.callOptionsTypeName}{
            @join settings : view.callSettings
                {@settings.methodName}: retry[[2]string{"{@settings.retryParamsName}", "{@settings.retryCodesName}"}],
            @end
        }
    }

    // {@view.clientTypeName} is a client for interacting with {@view.serviceOriginalName}.
    type {@view.clientTypeName} struct {
        // The connection to the service.
        conn *grpc.ClientConn

        // The gRPC API client.
        @join stub : view.stubs
            {@stub.name} {@stub.grpcClientTypeName}
        @end

        // The call options for this service.
        CallOptions *{@view.callOptionsTypeName}

        // The metadata to be sent with each request.
        metadata metadata.MD
    }

    // {@view.clientConstructorName} creates a new {@view.servicePhraseName} client.
    //
    // {@view.serviceDoc.firstLine}
    @join line : view.serviceDoc.remainingLines
        // {@line}
    @end
    func {@view.clientConstructorName}(ctx context.Context, opts ...option.ClientOption) (*{@view.clientTypeName}, error) {
        conn, err := transport.DialGRPC(ctx, append({@view.defaultClientOptionFunctionName}(), opts...)...)
        if err != nil {
            return nil, err
        }
        c := &{@view.clientTypeName} {
            conn: conn,
            CallOptions: {@view.defaultCallOptionFunctionName}(),

            @join stub : view.stubs
                {@stub.name}: {@stub.createStubFunctionName}(conn),
            @end
        }
        c.SetGoogleClientInfo("gax", gax.Version)
        return c, nil
    }

    // Connection returns the client's connection to the API service.
    func (c *{@view.clientTypeName}) Connection() *grpc.ClientConn {
        return c.conn
    }

    // Close closes the connection to the API service. The user should invoke this when
    // the client is no longer required.
    func (c *{@view.clientTypeName}) Close() error {
        return c.conn.Close()
    }

    // SetGoogleClientInfo sets the name and version of the application in
    // the `x-goog-api-client` header passed on each request. Intended for
    // use by Google-written clients.
    func (c *{@view.clientTypeName}) SetGoogleClientInfo(name, version string) {
        v := fmt.Sprintf("%s/%s %s gax/%s go/%s", name, version, gapicNameVersion, gax.Version, runtime.Version())
        c.metadata = metadata.Pairs("x-goog-api-client", v)
    }

    @join getter : view.pathTemplateGetters
        // {@getter.name} returns the path for the {@getter.resourceName} resource.
        func {@getter.name}({@pathTemplateParams(getter.args)} string) string {
            path, err := {@getter.pathTemplateName}.Render(map[string]string{
                @join arg : getter.args
                    "{@arg.templateKey}": {@arg.name},
                @end
            })
            if err != nil {
                panic(err)
            }
            return path
        }

    @end

    @join resource : view.iamResources
        func (c *{@view.clientTypeName}) {@resource.resourceGetterFunctionName}({@resource.paramName} {@resource.resourceTypeName}) *iam.Handle {
            return iam.InternalNewHandle(c.Connection(), {@resource.paramName}.{@resource.fieldName})
        }

    @end

    @join method : view.apiMethods
        @join doc : method.doc.mainDocLines
            // {@doc}
        @end

        @switch method.grpcStreamingType
        @case "BidiStreaming"
            {@noRequestStreamMethod(view, method)}
        @case "ClientStreaming"
            {@noRequestStreamMethod(view, method)}
        @case "ServerStreaming"
            {@simpleMethod(view, method)}
        @case "NonStreaming"
            @switch method.type
            @case "PagedRequestObjectMethod"
                {@pageStreamingMethod(view, method)}
            @case "RequestObjectMethod"
                @if method.hasReturnValue
                    @if method.isLongRunning
                        {@lroMethod(view, method)}
                    @else
                        {@simpleMethod(view, method)}
                    @end
                @else
                    {@emptyReturnMethod(view, method)}
                @end
            @end
        @end

    @end

    @join iter : view.pageStreamingDescriptorClasses
        {@iterator(iter)}
    @end
@end

@private simpleMethod(view, method)
    func (c *{@view.clientTypeName}) {@method.name}(ctx context.Context, req {@method.apiRequestTypeName}) ({@method.responseTypeName}, error) {
        {@mergeMetadata()}
        var resp {@method.responseTypeName}
        err := gax.Invoke(ctx, func(ctx context.Context) error {
            var err error
            resp, err = c.{@method.stubName}.{@method.callableName}(ctx, req)
            return err
        }, c.CallOptions.{@method.settingsGetterName}...)
        if err != nil {
            return nil, err
        }
        return resp, nil
    }
@end

@private lroMethod(view, method)
    func (c *{@view.clientTypeName}) {@method.name}(ctx context.Context, req {@method.apiRequestTypeName}) (*longrunning.Operation, error) {
        {@mergeMetadata()}
        var resp {@method.responseTypeName}
        err := gax.Invoke(ctx, func(ctx context.Context) error {
            var err error
            resp, err = c.{@method.stubName}.{@method.callableName}(ctx, req)
            return err
        }, c.CallOptions.{@method.name}...)
        if err != nil {
            return nil, err
        }
        return longrunning.InternalNewOperation(c.Connection(), resp), nil
    }
@end

# Used for bidi and request GRPC streaming.
# The function is not accept a request, but otherwise the same with simpleMethod.
@private noRequestStreamMethod(view, method)
    func (c *{@view.clientTypeName}) {@method.name}(ctx context.Context) ({@method.responseTypeName}, error) {
        {@mergeMetadata()}
        var resp {@method.responseTypeName}
        err := gax.Invoke(ctx, func(ctx context.Context) error {
            var err error
            resp, err = c.{@method.stubName}.{@method.name}(ctx)
            return err
        }, c.CallOptions.{@method.settingsGetterName}...)
        if err != nil {
            return nil, err
        }
        return resp, nil
    }
@end

@private emptyReturnMethod(view, method)
    func (c *{@view.clientTypeName}) {@method.name}(ctx context.Context, req {@method.apiRequestTypeName}) error {
        {@mergeMetadata()}
        err := gax.Invoke(ctx, func(ctx context.Context) error {
            var err error
            _, err = c.{@method.stubName}.{@method.callableName}(ctx, req)
            return err
        }, c.CallOptions.{@method.settingsGetterName}...)
        return err
    }
@end

@private pageStreamingMethod(view, method)
    func (c *{@view.clientTypeName}) {@method.name}(ctx context.Context, req {@method.apiRequestTypeName}) *{@method.responseTypeName} {
        {@mergeMetadata()}
        it := &{@method.responseTypeName}{}

        fetch := func(pageSize int, pageToken string) (string, error) {
            var resp {@method.listMethod.responseObjectTypeName}
            req.PageToken = pageToken
            if pageSize > math.MaxInt32 {
                req.PageSize = math.MaxInt32
            } else {
                req.PageSize = int32(pageSize)
            }
            err := gax.Invoke(ctx, func(ctx context.Context) error {
                var err error
                resp, err = c.{@method.stubName}.{@method.callableName}(ctx, req)
                return err
            }, c.CallOptions.{@method.settingsGetterName}...)
            if err != nil {
                return "", err
            }
            it.items = append(it.items, resp.{@method.listMethod.resourceFieldName}...)
            return resp.NextPageToken, nil
        }
        bufLen := func() int { return len(it.items) }
        takeBuf := func() interface{} {
            b := it.items
            it.items = nil
            return b
        }

        it.pageInfo, it.nextFunc = iterator.NewPageInfo(fetch, bufLen, takeBuf)
        return it
    }
@end

@private iterator(iter)
    // {@iter.typeName} manages a stream of {@iter.resourceTypeName}.
    type {@iter.typeName} struct {
        items    []{@iter.resourceTypeName}
        pageInfo *iterator.PageInfo
        nextFunc func() error
    }

    // PageInfo supports pagination. See the google.golang.org/api/iterator package for details.
    func (it *{@iter.typeName}) PageInfo() *iterator.PageInfo {
        return it.pageInfo
    }

    // Next returns the next result. Its second return value is iterator.Done if there are no more
    // results. Once Next returns Done, all subsequent calls will return Done.
    func (it *{@iter.typeName}) Next() ({@iter.resourceTypeName}, error) {
        if err := it.nextFunc(); err != nil {
            return {@iter.resourceZeroValue}, err
        }
        item := it.items[0]
        it.items = it.items[1:]
        return item, nil
    }

@end

@private pathTemplateParams(args)
    @join e : args on ", "
      {@e.name}
    @end
@end

@private mergeMetadata()
    md, _ := metadata.FromContext(ctx)
    ctx = metadata.NewContext(ctx, metadata.Join(md, c.metadata))
@end
