@extends "go/header.snip"

@snippet generate(view)
    {@headerComment()}

    // AUTO-GENERATED CODE. DO NOT EDIT.

    package {@view.packageName}

    import (
        "fmt"
        "runtime"
        "time"

        "github.com/googleapis/gax-go"
        "golang.org/x/net/context"
        "google.golang.org/api/option"
        "google.golang.org/api/transport"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
    )

    var (
        @join pathTemplate : view.pathTemplates
            {@pathTemplate.name} = gax.MustCompilePathTemplate("{@pathTemplate.pattern}")
        @end
    )

    // CallOptions contains the retry settings for each method of this client.
    type {@view.name}CallOptions struct {
        @join apiMethod : view.apiMethods
            {@apiMethod.name} []gax.CallOption
        @end
    }

    func default{@view.name}ClientOptions() []option.ClientOption {
        return []option.ClientOption{
            option.WithEndpoint("{@view.serviceAddress}:{@view.servicePort}"),
            option.WithScopes(
                @join scope : view.authScopes
                    "{@scope}",
                @end
            ),
        }
    }

    func default{@view.name}CallOptions() *{@view.name}CallOptions {
        @join retryCodesDef : view.retryCodesDefinitions
            {@retryCodesDef.key} := gax.WithRetryCodes([]codes.Code{
                    @join code : retryCodesDef.codes
                        codes.{@code},
                    @end
            })
        @end
        return &{@view.name}CallOptions{
            @join settings : view.callSettings
                {@settings.methodName}: retry[[2]string{"{@settings.retryParamsName}", "{@settings.retryCodesName}"}],
            @end
        }
    }

    // {@view.name}Client is a client for interacting with {@view.serviceName}.
    type {@view.name}Client struct {
        // The connection to the service.
        conn *grpc.ClientConn

        // The gRPC API client.
        client {@view.servicePackageName}.{@view.serviceName}Client

        // The call options for this service.
        CallOptions *{@view.name}CallOptions

        // The metadata to be sent with each request.
        metadata map[string][]string
    }

    // New{@view.name}Client creates a new {@view.serviceName} client.
    //
    @join line : view.serviceDoc
        {@line}
    @end
    func New{@view.name}Client(ctx context.Context, opts ...option.ClientOption) (*{@view.name}Client, error) {
        conn, err := transport.DialGRPC(ctx, append(default{@view.name}ClientOptions(), opts...)...)
        if err != nil {
            return nil, err
        }
        c := &{@view.name}Client {
            conn: conn,
            client: {@view.servicePackageName}.New{@view.serviceName}Client(conn),
            CallOptions: default{@view.name}CallOptions(),
        }
        c.SetGoogleClientInfo("gax", gax.Version)
        return c, nil
    }

    // Connection returns the client's connection to the API service.
    func (c *{@view.name}Client) Connection() *grpc.ClientConn {
        return c.conn
    }

    // Close closes the connection to the API service. The user should invoke this when
    // the client is no longer required.
    func (c *{@view.name}Client) Close() error {
        return c.conn.Close()
    }

    // SetGoogleClientInfo sets the name and version of the application in
    // the `x-goog-api-client` header passed on each request. Intended for
    // use by Google-written clients.
    func (c *{@view.name}Client) SetGoogleClientInfo(name, version string) {
        c.metadata = map[string][]string{
            "x-goog-api-client": {fmt.Sprintf("%s/%s %s gax/%s go/%s", name, version, gapicNameVersion, gax.Version, runtime.Version())},
        }
    }

    @join getter : view.pathTemplateGetters
        // {@getter.name} returns the path for the {@getter.resourceName} resource.
        func {@getter.name}({@pathTemplateParams(getter.args)} string) string {
            path, err := {@getter.pathTemplateName}.Render(map[string]string{
                @join arg : getter.args
                    "{@arg.templateArg}": {@arg.funcParam},
                @end
            })
            if err != nil {
                panic(err)
            }
            return path
        }

    @end

    @join method : view.apiMethods
        @join doc : method.doc.mainDocLines
            // {@doc}
        @end

        @if method.isPageStreaming
            {@pageStreamingMethod(view, method)}
        @else
            @if method.hasReturnValue
                {@simpleMethod(view, method)}
            @else
                {@emptyReturnMethod(view, method)}
            @end
        @end

    @end
@end

@private simpleMethod(view, method)
    func (c *{@view.name}Client) {@method.name}(ctx context.Context, req *{@method.apiRequestTypeName}) (*{@method.responseTypeName}, error) {
        ctx = metadata.NewContext(ctx, c.metadata)
        var resp *{@method.responseTypeName}
        err := gax.Invoke(ctx, func(ctx context.Context) error {
            var err error
            resp, err = c.client.{@method.name}(ctx, req)
            return err
        }, c.CallOptions.{@method.name}...)
        if err != nil {
            return nil, err
        }
        return resp, nil
    }
@end

@private emptyReturnMethod(view, method)
    func (c *{@view.name}Client) {@method.name}(ctx context.Context, req *{@method.apiRequestTypeName}) error {
        ctx = metadata.NewContext(ctx, c.metadata)
        err := gax.Invoke(ctx, func(ctx context.Context) error {
            var err error
            _, err = c.client.{@method.name}(ctx, req)
            return err
        }, c.CallOptions.{@method.name}...)
        return err
    }
@end

@private pageStreamingMethod(view, method)
    func (c *{@view.name}Client) {@method.name}(ctx context.Context, req *{@method.apiRequestTypeName}) *{@method.responseTypeName} {
        ctx = metadata.NewContext(ctx, c.metadata)
        it := &{@method.responseTypeName}{}
        it.apiCall = func() error {
            var resp *{@method.listResponseObjectTypeName}
            err := gax.Invoke(ctx, func(ctx context.Context) error {
                var err error
                req.PageToken = it.nextPageToken
                resp, err = c.client.{@method.name}(ctx, req)
                return err
            }, c.CallOptions.{@method.name}...)
            if err != nil {
                return err
            }
            if resp.NextPageToken == "" {
                it.atLastPage = true
            }
            it.nextPageToken = resp.NextPageToken
            it.items = resp.{@method.listMethod.resourceFieldName}
            return nil
        }
        return it
    }
@end

@private pathTemplateParams(args)
    @join e : args on ", "
      {@e.funcParam}
    @end
@end
