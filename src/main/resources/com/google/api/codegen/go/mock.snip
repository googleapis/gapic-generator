@extends "go/header.snip"

@snippet generate(view)
    {@headerComment(view.fileHeader)}

    package {@view.fileHeader.localPackageName}

    import (
        {@imports(view.fileHeader.imports)}
    )

    import (
        "flag"
        "io"
        "log"
        "net"
        "os"
        "reflect"
        "testing"

        "golang.org/x/net/context"
        "google.golang.org/api/option"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
    )

    var _ = io.EOF

    @join impl : view.serviceImpls
        type {@impl.name} struct {
            reqs []interface{}

            // If set, all calls return this error.
            err error

            // responses to return if err == nil
            resps []interface{}
        }

        @join method : impl.grpcMethods
            @switch method.grpcStreamingType
            @case "BidiStreaming"
                {@bidiMethod(impl, method)}
            @case "ClientStreaming"
                {@clientStreamMethod(impl, method)}
            @case "ServerStreaming"
                {@serverStreamMethod(impl, method)}
            @case "NonStreaming"
                {@simpleMethod(impl, method)}
            @end


        @end
    @end

    // clientOpt is the option tests should use to connect to the test server.
    // It is initialized by TestMain.
    var clientOpt option.ClientOption

    var (
        @join service : view.mockServices
            {@service.varName} {@service.implName}
        @end
    )

    func TestMain(m *testing.M) {
        flag.Parse()

        serv := grpc.NewServer()
        @join service : view.mockServices
            {@service.registerFunctionName}(serv, &{@service.varName})
        @end

        lis, err := net.Listen("tcp", "localhost:0")
        if err != nil {
            log.Fatal(err)
        }
        go serv.Serve(lis)

        conn, err := grpc.Dial(lis.Addr().String(), grpc.WithInsecure())
        if err != nil {
            log.Fatal(err)
        }
        clientOpt = option.WithGRPCConn(conn)

        os.Exit(m.Run())
    }

    @join testClass : view.testClasses
        @join testCase : testClass.testCases
            {@testError(testCase)}
        @end
    @end
@end

@private simpleMethod(impl, method)
    func (s *{@impl.name}) {@method.name}(_ context.Context, req {@method.requestTypeName}) ({@method.responseTypeName}, error) {
        s.reqs = append(s.reqs, req)
        if s.err != nil {
            return nil, s.err
        }
        return s.resps[0].({@method.responseTypeName}), nil
    }
@end

@private serverStreamMethod(impl, method)
    func (s *{@impl.name}) {@method.name}(req {@method.requestTypeName}, stream {@method.streamHandleTypeName}) error {
        s.reqs = append(s.reqs, req)
        if s.err != nil {
            return s.err
        }
        for _, v := range s.resps {
            if err := stream.Send(v.({@method.responseTypeName})); err != nil {
                return err
            }
        }
        return nil
    }
@end

@private clientStreamMethod(impl, method)
    func (s *{@impl.name}) {@method.name}(stream {@method.streamHandleTypeName}) error {
        if s.err != nil {
            return s.err
        }
        for {
            if req, err := stream.Recv(); err == io.EOF {
                return stream.SendAndClose(s.resps[0].({@method.responseTypeName}))
            } else if err != nil {
                return err
            } else {
                s.reqs = append(s.reqs, req)
            }
        }
    }
@end

@private bidiMethod(impl, method)
    func (s *{@impl.name}) {@method.name}(stream {@method.streamHandleTypeName}) error {
        if s.err != nil {
            return s.err
        }

        ch := make(chan error, 2)
        go func() {
            for {
                if req, err := stream.Recv(); err == io.EOF {
                    ch <- nil
                    return
                } else if err != nil {
                    ch <- err
                    return
                } else {
                    s.reqs = append(s.reqs, req)
                }
            }
        }()
        go func() {
            for _, v := range s.resps {
                if err := stream.Send(v.({@method.responseTypeName})); err != nil {
                    ch <- err
                    return
                }
            }
            ch <- nil
        }()

        // Doesn't really matter which one we get.
        err := <-ch
        if err2 := <-ch; err == nil {
            err = err2
        }
        return err
    }
@end

@private testError(test)
    func {@test.nameWithException}(t *testing.T) {
        errCode := codes.Internal
        {@test.mockServiceVarName}.err = grpc.Errorf(errCode, "test error")

        c, err := {@test.serviceConstructorName}(context.Background(), clientOpt)
        if err != nil {
            t.Fatal(err)
        }

        var req {@test.requestTypeName}

        # TODO(pongad): Use struct initializer instead of reflection.
        # The type name has the pointer-star: "*pkg.Type", so we can't use it to initialize.
        # This should fall off from initializing requests in happy-case test.
        reflect.ValueOf(&req).Elem().Set(reflect.New(reflect.TypeOf(req).Elem()))

        @switch test.grpcStreamingType
        @case "BidiStreaming"
            stream, err := c.{@test.surfaceMethodName}(context.Background())
            if err != nil {
                t.Fatal(err)
            }
            _, err = stream.Recv()
        @case "ServerStreaming"
            stream, err := c.{@test.surfaceMethodName}(context.Background())
            if err != nil {
                t.Fatal(err)
            }
            _, err = stream.Recv()
        @case "ClientStreaming"
            stream, err := c.{@test.surfaceMethodName}(context.Background())
            if err != nil {
                t.Fatal(err)
            }
            _, err = stream.CloseAndRecv()
        @case "NonStreaming"
            @switch test.clientMethodType
            @case "PagedRequestObjectMethod"
                _, err = c.{@test.surfaceMethodName}(context.Background(), req).Next()
            @case "RequestObjectMethod"
                @if test.hasReturnValue
                    _, err = c.{@test.surfaceMethodName}(context.Background(), req)
                @else
                    err = c.{@test.surfaceMethodName}(context.Background(), req)
                @end
            @end
        @end

        if c := grpc.Code(err); c != errCode {
            t.Errorf("got error code %q, want %q", c, errCode)
        }
    }
@end
