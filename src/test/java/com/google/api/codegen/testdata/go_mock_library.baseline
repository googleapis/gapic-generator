============== file: cloud.google.com/go/library/apiv1/mock_test.go ==============
// Copyright 2017, Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// AUTO-GENERATED CODE. DO NOT EDIT.

package library

import (
    emptypb "github.com/golang/protobuf/ptypes/empty"
    librarypb "google.golang.org/genproto/googleapis/example/library/v1"
    longrunningpb "google.golang.org/genproto/googleapis/longrunning"
    taggerpb "google.golang.org/genproto/googleapis/tagger/v1"
)

import (
    "flag"
    "fmt"
    "io"
    "log"
    "net"
    "os"
    "strings"
    "testing"

    "github.com/golang/protobuf/proto"
    "github.com/golang/protobuf/ptypes"
    "golang.org/x/net/context"
    "google.golang.org/api/option"
    status "google.golang.org/genproto/googleapis/rpc/status"
    "google.golang.org/grpc"
    "google.golang.org/grpc/codes"
    "google.golang.org/grpc/metadata"
    gstatus "google.golang.org/grpc/status"
)

var _ = io.EOF
var _ = ptypes.MarshalAny
var _ status.Status

type mockLibraryServer struct {
    // Embed for forward compatibility.
    // Tests will keep working if more methods are added
    // in the future.
    librarypb.LibraryServiceServer

    reqs []proto.Message

    // If set, all calls return this error.
    err error

    // responses to return if err == nil
    resps []proto.Message
}

func (s *mockLibraryServer) CreateShelf(ctx context.Context, req *librarypb.CreateShelfRequest) (*librarypb.Shelf, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*librarypb.Shelf), nil
}

func (s *mockLibraryServer) GetShelf(ctx context.Context, req *librarypb.GetShelfRequest) (*librarypb.Shelf, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*librarypb.Shelf), nil
}

func (s *mockLibraryServer) ListShelves(ctx context.Context, req *librarypb.ListShelvesRequest) (*librarypb.ListShelvesResponse, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*librarypb.ListShelvesResponse), nil
}

func (s *mockLibraryServer) DeleteShelf(ctx context.Context, req *librarypb.DeleteShelfRequest) (*emptypb.Empty, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*emptypb.Empty), nil
}

func (s *mockLibraryServer) MergeShelves(ctx context.Context, req *librarypb.MergeShelvesRequest) (*librarypb.Shelf, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*librarypb.Shelf), nil
}

func (s *mockLibraryServer) CreateBook(ctx context.Context, req *librarypb.CreateBookRequest) (*librarypb.Book, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*librarypb.Book), nil
}

func (s *mockLibraryServer) PublishSeries(ctx context.Context, req *librarypb.PublishSeriesRequest) (*librarypb.PublishSeriesResponse, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*librarypb.PublishSeriesResponse), nil
}

func (s *mockLibraryServer) GetBook(ctx context.Context, req *librarypb.GetBookRequest) (*librarypb.Book, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*librarypb.Book), nil
}

func (s *mockLibraryServer) ListBooks(ctx context.Context, req *librarypb.ListBooksRequest) (*librarypb.ListBooksResponse, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*librarypb.ListBooksResponse), nil
}

func (s *mockLibraryServer) DeleteBook(ctx context.Context, req *librarypb.DeleteBookRequest) (*emptypb.Empty, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*emptypb.Empty), nil
}

func (s *mockLibraryServer) UpdateBook(ctx context.Context, req *librarypb.UpdateBookRequest) (*librarypb.Book, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*librarypb.Book), nil
}

func (s *mockLibraryServer) MoveBook(ctx context.Context, req *librarypb.MoveBookRequest) (*librarypb.Book, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*librarypb.Book), nil
}

func (s *mockLibraryServer) ListStrings(ctx context.Context, req *librarypb.ListStringsRequest) (*librarypb.ListStringsResponse, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*librarypb.ListStringsResponse), nil
}

func (s *mockLibraryServer) AddComments(ctx context.Context, req *librarypb.AddCommentsRequest) (*emptypb.Empty, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*emptypb.Empty), nil
}

func (s *mockLibraryServer) GetBookFromArchive(ctx context.Context, req *librarypb.GetBookFromArchiveRequest) (*librarypb.BookFromArchive, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*librarypb.BookFromArchive), nil
}

func (s *mockLibraryServer) GetBookFromAnywhere(ctx context.Context, req *librarypb.GetBookFromAnywhereRequest) (*librarypb.BookFromAnywhere, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*librarypb.BookFromAnywhere), nil
}

func (s *mockLibraryServer) UpdateBookIndex(ctx context.Context, req *librarypb.UpdateBookIndexRequest) (*emptypb.Empty, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*emptypb.Empty), nil
}

func (s *mockLibraryServer) StreamShelves(req *librarypb.StreamShelvesRequest, stream librarypb.LibraryService_StreamShelvesServer) error {
    md, _ := metadata.FromIncomingContext(stream.Context())
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return s.err
    }
    for _, v := range s.resps {
        if err := stream.Send(v.(*librarypb.StreamShelvesResponse)); err != nil {
            return err
        }
    }
    return nil
}

func (s *mockLibraryServer) StreamBooks(req *librarypb.StreamBooksRequest, stream librarypb.LibraryService_StreamBooksServer) error {
    md, _ := metadata.FromIncomingContext(stream.Context())
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return s.err
    }
    for _, v := range s.resps {
        if err := stream.Send(v.(*librarypb.Book)); err != nil {
            return err
        }
    }
    return nil
}

func (s *mockLibraryServer) DiscussBook(stream librarypb.LibraryService_DiscussBookServer) error {
    md, _ := metadata.FromIncomingContext(stream.Context())
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    for {
        if req, err := stream.Recv(); err == io.EOF {
            break
        } else if err != nil {
            return err
        } else {
            s.reqs = append(s.reqs, req)
        }
    }
    if s.err != nil {
        return s.err
    }
    for _, v := range s.resps {
        if err := stream.Send(v.(*librarypb.Comment)); err != nil {
            return err
        }
    }
    return nil
}

func (s *mockLibraryServer) MonologAboutBook(stream librarypb.LibraryService_MonologAboutBookServer) error {
    md, _ := metadata.FromIncomingContext(stream.Context())
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    for {
        if req, err := stream.Recv(); err == io.EOF {
            break
        } else if err != nil {
            return err
        } else {
            s.reqs = append(s.reqs, req)
        }
    }
    if s.err != nil {
        return s.err
    }
    return stream.SendAndClose(s.resps[0].(*librarypb.Comment))
}

func (s *mockLibraryServer) FindRelatedBooks(ctx context.Context, req *librarypb.FindRelatedBooksRequest) (*librarypb.FindRelatedBooksResponse, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*librarypb.FindRelatedBooksResponse), nil
}

func (s *mockLibraryServer) AddTag(ctx context.Context, req *taggerpb.AddTagRequest) (*taggerpb.AddTagResponse, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*taggerpb.AddTagResponse), nil
}

func (s *mockLibraryServer) GetBigBook(ctx context.Context, req *librarypb.GetBookRequest) (*longrunningpb.Operation, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*longrunningpb.Operation), nil
}

func (s *mockLibraryServer) GetBigNothing(ctx context.Context, req *librarypb.GetBookRequest) (*longrunningpb.Operation, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*longrunningpb.Operation), nil
}

func (s *mockLibraryServer) TestOptionalRequiredFlatteningParams(ctx context.Context, req *librarypb.TestOptionalRequiredFlatteningParamsRequest) (*librarypb.TestOptionalRequiredFlatteningParamsResponse, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*librarypb.TestOptionalRequiredFlatteningParamsResponse), nil
}

type mockLabelerServer struct {
    // Embed for forward compatibility.
    // Tests will keep working if more methods are added
    // in the future.
    taggerpb.LabelerServer

    reqs []proto.Message

    // If set, all calls return this error.
    err error

    // responses to return if err == nil
    resps []proto.Message
}

func (s *mockLabelerServer) AddLabel(ctx context.Context, req *taggerpb.AddLabelRequest) (*taggerpb.AddLabelResponse, error) {
    md, _ := metadata.FromIncomingContext(ctx)
    if xg := md["x-goog-api-client"]; len(xg) == 0 || !strings.Contains(xg[0], "gl-go/") {
        return nil, fmt.Errorf("x-goog-api-client = %v, expected gl-go key", xg)
    }
    s.reqs = append(s.reqs, req)
    if s.err != nil {
        return nil, s.err
    }
    return s.resps[0].(*taggerpb.AddLabelResponse), nil
}


// clientOpt is the option tests should use to connect to the test server.
// It is initialized by TestMain.
var clientOpt option.ClientOption

var (
    mockLibrary mockLibraryServer
    mockLabeler mockLabelerServer
)

func TestMain(m *testing.M) {
    flag.Parse()

    serv := grpc.NewServer()
    librarypb.RegisterLibraryServiceServer(serv, &mockLibrary)
    taggerpb.RegisterLabelerServer(serv, &mockLabeler)

    lis, err := net.Listen("tcp", "localhost:0")
    if err != nil {
        log.Fatal(err)
    }
    go serv.Serve(lis)

    conn, err := grpc.Dial(lis.Addr().String(), grpc.WithInsecure())
    if err != nil {
        log.Fatal(err)
    }
    clientOpt = option.WithGRPCConn(conn)

    os.Exit(m.Run())
}

func TestLibraryServiceCreateShelf(t *testing.T) {
    var name string = "name3373707"
    var theme string = "theme110327241"
    var internalTheme string = "internalTheme792518087"
    var expectedResponse = &librarypb.Shelf{
        Name: name,
        Theme: theme,
        InternalTheme: internalTheme,
    }

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var shelf *librarypb.Shelf = &librarypb.Shelf{}
    var request = &librarypb.CreateShelfRequest{
        Shelf: shelf,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.CreateShelf(context.Background(), request)

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    if want, got := expectedResponse, resp; !proto.Equal(want, got) {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServiceCreateShelfError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var shelf *librarypb.Shelf = &librarypb.Shelf{}
    var request = &librarypb.CreateShelfRequest{
        Shelf: shelf,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.CreateShelf(context.Background(), request)

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLibraryServiceGetShelf(t *testing.T) {
    var name2 string = "name2-1052831874"
    var theme string = "theme110327241"
    var internalTheme string = "internalTheme792518087"
    var expectedResponse = &librarypb.Shelf{
        Name: name2,
        Theme: theme,
        InternalTheme: internalTheme,
    }

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var formattedName string = ShelfPath("[SHELF_ID]")
    var options string = "options-1249474914"
    var request = &librarypb.GetShelfRequest{
        Name: formattedName,
        Options: options,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.GetShelf(context.Background(), request)

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    if want, got := expectedResponse, resp; !proto.Equal(want, got) {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServiceGetShelfError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var formattedName string = ShelfPath("[SHELF_ID]")
    var options string = "options-1249474914"
    var request = &librarypb.GetShelfRequest{
        Name: formattedName,
        Options: options,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.GetShelf(context.Background(), request)

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLibraryServiceListShelves(t *testing.T) {
    var nextPageToken string = ""
    var shelvesElement *librarypb.Shelf = &librarypb.Shelf{}
    var shelves = []*librarypb.Shelf{shelvesElement}
    var expectedResponse = &librarypb.ListShelvesResponse{
        NextPageToken: nextPageToken,
        Shelves: shelves,
    }

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var request *librarypb.ListShelvesRequest = &librarypb.ListShelvesRequest{}

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.ListShelves(context.Background(), request).Next()

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    want := (interface{})(expectedResponse.Shelves[0])
    got := (interface{})(resp)
    var ok bool

    switch want := (want).(type) {
    case proto.Message:
        ok = proto.Equal(want, got.(proto.Message))
    default:
        ok = want == got
    }
    if !ok {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServiceListShelvesError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var request *librarypb.ListShelvesRequest = &librarypb.ListShelvesRequest{}

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.ListShelves(context.Background(), request).Next()

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLibraryServiceDeleteShelf(t *testing.T) {
    var expectedResponse *emptypb.Empty = &emptypb.Empty{}

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var formattedName string = ShelfPath("[SHELF_ID]")
    var request = &librarypb.DeleteShelfRequest{
        Name: formattedName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    err = c.DeleteShelf(context.Background(), request)

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

}

func TestLibraryServiceDeleteShelfError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var formattedName string = ShelfPath("[SHELF_ID]")
    var request = &librarypb.DeleteShelfRequest{
        Name: formattedName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    err = c.DeleteShelf(context.Background(), request)

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
}
func TestLibraryServiceMergeShelves(t *testing.T) {
    var name2 string = "name2-1052831874"
    var theme string = "theme110327241"
    var internalTheme string = "internalTheme792518087"
    var expectedResponse = &librarypb.Shelf{
        Name: name2,
        Theme: theme,
        InternalTheme: internalTheme,
    }

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var formattedName string = ShelfPath("[SHELF_ID]")
    var formattedOtherShelfName string = ShelfPath("[SHELF_ID]")
    var request = &librarypb.MergeShelvesRequest{
        Name: formattedName,
        OtherShelfName: formattedOtherShelfName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.MergeShelves(context.Background(), request)

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    if want, got := expectedResponse, resp; !proto.Equal(want, got) {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServiceMergeShelvesError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var formattedName string = ShelfPath("[SHELF_ID]")
    var formattedOtherShelfName string = ShelfPath("[SHELF_ID]")
    var request = &librarypb.MergeShelvesRequest{
        Name: formattedName,
        OtherShelfName: formattedOtherShelfName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.MergeShelves(context.Background(), request)

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLibraryServiceCreateBook(t *testing.T) {
    var name2 string = "name2-1052831874"
    var author string = "author-1406328437"
    var title string = "title110371416"
    var read bool = true
    var expectedResponse = &librarypb.Book{
        Name: name2,
        Author: author,
        Title: title,
        Read: read,
    }

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var formattedName string = ShelfPath("[SHELF_ID]")
    var book *librarypb.Book = &librarypb.Book{}
    var request = &librarypb.CreateBookRequest{
        Name: formattedName,
        Book: book,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.CreateBook(context.Background(), request)

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    if want, got := expectedResponse, resp; !proto.Equal(want, got) {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServiceCreateBookError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var formattedName string = ShelfPath("[SHELF_ID]")
    var book *librarypb.Book = &librarypb.Book{}
    var request = &librarypb.CreateBookRequest{
        Name: formattedName,
        Book: book,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.CreateBook(context.Background(), request)

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLibraryServicePublishSeries(t *testing.T) {
    var bookNamesElement string = "bookNamesElement1491670575"
    var bookNames = []string{bookNamesElement}
    var expectedResponse = &librarypb.PublishSeriesResponse{
        BookNames: bookNames,
    }

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var shelf *librarypb.Shelf = &librarypb.Shelf{}
    var books []*librarypb.Book = nil
    var seriesString string = "foobar"
    var seriesUuid = &librarypb.SeriesUuid{
        Source: &librarypb.SeriesUuid_SeriesString{
            SeriesString: seriesString,
        },
    }
    var request = &librarypb.PublishSeriesRequest{
        Shelf: shelf,
        Books: books,
        SeriesUuid: seriesUuid,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.PublishSeries(context.Background(), request)

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    if want, got := expectedResponse, resp; !proto.Equal(want, got) {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServicePublishSeriesError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var shelf *librarypb.Shelf = &librarypb.Shelf{}
    var books []*librarypb.Book = nil
    var seriesString string = "foobar"
    var seriesUuid = &librarypb.SeriesUuid{
        Source: &librarypb.SeriesUuid_SeriesString{
            SeriesString: seriesString,
        },
    }
    var request = &librarypb.PublishSeriesRequest{
        Shelf: shelf,
        Books: books,
        SeriesUuid: seriesUuid,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.PublishSeries(context.Background(), request)

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLibraryServiceGetBook(t *testing.T) {
    var name2 string = "name2-1052831874"
    var author string = "author-1406328437"
    var title string = "title110371416"
    var read bool = true
    var expectedResponse = &librarypb.Book{
        Name: name2,
        Author: author,
        Title: title,
        Read: read,
    }

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var formattedName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var request = &librarypb.GetBookRequest{
        Name: formattedName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.GetBook(context.Background(), request)

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    if want, got := expectedResponse, resp; !proto.Equal(want, got) {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServiceGetBookError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var formattedName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var request = &librarypb.GetBookRequest{
        Name: formattedName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.GetBook(context.Background(), request)

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLibraryServiceListBooks(t *testing.T) {
    var nextPageToken string = ""
    var booksElement *librarypb.Book = &librarypb.Book{}
    var books = []*librarypb.Book{booksElement}
    var expectedResponse = &librarypb.ListBooksResponse{
        NextPageToken: nextPageToken,
        Books: books,
    }

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var formattedName string = ShelfPath("[SHELF_ID]")
    var request = &librarypb.ListBooksRequest{
        Name: formattedName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.ListBooks(context.Background(), request).Next()

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    want := (interface{})(expectedResponse.Books[0])
    got := (interface{})(resp)
    var ok bool

    switch want := (want).(type) {
    case proto.Message:
        ok = proto.Equal(want, got.(proto.Message))
    default:
        ok = want == got
    }
    if !ok {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServiceListBooksError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var formattedName string = ShelfPath("[SHELF_ID]")
    var request = &librarypb.ListBooksRequest{
        Name: formattedName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.ListBooks(context.Background(), request).Next()

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLibraryServiceDeleteBook(t *testing.T) {
    var expectedResponse *emptypb.Empty = &emptypb.Empty{}

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var formattedName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var request = &librarypb.DeleteBookRequest{
        Name: formattedName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    err = c.DeleteBook(context.Background(), request)

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

}

func TestLibraryServiceDeleteBookError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var formattedName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var request = &librarypb.DeleteBookRequest{
        Name: formattedName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    err = c.DeleteBook(context.Background(), request)

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
}
func TestLibraryServiceUpdateBook(t *testing.T) {
    var name2 string = "name2-1052831874"
    var author string = "author-1406328437"
    var title string = "title110371416"
    var read bool = true
    var expectedResponse = &librarypb.Book{
        Name: name2,
        Author: author,
        Title: title,
        Read: read,
    }

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var formattedName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var book *librarypb.Book = &librarypb.Book{}
    var request = &librarypb.UpdateBookRequest{
        Name: formattedName,
        Book: book,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.UpdateBook(context.Background(), request)

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    if want, got := expectedResponse, resp; !proto.Equal(want, got) {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServiceUpdateBookError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var formattedName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var book *librarypb.Book = &librarypb.Book{}
    var request = &librarypb.UpdateBookRequest{
        Name: formattedName,
        Book: book,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.UpdateBook(context.Background(), request)

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLibraryServiceMoveBook(t *testing.T) {
    var name2 string = "name2-1052831874"
    var author string = "author-1406328437"
    var title string = "title110371416"
    var read bool = true
    var expectedResponse = &librarypb.Book{
        Name: name2,
        Author: author,
        Title: title,
        Read: read,
    }

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var formattedName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var formattedOtherShelfName string = ShelfPath("[SHELF_ID]")
    var request = &librarypb.MoveBookRequest{
        Name: formattedName,
        OtherShelfName: formattedOtherShelfName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.MoveBook(context.Background(), request)

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    if want, got := expectedResponse, resp; !proto.Equal(want, got) {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServiceMoveBookError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var formattedName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var formattedOtherShelfName string = ShelfPath("[SHELF_ID]")
    var request = &librarypb.MoveBookRequest{
        Name: formattedName,
        OtherShelfName: formattedOtherShelfName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.MoveBook(context.Background(), request)

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLibraryServiceListStrings(t *testing.T) {
    var nextPageToken string = ""
    var stringsElement string = "stringsElement474465855"
    var strings = []string{stringsElement}
    var expectedResponse = &librarypb.ListStringsResponse{
        NextPageToken: nextPageToken,
        Strings: strings,
    }

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var request *librarypb.ListStringsRequest = &librarypb.ListStringsRequest{}

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.ListStrings(context.Background(), request).Next()

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    want := (interface{})(expectedResponse.Strings[0])
    got := (interface{})(resp)
    var ok bool

    switch want := (want).(type) {
    case proto.Message:
        ok = proto.Equal(want, got.(proto.Message))
    default:
        ok = want == got
    }
    if !ok {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServiceListStringsError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var request *librarypb.ListStringsRequest = &librarypb.ListStringsRequest{}

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.ListStrings(context.Background(), request).Next()

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLibraryServiceAddComments(t *testing.T) {
    var expectedResponse *emptypb.Empty = &emptypb.Empty{}

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var formattedName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var comment []byte = []byte("95")
    var stage librarypb.Comment_Stage = librarypb.Comment_UNSET
    var alignment librarypb.SomeMessage2_SomeMessage3_Alignment = librarypb.SomeMessage2_SomeMessage3_CHAR
    var commentsElement = &librarypb.Comment{
        Comment: comment,
        Stage: stage,
        Alignment: alignment,
    }
    var comments = []*librarypb.Comment{commentsElement}
    var request = &librarypb.AddCommentsRequest{
        Name: formattedName,
        Comments: comments,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    err = c.AddComments(context.Background(), request)

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

}

func TestLibraryServiceAddCommentsError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var formattedName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var comment []byte = []byte("95")
    var stage librarypb.Comment_Stage = librarypb.Comment_UNSET
    var alignment librarypb.SomeMessage2_SomeMessage3_Alignment = librarypb.SomeMessage2_SomeMessage3_CHAR
    var commentsElement = &librarypb.Comment{
        Comment: comment,
        Stage: stage,
        Alignment: alignment,
    }
    var comments = []*librarypb.Comment{commentsElement}
    var request = &librarypb.AddCommentsRequest{
        Name: formattedName,
        Comments: comments,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    err = c.AddComments(context.Background(), request)

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
}
func TestLibraryServiceGetBookFromArchive(t *testing.T) {
    var name2 string = "name2-1052831874"
    var author string = "author-1406328437"
    var title string = "title110371416"
    var read bool = true
    var expectedResponse = &librarypb.BookFromArchive{
        Name: name2,
        Author: author,
        Title: title,
        Read: read,
    }

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var formattedName string = ArchivedBookPath("[ARCHIVE_PATH]", "[BOOK_ID]")
    var request = &librarypb.GetBookFromArchiveRequest{
        Name: formattedName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.GetBookFromArchive(context.Background(), request)

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    if want, got := expectedResponse, resp; !proto.Equal(want, got) {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServiceGetBookFromArchiveError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var formattedName string = ArchivedBookPath("[ARCHIVE_PATH]", "[BOOK_ID]")
    var request = &librarypb.GetBookFromArchiveRequest{
        Name: formattedName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.GetBookFromArchive(context.Background(), request)

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLibraryServiceGetBookFromAnywhere(t *testing.T) {
    var name2 string = "name2-1052831874"
    var author string = "author-1406328437"
    var title string = "title110371416"
    var read bool = true
    var expectedResponse = &librarypb.BookFromAnywhere{
        Name: name2,
        Author: author,
        Title: title,
        Read: read,
    }

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var formattedName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var formattedAltBookName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var request = &librarypb.GetBookFromAnywhereRequest{
        Name: formattedName,
        AltBookName: formattedAltBookName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.GetBookFromAnywhere(context.Background(), request)

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    if want, got := expectedResponse, resp; !proto.Equal(want, got) {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServiceGetBookFromAnywhereError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var formattedName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var formattedAltBookName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var request = &librarypb.GetBookFromAnywhereRequest{
        Name: formattedName,
        AltBookName: formattedAltBookName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.GetBookFromAnywhere(context.Background(), request)

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLibraryServiceUpdateBookIndex(t *testing.T) {
    var expectedResponse *emptypb.Empty = &emptypb.Empty{}

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var formattedName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var indexName string = "default index"
    var indexMapItem string = "indexMapItem1918721251"
    var indexMap = map[string]string{
        "default_key": indexMapItem,
    }
    var request = &librarypb.UpdateBookIndexRequest{
        Name: formattedName,
        IndexName: indexName,
        IndexMap: indexMap,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    err = c.UpdateBookIndex(context.Background(), request)

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

}

func TestLibraryServiceUpdateBookIndexError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var formattedName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var indexName string = "default index"
    var indexMapItem string = "indexMapItem1918721251"
    var indexMap = map[string]string{
        "default_key": indexMapItem,
    }
    var request = &librarypb.UpdateBookIndexRequest{
        Name: formattedName,
        IndexName: indexName,
        IndexMap: indexMap,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    err = c.UpdateBookIndex(context.Background(), request)

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
}
func TestLibraryServiceStreamShelves(t *testing.T) {
    var shelvesElement *librarypb.Shelf = &librarypb.Shelf{}
    var shelves = []*librarypb.Shelf{shelvesElement}
    var expectedResponse = &librarypb.StreamShelvesResponse{
        Shelves: shelves,
    }

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var request *librarypb.StreamShelvesRequest = &librarypb.StreamShelvesRequest{}

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    stream, err := c.StreamShelves(context.Background(), request)
    if err != nil {
        t.Fatal(err)
    }
    resp, err := stream.Recv()

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    if want, got := expectedResponse, resp; !proto.Equal(want, got) {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServiceStreamShelvesError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var request *librarypb.StreamShelvesRequest = &librarypb.StreamShelvesRequest{}

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    stream, err := c.StreamShelves(context.Background(), request)
    if err != nil {
        t.Fatal(err)
    }
    resp, err := stream.Recv()

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLibraryServiceStreamBooks(t *testing.T) {
    var name2 string = "name2-1052831874"
    var author string = "author-1406328437"
    var title string = "title110371416"
    var read bool = true
    var expectedResponse = &librarypb.Book{
        Name: name2,
        Author: author,
        Title: title,
        Read: read,
    }

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var name string = "name3373707"
    var request = &librarypb.StreamBooksRequest{
        Name: name,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    stream, err := c.StreamBooks(context.Background(), request)
    if err != nil {
        t.Fatal(err)
    }
    resp, err := stream.Recv()

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    if want, got := expectedResponse, resp; !proto.Equal(want, got) {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServiceStreamBooksError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var name string = "name3373707"
    var request = &librarypb.StreamBooksRequest{
        Name: name,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    stream, err := c.StreamBooks(context.Background(), request)
    if err != nil {
        t.Fatal(err)
    }
    resp, err := stream.Recv()

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLibraryServiceDiscussBook(t *testing.T) {
    var userName string = "userName339340927"
    var comment []byte = []byte("95")
    var expectedResponse = &librarypb.Comment{
        UserName: userName,
        Comment: comment,
    }

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var name string = "name3373707"
    var request = &librarypb.DiscussBookRequest{
        Name: name,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    stream, err := c.DiscussBook(context.Background())
    if err != nil {
        t.Fatal(err)
    }
    if err := stream.Send(request); err != nil {
        t.Fatal(err)
    }
    if err := stream.CloseSend(); err != nil {
        t.Fatal(err)
    }
    resp, err := stream.Recv()

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    if want, got := expectedResponse, resp; !proto.Equal(want, got) {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServiceDiscussBookError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var name string = "name3373707"
    var request = &librarypb.DiscussBookRequest{
        Name: name,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    stream, err := c.DiscussBook(context.Background())
    if err != nil {
        t.Fatal(err)
    }
    if err := stream.Send(request); err != nil {
        t.Fatal(err)
    }
    if err := stream.CloseSend(); err != nil {
        t.Fatal(err)
    }
    resp, err := stream.Recv()

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLibraryServiceMonologAboutBook(t *testing.T) {
    var userName string = "userName339340927"
    var comment []byte = []byte("95")
    var expectedResponse = &librarypb.Comment{
        UserName: userName,
        Comment: comment,
    }

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var name string = "name3373707"
    var request = &librarypb.DiscussBookRequest{
        Name: name,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    stream, err := c.MonologAboutBook(context.Background())
    if err != nil {
        t.Fatal(err)
    }
    resp, err := stream.CloseAndRecv()

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    if want, got := expectedResponse, resp; !proto.Equal(want, got) {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServiceMonologAboutBookError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var name string = "name3373707"
    var request = &librarypb.DiscussBookRequest{
        Name: name,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    stream, err := c.MonologAboutBook(context.Background())
    if err != nil {
        t.Fatal(err)
    }
    resp, err := stream.CloseAndRecv()

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLibraryServiceFindRelatedBooks(t *testing.T) {
    var nextPageToken string = ""
    var namesElement2 string = "namesElement21120252792"
    var names2 = []string{namesElement2}
    var expectedResponse = &librarypb.FindRelatedBooksResponse{
        NextPageToken: nextPageToken,
        Names: names2,
    }

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var namesElement string = "namesElement-249113339"
    var names = []string{namesElement}
    var shelves []string = nil
    var request = &librarypb.FindRelatedBooksRequest{
        Names: names,
        Shelves: shelves,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.FindRelatedBooks(context.Background(), request).Next()

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    want := (interface{})(expectedResponse.Names[0])
    got := (interface{})(resp)
    var ok bool

    switch want := (want).(type) {
    case proto.Message:
        ok = proto.Equal(want, got.(proto.Message))
    default:
        ok = want == got
    }
    if !ok {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServiceFindRelatedBooksError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var namesElement string = "namesElement-249113339"
    var names = []string{namesElement}
    var shelves []string = nil
    var request = &librarypb.FindRelatedBooksRequest{
        Names: names,
        Shelves: shelves,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.FindRelatedBooks(context.Background(), request).Next()

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLabelerAddLabel(t *testing.T) {
    var expectedResponse *taggerpb.AddLabelResponse = &taggerpb.AddLabelResponse{}

    mockLabeler.err = nil
    mockLabeler.reqs = nil

    mockLabeler.resps = append(mockLabeler.resps[:0], expectedResponse)

    var formattedResource string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var label string = "label102727412"
    var request = &taggerpb.AddLabelRequest{
        Resource: formattedResource,
        Label: label,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.addLabel(context.Background(), request)

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLabeler.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    if want, got := expectedResponse, resp; !proto.Equal(want, got) {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLabelerAddLabelError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLabeler.err = gstatus.Error(errCode, "test error")

    var formattedResource string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var label string = "label102727412"
    var request = &taggerpb.AddLabelRequest{
        Resource: formattedResource,
        Label: label,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.addLabel(context.Background(), request)

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLibraryServiceGetBigBook(t *testing.T) {
    var name2 string = "name2-1052831874"
    var author string = "author-1406328437"
    var title string = "title110371416"
    var read bool = true
    var expectedResponse = &librarypb.Book{
        Name: name2,
        Author: author,
        Title: title,
        Read: read,
    }

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    any, err := ptypes.MarshalAny(expectedResponse)
    if err != nil {
        t.Fatal(err)
    }
    mockLibrary.resps = append(mockLibrary.resps[:0], &longrunningpb.Operation{
        Name: "longrunning-test",
        Done: true,
        Result: &longrunningpb.Operation_Response{ Response: any },
    })

    var formattedName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var request = &librarypb.GetBookRequest{
        Name: formattedName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    respLRO, err := c.GetBigBook(context.Background(), request)
    if err != nil {
        t.Fatal(err)
    }
    resp, err := respLRO.Wait(context.Background())

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    if want, got := expectedResponse, resp; !proto.Equal(want, got) {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServiceGetBigBookError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = nil
    mockLibrary.resps = append(mockLibrary.resps[:0], &longrunningpb.Operation{
        Name: "longrunning-test",
        Done: true,
        Result: &longrunningpb.Operation_Error{
            Error: &status.Status{
                Code: int32(errCode),
                Message: "test error",
            },
        },
    })

    var formattedName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var request = &librarypb.GetBookRequest{
        Name: formattedName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    respLRO, err := c.GetBigBook(context.Background(), request)
    if err != nil {
        t.Fatal(err)
    }
    resp, err := respLRO.Wait(context.Background())

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
func TestLibraryServiceGetBigNothing(t *testing.T) {
    var expectedResponse *emptypb.Empty = &emptypb.Empty{}

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    any, err := ptypes.MarshalAny(expectedResponse)
    if err != nil {
        t.Fatal(err)
    }
    mockLibrary.resps = append(mockLibrary.resps[:0], &longrunningpb.Operation{
        Name: "longrunning-test",
        Done: true,
        Result: &longrunningpb.Operation_Response{ Response: any },
    })

    var formattedName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var request = &librarypb.GetBookRequest{
        Name: formattedName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    respLRO, err := c.GetBigNothing(context.Background(), request)
    if err != nil {
        t.Fatal(err)
    }
    err = respLRO.Wait(context.Background())

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

}

func TestLibraryServiceGetBigNothingError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = nil
    mockLibrary.resps = append(mockLibrary.resps[:0], &longrunningpb.Operation{
        Name: "longrunning-test",
        Done: true,
        Result: &longrunningpb.Operation_Error{
            Error: &status.Status{
                Code: int32(errCode),
                Message: "test error",
            },
        },
    })

    var formattedName string = BookPath("[SHELF_ID]", "[BOOK_ID]")
    var request = &librarypb.GetBookRequest{
        Name: formattedName,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    respLRO, err := c.GetBigNothing(context.Background(), request)
    if err != nil {
        t.Fatal(err)
    }
    err = respLRO.Wait(context.Background())

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
}
func TestLibraryServiceTestOptionalRequiredFlatteningParams(t *testing.T) {
    var expectedResponse *librarypb.TestOptionalRequiredFlatteningParamsResponse = &librarypb.TestOptionalRequiredFlatteningParamsResponse{}

    mockLibrary.err = nil
    mockLibrary.reqs = nil

    mockLibrary.resps = append(mockLibrary.resps[:0], expectedResponse)

    var requiredSingularInt32 int32 = -72313594
    var requiredSingularInt64 int64 = -72313499
    var requiredSingularFloat float32 = -7514705.0
    var requiredSingularDouble float64 = 1.9111005E8
    var requiredSingularBool bool = true
    var requiredSingularEnum librarypb.TestOptionalRequiredFlatteningParamsRequest_InnerEnum = librarypb.TestOptionalRequiredFlatteningParamsRequest_ZERO
    var requiredSingularString string = "requiredSingularString-1949894503"
    var requiredSingularBytes []byte = []byte("-29")
    var requiredSingularMessage *librarypb.TestOptionalRequiredFlatteningParamsRequest_InnerMessage = &librarypb.TestOptionalRequiredFlatteningParamsRequest_InnerMessage{}
    var requiredSingularResourceName string = "requiredSingularResourceName-1701575020"
    var requiredSingularResourceNameOneof string = "requiredSingularResourceNameOneof-25303726"
    var requiredSingularFixed32 int32 = 720656715
    var requiredSingularFixed64 int64 = 720656810
    var requiredRepeatedInt32 []int32 = nil
    var requiredRepeatedInt64 []int64 = nil
    var requiredRepeatedFloat []float32 = nil
    var requiredRepeatedDouble []float64 = nil
    var requiredRepeatedBool []bool = nil
    var requiredRepeatedEnum []librarypb.TestOptionalRequiredFlatteningParamsRequest_InnerEnum = nil
    var requiredRepeatedString []string = nil
    var requiredRepeatedBytes [][]byte = nil
    var requiredRepeatedMessage []*librarypb.TestOptionalRequiredFlatteningParamsRequest_InnerMessage = nil
    var formattedRequiredRepeatedResourceName []string = nil
    var formattedRequiredRepeatedResourceNameOneof []string = nil
    var requiredRepeatedFixed32 []int32 = nil
    var requiredRepeatedFixed64 []int64 = nil
    var requiredMap map[int32]string = nil
    var request = &librarypb.TestOptionalRequiredFlatteningParamsRequest{
        RequiredSingularInt32: requiredSingularInt32,
        RequiredSingularInt64: requiredSingularInt64,
        RequiredSingularFloat: requiredSingularFloat,
        RequiredSingularDouble: requiredSingularDouble,
        RequiredSingularBool: requiredSingularBool,
        RequiredSingularEnum: requiredSingularEnum,
        RequiredSingularString: requiredSingularString,
        RequiredSingularBytes: requiredSingularBytes,
        RequiredSingularMessage: requiredSingularMessage,
        RequiredSingularResourceName: requiredSingularResourceName,
        RequiredSingularResourceNameOneof: requiredSingularResourceNameOneof,
        RequiredSingularFixed32: requiredSingularFixed32,
        RequiredSingularFixed64: requiredSingularFixed64,
        RequiredRepeatedInt32: requiredRepeatedInt32,
        RequiredRepeatedInt64: requiredRepeatedInt64,
        RequiredRepeatedFloat: requiredRepeatedFloat,
        RequiredRepeatedDouble: requiredRepeatedDouble,
        RequiredRepeatedBool: requiredRepeatedBool,
        RequiredRepeatedEnum: requiredRepeatedEnum,
        RequiredRepeatedString: requiredRepeatedString,
        RequiredRepeatedBytes: requiredRepeatedBytes,
        RequiredRepeatedMessage: requiredRepeatedMessage,
        RequiredRepeatedResourceName: formattedRequiredRepeatedResourceName,
        RequiredRepeatedResourceNameOneof: formattedRequiredRepeatedResourceNameOneof,
        RequiredRepeatedFixed32: requiredRepeatedFixed32,
        RequiredRepeatedFixed64: requiredRepeatedFixed64,
        RequiredMap: requiredMap,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.TestOptionalRequiredFlatteningParams(context.Background(), request)

    if err != nil {
        t.Fatal(err)
    }

    if want, got := request, mockLibrary.reqs[0]; !proto.Equal(want, got) {
        t.Errorf("wrong request %q, want %q", got, want)
    }

    if want, got := expectedResponse, resp; !proto.Equal(want, got) {
        t.Errorf("wrong response %q, want %q)", got, want)
    }
}

func TestLibraryServiceTestOptionalRequiredFlatteningParamsError(t *testing.T) {
    errCode := codes.PermissionDenied
    mockLibrary.err = gstatus.Error(errCode, "test error")

    var requiredSingularInt32 int32 = -72313594
    var requiredSingularInt64 int64 = -72313499
    var requiredSingularFloat float32 = -7514705.0
    var requiredSingularDouble float64 = 1.9111005E8
    var requiredSingularBool bool = true
    var requiredSingularEnum librarypb.TestOptionalRequiredFlatteningParamsRequest_InnerEnum = librarypb.TestOptionalRequiredFlatteningParamsRequest_ZERO
    var requiredSingularString string = "requiredSingularString-1949894503"
    var requiredSingularBytes []byte = []byte("-29")
    var requiredSingularMessage *librarypb.TestOptionalRequiredFlatteningParamsRequest_InnerMessage = &librarypb.TestOptionalRequiredFlatteningParamsRequest_InnerMessage{}
    var requiredSingularResourceName string = "requiredSingularResourceName-1701575020"
    var requiredSingularResourceNameOneof string = "requiredSingularResourceNameOneof-25303726"
    var requiredSingularFixed32 int32 = 720656715
    var requiredSingularFixed64 int64 = 720656810
    var requiredRepeatedInt32 []int32 = nil
    var requiredRepeatedInt64 []int64 = nil
    var requiredRepeatedFloat []float32 = nil
    var requiredRepeatedDouble []float64 = nil
    var requiredRepeatedBool []bool = nil
    var requiredRepeatedEnum []librarypb.TestOptionalRequiredFlatteningParamsRequest_InnerEnum = nil
    var requiredRepeatedString []string = nil
    var requiredRepeatedBytes [][]byte = nil
    var requiredRepeatedMessage []*librarypb.TestOptionalRequiredFlatteningParamsRequest_InnerMessage = nil
    var formattedRequiredRepeatedResourceName []string = nil
    var formattedRequiredRepeatedResourceNameOneof []string = nil
    var requiredRepeatedFixed32 []int32 = nil
    var requiredRepeatedFixed64 []int64 = nil
    var requiredMap map[int32]string = nil
    var request = &librarypb.TestOptionalRequiredFlatteningParamsRequest{
        RequiredSingularInt32: requiredSingularInt32,
        RequiredSingularInt64: requiredSingularInt64,
        RequiredSingularFloat: requiredSingularFloat,
        RequiredSingularDouble: requiredSingularDouble,
        RequiredSingularBool: requiredSingularBool,
        RequiredSingularEnum: requiredSingularEnum,
        RequiredSingularString: requiredSingularString,
        RequiredSingularBytes: requiredSingularBytes,
        RequiredSingularMessage: requiredSingularMessage,
        RequiredSingularResourceName: requiredSingularResourceName,
        RequiredSingularResourceNameOneof: requiredSingularResourceNameOneof,
        RequiredSingularFixed32: requiredSingularFixed32,
        RequiredSingularFixed64: requiredSingularFixed64,
        RequiredRepeatedInt32: requiredRepeatedInt32,
        RequiredRepeatedInt64: requiredRepeatedInt64,
        RequiredRepeatedFloat: requiredRepeatedFloat,
        RequiredRepeatedDouble: requiredRepeatedDouble,
        RequiredRepeatedBool: requiredRepeatedBool,
        RequiredRepeatedEnum: requiredRepeatedEnum,
        RequiredRepeatedString: requiredRepeatedString,
        RequiredRepeatedBytes: requiredRepeatedBytes,
        RequiredRepeatedMessage: requiredRepeatedMessage,
        RequiredRepeatedResourceName: formattedRequiredRepeatedResourceName,
        RequiredRepeatedResourceNameOneof: formattedRequiredRepeatedResourceNameOneof,
        RequiredRepeatedFixed32: requiredRepeatedFixed32,
        RequiredRepeatedFixed64: requiredRepeatedFixed64,
        RequiredMap: requiredMap,
    }

    c, err := NewClient(context.Background(), clientOpt)
    if err != nil {
        t.Fatal(err)
    }

    resp, err := c.TestOptionalRequiredFlatteningParams(context.Background(), request)

    if st, ok := gstatus.FromError(err); !ok {
        t.Errorf("got error %v, expected grpc error", err)
    } else if c := st.Code(); c != errCode {
        t.Errorf("got error code %q, want %q", c, errCode)
    }
    _ = resp
}
