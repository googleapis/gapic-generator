============== file: Google.Example.Library.V1/Google.Example.Library.V1.SmokeTests/Google.Example.Library.V1.SmokeTests.csproj ==============
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netcoreapp1.0</TargetFramework>
    <OutputType>Exe</OutputType>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="../Google.Example.Library.V1/Google.Example.Library.V1.csproj" />
  </ItemGroup>

</Project>

============== file: Google.Example.Library.V1/Google.Example.Library.V1.SmokeTests/LibraryServiceSmokeTest.g.cs ==============
// Copyright 2017, Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

using Google.Api.Gax;
using Google.Api.Gax.Grpc;
using Google.Protobuf.WellKnownTypes;
using Grpc.Core;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Threading;
using System.Threading.Tasks;

namespace Google.Example.Library.V1.SmokeTests
{
    public class LibraryServiceSmokeTest
    {
        public static int Main(string[] args)
        {
            // Read projectId from args
            if (args.Length != 1)
            {
                Console.WriteLine("Usage: Project ID must be passed as first argument.");
                Console.WriteLine();
                return 1;
            }
            string projectId = args[0];

            // Create client
            LibraryServiceClient client = LibraryServiceClient.Create();

            // Initialize request argument(s)
            BookName name = new BookName($"testShelf-{Guid.NewGuid()}", projectId);
            string optionalFoo = "";
            Book book = new Book
            {
                Rating = Book.Types.Rating.Good,
            };
            FieldMask updateMask = new FieldMask();
            FieldMask physicalMask = new FieldMask();

            // Call API method
            Book response = client.UpdateBook(name, optionalFoo, book, updateMask, physicalMask);
            // Show the result
            Console.WriteLine(response);

            // Success
            Console.WriteLine("Smoke test passed OK");
            return 0;
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Snippets/LibraryServiceClientSnippets.g.cs ==============
// Copyright 2017, Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

using Google.Api.Gax;
using Google.Api.Gax.Grpc;
using Google.Example.Library.V1;
using Google.LongRunning;
using Google.Protobuf;
using Google.Protobuf.WellKnownTypes;
using Google.Tagger.V1;
using Grpc.Core;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace Google.Example.Library.V1.Snippets
{
    /// <summary>Generated snippets</summary>
    public class GeneratedLibraryServiceClientSnippets
    {
        /// <summary>Snippet for CreateShelfAsync</summary>
        public async Task CreateShelfAsync()
        {
            // Snippet: CreateShelfAsync(Shelf,CallSettings)
            // Additional: CreateShelfAsync(Shelf,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            Shelf shelf = new Shelf();
            // Make the request
            Shelf response = await libraryServiceClient.CreateShelfAsync(shelf);
            // End snippet
        }

        /// <summary>Snippet for CreateShelf</summary>
        public void CreateShelf()
        {
            // Snippet: CreateShelf(Shelf,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            Shelf shelf = new Shelf();
            // Make the request
            Shelf response = libraryServiceClient.CreateShelf(shelf);
            // End snippet
        }

        /// <summary>Snippet for CreateShelfAsync</summary>
        public async Task CreateShelfAsync_RequestObject()
        {
            // Snippet: CreateShelfAsync(CreateShelfRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            CreateShelfRequest request = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            // Make the request
            Shelf response = await libraryServiceClient.CreateShelfAsync(request);
            // End snippet
        }

        /// <summary>Snippet for CreateShelf</summary>
        public void CreateShelf_RequestObject()
        {
            // Snippet: CreateShelf(CreateShelfRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            CreateShelfRequest request = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            // Make the request
            Shelf response = libraryServiceClient.CreateShelf(request);
            // End snippet
        }

        /// <summary>Snippet for GetShelfAsync</summary>
        public async Task GetShelfAsync1()
        {
            // Snippet: GetShelfAsync(ShelfName,CallSettings)
            // Additional: GetShelfAsync(ShelfName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            // Make the request
            Shelf response = await libraryServiceClient.GetShelfAsync(name);
            // End snippet
        }

        /// <summary>Snippet for GetShelf</summary>
        public void GetShelf1()
        {
            // Snippet: GetShelf(ShelfName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            // Make the request
            Shelf response = libraryServiceClient.GetShelf(name);
            // End snippet
        }

        /// <summary>Snippet for GetShelfAsync</summary>
        public async Task GetShelfAsync2()
        {
            // Snippet: GetShelfAsync(string,SomeMessage,CallSettings)
            // Additional: GetShelfAsync(string,SomeMessage,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            string formattedName = new ShelfName("[SHELF_ID]").ToString();
            SomeMessage message = new SomeMessage();
            // Make the request
            Shelf response = await libraryServiceClient.GetShelfAsync(formattedName, message);
            // End snippet
        }

        /// <summary>Snippet for GetShelf</summary>
        public void GetShelf2()
        {
            // Snippet: GetShelf(string,SomeMessage,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            string formattedName = new ShelfName("[SHELF_ID]").ToString();
            SomeMessage message = new SomeMessage();
            // Make the request
            Shelf response = libraryServiceClient.GetShelf(formattedName, message);
            // End snippet
        }

        /// <summary>Snippet for GetShelfAsync</summary>
        public async Task GetShelfAsync3()
        {
            // Snippet: GetShelfAsync(string,SomeMessage,StringBuilder,CallSettings)
            // Additional: GetShelfAsync(string,SomeMessage,StringBuilder,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            string formattedName = new ShelfName("[SHELF_ID]").ToString();
            SomeMessage message = new SomeMessage();
            StringBuilder stringBuilder = new StringBuilder();
            // Make the request
            Shelf response = await libraryServiceClient.GetShelfAsync(formattedName, message, stringBuilder);
            // End snippet
        }

        /// <summary>Snippet for GetShelf</summary>
        public void GetShelf3()
        {
            // Snippet: GetShelf(string,SomeMessage,StringBuilder,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            string formattedName = new ShelfName("[SHELF_ID]").ToString();
            SomeMessage message = new SomeMessage();
            StringBuilder stringBuilder = new StringBuilder();
            // Make the request
            Shelf response = libraryServiceClient.GetShelf(formattedName, message, stringBuilder);
            // End snippet
        }

        /// <summary>Snippet for GetShelfAsync</summary>
        public async Task GetShelfAsync_RequestObject()
        {
            // Snippet: GetShelfAsync(GetShelfRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetShelfRequest request = new GetShelfRequest
            {
                Name = new ShelfName("[SHELF_ID]").ToString(),
                Options = "",
            };
            // Make the request
            Shelf response = await libraryServiceClient.GetShelfAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetShelf</summary>
        public void GetShelf_RequestObject()
        {
            // Snippet: GetShelf(GetShelfRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetShelfRequest request = new GetShelfRequest
            {
                Name = new ShelfName("[SHELF_ID]").ToString(),
                Options = "",
            };
            // Make the request
            Shelf response = libraryServiceClient.GetShelf(request);
            // End snippet
        }

        /// <summary>Snippet for ListShelvesAsync</summary>
        public async Task ListShelvesAsync()
        {
            // Snippet: ListShelvesAsync(string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Make the request
            PagedAsyncEnumerable<ListShelvesResponse, Shelf> response =
                libraryServiceClient.ListShelvesAsync();

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((Shelf item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListShelvesResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Shelf item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Shelf> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Shelf item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListShelves</summary>
        public void ListShelves()
        {
            // Snippet: ListShelves(string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Make the request
            PagedEnumerable<ListShelvesResponse, Shelf> response =
                libraryServiceClient.ListShelves();

            // Iterate over all response items, lazily performing RPCs as required
            foreach (Shelf item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListShelvesResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Shelf item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Shelf> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Shelf item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListShelvesAsync</summary>
        public async Task ListShelvesAsync_RequestObject()
        {
            // Snippet: ListShelvesAsync(ListShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ListShelvesRequest request = new ListShelvesRequest();
            // Make the request
            PagedAsyncEnumerable<ListShelvesResponse, Shelf> response =
                libraryServiceClient.ListShelvesAsync(request);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((Shelf item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListShelvesResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Shelf item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Shelf> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Shelf item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListShelves</summary>
        public void ListShelves_RequestObject()
        {
            // Snippet: ListShelves(ListShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ListShelvesRequest request = new ListShelvesRequest();
            // Make the request
            PagedEnumerable<ListShelvesResponse, Shelf> response =
                libraryServiceClient.ListShelves(request);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (Shelf item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListShelvesResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Shelf item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Shelf> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Shelf item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for DeleteShelfAsync</summary>
        public async Task DeleteShelfAsync()
        {
            // Snippet: DeleteShelfAsync(ShelfName,CallSettings)
            // Additional: DeleteShelfAsync(ShelfName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            // Make the request
            await libraryServiceClient.DeleteShelfAsync(name);
            // End snippet
        }

        /// <summary>Snippet for DeleteShelf</summary>
        public void DeleteShelf()
        {
            // Snippet: DeleteShelf(ShelfName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            // Make the request
            libraryServiceClient.DeleteShelf(name);
            // End snippet
        }

        /// <summary>Snippet for DeleteShelfAsync</summary>
        public async Task DeleteShelfAsync_RequestObject()
        {
            // Snippet: DeleteShelfAsync(DeleteShelfRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            DeleteShelfRequest request = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            await libraryServiceClient.DeleteShelfAsync(request);
            // End snippet
        }

        /// <summary>Snippet for DeleteShelf</summary>
        public void DeleteShelf_RequestObject()
        {
            // Snippet: DeleteShelf(DeleteShelfRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            DeleteShelfRequest request = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            libraryServiceClient.DeleteShelf(request);
            // End snippet
        }

        /// <summary>Snippet for MergeShelvesAsync</summary>
        public async Task MergeShelvesAsync()
        {
            // Snippet: MergeShelvesAsync(ShelfName,ShelfName,CallSettings)
            // Additional: MergeShelvesAsync(ShelfName,ShelfName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            // Make the request
            Shelf response = await libraryServiceClient.MergeShelvesAsync(name, otherShelfName);
            // End snippet
        }

        /// <summary>Snippet for MergeShelves</summary>
        public void MergeShelves()
        {
            // Snippet: MergeShelves(ShelfName,ShelfName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            // Make the request
            Shelf response = libraryServiceClient.MergeShelves(name, otherShelfName);
            // End snippet
        }

        /// <summary>Snippet for MergeShelvesAsync</summary>
        public async Task MergeShelvesAsync_RequestObject()
        {
            // Snippet: MergeShelvesAsync(MergeShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            MergeShelvesRequest request = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            Shelf response = await libraryServiceClient.MergeShelvesAsync(request);
            // End snippet
        }

        /// <summary>Snippet for MergeShelves</summary>
        public void MergeShelves_RequestObject()
        {
            // Snippet: MergeShelves(MergeShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            MergeShelvesRequest request = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            Shelf response = libraryServiceClient.MergeShelves(request);
            // End snippet
        }

        /// <summary>Snippet for CreateBookAsync</summary>
        public async Task CreateBookAsync()
        {
            // Snippet: CreateBookAsync(string,Book,CallSettings)
            // Additional: CreateBookAsync(string,Book,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            string formattedName = new ShelfName("[SHELF_ID]").ToString();
            Book book = new Book();
            // Make the request
            Book response = await libraryServiceClient.CreateBookAsync(formattedName, book);
            // End snippet
        }

        /// <summary>Snippet for CreateBook</summary>
        public void CreateBook()
        {
            // Snippet: CreateBook(string,Book,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            string formattedName = new ShelfName("[SHELF_ID]").ToString();
            Book book = new Book();
            // Make the request
            Book response = libraryServiceClient.CreateBook(formattedName, book);
            // End snippet
        }

        /// <summary>Snippet for CreateBookAsync</summary>
        public async Task CreateBookAsync_RequestObject()
        {
            // Snippet: CreateBookAsync(CreateBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            CreateBookRequest request = new CreateBookRequest
            {
                Name = new ShelfName("[SHELF_ID]").ToString(),
                Book = new Book(),
            };
            // Make the request
            Book response = await libraryServiceClient.CreateBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for CreateBook</summary>
        public void CreateBook_RequestObject()
        {
            // Snippet: CreateBook(CreateBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            CreateBookRequest request = new CreateBookRequest
            {
                Name = new ShelfName("[SHELF_ID]").ToString(),
                Book = new Book(),
            };
            // Make the request
            Book response = libraryServiceClient.CreateBook(request);
            // End snippet
        }

        /// <summary>Snippet for PublishSeriesAsync</summary>
        public async Task PublishSeriesAsync()
        {
            // Snippet: PublishSeriesAsync(Shelf,IEnumerable<Book>,uint?,SeriesUuid,CallSettings)
            // Additional: PublishSeriesAsync(Shelf,IEnumerable<Book>,uint?,SeriesUuid,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            Shelf shelf = new Shelf();
            IEnumerable<Book> books = new List<Book>();
            uint edition = 0;
            SeriesUuid seriesUuid = new SeriesUuid
            {
                SeriesString = "foobar",
            };
            // Make the request
            PublishSeriesResponse response = await libraryServiceClient.PublishSeriesAsync(shelf, books, edition, seriesUuid);
            // End snippet
        }

        /// <summary>Snippet for PublishSeries</summary>
        public void PublishSeries()
        {
            // Snippet: PublishSeries(Shelf,IEnumerable<Book>,uint?,SeriesUuid,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            Shelf shelf = new Shelf();
            IEnumerable<Book> books = new List<Book>();
            uint edition = 0;
            SeriesUuid seriesUuid = new SeriesUuid
            {
                SeriesString = "foobar",
            };
            // Make the request
            PublishSeriesResponse response = libraryServiceClient.PublishSeries(shelf, books, edition, seriesUuid);
            // End snippet
        }

        /// <summary>Snippet for PublishSeriesAsync</summary>
        public async Task PublishSeriesAsync_RequestObject()
        {
            // Snippet: PublishSeriesAsync(PublishSeriesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                SeriesUuid = new SeriesUuid
                             {
                                 SeriesString = "foobar",
                             },
            };
            // Make the request
            PublishSeriesResponse response = await libraryServiceClient.PublishSeriesAsync(request);
            // End snippet
        }

        /// <summary>Snippet for PublishSeries</summary>
        public void PublishSeries_RequestObject()
        {
            // Snippet: PublishSeries(PublishSeriesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                SeriesUuid = new SeriesUuid
                             {
                                 SeriesString = "foobar",
                             },
            };
            // Make the request
            PublishSeriesResponse response = libraryServiceClient.PublishSeries(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookAsync</summary>
        public async Task GetBookAsync()
        {
            // Snippet: GetBookAsync(BookName,CallSettings)
            // Additional: GetBookAsync(BookName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            Book response = await libraryServiceClient.GetBookAsync(name);
            // End snippet
        }

        /// <summary>Snippet for GetBook</summary>
        public void GetBook()
        {
            // Snippet: GetBook(BookName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            Book response = libraryServiceClient.GetBook(name);
            // End snippet
        }

        /// <summary>Snippet for GetBookAsync</summary>
        public async Task GetBookAsync_RequestObject()
        {
            // Snippet: GetBookAsync(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            // Make the request
            Book response = await libraryServiceClient.GetBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetBook</summary>
        public void GetBook_RequestObject()
        {
            // Snippet: GetBook(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            // Make the request
            Book response = libraryServiceClient.GetBook(request);
            // End snippet
        }

        /// <summary>Snippet for ListBooksAsync</summary>
        public async Task ListBooksAsync()
        {
            // Snippet: ListBooksAsync(ShelfName,string,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            string filter = "";
            // Make the request
            PagedAsyncEnumerable<ListBooksResponse, Book> response =
                libraryServiceClient.ListBooksAsync(name, filter);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((Book item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListBooksResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Book item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Book> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Book item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListBooks</summary>
        public void ListBooks()
        {
            // Snippet: ListBooks(ShelfName,string,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            string filter = "";
            // Make the request
            PagedEnumerable<ListBooksResponse, Book> response =
                libraryServiceClient.ListBooks(name, filter);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (Book item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListBooksResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Book item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Book> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Book item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListBooksAsync</summary>
        public async Task ListBooksAsync_RequestObject()
        {
            // Snippet: ListBooksAsync(ListBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ListBooksRequest request = new ListBooksRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            PagedAsyncEnumerable<ListBooksResponse, Book> response =
                libraryServiceClient.ListBooksAsync(request);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((Book item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListBooksResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Book item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Book> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Book item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListBooks</summary>
        public void ListBooks_RequestObject()
        {
            // Snippet: ListBooks(ListBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ListBooksRequest request = new ListBooksRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            PagedEnumerable<ListBooksResponse, Book> response =
                libraryServiceClient.ListBooks(request);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (Book item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListBooksResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Book item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Book> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Book item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for DeleteBookAsync</summary>
        public async Task DeleteBookAsync()
        {
            // Snippet: DeleteBookAsync(BookName,CallSettings)
            // Additional: DeleteBookAsync(BookName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            await libraryServiceClient.DeleteBookAsync(name);
            // End snippet
        }

        /// <summary>Snippet for DeleteBook</summary>
        public void DeleteBook()
        {
            // Snippet: DeleteBook(BookName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            libraryServiceClient.DeleteBook(name);
            // End snippet
        }

        /// <summary>Snippet for DeleteBookAsync</summary>
        public async Task DeleteBookAsync_RequestObject()
        {
            // Snippet: DeleteBookAsync(DeleteBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            DeleteBookRequest request = new DeleteBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            // Make the request
            await libraryServiceClient.DeleteBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for DeleteBook</summary>
        public void DeleteBook_RequestObject()
        {
            // Snippet: DeleteBook(DeleteBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            DeleteBookRequest request = new DeleteBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            // Make the request
            libraryServiceClient.DeleteBook(request);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookAsync</summary>
        public async Task UpdateBookAsync1()
        {
            // Snippet: UpdateBookAsync(BookName,Book,CallSettings)
            // Additional: UpdateBookAsync(BookName,Book,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            Book book = new Book();
            // Make the request
            Book response = await libraryServiceClient.UpdateBookAsync(name, book);
            // End snippet
        }

        /// <summary>Snippet for UpdateBook</summary>
        public void UpdateBook1()
        {
            // Snippet: UpdateBook(BookName,Book,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            Book book = new Book();
            // Make the request
            Book response = libraryServiceClient.UpdateBook(name, book);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookAsync</summary>
        public async Task UpdateBookAsync2()
        {
            // Snippet: UpdateBookAsync(BookName,string,Book,FieldMask,FieldMask,CallSettings)
            // Additional: UpdateBookAsync(BookName,string,Book,FieldMask,FieldMask,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            string optionalFoo = "";
            Book book = new Book();
            FieldMask updateMask = new FieldMask();
            FieldMask physicalMask = new FieldMask();
            // Make the request
            Book response = await libraryServiceClient.UpdateBookAsync(name, optionalFoo, book, updateMask, physicalMask);
            // End snippet
        }

        /// <summary>Snippet for UpdateBook</summary>
        public void UpdateBook2()
        {
            // Snippet: UpdateBook(BookName,string,Book,FieldMask,FieldMask,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            string optionalFoo = "";
            Book book = new Book();
            FieldMask updateMask = new FieldMask();
            FieldMask physicalMask = new FieldMask();
            // Make the request
            Book response = libraryServiceClient.UpdateBook(name, optionalFoo, book, updateMask, physicalMask);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookAsync</summary>
        public async Task UpdateBookAsync_RequestObject()
        {
            // Snippet: UpdateBookAsync(UpdateBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            UpdateBookRequest request = new UpdateBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Book = new Book(),
            };
            // Make the request
            Book response = await libraryServiceClient.UpdateBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for UpdateBook</summary>
        public void UpdateBook_RequestObject()
        {
            // Snippet: UpdateBook(UpdateBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            UpdateBookRequest request = new UpdateBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Book = new Book(),
            };
            // Make the request
            Book response = libraryServiceClient.UpdateBook(request);
            // End snippet
        }

        /// <summary>Snippet for MoveBookAsync</summary>
        public async Task MoveBookAsync()
        {
            // Snippet: MoveBookAsync(BookName,ShelfName,CallSettings)
            // Additional: MoveBookAsync(BookName,ShelfName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            // Make the request
            Book response = await libraryServiceClient.MoveBookAsync(name, otherShelfName);
            // End snippet
        }

        /// <summary>Snippet for MoveBook</summary>
        public void MoveBook()
        {
            // Snippet: MoveBook(BookName,ShelfName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            // Make the request
            Book response = libraryServiceClient.MoveBook(name, otherShelfName);
            // End snippet
        }

        /// <summary>Snippet for MoveBookAsync</summary>
        public async Task MoveBookAsync_RequestObject()
        {
            // Snippet: MoveBookAsync(MoveBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            MoveBookRequest request = new MoveBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            Book response = await libraryServiceClient.MoveBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for MoveBook</summary>
        public void MoveBook_RequestObject()
        {
            // Snippet: MoveBook(MoveBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            MoveBookRequest request = new MoveBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            Book response = libraryServiceClient.MoveBook(request);
            // End snippet
        }

        /// <summary>Snippet for ListStringsAsync</summary>
        public async Task ListStringsAsync1()
        {
            // Snippet: ListStringsAsync(string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Make the request
            PagedAsyncEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStringsAsync();

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((IResourceName item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListStringsResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStrings</summary>
        public void ListStrings1()
        {
            // Snippet: ListStrings(string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Make the request
            PagedEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStrings();

            // Iterate over all response items, lazily performing RPCs as required
            foreach (IResourceName item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListStringsResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStringsAsync</summary>
        public async Task ListStringsAsync2()
        {
            // Snippet: ListStringsAsync(IResourceName,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            IResourceName name = new ShelfName("[SHELF_ID]");
            // Make the request
            PagedAsyncEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStringsAsync(name);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((IResourceName item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListStringsResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStrings</summary>
        public void ListStrings2()
        {
            // Snippet: ListStrings(IResourceName,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            IResourceName name = new ShelfName("[SHELF_ID]");
            // Make the request
            PagedEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStrings(name);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (IResourceName item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListStringsResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStringsAsync</summary>
        public async Task ListStringsAsync_RequestObject()
        {
            // Snippet: ListStringsAsync(ListStringsRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ListStringsRequest request = new ListStringsRequest();
            // Make the request
            PagedAsyncEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStringsAsync(request);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((IResourceName item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListStringsResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStrings</summary>
        public void ListStrings_RequestObject()
        {
            // Snippet: ListStrings(ListStringsRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ListStringsRequest request = new ListStringsRequest();
            // Make the request
            PagedEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStrings(request);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (IResourceName item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListStringsResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for AddCommentsAsync</summary>
        public async Task AddCommentsAsync()
        {
            // Snippet: AddCommentsAsync(string,IEnumerable<Comment>,CallSettings)
            // Additional: AddCommentsAsync(string,IEnumerable<Comment>,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            string formattedName = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString();
            IEnumerable<Comment> comments = new[]
            {
                new Comment
                {
                    Comment = ByteString.CopyFromUtf8(""),
                    Stage = Comment.Types.Stage.Unset,
                    Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                },
            };
            // Make the request
            await libraryServiceClient.AddCommentsAsync(formattedName, comments);
            // End snippet
        }

        /// <summary>Snippet for AddComments</summary>
        public void AddComments()
        {
            // Snippet: AddComments(string,IEnumerable<Comment>,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            string formattedName = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString();
            IEnumerable<Comment> comments = new[]
            {
                new Comment
                {
                    Comment = ByteString.CopyFromUtf8(""),
                    Stage = Comment.Types.Stage.Unset,
                    Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                },
            };
            // Make the request
            libraryServiceClient.AddComments(formattedName, comments);
            // End snippet
        }

        /// <summary>Snippet for AddCommentsAsync</summary>
        public async Task AddCommentsAsync_RequestObject()
        {
            // Snippet: AddCommentsAsync(AddCommentsRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            AddCommentsRequest request = new AddCommentsRequest
            {
                Name = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Comments = {
                               new Comment
                               {
                                   Comment = ByteString.CopyFromUtf8(""),
                                   Stage = Comment.Types.Stage.Unset,
                                   Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                               },
                           },
            };
            // Make the request
            await libraryServiceClient.AddCommentsAsync(request);
            // End snippet
        }

        /// <summary>Snippet for AddComments</summary>
        public void AddComments_RequestObject()
        {
            // Snippet: AddComments(AddCommentsRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            AddCommentsRequest request = new AddCommentsRequest
            {
                Name = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Comments = {
                               new Comment
                               {
                                   Comment = ByteString.CopyFromUtf8(""),
                                   Stage = Comment.Types.Stage.Unset,
                                   Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                               },
                           },
            };
            // Make the request
            libraryServiceClient.AddComments(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromArchiveAsync</summary>
        public async Task GetBookFromArchiveAsync()
        {
            // Snippet: GetBookFromArchiveAsync(ArchivedBookName,CallSettings)
            // Additional: GetBookFromArchiveAsync(ArchivedBookName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ArchivedBookName name = new ArchivedBookName("[ARCHIVE_PATH]", "[BOOK_ID]");
            // Make the request
            BookFromArchive response = await libraryServiceClient.GetBookFromArchiveAsync(name);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromArchive</summary>
        public void GetBookFromArchive()
        {
            // Snippet: GetBookFromArchive(ArchivedBookName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ArchivedBookName name = new ArchivedBookName("[ARCHIVE_PATH]", "[BOOK_ID]");
            // Make the request
            BookFromArchive response = libraryServiceClient.GetBookFromArchive(name);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromArchiveAsync</summary>
        public async Task GetBookFromArchiveAsync_RequestObject()
        {
            // Snippet: GetBookFromArchiveAsync(GetBookFromArchiveRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookFromArchiveRequest request = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE_PATH]", "[BOOK_ID]"),
            };
            // Make the request
            BookFromArchive response = await libraryServiceClient.GetBookFromArchiveAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromArchive</summary>
        public void GetBookFromArchive_RequestObject()
        {
            // Snippet: GetBookFromArchive(GetBookFromArchiveRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookFromArchiveRequest request = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE_PATH]", "[BOOK_ID]"),
            };
            // Make the request
            BookFromArchive response = libraryServiceClient.GetBookFromArchive(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAnywhereAsync</summary>
        public async Task GetBookFromAnywhereAsync()
        {
            // Snippet: GetBookFromAnywhereAsync(BookNameOneof,BookName,CallSettings)
            // Additional: GetBookFromAnywhereAsync(BookNameOneof,BookName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            BookName altBookName = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            BookFromAnywhere response = await libraryServiceClient.GetBookFromAnywhereAsync(name, altBookName);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAnywhere</summary>
        public void GetBookFromAnywhere()
        {
            // Snippet: GetBookFromAnywhere(BookNameOneof,BookName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            BookName altBookName = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            BookFromAnywhere response = libraryServiceClient.GetBookFromAnywhere(name, altBookName);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAnywhereAsync</summary>
        public async Task GetBookFromAnywhereAsync_RequestObject()
        {
            // Snippet: GetBookFromAnywhereAsync(GetBookFromAnywhereRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookFromAnywhereRequest request = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
            };
            // Make the request
            BookFromAnywhere response = await libraryServiceClient.GetBookFromAnywhereAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAnywhere</summary>
        public void GetBookFromAnywhere_RequestObject()
        {
            // Snippet: GetBookFromAnywhere(GetBookFromAnywhereRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookFromAnywhereRequest request = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
            };
            // Make the request
            BookFromAnywhere response = libraryServiceClient.GetBookFromAnywhere(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAbsolutelyAnywhereAsync</summary>
        public async Task GetBookFromAbsolutelyAnywhereAsync()
        {
            // Snippet: GetBookFromAbsolutelyAnywhereAsync(BookNameOneof,CallSettings)
            // Additional: GetBookFromAbsolutelyAnywhereAsync(BookNameOneof,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            // Make the request
            BookFromAnywhere response = await libraryServiceClient.GetBookFromAbsolutelyAnywhereAsync(name);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAbsolutelyAnywhere</summary>
        public void GetBookFromAbsolutelyAnywhere()
        {
            // Snippet: GetBookFromAbsolutelyAnywhere(BookNameOneof,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            // Make the request
            BookFromAnywhere response = libraryServiceClient.GetBookFromAbsolutelyAnywhere(name);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAbsolutelyAnywhereAsync</summary>
        public async Task GetBookFromAbsolutelyAnywhereAsync_RequestObject()
        {
            // Snippet: GetBookFromAbsolutelyAnywhereAsync(GetBookFromAbsolutelyAnywhereRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookFromAbsolutelyAnywhereRequest request = new GetBookFromAbsolutelyAnywhereRequest
            {
                AsResourceName = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
            };
            // Make the request
            BookFromAnywhere response = await libraryServiceClient.GetBookFromAbsolutelyAnywhereAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAbsolutelyAnywhere</summary>
        public void GetBookFromAbsolutelyAnywhere_RequestObject()
        {
            // Snippet: GetBookFromAbsolutelyAnywhere(GetBookFromAbsolutelyAnywhereRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookFromAbsolutelyAnywhereRequest request = new GetBookFromAbsolutelyAnywhereRequest
            {
                AsResourceName = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
            };
            // Make the request
            BookFromAnywhere response = libraryServiceClient.GetBookFromAbsolutelyAnywhere(request);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookIndexAsync</summary>
        public async Task UpdateBookIndexAsync()
        {
            // Snippet: UpdateBookIndexAsync(BookName,string,IDictionary<string, string>,CallSettings)
            // Additional: UpdateBookIndexAsync(BookName,string,IDictionary<string, string>,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            string indexName = "default index";
            IDictionary<string, string> indexMap = new Dictionary<string, string>
            {
                { "default_key", "" },
            };
            // Make the request
            await libraryServiceClient.UpdateBookIndexAsync(name, indexName, indexMap);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookIndex</summary>
        public void UpdateBookIndex()
        {
            // Snippet: UpdateBookIndex(BookName,string,IDictionary<string, string>,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            string indexName = "default index";
            IDictionary<string, string> indexMap = new Dictionary<string, string>
            {
                { "default_key", "" },
            };
            // Make the request
            libraryServiceClient.UpdateBookIndex(name, indexName, indexMap);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookIndexAsync</summary>
        public async Task UpdateBookIndexAsync_RequestObject()
        {
            // Snippet: UpdateBookIndexAsync(UpdateBookIndexRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            UpdateBookIndexRequest request = new UpdateBookIndexRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                IndexName = "default index",
                IndexMap = {
                               { "default_key", "" },
                           },
            };
            // Make the request
            await libraryServiceClient.UpdateBookIndexAsync(request);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookIndex</summary>
        public void UpdateBookIndex_RequestObject()
        {
            // Snippet: UpdateBookIndex(UpdateBookIndexRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            UpdateBookIndexRequest request = new UpdateBookIndexRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                IndexName = "default index",
                IndexMap = {
                               { "default_key", "" },
                           },
            };
            // Make the request
            libraryServiceClient.UpdateBookIndex(request);
            // End snippet
        }

        /// <summary>Snippet for StreamShelves</summary>
        public async Task StreamShelves()
        {
            // Snippet: StreamShelves(StreamShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument
            StreamShelvesRequest request = new StreamShelvesRequest();
            // Make the request, returning a streaming response
            LibraryServiceClient.StreamShelvesStream streamingResponse = libraryServiceClient.StreamShelves(request);

            // Read streaming responses from server until complete
            IAsyncEnumerator<StreamShelvesResponse> responseStream = streamingResponse.ResponseStream;
            while (await responseStream.MoveNext())
            {
                StreamShelvesResponse response = responseStream.Current;
                // Do something with streamed response
            }
            // The response stream has completed
            // End snippet
        }

        /// <summary>Snippet for StreamBooks</summary>
        public async Task StreamBooks()
        {
            // Snippet: StreamBooks(StreamBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument
            StreamBooksRequest request = new StreamBooksRequest
            {
                Name = "",
            };
            // Make the request, returning a streaming response
            LibraryServiceClient.StreamBooksStream streamingResponse = libraryServiceClient.StreamBooks(request);

            // Read streaming responses from server until complete
            IAsyncEnumerator<Book> responseStream = streamingResponse.ResponseStream;
            while (await responseStream.MoveNext())
            {
                Book response = responseStream.Current;
                // Do something with streamed response
            }
            // The response stream has completed
            // End snippet
        }

        /// <summary>Snippet for DiscussBook</summary>
        public async Task DiscussBook()
        {
            // Snippet: DiscussBook(CallSettings,BidirectionalStreamingSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize streaming call, retrieving the stream object
            LibraryServiceClient.DiscussBookStream duplexStream = libraryServiceClient.DiscussBook();

            // Sending requests and retrieving responses can be arbitrarily interleaved.
            // Exact sequence will depend on client/server behavior.

            // Create task to do something with responses from server
            Task responseHandlerTask = Task.Run(async () =>
            {
                IAsyncEnumerator<Comment> responseStream = duplexStream.ResponseStream;
                while (await responseStream.MoveNext())
                {
                    Comment response = responseStream.Current;
                    // Do something with streamed response
                }
                // The response stream has completed
            });

            // Send requests to the server
            bool done = false;
            while (!done)
            {
                // Initialize a request
                DiscussBookRequest request = new DiscussBookRequest
                {
                    Name = "",
                };
                // Stream a request to the server
                await duplexStream.WriteAsync(request);

                // Set "done" to true when sending requests is complete
            }
            // Complete writing requests to the stream
            await duplexStream.WriteCompleteAsync();
            // Await the response handler.
            // This will complete once all server responses have been processed.
            await responseHandlerTask;
            // End snippet
        }

        /// <summary>Snippet for FindRelatedBooksAsync</summary>
        public async Task FindRelatedBooksAsync()
        {
            // Snippet: FindRelatedBooksAsync(IEnumerable<BookName>,IEnumerable<ShelfName>,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            IEnumerable<BookName> names = new[]
            {
                new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            IEnumerable<ShelfName> shelves = new List<ShelfName>();
            // Make the request
            PagedAsyncEnumerable<FindRelatedBooksResponse, BookName> response =
                libraryServiceClient.FindRelatedBooksAsync(names, shelves);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((BookName item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((FindRelatedBooksResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (BookName item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookName> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (BookName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for FindRelatedBooks</summary>
        public void FindRelatedBooks()
        {
            // Snippet: FindRelatedBooks(IEnumerable<BookName>,IEnumerable<ShelfName>,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            IEnumerable<BookName> names = new[]
            {
                new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            IEnumerable<ShelfName> shelves = new List<ShelfName>();
            // Make the request
            PagedEnumerable<FindRelatedBooksResponse, BookName> response =
                libraryServiceClient.FindRelatedBooks(names, shelves);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (BookName item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (FindRelatedBooksResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (BookName item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookName> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (BookName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for FindRelatedBooksAsync</summary>
        public async Task FindRelatedBooksAsync_RequestObject()
        {
            // Snippet: FindRelatedBooksAsync(FindRelatedBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            FindRelatedBooksRequest request = new FindRelatedBooksRequest
            {
                BookNames = {
                                new BookName("[SHELF_ID]", "[BOOK_ID]"),
                            },
                ShelvesAsShelfNames = { },
            };
            // Make the request
            PagedAsyncEnumerable<FindRelatedBooksResponse, BookName> response =
                libraryServiceClient.FindRelatedBooksAsync(request);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((BookName item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((FindRelatedBooksResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (BookName item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookName> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (BookName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for FindRelatedBooks</summary>
        public void FindRelatedBooks_RequestObject()
        {
            // Snippet: FindRelatedBooks(FindRelatedBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            FindRelatedBooksRequest request = new FindRelatedBooksRequest
            {
                BookNames = {
                                new BookName("[SHELF_ID]", "[BOOK_ID]"),
                            },
                ShelvesAsShelfNames = { },
            };
            // Make the request
            PagedEnumerable<FindRelatedBooksResponse, BookName> response =
                libraryServiceClient.FindRelatedBooks(request);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (BookName item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (FindRelatedBooksResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (BookName item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookName> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (BookName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for AddTagAsync</summary>
        public async Task AddTagAsync()
        {
            // Snippet: AddTagAsync(string,string,CallSettings)
            // Additional: AddTagAsync(string,string,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            string formattedResource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString();
            string tag = "";
            // Make the request
            AddTagResponse response = await libraryServiceClient.AddTagAsync(formattedResource, tag);
            // End snippet
        }

        /// <summary>Snippet for AddTag</summary>
        public void AddTag()
        {
            // Snippet: AddTag(string,string,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            string formattedResource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString();
            string tag = "";
            // Make the request
            AddTagResponse response = libraryServiceClient.AddTag(formattedResource, tag);
            // End snippet
        }

        /// <summary>Snippet for AddTagAsync</summary>
        public async Task AddTagAsync_RequestObject()
        {
            // Snippet: AddTagAsync(AddTagRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            AddTagRequest request = new AddTagRequest
            {
                Resource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Tag = "",
            };
            // Make the request
            AddTagResponse response = await libraryServiceClient.AddTagAsync(request);
            // End snippet
        }

        /// <summary>Snippet for AddTag</summary>
        public void AddTag_RequestObject()
        {
            // Snippet: AddTag(AddTagRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            AddTagRequest request = new AddTagRequest
            {
                Resource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Tag = "",
            };
            // Make the request
            AddTagResponse response = libraryServiceClient.AddTag(request);
            // End snippet
        }

        /// <summary>Snippet for AddLabelAsync</summary>
        public async Task AddLabelAsync()
        {
            // Snippet: AddLabelAsync(string,string,CallSettings)
            // Additional: AddLabelAsync(string,string,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            string formattedResource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString();
            string label = "";
            // Make the request
            AddLabelResponse response = await libraryServiceClient.AddLabelAsync(formattedResource, label);
            // End snippet
        }

        /// <summary>Snippet for AddLabel</summary>
        public void AddLabel()
        {
            // Snippet: AddLabel(string,string,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            string formattedResource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString();
            string label = "";
            // Make the request
            AddLabelResponse response = libraryServiceClient.AddLabel(formattedResource, label);
            // End snippet
        }

        /// <summary>Snippet for AddLabelAsync</summary>
        public async Task AddLabelAsync_RequestObject()
        {
            // Snippet: AddLabelAsync(AddLabelRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            AddLabelRequest request = new AddLabelRequest
            {
                Resource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Label = "",
            };
            // Make the request
            AddLabelResponse response = await libraryServiceClient.AddLabelAsync(request);
            // End snippet
        }

        /// <summary>Snippet for AddLabel</summary>
        public void AddLabel_RequestObject()
        {
            // Snippet: AddLabel(AddLabelRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            AddLabelRequest request = new AddLabelRequest
            {
                Resource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Label = "",
            };
            // Make the request
            AddLabelResponse response = libraryServiceClient.AddLabel(request);
            // End snippet
        }

        /// <summary>Snippet for GetBigBookAsync</summary>
        public async Task GetBigBookAsync()
        {
            // Snippet: GetBigBookAsync(BookName,CallSettings)
            // Additional: GetBigBookAsync(BookName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            Operation<Book, GetBigBookMetadata> response =
                await libraryServiceClient.GetBigBookAsync(name);

            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> completedResponse =
                await response.PollUntilCompletedAsync();
            // Retrieve the operation result
            Book result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Book, GetBigBookMetadata> retrievedResponse =
                await libraryServiceClient.PollOnceGetBigBookAsync(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                Book retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigBook</summary>
        public void GetBigBook()
        {
            // Snippet: GetBigBook(BookName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            Operation<Book, GetBigBookMetadata> response =
                libraryServiceClient.GetBigBook(name);

            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> completedResponse =
                response.PollUntilCompleted();
            // Retrieve the operation result
            Book result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Book, GetBigBookMetadata> retrievedResponse =
                libraryServiceClient.PollOnceGetBigBook(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                Book retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigBookAsync</summary>
        public async Task GetBigBookAsync_RequestObject()
        {
            // Snippet: GetBigBookAsync(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            // Make the request
            Operation<Book, GetBigBookMetadata> response =
                await libraryServiceClient.GetBigBookAsync(request);

            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> completedResponse =
                await response.PollUntilCompletedAsync();
            // Retrieve the operation result
            Book result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Book, GetBigBookMetadata> retrievedResponse =
                await libraryServiceClient.PollOnceGetBigBookAsync(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                Book retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigBook</summary>
        public void GetBigBook_RequestObject()
        {
            // Snippet: GetBigBook(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            // Make the request
            Operation<Book, GetBigBookMetadata> response =
                libraryServiceClient.GetBigBook(request);

            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> completedResponse =
                response.PollUntilCompleted();
            // Retrieve the operation result
            Book result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Book, GetBigBookMetadata> retrievedResponse =
                libraryServiceClient.PollOnceGetBigBook(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                Book retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigNothingAsync</summary>
        public async Task GetBigNothingAsync()
        {
            // Snippet: GetBigNothingAsync(BookName,CallSettings)
            // Additional: GetBigNothingAsync(BookName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            Operation<Empty, GetBigBookMetadata> response =
                await libraryServiceClient.GetBigNothingAsync(name);

            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> completedResponse =
                await response.PollUntilCompletedAsync();
            // The long-running operation is now complete.

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Empty, GetBigBookMetadata> retrievedResponse =
                await libraryServiceClient.PollOnceGetBigNothingAsync(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // The long-running operation is now complete.
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigNothing</summary>
        public void GetBigNothing()
        {
            // Snippet: GetBigNothing(BookName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            Operation<Empty, GetBigBookMetadata> response =
                libraryServiceClient.GetBigNothing(name);

            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> completedResponse =
                response.PollUntilCompleted();
            // The long-running operation is now complete.

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Empty, GetBigBookMetadata> retrievedResponse =
                libraryServiceClient.PollOnceGetBigNothing(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // The long-running operation is now complete.
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigNothingAsync</summary>
        public async Task GetBigNothingAsync_RequestObject()
        {
            // Snippet: GetBigNothingAsync(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            // Make the request
            Operation<Empty, GetBigBookMetadata> response =
                await libraryServiceClient.GetBigNothingAsync(request);

            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> completedResponse =
                await response.PollUntilCompletedAsync();
            // The long-running operation is now complete.

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Empty, GetBigBookMetadata> retrievedResponse =
                await libraryServiceClient.PollOnceGetBigNothingAsync(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // The long-running operation is now complete.
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigNothing</summary>
        public void GetBigNothing_RequestObject()
        {
            // Snippet: GetBigNothing(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            // Make the request
            Operation<Empty, GetBigBookMetadata> response =
                libraryServiceClient.GetBigNothing(request);

            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> completedResponse =
                response.PollUntilCompleted();
            // The long-running operation is now complete.

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Empty, GetBigBookMetadata> retrievedResponse =
                libraryServiceClient.PollOnceGetBigNothing(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // The long-running operation is now complete.
            }
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParamsAsync</summary>
        public async Task TestOptionalRequiredFlatteningParamsAsync1()
        {
            // Snippet: TestOptionalRequiredFlatteningParamsAsync(,CallSettings)
            // Additional: TestOptionalRequiredFlatteningParamsAsync(,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = await libraryServiceClient.TestOptionalRequiredFlatteningParamsAsync();
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParams</summary>
        public void TestOptionalRequiredFlatteningParams1()
        {
            // Snippet: TestOptionalRequiredFlatteningParams(,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = libraryServiceClient.TestOptionalRequiredFlatteningParams();
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParamsAsync</summary>
        public async Task TestOptionalRequiredFlatteningParamsAsync2()
        {
            // Snippet: TestOptionalRequiredFlatteningParamsAsync(int,long,float,double,bool,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookName,BookNameOneof,int,long,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookName>,IEnumerable<BookNameOneof>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,int?,long?,float?,double?,bool?,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum?,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookName,BookNameOneof,int?,long?,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookName>,IEnumerable<BookNameOneof>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,CallSettings)
            // Additional: TestOptionalRequiredFlatteningParamsAsync(int,long,float,double,bool,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookName,BookNameOneof,int,long,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookName>,IEnumerable<BookNameOneof>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,int?,long?,float?,double?,bool?,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum?,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookName,BookNameOneof,int?,long?,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookName>,IEnumerable<BookNameOneof>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            int requiredSingularInt32 = 0;
            long requiredSingularInt64 = 0L;
            float requiredSingularFloat = 0.0f;
            double requiredSingularDouble = 0.0;
            bool requiredSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string requiredSingularString = "";
            ByteString requiredSingularBytes = ByteString.CopyFromUtf8("");
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookName requiredSingularResourceName = new BookName("[SHELF_ID]", "[BOOK_ID]");
            BookNameOneof requiredSingularResourceNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            int requiredSingularFixed32 = 0;
            long requiredSingularFixed64 = 0L;
            IEnumerable<int> requiredRepeatedInt32 = new List<int>();
            IEnumerable<long> requiredRepeatedInt64 = new List<long>();
            IEnumerable<float> requiredRepeatedFloat = new List<float>();
            IEnumerable<double> requiredRepeatedDouble = new List<double>();
            IEnumerable<bool> requiredRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> requiredRepeatedString = new List<string>();
            IEnumerable<ByteString> requiredRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookName> requiredRepeatedResourceName = new List<BookName>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<int> requiredRepeatedFixed32 = new List<int>();
            IEnumerable<long> requiredRepeatedFixed64 = new List<long>();
            IDictionary<int, string> requiredMap = new Dictionary<int, string>();
            int optionalSingularInt32 = 0;
            long optionalSingularInt64 = 0L;
            float optionalSingularFloat = 0.0f;
            double optionalSingularDouble = 0.0;
            bool optionalSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum optionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string optionalSingularString = "";
            ByteString optionalSingularBytes = ByteString.CopyFromUtf8("");
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookName optionalSingularResourceName = new BookName("[SHELF_ID]", "[BOOK_ID]");
            BookNameOneof optionalSingularResourceNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            int optionalSingularFixed32 = 0;
            long optionalSingularFixed64 = 0L;
            IEnumerable<int> optionalRepeatedInt32 = new List<int>();
            IEnumerable<long> optionalRepeatedInt64 = new List<long>();
            IEnumerable<float> optionalRepeatedFloat = new List<float>();
            IEnumerable<double> optionalRepeatedDouble = new List<double>();
            IEnumerable<bool> optionalRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> optionalRepeatedString = new List<string>();
            IEnumerable<ByteString> optionalRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookName> optionalRepeatedResourceName = new List<BookName>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<int> optionalRepeatedFixed32 = new List<int>();
            IEnumerable<long> optionalRepeatedFixed64 = new List<long>();
            IDictionary<int, string> optionalMap = new Dictionary<int, string>();
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = await libraryServiceClient.TestOptionalRequiredFlatteningParamsAsync(requiredSingularInt32, requiredSingularInt64, requiredSingularFloat, requiredSingularDouble, requiredSingularBool, requiredSingularEnum, requiredSingularString, requiredSingularBytes, requiredSingularMessage, requiredSingularResourceName, requiredSingularResourceNameOneof, requiredSingularFixed32, requiredSingularFixed64, requiredRepeatedInt32, requiredRepeatedInt64, requiredRepeatedFloat, requiredRepeatedDouble, requiredRepeatedBool, requiredRepeatedEnum, requiredRepeatedString, requiredRepeatedBytes, requiredRepeatedMessage, requiredRepeatedResourceName, requiredRepeatedResourceNameOneof, requiredRepeatedFixed32, requiredRepeatedFixed64, requiredMap, optionalSingularInt32, optionalSingularInt64, optionalSingularFloat, optionalSingularDouble, optionalSingularBool, optionalSingularEnum, optionalSingularString, optionalSingularBytes, optionalSingularMessage, optionalSingularResourceName, optionalSingularResourceNameOneof, optionalSingularFixed32, optionalSingularFixed64, optionalRepeatedInt32, optionalRepeatedInt64, optionalRepeatedFloat, optionalRepeatedDouble, optionalRepeatedBool, optionalRepeatedEnum, optionalRepeatedString, optionalRepeatedBytes, optionalRepeatedMessage, optionalRepeatedResourceName, optionalRepeatedResourceNameOneof, optionalRepeatedFixed32, optionalRepeatedFixed64, optionalMap);
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParams</summary>
        public void TestOptionalRequiredFlatteningParams2()
        {
            // Snippet: TestOptionalRequiredFlatteningParams(int,long,float,double,bool,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookName,BookNameOneof,int,long,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookName>,IEnumerable<BookNameOneof>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,int?,long?,float?,double?,bool?,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum?,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookName,BookNameOneof,int?,long?,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookName>,IEnumerable<BookNameOneof>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            int requiredSingularInt32 = 0;
            long requiredSingularInt64 = 0L;
            float requiredSingularFloat = 0.0f;
            double requiredSingularDouble = 0.0;
            bool requiredSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string requiredSingularString = "";
            ByteString requiredSingularBytes = ByteString.CopyFromUtf8("");
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookName requiredSingularResourceName = new BookName("[SHELF_ID]", "[BOOK_ID]");
            BookNameOneof requiredSingularResourceNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            int requiredSingularFixed32 = 0;
            long requiredSingularFixed64 = 0L;
            IEnumerable<int> requiredRepeatedInt32 = new List<int>();
            IEnumerable<long> requiredRepeatedInt64 = new List<long>();
            IEnumerable<float> requiredRepeatedFloat = new List<float>();
            IEnumerable<double> requiredRepeatedDouble = new List<double>();
            IEnumerable<bool> requiredRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> requiredRepeatedString = new List<string>();
            IEnumerable<ByteString> requiredRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookName> requiredRepeatedResourceName = new List<BookName>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<int> requiredRepeatedFixed32 = new List<int>();
            IEnumerable<long> requiredRepeatedFixed64 = new List<long>();
            IDictionary<int, string> requiredMap = new Dictionary<int, string>();
            int optionalSingularInt32 = 0;
            long optionalSingularInt64 = 0L;
            float optionalSingularFloat = 0.0f;
            double optionalSingularDouble = 0.0;
            bool optionalSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum optionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string optionalSingularString = "";
            ByteString optionalSingularBytes = ByteString.CopyFromUtf8("");
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookName optionalSingularResourceName = new BookName("[SHELF_ID]", "[BOOK_ID]");
            BookNameOneof optionalSingularResourceNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            int optionalSingularFixed32 = 0;
            long optionalSingularFixed64 = 0L;
            IEnumerable<int> optionalRepeatedInt32 = new List<int>();
            IEnumerable<long> optionalRepeatedInt64 = new List<long>();
            IEnumerable<float> optionalRepeatedFloat = new List<float>();
            IEnumerable<double> optionalRepeatedDouble = new List<double>();
            IEnumerable<bool> optionalRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> optionalRepeatedString = new List<string>();
            IEnumerable<ByteString> optionalRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookName> optionalRepeatedResourceName = new List<BookName>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<int> optionalRepeatedFixed32 = new List<int>();
            IEnumerable<long> optionalRepeatedFixed64 = new List<long>();
            IDictionary<int, string> optionalMap = new Dictionary<int, string>();
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = libraryServiceClient.TestOptionalRequiredFlatteningParams(requiredSingularInt32, requiredSingularInt64, requiredSingularFloat, requiredSingularDouble, requiredSingularBool, requiredSingularEnum, requiredSingularString, requiredSingularBytes, requiredSingularMessage, requiredSingularResourceName, requiredSingularResourceNameOneof, requiredSingularFixed32, requiredSingularFixed64, requiredRepeatedInt32, requiredRepeatedInt64, requiredRepeatedFloat, requiredRepeatedDouble, requiredRepeatedBool, requiredRepeatedEnum, requiredRepeatedString, requiredRepeatedBytes, requiredRepeatedMessage, requiredRepeatedResourceName, requiredRepeatedResourceNameOneof, requiredRepeatedFixed32, requiredRepeatedFixed64, requiredMap, optionalSingularInt32, optionalSingularInt64, optionalSingularFloat, optionalSingularDouble, optionalSingularBool, optionalSingularEnum, optionalSingularString, optionalSingularBytes, optionalSingularMessage, optionalSingularResourceName, optionalSingularResourceNameOneof, optionalSingularFixed32, optionalSingularFixed64, optionalRepeatedInt32, optionalRepeatedInt64, optionalRepeatedFloat, optionalRepeatedDouble, optionalRepeatedBool, optionalRepeatedEnum, optionalRepeatedString, optionalRepeatedBytes, optionalRepeatedMessage, optionalRepeatedResourceName, optionalRepeatedResourceNameOneof, optionalRepeatedFixed32, optionalRepeatedFixed64, optionalMap);
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParamsAsync</summary>
        public async Task TestOptionalRequiredFlatteningParamsAsync_RequestObject()
        {
            // Snippet: TestOptionalRequiredFlatteningParamsAsync(TestOptionalRequiredFlatteningParamsRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            TestOptionalRequiredFlatteningParamsRequest request = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 0,
                RequiredSingularInt64 = 0L,
                RequiredSingularFloat = 0.0f,
                RequiredSingularDouble = 0.0,
                RequiredSingularBool = false,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "",
                RequiredSingularBytes = ByteString.CopyFromUtf8(""),
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                RequiredSingularFixed32 = 0,
                RequiredSingularFixed64 = 0L,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNames = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
            };
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = await libraryServiceClient.TestOptionalRequiredFlatteningParamsAsync(request);
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParams</summary>
        public void TestOptionalRequiredFlatteningParams_RequestObject()
        {
            // Snippet: TestOptionalRequiredFlatteningParams(TestOptionalRequiredFlatteningParamsRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            TestOptionalRequiredFlatteningParamsRequest request = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 0,
                RequiredSingularInt64 = 0L,
                RequiredSingularFloat = 0.0f,
                RequiredSingularDouble = 0.0,
                RequiredSingularBool = false,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "",
                RequiredSingularBytes = ByteString.CopyFromUtf8(""),
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                RequiredSingularFixed32 = 0,
                RequiredSingularFixed64 = 0L,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNames = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
            };
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = libraryServiceClient.TestOptionalRequiredFlatteningParams(request);
            // End snippet
        }

    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1/Google.Example.Library.V1.csproj ==============
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>

    <!-- TODO: Version defaults to 1.0.0, edit as required -->
    <Version>1.0.0</Version>

    <!-- TODO: NuGet packaging options -->
    <!--
      <Description>
        Google Example Library API
        A simple Google Example Library API.
      </Description>
      <PackageTags>PubSub;Google;Cloud</PackageTags>
      <Copyright>Copyright 2017, Google Inc. All rights reserved.</Copyright>
      <Authors>Google, Inc.</Authors>
      *** TODO: These Icon, License, Project, and repo settings *MUST* be checked and edited ***
      *** The values given are just examples ***
      <PackageIconUrl>TODO: https://cloud.google.com/images/gcp-icon-64x64.png</PackageIconUrl>
      <PackageLicenseUrl>TODO: http://www.apache.org/licenses/LICENSE-2.0</PackageLicenseUrl>
      <PackageProjectUrl>TODO: https://github.com/GoogleCloudPlatform/google-cloud-dotnet</PackageProjectUrl>
      <RepositoryType>TODO: git</RepositoryType>
      <RepositoryUrl>TODO: https://github.com/GoogleCloudPlatform/google-cloud-dotnet</RepositoryUrl>
    -->

    <!-- TODO: Configure package signing -->
    <!--
      <AssemblyOriginatorKeyFile>...</AssemblyOriginatorKeyFile>
      <SignAssembly>true</SignAssembly>
      <PublicSign Condition=" '$(OS)' != 'Windows_NT' ">true</PublicSign>
    -->

    <!-- These items should not require editing -->
    <TargetFrameworks>netstandard1.5;net45</TargetFrameworks>
    <TargetFrameworks Condition=" '$(OS)' != 'Windows_NT' ">netstandard1.5</TargetFrameworks>
    <LangVersion>latest</LangVersion>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <Deterministic>true</Deterministic>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>

  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Google.Api.Gax.Grpc" Version="2.1.0" />
    <PackageReference Include="Grpc.Core" Version="1.6.1" />
  </ItemGroup>

</Project>

============== file: Google.Example.Library.V1/Google.Example.Library.V1/LibraryServiceClient.cs ==============
// Copyright 2017, Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

using Google.Api.Gax;
using Google.Api.Gax.Grpc;
using Google.Cloud.Tagger.V1;
using Google.LongRunning;
using Google.Protobuf;
using Google.Protobuf.WellKnownTypes;
using Google.Tagger.V1;
using Grpc.Core;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace Google.Example.Library.V1
{
    /// <summary>
    /// Settings for a <see cref="LibraryServiceClient"/>.
    /// </summary>
    public sealed partial class LibraryServiceSettings : ServiceSettingsBase
    {
        /// <summary>
        /// Get a new instance of the default <see cref="LibraryServiceSettings"/>.
        /// </summary>
        /// <returns>
        /// A new instance of the default <see cref="LibraryServiceSettings"/>.
        /// </returns>
        public static LibraryServiceSettings GetDefault() => new LibraryServiceSettings();

        /// <summary>
        /// Constructs a new <see cref="LibraryServiceSettings"/> object with default settings.
        /// </summary>
        public LibraryServiceSettings() { }

        private LibraryServiceSettings(LibraryServiceSettings existing) : base(existing)
        {
            GaxPreconditions.CheckNotNull(existing, nameof(existing));
            CreateShelfSettings = existing.CreateShelfSettings;
            GetShelfSettings = existing.GetShelfSettings;
            ListShelvesSettings = existing.ListShelvesSettings;
            DeleteShelfSettings = existing.DeleteShelfSettings;
            MergeShelvesSettings = existing.MergeShelvesSettings;
            CreateBookSettings = existing.CreateBookSettings;
            PublishSeriesSettings = existing.PublishSeriesSettings;
            GetBookSettings = existing.GetBookSettings;
            ListBooksSettings = existing.ListBooksSettings;
            DeleteBookSettings = existing.DeleteBookSettings;
            UpdateBookSettings = existing.UpdateBookSettings;
            MoveBookSettings = existing.MoveBookSettings;
            ListStringsSettings = existing.ListStringsSettings;
            AddCommentsSettings = existing.AddCommentsSettings;
            GetBookFromArchiveSettings = existing.GetBookFromArchiveSettings;
            GetBookFromAnywhereSettings = existing.GetBookFromAnywhereSettings;
            GetBookFromAbsolutelyAnywhereSettings = existing.GetBookFromAbsolutelyAnywhereSettings;
            UpdateBookIndexSettings = existing.UpdateBookIndexSettings;
            StreamShelvesSettings = existing.StreamShelvesSettings;
            StreamBooksSettings = existing.StreamBooksSettings;
            DiscussBookSettings = existing.DiscussBookSettings;
            DiscussBookStreamingSettings = existing.DiscussBookStreamingSettings;
            FindRelatedBooksSettings = existing.FindRelatedBooksSettings;
            AddTagSettings = existing.AddTagSettings;
            AddLabelSettings = existing.AddLabelSettings;
            GetBigBookSettings = existing.GetBigBookSettings;
            GetBigBookOperationsSettings = existing.GetBigBookOperationsSettings?.Clone();
            GetBigNothingSettings = existing.GetBigNothingSettings;
            GetBigNothingOperationsSettings = existing.GetBigNothingOperationsSettings?.Clone();
            TestOptionalRequiredFlatteningParamsSettings = existing.TestOptionalRequiredFlatteningParamsSettings;
            OnCopy(existing);
        }

        partial void OnCopy(LibraryServiceSettings existing);

        /// <summary>
        /// The filter specifying which RPC <see cref="StatusCode"/>s are eligible for retry
        /// for "Idempotent" <see cref="LibraryServiceClient"/> RPC methods.
        /// </summary>
        /// <remarks>
        /// The eligible RPC <see cref="StatusCode"/>s for retry for "Idempotent" RPC methods are:
        /// <list type="bullet">
        /// <item><description><see cref="StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="StatusCode.Unavailable"/></description></item>
        /// </list>
        /// </remarks>
        public static Predicate<RpcException> IdempotentRetryFilter { get; } =
            RetrySettings.FilterForStatusCodes(StatusCode.DeadlineExceeded, StatusCode.Unavailable);

        /// <summary>
        /// The filter specifying which RPC <see cref="StatusCode"/>s are eligible for retry
        /// for "NonIdempotent" <see cref="LibraryServiceClient"/> RPC methods.
        /// </summary>
        /// <remarks>
        /// There are no RPC <see cref="StatusCode"/>s eligible for retry for "NonIdempotent" RPC methods.
        /// </remarks>
        public static Predicate<RpcException> NonIdempotentRetryFilter { get; } =
            RetrySettings.FilterForStatusCodes();

        /// <summary>
        /// "Default" retry backoff for <see cref="LibraryServiceClient"/> RPC methods.
        /// </summary>
        /// <returns>
        /// The "Default" retry backoff for <see cref="LibraryServiceClient"/> RPC methods.
        /// </returns>
        /// <remarks>
        /// The "Default" retry backoff for <see cref="LibraryServiceClient"/> RPC methods is defined as:
        /// <list type="bullet">
        /// <item><description>Initial delay: 100 milliseconds</description></item>
        /// <item><description>Maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Delay multiplier: 1.2</description></item>
        /// </list>
        /// </remarks>
        public static BackoffSettings GetDefaultRetryBackoff() => new BackoffSettings(
            delay: TimeSpan.FromMilliseconds(100),
            maxDelay: TimeSpan.FromMilliseconds(1000),
            delayMultiplier: 1.2
        );

        /// <summary>
        /// "Default" timeout backoff for <see cref="LibraryServiceClient"/> RPC methods.
        /// </summary>
        /// <returns>
        /// The "Default" timeout backoff for <see cref="LibraryServiceClient"/> RPC methods.
        /// </returns>
        /// <remarks>
        /// The "Default" timeout backoff for <see cref="LibraryServiceClient"/> RPC methods is defined as:
        /// <list type="bullet">
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Maximum timeout: 3000 milliseconds</description></item>
        /// </list>
        /// </remarks>
        public static BackoffSettings GetDefaultTimeoutBackoff() => new BackoffSettings(
            delay: TimeSpan.FromMilliseconds(300),
            maxDelay: TimeSpan.FromMilliseconds(3000),
            delayMultiplier: 1.3
        );

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.CreateShelf</c> and <c>LibraryServiceClient.CreateShelfAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.CreateShelf</c> and
        /// <c>LibraryServiceClient.CreateShelfAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings CreateShelfSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetShelf</c> and <c>LibraryServiceClient.GetShelfAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetShelf</c> and
        /// <c>LibraryServiceClient.GetShelfAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings GetShelfSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.ListShelves</c> and <c>LibraryServiceClient.ListShelvesAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.ListShelves</c> and
        /// <c>LibraryServiceClient.ListShelvesAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings ListShelvesSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.DeleteShelf</c> and <c>LibraryServiceClient.DeleteShelfAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.DeleteShelf</c> and
        /// <c>LibraryServiceClient.DeleteShelfAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings DeleteShelfSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.MergeShelves</c> and <c>LibraryServiceClient.MergeShelvesAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.MergeShelves</c> and
        /// <c>LibraryServiceClient.MergeShelvesAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings MergeShelvesSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.CreateBook</c> and <c>LibraryServiceClient.CreateBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.CreateBook</c> and
        /// <c>LibraryServiceClient.CreateBookAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings CreateBookSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.PublishSeries</c> and <c>LibraryServiceClient.PublishSeriesAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.PublishSeries</c> and
        /// <c>LibraryServiceClient.PublishSeriesAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings PublishSeriesSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBook</c> and <c>LibraryServiceClient.GetBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBook</c> and
        /// <c>LibraryServiceClient.GetBookAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings GetBookSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.ListBooks</c> and <c>LibraryServiceClient.ListBooksAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.ListBooks</c> and
        /// <c>LibraryServiceClient.ListBooksAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings ListBooksSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.DeleteBook</c> and <c>LibraryServiceClient.DeleteBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.DeleteBook</c> and
        /// <c>LibraryServiceClient.DeleteBookAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings DeleteBookSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.UpdateBook</c> and <c>LibraryServiceClient.UpdateBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.UpdateBook</c> and
        /// <c>LibraryServiceClient.UpdateBookAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings UpdateBookSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.MoveBook</c> and <c>LibraryServiceClient.MoveBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.MoveBook</c> and
        /// <c>LibraryServiceClient.MoveBookAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings MoveBookSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.ListStrings</c> and <c>LibraryServiceClient.ListStringsAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.ListStrings</c> and
        /// <c>LibraryServiceClient.ListStringsAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings ListStringsSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.AddComments</c> and <c>LibraryServiceClient.AddCommentsAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.AddComments</c> and
        /// <c>LibraryServiceClient.AddCommentsAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings AddCommentsSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBookFromArchive</c> and <c>LibraryServiceClient.GetBookFromArchiveAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBookFromArchive</c> and
        /// <c>LibraryServiceClient.GetBookFromArchiveAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings GetBookFromArchiveSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBookFromAnywhere</c> and <c>LibraryServiceClient.GetBookFromAnywhereAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBookFromAnywhere</c> and
        /// <c>LibraryServiceClient.GetBookFromAnywhereAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings GetBookFromAnywhereSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBookFromAbsolutelyAnywhere</c> and <c>LibraryServiceClient.GetBookFromAbsolutelyAnywhereAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBookFromAbsolutelyAnywhere</c> and
        /// <c>LibraryServiceClient.GetBookFromAbsolutelyAnywhereAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings GetBookFromAbsolutelyAnywhereSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.UpdateBookIndex</c> and <c>LibraryServiceClient.UpdateBookIndexAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.UpdateBookIndex</c> and
        /// <c>LibraryServiceClient.UpdateBookIndexAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings UpdateBookIndexSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for calls to <c>LibraryServiceClient.StreamShelves</c>.
        /// </summary>
        /// <remarks>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings StreamShelvesSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromTimeout(TimeSpan.FromMilliseconds(30000)));

        /// <summary>
        /// <see cref="CallSettings"/> for calls to <c>LibraryServiceClient.StreamBooks</c>.
        /// </summary>
        /// <remarks>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings StreamBooksSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromTimeout(TimeSpan.FromMilliseconds(30000)));

        /// <summary>
        /// <see cref="CallSettings"/> for calls to <c>LibraryServiceClient.DiscussBook</c>.
        /// </summary>
        /// <remarks>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings DiscussBookSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromTimeout(TimeSpan.FromMilliseconds(30000)));

        /// <summary>
        /// <see cref="BidirectionalStreamingSettings"/> for calls to
        /// <c>LibraryServiceClient.DiscussBook</c>.
        /// </summary>
        /// <remarks>
        /// The default local send queue size is 100.
        /// </remarks>
        public BidirectionalStreamingSettings DiscussBookStreamingSettings { get; set; } =
            new BidirectionalStreamingSettings(100);

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.FindRelatedBooks</c> and <c>LibraryServiceClient.FindRelatedBooksAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.FindRelatedBooks</c> and
        /// <c>LibraryServiceClient.FindRelatedBooksAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings FindRelatedBooksSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.AddTag</c> and <c>LibraryServiceClient.AddTagAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.AddTag</c> and
        /// <c>LibraryServiceClient.AddTagAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings AddTagSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.AddLabel</c> and <c>LibraryServiceClient.AddLabelAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.AddLabel</c> and
        /// <c>LibraryServiceClient.AddLabelAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings AddLabelSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBigBook</c> and <c>LibraryServiceClient.GetBigBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBigBook</c> and
        /// <c>LibraryServiceClient.GetBigBookAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings GetBigBookSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// Long Running Operation settings for calls to <c>LibraryServiceClient.GetBigBook</c>.
        /// </summary>
        /// <remarks>
        /// Uses default <see cref="PollSettings"/> of:
        /// <list type="bullet">
        /// <item><description>Initial delay: 3000 milliseconds</description></item>
        /// <item><description>Delay multiplier: 1.3</description></item>
        /// <item><description>Maximum delay: 30000 milliseconds</description></item>
        /// <item><description>Total timeout: 86400000 milliseconds</description></item>
        /// </list>
        /// </remarks>
        public OperationsSettings GetBigBookOperationsSettings { get; set; } = new OperationsSettings
        {
            DefaultPollSettings = new PollSettings(
                Expiration.FromTimeout(TimeSpan.FromMilliseconds(86400000L)),
                TimeSpan.FromMilliseconds(3000L),
                1.3,
                TimeSpan.FromMilliseconds(30000L))
        };

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBigNothing</c> and <c>LibraryServiceClient.GetBigNothingAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBigNothing</c> and
        /// <c>LibraryServiceClient.GetBigNothingAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings GetBigNothingSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// Long Running Operation settings for calls to <c>LibraryServiceClient.GetBigNothing</c>.
        /// </summary>
        /// <remarks>
        /// Uses default <see cref="PollSettings"/> of:
        /// <list type="bullet">
        /// <item><description>Initial delay: 3000 milliseconds</description></item>
        /// <item><description>Delay multiplier: 1.3</description></item>
        /// <item><description>Maximum delay: 60000 milliseconds</description></item>
        /// <item><description>Total timeout: 600000 milliseconds</description></item>
        /// </list>
        /// </remarks>
        public OperationsSettings GetBigNothingOperationsSettings { get; set; } = new OperationsSettings
        {
            DefaultPollSettings = new PollSettings(
                Expiration.FromTimeout(TimeSpan.FromMilliseconds(600000L)),
                TimeSpan.FromMilliseconds(3000L),
                1.3,
                TimeSpan.FromMilliseconds(60000L))
        };

        /// <summary>
        /// <see cref="CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.TestOptionalRequiredFlatteningParams</c> and <c>LibraryServiceClient.TestOptionalRequiredFlatteningParamsAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.TestOptionalRequiredFlatteningParams</c> and
        /// <c>LibraryServiceClient.TestOptionalRequiredFlatteningParamsAsync</c> <see cref="RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public CallSettings TestOptionalRequiredFlatteningParamsSettings { get; set; } = CallSettings.FromCallTiming(
            CallTiming.FromRetry(new RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: Expiration.FromTimeout(TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// Creates a deep clone of this object, with all the same property values.
        /// </summary>
        /// <returns>A deep clone of this <see cref="LibraryServiceSettings"/> object.</returns>
        public LibraryServiceSettings Clone() => new LibraryServiceSettings(this);
    }

    /// <summary>
    /// LibraryService client wrapper, for convenient use.
    /// </summary>
    public abstract partial class LibraryServiceClient
    {
        /// <summary>
        /// The default endpoint for the LibraryService service, which is a host of "library-example.googleapis.com" and a port of 443.
        /// </summary>
        public static ServiceEndpoint DefaultEndpoint { get; } = new ServiceEndpoint("library-example.googleapis.com", 443);

        /// <summary>
        /// The default LibraryService scopes.
        /// </summary>
        /// <remarks>
        /// The default LibraryService scopes are:
        /// <list type="bullet">
        /// <item><description>"https://www.googleapis.com/auth/cloud-platform"</description></item>
        /// <item><description>"https://www.googleapis.com/auth/library"</description></item>
        /// </list>
        /// </remarks>
        public static IReadOnlyList<string> DefaultScopes { get; } = new ReadOnlyCollection<string>(new string[] {
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/library",
        });

        private static readonly ChannelPool s_channelPool = new ChannelPool(DefaultScopes);

        // Note: we could have parameterless overloads of Create and CreateAsync,
        // documented to just use the default endpoint, settings and credentials.
        // Pros:
        // - Might be more reassuring on first use
        // - Allows method group conversions
        // Con: overloads!

        /// <summary>
        /// Asynchronously creates a <see cref="LibraryServiceClient"/>, applying defaults for all unspecified settings,
        /// and creating a channel connecting to the given endpoint with application default credentials where
        /// necessary.
        /// </summary>
        /// <param name="endpoint">Optional <see cref="ServiceEndpoint"/>.</param>
        /// <param name="settings">Optional <see cref="LibraryServiceSettings"/>.</param>
        /// <returns>The task representing the created <see cref="LibraryServiceClient"/>.</returns>
        public static async Task<LibraryServiceClient> CreateAsync(ServiceEndpoint endpoint = null, LibraryServiceSettings settings = null)
        {
            Channel channel = await s_channelPool.GetChannelAsync(endpoint ?? DefaultEndpoint).ConfigureAwait(false);
            return Create(channel, settings);
        }

        /// <summary>
        /// Synchronously creates a <see cref="LibraryServiceClient"/>, applying defaults for all unspecified settings,
        /// and creating a channel connecting to the given endpoint with application default credentials where
        /// necessary.
        /// </summary>
        /// <param name="endpoint">Optional <see cref="ServiceEndpoint"/>.</param>
        /// <param name="settings">Optional <see cref="LibraryServiceSettings"/>.</param>
        /// <returns>The created <see cref="LibraryServiceClient"/>.</returns>
        public static LibraryServiceClient Create(ServiceEndpoint endpoint = null, LibraryServiceSettings settings = null)
        {
            Channel channel = s_channelPool.GetChannel(endpoint ?? DefaultEndpoint);
            return Create(channel, settings);
        }

        /// <summary>
        /// Creates a <see cref="LibraryServiceClient"/> which uses the specified channel for remote operations.
        /// </summary>
        /// <param name="channel">The <see cref="Channel"/> for remote operations. Must not be null.</param>
        /// <param name="settings">Optional <see cref="LibraryServiceSettings"/>.</param>
        /// <returns>The created <see cref="LibraryServiceClient"/>.</returns>
        public static LibraryServiceClient Create(Channel channel, LibraryServiceSettings settings = null)
        {
            GaxPreconditions.CheckNotNull(channel, nameof(channel));
            LibraryService.LibraryServiceClient grpcClient = new LibraryService.LibraryServiceClient(channel);
            return new LibraryServiceClientImpl(grpcClient, settings);
        }

        /// <summary>
        /// Shuts down any channels automatically created by <see cref="Create(ServiceEndpoint, LibraryServiceSettings)"/>
        /// and <see cref="CreateAsync(ServiceEndpoint, LibraryServiceSettings)"/>. Channels which weren't automatically
        /// created are not affected.
        /// </summary>
        /// <remarks>After calling this method, further calls to <see cref="Create(ServiceEndpoint, LibraryServiceSettings)"/>
        /// and <see cref="CreateAsync(ServiceEndpoint, LibraryServiceSettings)"/> will create new channels, which could
        /// in turn be shut down by another call to this method.</remarks>
        /// <returns>A task representing the asynchronous shutdown operation.</returns>
        public static Task ShutdownDefaultChannelsAsync() => s_channelPool.ShutdownChannelsAsync();

        /// <summary>
        /// The underlying gRPC LibraryService client.
        /// </summary>
        public virtual LibraryService.LibraryServiceClient GrpcClient
        {
            get { throw new NotImplementedException(); }
        }

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="shelf">
        /// The shelf to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Shelf> CreateShelfAsync(
            Shelf shelf,
            CallSettings callSettings = null) => CreateShelfAsync(
                new CreateShelfRequest
                {
                    Shelf = GaxPreconditions.CheckNotNull(shelf, nameof(shelf)),
                },
                callSettings);

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="shelf">
        /// The shelf to create.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Shelf> CreateShelfAsync(
            Shelf shelf,
            CancellationToken cancellationToken) => CreateShelfAsync(
                shelf,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="shelf">
        /// The shelf to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf CreateShelf(
            Shelf shelf,
            CallSettings callSettings = null) => CreateShelf(
                new CreateShelfRequest
                {
                    Shelf = GaxPreconditions.CheckNotNull(shelf, nameof(shelf)),
                },
                callSettings);

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Shelf> CreateShelfAsync(
            CreateShelfRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf CreateShelf(
            CreateShelfRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Shelf> GetShelfAsync(
            ShelfName name,
            CallSettings callSettings = null) => GetShelfAsync(
                new GetShelfRequest
                {
                    ShelfName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Shelf> GetShelfAsync(
            ShelfName name,
            CancellationToken cancellationToken) => GetShelfAsync(
                name,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            ShelfName name,
            CallSettings callSettings = null) => GetShelf(
                new GetShelfRequest
                {
                    ShelfName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Shelf> GetShelfAsync(
            string name,
            SomeMessage message,
            CallSettings callSettings = null) => GetShelfAsync(
                new GetShelfRequest
                {
                    Name = GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Message = message, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Shelf> GetShelfAsync(
            string name,
            SomeMessage message,
            CancellationToken cancellationToken) => GetShelfAsync(
                name,
                message,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            string name,
            SomeMessage message,
            CallSettings callSettings = null) => GetShelf(
                new GetShelfRequest
                {
                    Name = GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Message = message, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="stringBuilder">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Shelf> GetShelfAsync(
            string name,
            SomeMessage message,
            StringBuilder stringBuilder,
            CallSettings callSettings = null) => GetShelfAsync(
                new GetShelfRequest
                {
                    Name = GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Message = message, // Optional
                    StringBuilder = stringBuilder, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="stringBuilder">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Shelf> GetShelfAsync(
            string name,
            SomeMessage message,
            StringBuilder stringBuilder,
            CancellationToken cancellationToken) => GetShelfAsync(
                name,
                message,
                stringBuilder,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="stringBuilder">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            string name,
            SomeMessage message,
            StringBuilder stringBuilder,
            CallSettings callSettings = null) => GetShelf(
                new GetShelfRequest
                {
                    Name = GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Message = message, // Optional
                    StringBuilder = stringBuilder, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Shelf> GetShelfAsync(
            GetShelfRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            GetShelfRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public virtual PagedAsyncEnumerable<ListShelvesResponse, Shelf> ListShelvesAsync(
            string pageToken = null,
            int? pageSize = null,
            CallSettings callSettings = null) => ListShelvesAsync(
                new ListShelvesRequest
                {
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public virtual PagedEnumerable<ListShelvesResponse, Shelf> ListShelves(
            string pageToken = null,
            int? pageSize = null,
            CallSettings callSettings = null) => ListShelves(
                new ListShelvesRequest
                {
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public virtual PagedAsyncEnumerable<ListShelvesResponse, Shelf> ListShelvesAsync(
            ListShelvesRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public virtual PagedEnumerable<ListShelvesResponse, Shelf> ListShelves(
            ListShelvesRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task DeleteShelfAsync(
            ShelfName name,
            CallSettings callSettings = null) => DeleteShelfAsync(
                new DeleteShelfRequest
                {
                    ShelfName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to delete.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task DeleteShelfAsync(
            ShelfName name,
            CancellationToken cancellationToken) => DeleteShelfAsync(
                name,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual void DeleteShelf(
            ShelfName name,
            CallSettings callSettings = null) => DeleteShelf(
                new DeleteShelfRequest
                {
                    ShelfName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task DeleteShelfAsync(
            DeleteShelfRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual void DeleteShelf(
            DeleteShelfRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf we're adding books to.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the shelf we're removing books from and deleting.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Shelf> MergeShelvesAsync(
            ShelfName name,
            ShelfName otherShelfName,
            CallSettings callSettings = null) => MergeShelvesAsync(
                new MergeShelvesRequest
                {
                    ShelfName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OtherShelfNameAsShelfName = GaxPreconditions.CheckNotNull(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf we're adding books to.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the shelf we're removing books from and deleting.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Shelf> MergeShelvesAsync(
            ShelfName name,
            ShelfName otherShelfName,
            CancellationToken cancellationToken) => MergeShelvesAsync(
                name,
                otherShelfName,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf we're adding books to.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the shelf we're removing books from and deleting.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf MergeShelves(
            ShelfName name,
            ShelfName otherShelfName,
            CallSettings callSettings = null) => MergeShelves(
                new MergeShelvesRequest
                {
                    ShelfName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OtherShelfNameAsShelfName = GaxPreconditions.CheckNotNull(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Shelf> MergeShelvesAsync(
            MergeShelvesRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf MergeShelves(
            MergeShelvesRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf in which the book is created.
        /// </param>
        /// <param name="book">
        /// The book to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Book> CreateBookAsync(
            string name,
            Book book,
            CallSettings callSettings = null) => CreateBookAsync(
                new CreateBookRequest
                {
                    Name = GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Book = GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf in which the book is created.
        /// </param>
        /// <param name="book">
        /// The book to create.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Book> CreateBookAsync(
            string name,
            Book book,
            CancellationToken cancellationToken) => CreateBookAsync(
                name,
                book,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf in which the book is created.
        /// </param>
        /// <param name="book">
        /// The book to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book CreateBook(
            string name,
            Book book,
            CallSettings callSettings = null) => CreateBook(
                new CreateBookRequest
                {
                    Name = GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Book = GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Book> CreateBookAsync(
            CreateBookRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book CreateBook(
            CreateBookRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="shelf">
        /// The shelf in which the series is created.
        /// </param>
        /// <param name="books">
        /// The books to publish in the series.
        /// </param>
        /// <param name="edition">
        /// The edition of the series
        /// </param>
        /// <param name="seriesUuid">
        /// Uniquely identifies the series to the publishing house.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<PublishSeriesResponse> PublishSeriesAsync(
            Shelf shelf,
            IEnumerable<Book> books,
            uint? edition,
            SeriesUuid seriesUuid,
            CallSettings callSettings = null) => PublishSeriesAsync(
                new PublishSeriesRequest
                {
                    Shelf = GaxPreconditions.CheckNotNull(shelf, nameof(shelf)),
                    Books = { GaxPreconditions.CheckNotNull(books, nameof(books)) },
                    Edition = edition ?? 0, // Optional
                    SeriesUuid = GaxPreconditions.CheckNotNull(seriesUuid, nameof(seriesUuid)),
                },
                callSettings);

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="shelf">
        /// The shelf in which the series is created.
        /// </param>
        /// <param name="books">
        /// The books to publish in the series.
        /// </param>
        /// <param name="edition">
        /// The edition of the series
        /// </param>
        /// <param name="seriesUuid">
        /// Uniquely identifies the series to the publishing house.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<PublishSeriesResponse> PublishSeriesAsync(
            Shelf shelf,
            IEnumerable<Book> books,
            uint? edition,
            SeriesUuid seriesUuid,
            CancellationToken cancellationToken) => PublishSeriesAsync(
                shelf,
                books,
                edition,
                seriesUuid,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="shelf">
        /// The shelf in which the series is created.
        /// </param>
        /// <param name="books">
        /// The books to publish in the series.
        /// </param>
        /// <param name="edition">
        /// The edition of the series
        /// </param>
        /// <param name="seriesUuid">
        /// Uniquely identifies the series to the publishing house.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual PublishSeriesResponse PublishSeries(
            Shelf shelf,
            IEnumerable<Book> books,
            uint? edition,
            SeriesUuid seriesUuid,
            CallSettings callSettings = null) => PublishSeries(
                new PublishSeriesRequest
                {
                    Shelf = GaxPreconditions.CheckNotNull(shelf, nameof(shelf)),
                    Books = { GaxPreconditions.CheckNotNull(books, nameof(books)) },
                    Edition = edition ?? 0, // Optional
                    SeriesUuid = GaxPreconditions.CheckNotNull(seriesUuid, nameof(seriesUuid)),
                },
                callSettings);

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<PublishSeriesResponse> PublishSeriesAsync(
            PublishSeriesRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual PublishSeriesResponse PublishSeries(
            PublishSeriesRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Book> GetBookAsync(
            BookName name,
            CallSettings callSettings = null) => GetBookAsync(
                new GetBookRequest
                {
                    BookName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Book> GetBookAsync(
            BookName name,
            CancellationToken cancellationToken) => GetBookAsync(
                name,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book GetBook(
            BookName name,
            CallSettings callSettings = null) => GetBook(
                new GetBookRequest
                {
                    BookName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Book> GetBookAsync(
            GetBookRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book GetBook(
            GetBookRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf whose books we'd like to list.
        /// </param>
        /// <param name="filter">
        /// To test python built-in wrapping.
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual PagedAsyncEnumerable<ListBooksResponse, Book> ListBooksAsync(
            ShelfName name,
            string filter,
            string pageToken = null,
            int? pageSize = null,
            CallSettings callSettings = null) => ListBooksAsync(
                new ListBooksRequest
                {
                    ShelfName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Filter = filter ?? "", // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf whose books we'd like to list.
        /// </param>
        /// <param name="filter">
        /// To test python built-in wrapping.
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual PagedEnumerable<ListBooksResponse, Book> ListBooks(
            ShelfName name,
            string filter,
            string pageToken = null,
            int? pageSize = null,
            CallSettings callSettings = null) => ListBooks(
                new ListBooksRequest
                {
                    ShelfName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Filter = filter ?? "", // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual PagedAsyncEnumerable<ListBooksResponse, Book> ListBooksAsync(
            ListBooksRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual PagedEnumerable<ListBooksResponse, Book> ListBooks(
            ListBooksRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task DeleteBookAsync(
            BookName name,
            CallSettings callSettings = null) => DeleteBookAsync(
                new DeleteBookRequest
                {
                    BookName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to delete.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task DeleteBookAsync(
            BookName name,
            CancellationToken cancellationToken) => DeleteBookAsync(
                name,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual void DeleteBook(
            BookName name,
            CallSettings callSettings = null) => DeleteBook(
                new DeleteBookRequest
                {
                    BookName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task DeleteBookAsync(
            DeleteBookRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual void DeleteBook(
            DeleteBookRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Book> UpdateBookAsync(
            BookName name,
            Book book,
            CallSettings callSettings = null) => UpdateBookAsync(
                new UpdateBookRequest
                {
                    BookName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Book = GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Book> UpdateBookAsync(
            BookName name,
            Book book,
            CancellationToken cancellationToken) => UpdateBookAsync(
                name,
                book,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book UpdateBook(
            BookName name,
            Book book,
            CallSettings callSettings = null) => UpdateBook(
                new UpdateBookRequest
                {
                    BookName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Book = GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="optionalFoo">
        /// An optional foo.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="updateMask">
        /// A field mask to apply, rendered as an HTTP parameter.
        /// </param>
        /// <param name="physicalMask">
        /// To test Python import clash resolution.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Book> UpdateBookAsync(
            BookName name,
            string optionalFoo,
            Book book,
            FieldMask updateMask,
            FieldMask physicalMask,
            CallSettings callSettings = null) => UpdateBookAsync(
                new UpdateBookRequest
                {
                    BookName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OptionalFoo = optionalFoo ?? "", // Optional
                    Book = GaxPreconditions.CheckNotNull(book, nameof(book)),
                    UpdateMask = updateMask, // Optional
                    PhysicalMask = physicalMask, // Optional
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="optionalFoo">
        /// An optional foo.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="updateMask">
        /// A field mask to apply, rendered as an HTTP parameter.
        /// </param>
        /// <param name="physicalMask">
        /// To test Python import clash resolution.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Book> UpdateBookAsync(
            BookName name,
            string optionalFoo,
            Book book,
            FieldMask updateMask,
            FieldMask physicalMask,
            CancellationToken cancellationToken) => UpdateBookAsync(
                name,
                optionalFoo,
                book,
                updateMask,
                physicalMask,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="optionalFoo">
        /// An optional foo.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="updateMask">
        /// A field mask to apply, rendered as an HTTP parameter.
        /// </param>
        /// <param name="physicalMask">
        /// To test Python import clash resolution.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book UpdateBook(
            BookName name,
            string optionalFoo,
            Book book,
            FieldMask updateMask,
            FieldMask physicalMask,
            CallSettings callSettings = null) => UpdateBook(
                new UpdateBookRequest
                {
                    BookName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OptionalFoo = optionalFoo ?? "", // Optional
                    Book = GaxPreconditions.CheckNotNull(book, nameof(book)),
                    UpdateMask = updateMask, // Optional
                    PhysicalMask = physicalMask, // Optional
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Book> UpdateBookAsync(
            UpdateBookRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book UpdateBook(
            UpdateBookRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to move.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the destination shelf.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Book> MoveBookAsync(
            BookName name,
            ShelfName otherShelfName,
            CallSettings callSettings = null) => MoveBookAsync(
                new MoveBookRequest
                {
                    BookName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OtherShelfNameAsShelfName = GaxPreconditions.CheckNotNull(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to move.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the destination shelf.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Book> MoveBookAsync(
            BookName name,
            ShelfName otherShelfName,
            CancellationToken cancellationToken) => MoveBookAsync(
                name,
                otherShelfName,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to move.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the destination shelf.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book MoveBook(
            BookName name,
            ShelfName otherShelfName,
            CallSettings callSettings = null) => MoveBook(
                new MoveBookRequest
                {
                    BookName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OtherShelfNameAsShelfName = GaxPreconditions.CheckNotNull(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Book> MoveBookAsync(
            MoveBookRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book MoveBook(
            MoveBookRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual PagedAsyncEnumerable<ListStringsResponse, IResourceName> ListStringsAsync(
            string pageToken = null,
            int? pageSize = null,
            CallSettings callSettings = null) => ListStringsAsync(
                new ListStringsRequest
                {
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual PagedEnumerable<ListStringsResponse, IResourceName> ListStrings(
            string pageToken = null,
            int? pageSize = null,
            CallSettings callSettings = null) => ListStrings(
                new ListStringsRequest
                {
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual PagedAsyncEnumerable<ListStringsResponse, IResourceName> ListStringsAsync(
            IResourceName name,
            string pageToken = null,
            int? pageSize = null,
            CallSettings callSettings = null) => ListStringsAsync(
                new ListStringsRequest
                {
                    AsResourceName = name, // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual PagedEnumerable<ListStringsResponse, IResourceName> ListStrings(
            IResourceName name,
            string pageToken = null,
            int? pageSize = null,
            CallSettings callSettings = null) => ListStrings(
                new ListStringsRequest
                {
                    AsResourceName = name, // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual PagedAsyncEnumerable<ListStringsResponse, IResourceName> ListStringsAsync(
            ListStringsRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual PagedEnumerable<ListStringsResponse, IResourceName> ListStrings(
            ListStringsRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="comments">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task AddCommentsAsync(
            string name,
            IEnumerable<Comment> comments,
            CallSettings callSettings = null) => AddCommentsAsync(
                new AddCommentsRequest
                {
                    Name = GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Comments = { GaxPreconditions.CheckNotNull(comments, nameof(comments)) },
                },
                callSettings);

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="comments">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task AddCommentsAsync(
            string name,
            IEnumerable<Comment> comments,
            CancellationToken cancellationToken) => AddCommentsAsync(
                name,
                comments,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="comments">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual void AddComments(
            string name,
            IEnumerable<Comment> comments,
            CallSettings callSettings = null) => AddComments(
                new AddCommentsRequest
                {
                    Name = GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Comments = { GaxPreconditions.CheckNotNull(comments, nameof(comments)) },
                },
                callSettings);

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task AddCommentsAsync(
            AddCommentsRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual void AddComments(
            AddCommentsRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<BookFromArchive> GetBookFromArchiveAsync(
            ArchivedBookName name,
            CallSettings callSettings = null) => GetBookFromArchiveAsync(
                new GetBookFromArchiveRequest
                {
                    ArchivedBookName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<BookFromArchive> GetBookFromArchiveAsync(
            ArchivedBookName name,
            CancellationToken cancellationToken) => GetBookFromArchiveAsync(
                name,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromArchive GetBookFromArchive(
            ArchivedBookName name,
            CallSettings callSettings = null) => GetBookFromArchive(
                new GetBookFromArchiveRequest
                {
                    ArchivedBookName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<BookFromArchive> GetBookFromArchiveAsync(
            GetBookFromArchiveRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromArchive GetBookFromArchive(
            GetBookFromArchiveRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="altBookName">
        /// An alternate book name, used to test restricting flattened field to a
        /// single resource name type in a oneof.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            BookNameOneof name,
            BookName altBookName,
            CallSettings callSettings = null) => GetBookFromAnywhereAsync(
                new GetBookFromAnywhereRequest
                {
                    BookNameOneof = GaxPreconditions.CheckNotNull(name, nameof(name)),
                    AltBookNameAsBookNameOneof = BookNameOneof.From(GaxPreconditions.CheckNotNull(altBookName, nameof(altBookName))),
                },
                callSettings);

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="altBookName">
        /// An alternate book name, used to test restricting flattened field to a
        /// single resource name type in a oneof.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            BookNameOneof name,
            BookName altBookName,
            CancellationToken cancellationToken) => GetBookFromAnywhereAsync(
                name,
                altBookName,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="altBookName">
        /// An alternate book name, used to test restricting flattened field to a
        /// single resource name type in a oneof.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAnywhere(
            BookNameOneof name,
            BookName altBookName,
            CallSettings callSettings = null) => GetBookFromAnywhere(
                new GetBookFromAnywhereRequest
                {
                    BookNameOneof = GaxPreconditions.CheckNotNull(name, nameof(name)),
                    AltBookNameAsBookNameOneof = BookNameOneof.From(GaxPreconditions.CheckNotNull(altBookName, nameof(altBookName))),
                },
                callSettings);

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            GetBookFromAnywhereRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAnywhere(
            GetBookFromAnywhereRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            BookNameOneof name,
            CallSettings callSettings = null) => GetBookFromAbsolutelyAnywhereAsync(
                new GetBookFromAbsolutelyAnywhereRequest
                {
                    AsResourceName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            BookNameOneof name,
            CancellationToken cancellationToken) => GetBookFromAbsolutelyAnywhereAsync(
                name,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAbsolutelyAnywhere(
            BookNameOneof name,
            CallSettings callSettings = null) => GetBookFromAbsolutelyAnywhere(
                new GetBookFromAbsolutelyAnywhereRequest
                {
                    AsResourceName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            GetBookFromAbsolutelyAnywhereRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAbsolutelyAnywhere(
            GetBookFromAbsolutelyAnywhereRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="indexName">
        /// The name of the index for the book
        /// </param>
        /// <param name="indexMap">
        /// The index to update the book with
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task UpdateBookIndexAsync(
            BookName name,
            string indexName,
            IDictionary<string, string> indexMap,
            CallSettings callSettings = null) => UpdateBookIndexAsync(
                new UpdateBookIndexRequest
                {
                    BookName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                    IndexName = GaxPreconditions.CheckNotNullOrEmpty(indexName, nameof(indexName)),
                    IndexMap = { GaxPreconditions.CheckNotNull(indexMap, nameof(indexMap)) },
                },
                callSettings);

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="indexName">
        /// The name of the index for the book
        /// </param>
        /// <param name="indexMap">
        /// The index to update the book with
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task UpdateBookIndexAsync(
            BookName name,
            string indexName,
            IDictionary<string, string> indexMap,
            CancellationToken cancellationToken) => UpdateBookIndexAsync(
                name,
                indexName,
                indexMap,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="indexName">
        /// The name of the index for the book
        /// </param>
        /// <param name="indexMap">
        /// The index to update the book with
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual void UpdateBookIndex(
            BookName name,
            string indexName,
            IDictionary<string, string> indexMap,
            CallSettings callSettings = null) => UpdateBookIndex(
                new UpdateBookIndexRequest
                {
                    BookName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                    IndexName = GaxPreconditions.CheckNotNullOrEmpty(indexName, nameof(indexName)),
                    IndexMap = { GaxPreconditions.CheckNotNull(indexMap, nameof(indexMap)) },
                },
                callSettings);

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task UpdateBookIndexAsync(
            UpdateBookIndexRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual void UpdateBookIndex(
            UpdateBookIndexRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Test server streaming
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The server stream.
        /// </returns>
        public virtual StreamShelvesStream StreamShelves(
            StreamShelvesRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Server streaming methods for <c>StreamShelves</c>.
        /// </summary>
        public abstract partial class StreamShelvesStream : ServerStreamingBase<StreamShelvesResponse>
        {
        }

        /// <summary>
        /// Test server streaming, non-paged responses.
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The server stream.
        /// </returns>
        public virtual StreamBooksStream StreamBooks(
            StreamBooksRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Server streaming methods for <c>StreamBooks</c>.
        /// </summary>
        public abstract partial class StreamBooksStream : ServerStreamingBase<Book>
        {
        }

        /// <summary>
        /// Test bidi-streaming.
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <param name="streamingSettings">
        /// If not null, applies streaming overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The client-server stream.
        /// </returns>
        public virtual DiscussBookStream DiscussBook(
            CallSettings callSettings = null,
            BidirectionalStreamingSettings streamingSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Bidirectional streaming methods for <c>DiscussBook</c>.
        /// </summary>
        public abstract partial class DiscussBookStream : BidirectionalStreamingBase<DiscussBookRequest, Comment>
        {
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="names">
        ///
        /// </param>
        /// <param name="shelves">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual PagedAsyncEnumerable<FindRelatedBooksResponse, BookName> FindRelatedBooksAsync(
            IEnumerable<BookName> names,
            IEnumerable<ShelfName> shelves,
            string pageToken = null,
            int? pageSize = null,
            CallSettings callSettings = null) => FindRelatedBooksAsync(
                new FindRelatedBooksRequest
                {
                    BookNames = { GaxPreconditions.CheckNotNull(names, nameof(names)) },
                    ShelvesAsShelfNames = { GaxPreconditions.CheckNotNull(shelves, nameof(shelves)) },
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="names">
        ///
        /// </param>
        /// <param name="shelves">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual PagedEnumerable<FindRelatedBooksResponse, BookName> FindRelatedBooks(
            IEnumerable<BookName> names,
            IEnumerable<ShelfName> shelves,
            string pageToken = null,
            int? pageSize = null,
            CallSettings callSettings = null) => FindRelatedBooks(
                new FindRelatedBooksRequest
                {
                    BookNames = { GaxPreconditions.CheckNotNull(names, nameof(names)) },
                    ShelvesAsShelfNames = { GaxPreconditions.CheckNotNull(shelves, nameof(shelves)) },
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual PagedAsyncEnumerable<FindRelatedBooksResponse, BookName> FindRelatedBooksAsync(
            FindRelatedBooksRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual PagedEnumerable<FindRelatedBooksResponse, BookName> FindRelatedBooks(
            FindRelatedBooksRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Adds a tag to the book. This RPC is a mixin.
        /// </summary>
        /// <param name="resource">
        /// REQUIRED: The resource which the tag is being added to.
        /// Resource is usually specified as a path, such as,
        /// projects/{project}/zones/{zone}/disks/{disk}.
        /// </param>
        /// <param name="tag">
        /// REQUIRED: The tag to add.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<AddTagResponse> AddTagAsync(
            string resource,
            string tag,
            CallSettings callSettings = null) => AddTagAsync(
                new AddTagRequest
                {
                    Resource = GaxPreconditions.CheckNotNullOrEmpty(resource, nameof(resource)),
                    Tag = GaxPreconditions.CheckNotNullOrEmpty(tag, nameof(tag)),
                },
                callSettings);

        /// <summary>
        /// Adds a tag to the book. This RPC is a mixin.
        /// </summary>
        /// <param name="resource">
        /// REQUIRED: The resource which the tag is being added to.
        /// Resource is usually specified as a path, such as,
        /// projects/{project}/zones/{zone}/disks/{disk}.
        /// </param>
        /// <param name="tag">
        /// REQUIRED: The tag to add.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<AddTagResponse> AddTagAsync(
            string resource,
            string tag,
            CancellationToken cancellationToken) => AddTagAsync(
                resource,
                tag,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Adds a tag to the book. This RPC is a mixin.
        /// </summary>
        /// <param name="resource">
        /// REQUIRED: The resource which the tag is being added to.
        /// Resource is usually specified as a path, such as,
        /// projects/{project}/zones/{zone}/disks/{disk}.
        /// </param>
        /// <param name="tag">
        /// REQUIRED: The tag to add.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual AddTagResponse AddTag(
            string resource,
            string tag,
            CallSettings callSettings = null) => AddTag(
                new AddTagRequest
                {
                    Resource = GaxPreconditions.CheckNotNullOrEmpty(resource, nameof(resource)),
                    Tag = GaxPreconditions.CheckNotNullOrEmpty(tag, nameof(tag)),
                },
                callSettings);

        /// <summary>
        /// Adds a tag to the book. This RPC is a mixin.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<AddTagResponse> AddTagAsync(
            AddTagRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Adds a tag to the book. This RPC is a mixin.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual AddTagResponse AddTag(
            AddTagRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="resource">
        /// REQUIRED: The resource which the label is being added to.
        /// Resource is usually specified as a path, such as,
        /// projects/{project}/zones/{zone}/disks/{disk}.
        /// </param>
        /// <param name="label">
        /// REQUIRED: The label to add.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<AddLabelResponse> AddLabelAsync(
            string resource,
            string label,
            CallSettings callSettings = null) => AddLabelAsync(
                new AddLabelRequest
                {
                    Resource = GaxPreconditions.CheckNotNullOrEmpty(resource, nameof(resource)),
                    Label = GaxPreconditions.CheckNotNullOrEmpty(label, nameof(label)),
                },
                callSettings);

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="resource">
        /// REQUIRED: The resource which the label is being added to.
        /// Resource is usually specified as a path, such as,
        /// projects/{project}/zones/{zone}/disks/{disk}.
        /// </param>
        /// <param name="label">
        /// REQUIRED: The label to add.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<AddLabelResponse> AddLabelAsync(
            string resource,
            string label,
            CancellationToken cancellationToken) => AddLabelAsync(
                resource,
                label,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="resource">
        /// REQUIRED: The resource which the label is being added to.
        /// Resource is usually specified as a path, such as,
        /// projects/{project}/zones/{zone}/disks/{disk}.
        /// </param>
        /// <param name="label">
        /// REQUIRED: The label to add.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual AddLabelResponse AddLabel(
            string resource,
            string label,
            CallSettings callSettings = null) => AddLabel(
                new AddLabelRequest
                {
                    Resource = GaxPreconditions.CheckNotNullOrEmpty(resource, nameof(resource)),
                    Label = GaxPreconditions.CheckNotNullOrEmpty(label, nameof(label)),
                },
                callSettings);

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<AddLabelResponse> AddLabelAsync(
            AddLabelRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual AddLabelResponse AddLabel(
            AddLabelRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            BookName name,
            CallSettings callSettings = null) => GetBigBookAsync(
                new GetBookRequest
                {
                    BookName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            BookName name,
            CancellationToken cancellationToken) => GetBigBookAsync(
                name,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Operation<Book, GetBigBookMetadata> GetBigBook(
            BookName name,
            CallSettings callSettings = null) => GetBigBook(
                new GetBookRequest
                {
                    BookName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            GetBookRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Asynchronously poll an operation once, using an <c>operationName</c> from a previous invocation of <c>GetBigBookAsync</c>.
        /// </summary>
        /// <param name="operationName">The name of a previously invoked operation. Must not be <c>null</c> or empty.</param>
        /// <param name="callSettings">If not null, applies overrides to this RPC call.</param>
        /// <returns>A task representing the result of polling the operation.</returns>
        public virtual Task<Operation<Book, GetBigBookMetadata>> PollOnceGetBigBookAsync(
            string operationName,
            CallSettings callSettings = null) => Operation<Book, GetBigBookMetadata>.PollOnceFromNameAsync(
                GaxPreconditions.CheckNotNullOrEmpty(operationName, nameof(operationName)),
                GetBigBookOperationsClient,
                callSettings);

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Operation<Book, GetBigBookMetadata> GetBigBook(
            GetBookRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// The long-running operations client for <c>GetBigBook</c>.
        /// </summary>
        public virtual OperationsClient GetBigBookOperationsClient
        {
            get { throw new NotImplementedException(); }
        }

        /// <summary>
        /// Poll an operation once, using an <c>operationName</c> from a previous invocation of <c>GetBigBook</c>.
        /// </summary>
        /// <param name="operationName">The name of a previously invoked operation. Must not be <c>null</c> or empty.</param>
        /// <param name="callSettings">If not null, applies overrides to this RPC call.</param>
        /// <returns>The result of polling the operation.</returns>
        public virtual Operation<Book, GetBigBookMetadata> PollOnceGetBigBook(
            string operationName,
            CallSettings callSettings = null) => Operation<Book, GetBigBookMetadata>.PollOnceFromName(
                GaxPreconditions.CheckNotNullOrEmpty(operationName, nameof(operationName)),
                GetBigBookOperationsClient,
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Operation<Empty, GetBigBookMetadata>> GetBigNothingAsync(
            BookName name,
            CallSettings callSettings = null) => GetBigNothingAsync(
                new GetBookRequest
                {
                    BookName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Operation<Empty, GetBigBookMetadata>> GetBigNothingAsync(
            BookName name,
            CancellationToken cancellationToken) => GetBigNothingAsync(
                name,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Operation<Empty, GetBigBookMetadata> GetBigNothing(
            BookName name,
            CallSettings callSettings = null) => GetBigNothing(
                new GetBookRequest
                {
                    BookName = GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<Operation<Empty, GetBigBookMetadata>> GetBigNothingAsync(
            GetBookRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Asynchronously poll an operation once, using an <c>operationName</c> from a previous invocation of <c>GetBigNothingAsync</c>.
        /// </summary>
        /// <param name="operationName">The name of a previously invoked operation. Must not be <c>null</c> or empty.</param>
        /// <param name="callSettings">If not null, applies overrides to this RPC call.</param>
        /// <returns>A task representing the result of polling the operation.</returns>
        public virtual Task<Operation<Empty, GetBigBookMetadata>> PollOnceGetBigNothingAsync(
            string operationName,
            CallSettings callSettings = null) => Operation<Empty, GetBigBookMetadata>.PollOnceFromNameAsync(
                GaxPreconditions.CheckNotNullOrEmpty(operationName, nameof(operationName)),
                GetBigNothingOperationsClient,
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Operation<Empty, GetBigBookMetadata> GetBigNothing(
            GetBookRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// The long-running operations client for <c>GetBigNothing</c>.
        /// </summary>
        public virtual OperationsClient GetBigNothingOperationsClient
        {
            get { throw new NotImplementedException(); }
        }

        /// <summary>
        /// Poll an operation once, using an <c>operationName</c> from a previous invocation of <c>GetBigNothing</c>.
        /// </summary>
        /// <param name="operationName">The name of a previously invoked operation. Must not be <c>null</c> or empty.</param>
        /// <param name="callSettings">If not null, applies overrides to this RPC call.</param>
        /// <returns>The result of polling the operation.</returns>
        public virtual Operation<Empty, GetBigBookMetadata> PollOnceGetBigNothing(
            string operationName,
            CallSettings callSettings = null) => Operation<Empty, GetBigBookMetadata>.PollOnceFromName(
                GaxPreconditions.CheckNotNullOrEmpty(operationName, nameof(operationName)),
                GetBigNothingOperationsClient,
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            CallSettings callSettings = null) => TestOptionalRequiredFlatteningParamsAsync(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            CancellationToken cancellationToken) => TestOptionalRequiredFlatteningParamsAsync(
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual TestOptionalRequiredFlatteningParamsResponse TestOptionalRequiredFlatteningParams(
            CallSettings callSettings = null) => TestOptionalRequiredFlatteningParams(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="requiredSingularInt32">
        ///
        /// </param>
        /// <param name="requiredSingularInt64">
        ///
        /// </param>
        /// <param name="requiredSingularFloat">
        ///
        /// </param>
        /// <param name="requiredSingularDouble">
        ///
        /// </param>
        /// <param name="requiredSingularBool">
        ///
        /// </param>
        /// <param name="requiredSingularEnum">
        ///
        /// </param>
        /// <param name="requiredSingularString">
        ///
        /// </param>
        /// <param name="requiredSingularBytes">
        ///
        /// </param>
        /// <param name="requiredSingularMessage">
        ///
        /// </param>
        /// <param name="requiredSingularResourceName">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredSingularFixed32">
        ///
        /// </param>
        /// <param name="requiredSingularFixed64">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloat">
        ///
        /// </param>
        /// <param name="requiredRepeatedDouble">
        ///
        /// </param>
        /// <param name="requiredRepeatedBool">
        ///
        /// </param>
        /// <param name="requiredRepeatedEnum">
        ///
        /// </param>
        /// <param name="requiredRepeatedString">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytes">
        ///
        /// </param>
        /// <param name="requiredRepeatedMessage">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceName">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed32">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed64">
        ///
        /// </param>
        /// <param name="requiredMap">
        ///
        /// </param>
        /// <param name="optionalSingularInt32">
        ///
        /// </param>
        /// <param name="optionalSingularInt64">
        ///
        /// </param>
        /// <param name="optionalSingularFloat">
        ///
        /// </param>
        /// <param name="optionalSingularDouble">
        ///
        /// </param>
        /// <param name="optionalSingularBool">
        ///
        /// </param>
        /// <param name="optionalSingularEnum">
        ///
        /// </param>
        /// <param name="optionalSingularString">
        ///
        /// </param>
        /// <param name="optionalSingularBytes">
        ///
        /// </param>
        /// <param name="optionalSingularMessage">
        ///
        /// </param>
        /// <param name="optionalSingularResourceName">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalSingularFixed32">
        ///
        /// </param>
        /// <param name="optionalSingularFixed64">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt32">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt64">
        ///
        /// </param>
        /// <param name="optionalRepeatedFloat">
        ///
        /// </param>
        /// <param name="optionalRepeatedDouble">
        ///
        /// </param>
        /// <param name="optionalRepeatedBool">
        ///
        /// </param>
        /// <param name="optionalRepeatedEnum">
        ///
        /// </param>
        /// <param name="optionalRepeatedString">
        ///
        /// </param>
        /// <param name="optionalRepeatedBytes">
        ///
        /// </param>
        /// <param name="optionalRepeatedMessage">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceName">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed32">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed64">
        ///
        /// </param>
        /// <param name="optionalMap">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            int requiredSingularInt32,
            long requiredSingularInt64,
            float requiredSingularFloat,
            double requiredSingularDouble,
            bool requiredSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum,
            string requiredSingularString,
            ByteString requiredSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage,
            BookName requiredSingularResourceName,
            BookNameOneof requiredSingularResourceNameOneof,
            int requiredSingularFixed32,
            long requiredSingularFixed64,
            IEnumerable<int> requiredRepeatedInt32,
            IEnumerable<long> requiredRepeatedInt64,
            IEnumerable<float> requiredRepeatedFloat,
            IEnumerable<double> requiredRepeatedDouble,
            IEnumerable<bool> requiredRepeatedBool,
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum,
            IEnumerable<string> requiredRepeatedString,
            IEnumerable<ByteString> requiredRepeatedBytes,
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage,
            IEnumerable<BookName> requiredRepeatedResourceName,
            IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof,
            IEnumerable<int> requiredRepeatedFixed32,
            IEnumerable<long> requiredRepeatedFixed64,
            IDictionary<int, string> requiredMap,
            int? optionalSingularInt32,
            long? optionalSingularInt64,
            float? optionalSingularFloat,
            double? optionalSingularDouble,
            bool? optionalSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum? optionalSingularEnum,
            string optionalSingularString,
            ByteString optionalSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage,
            BookName optionalSingularResourceName,
            BookNameOneof optionalSingularResourceNameOneof,
            int? optionalSingularFixed32,
            long? optionalSingularFixed64,
            IEnumerable<int> optionalRepeatedInt32,
            IEnumerable<long> optionalRepeatedInt64,
            IEnumerable<float> optionalRepeatedFloat,
            IEnumerable<double> optionalRepeatedDouble,
            IEnumerable<bool> optionalRepeatedBool,
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum,
            IEnumerable<string> optionalRepeatedString,
            IEnumerable<ByteString> optionalRepeatedBytes,
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage,
            IEnumerable<BookName> optionalRepeatedResourceName,
            IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof,
            IEnumerable<int> optionalRepeatedFixed32,
            IEnumerable<long> optionalRepeatedFixed64,
            IDictionary<int, string> optionalMap,
            CallSettings callSettings = null) => TestOptionalRequiredFlatteningParamsAsync(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                    RequiredSingularInt32 = requiredSingularInt32,
                    RequiredSingularInt64 = requiredSingularInt64,
                    RequiredSingularFloat = requiredSingularFloat,
                    RequiredSingularDouble = requiredSingularDouble,
                    RequiredSingularBool = requiredSingularBool,
                    RequiredSingularEnum = requiredSingularEnum,
                    RequiredSingularString = GaxPreconditions.CheckNotNullOrEmpty(requiredSingularString, nameof(requiredSingularString)),
                    RequiredSingularBytes = GaxPreconditions.CheckNotNull(requiredSingularBytes, nameof(requiredSingularBytes)),
                    RequiredSingularMessage = GaxPreconditions.CheckNotNull(requiredSingularMessage, nameof(requiredSingularMessage)),
                    RequiredSingularResourceNameAsBookName = GaxPreconditions.CheckNotNull(requiredSingularResourceName, nameof(requiredSingularResourceName)),
                    RequiredSingularResourceNameOneofAsBookNameOneof = GaxPreconditions.CheckNotNull(requiredSingularResourceNameOneof, nameof(requiredSingularResourceNameOneof)),
                    RequiredSingularFixed32 = requiredSingularFixed32,
                    RequiredSingularFixed64 = requiredSingularFixed64,
                    RequiredRepeatedInt32 = { GaxPreconditions.CheckNotNull(requiredRepeatedInt32, nameof(requiredRepeatedInt32)) },
                    RequiredRepeatedInt64 = { GaxPreconditions.CheckNotNull(requiredRepeatedInt64, nameof(requiredRepeatedInt64)) },
                    RequiredRepeatedFloat = { GaxPreconditions.CheckNotNull(requiredRepeatedFloat, nameof(requiredRepeatedFloat)) },
                    RequiredRepeatedDouble = { GaxPreconditions.CheckNotNull(requiredRepeatedDouble, nameof(requiredRepeatedDouble)) },
                    RequiredRepeatedBool = { GaxPreconditions.CheckNotNull(requiredRepeatedBool, nameof(requiredRepeatedBool)) },
                    RequiredRepeatedEnum = { GaxPreconditions.CheckNotNull(requiredRepeatedEnum, nameof(requiredRepeatedEnum)) },
                    RequiredRepeatedString = { GaxPreconditions.CheckNotNull(requiredRepeatedString, nameof(requiredRepeatedString)) },
                    RequiredRepeatedBytes = { GaxPreconditions.CheckNotNull(requiredRepeatedBytes, nameof(requiredRepeatedBytes)) },
                    RequiredRepeatedMessage = { GaxPreconditions.CheckNotNull(requiredRepeatedMessage, nameof(requiredRepeatedMessage)) },
                    RequiredRepeatedResourceNameAsBookNames = { GaxPreconditions.CheckNotNull(requiredRepeatedResourceName, nameof(requiredRepeatedResourceName)) },
                    RequiredRepeatedResourceNameOneofAsBookNameOneofs = { GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameOneof, nameof(requiredRepeatedResourceNameOneof)) },
                    RequiredRepeatedFixed32 = { GaxPreconditions.CheckNotNull(requiredRepeatedFixed32, nameof(requiredRepeatedFixed32)) },
                    RequiredRepeatedFixed64 = { GaxPreconditions.CheckNotNull(requiredRepeatedFixed64, nameof(requiredRepeatedFixed64)) },
                    RequiredMap = { GaxPreconditions.CheckNotNull(requiredMap, nameof(requiredMap)) },
                    OptionalSingularInt32 = optionalSingularInt32 ?? 0, // Optional
                    OptionalSingularInt64 = optionalSingularInt64 ?? 0L, // Optional
                    OptionalSingularFloat = optionalSingularFloat ?? 0.0f, // Optional
                    OptionalSingularDouble = optionalSingularDouble ?? 0.0, // Optional
                    OptionalSingularBool = optionalSingularBool ?? false, // Optional
                    OptionalSingularEnum = optionalSingularEnum ?? TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero, // Optional
                    OptionalSingularString = optionalSingularString ?? "", // Optional
                    OptionalSingularBytes = optionalSingularBytes ?? ByteString.Empty, // Optional
                    OptionalSingularMessage = optionalSingularMessage, // Optional
                    OptionalSingularResourceNameAsBookName = optionalSingularResourceName, // Optional
                    OptionalSingularResourceNameOneofAsBookNameOneof = optionalSingularResourceNameOneof, // Optional
                    OptionalSingularFixed32 = optionalSingularFixed32 ?? 0, // Optional
                    OptionalSingularFixed64 = optionalSingularFixed64 ?? 0L, // Optional
                    OptionalRepeatedInt32 = { optionalRepeatedInt32 ?? Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedInt64 = { optionalRepeatedInt64 ?? Enumerable.Empty<long>() }, // Optional
                    OptionalRepeatedFloat = { optionalRepeatedFloat ?? Enumerable.Empty<float>() }, // Optional
                    OptionalRepeatedDouble = { optionalRepeatedDouble ?? Enumerable.Empty<double>() }, // Optional
                    OptionalRepeatedBool = { optionalRepeatedBool ?? Enumerable.Empty<bool>() }, // Optional
                    OptionalRepeatedEnum = { optionalRepeatedEnum ?? Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>() }, // Optional
                    OptionalRepeatedString = { optionalRepeatedString ?? Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedBytes = { optionalRepeatedBytes ?? Enumerable.Empty<ByteString>() }, // Optional
                    OptionalRepeatedMessage = { optionalRepeatedMessage ?? Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>() }, // Optional
                    OptionalRepeatedResourceNameAsBookNames = { optionalRepeatedResourceName ?? Enumerable.Empty<BookName>() }, // Optional
                    OptionalRepeatedResourceNameOneofAsBookNameOneofs = { optionalRepeatedResourceNameOneof ?? Enumerable.Empty<BookNameOneof>() }, // Optional
                    OptionalRepeatedFixed32 = { optionalRepeatedFixed32 ?? Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedFixed64 = { optionalRepeatedFixed64 ?? Enumerable.Empty<long>() }, // Optional
                    OptionalMap = { optionalMap ?? EmptyDictionary<int, string>.Instance }, // Optional
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="requiredSingularInt32">
        ///
        /// </param>
        /// <param name="requiredSingularInt64">
        ///
        /// </param>
        /// <param name="requiredSingularFloat">
        ///
        /// </param>
        /// <param name="requiredSingularDouble">
        ///
        /// </param>
        /// <param name="requiredSingularBool">
        ///
        /// </param>
        /// <param name="requiredSingularEnum">
        ///
        /// </param>
        /// <param name="requiredSingularString">
        ///
        /// </param>
        /// <param name="requiredSingularBytes">
        ///
        /// </param>
        /// <param name="requiredSingularMessage">
        ///
        /// </param>
        /// <param name="requiredSingularResourceName">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredSingularFixed32">
        ///
        /// </param>
        /// <param name="requiredSingularFixed64">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloat">
        ///
        /// </param>
        /// <param name="requiredRepeatedDouble">
        ///
        /// </param>
        /// <param name="requiredRepeatedBool">
        ///
        /// </param>
        /// <param name="requiredRepeatedEnum">
        ///
        /// </param>
        /// <param name="requiredRepeatedString">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytes">
        ///
        /// </param>
        /// <param name="requiredRepeatedMessage">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceName">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed32">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed64">
        ///
        /// </param>
        /// <param name="requiredMap">
        ///
        /// </param>
        /// <param name="optionalSingularInt32">
        ///
        /// </param>
        /// <param name="optionalSingularInt64">
        ///
        /// </param>
        /// <param name="optionalSingularFloat">
        ///
        /// </param>
        /// <param name="optionalSingularDouble">
        ///
        /// </param>
        /// <param name="optionalSingularBool">
        ///
        /// </param>
        /// <param name="optionalSingularEnum">
        ///
        /// </param>
        /// <param name="optionalSingularString">
        ///
        /// </param>
        /// <param name="optionalSingularBytes">
        ///
        /// </param>
        /// <param name="optionalSingularMessage">
        ///
        /// </param>
        /// <param name="optionalSingularResourceName">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalSingularFixed32">
        ///
        /// </param>
        /// <param name="optionalSingularFixed64">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt32">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt64">
        ///
        /// </param>
        /// <param name="optionalRepeatedFloat">
        ///
        /// </param>
        /// <param name="optionalRepeatedDouble">
        ///
        /// </param>
        /// <param name="optionalRepeatedBool">
        ///
        /// </param>
        /// <param name="optionalRepeatedEnum">
        ///
        /// </param>
        /// <param name="optionalRepeatedString">
        ///
        /// </param>
        /// <param name="optionalRepeatedBytes">
        ///
        /// </param>
        /// <param name="optionalRepeatedMessage">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceName">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed32">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed64">
        ///
        /// </param>
        /// <param name="optionalMap">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            int requiredSingularInt32,
            long requiredSingularInt64,
            float requiredSingularFloat,
            double requiredSingularDouble,
            bool requiredSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum,
            string requiredSingularString,
            ByteString requiredSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage,
            BookName requiredSingularResourceName,
            BookNameOneof requiredSingularResourceNameOneof,
            int requiredSingularFixed32,
            long requiredSingularFixed64,
            IEnumerable<int> requiredRepeatedInt32,
            IEnumerable<long> requiredRepeatedInt64,
            IEnumerable<float> requiredRepeatedFloat,
            IEnumerable<double> requiredRepeatedDouble,
            IEnumerable<bool> requiredRepeatedBool,
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum,
            IEnumerable<string> requiredRepeatedString,
            IEnumerable<ByteString> requiredRepeatedBytes,
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage,
            IEnumerable<BookName> requiredRepeatedResourceName,
            IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof,
            IEnumerable<int> requiredRepeatedFixed32,
            IEnumerable<long> requiredRepeatedFixed64,
            IDictionary<int, string> requiredMap,
            int? optionalSingularInt32,
            long? optionalSingularInt64,
            float? optionalSingularFloat,
            double? optionalSingularDouble,
            bool? optionalSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum? optionalSingularEnum,
            string optionalSingularString,
            ByteString optionalSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage,
            BookName optionalSingularResourceName,
            BookNameOneof optionalSingularResourceNameOneof,
            int? optionalSingularFixed32,
            long? optionalSingularFixed64,
            IEnumerable<int> optionalRepeatedInt32,
            IEnumerable<long> optionalRepeatedInt64,
            IEnumerable<float> optionalRepeatedFloat,
            IEnumerable<double> optionalRepeatedDouble,
            IEnumerable<bool> optionalRepeatedBool,
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum,
            IEnumerable<string> optionalRepeatedString,
            IEnumerable<ByteString> optionalRepeatedBytes,
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage,
            IEnumerable<BookName> optionalRepeatedResourceName,
            IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof,
            IEnumerable<int> optionalRepeatedFixed32,
            IEnumerable<long> optionalRepeatedFixed64,
            IDictionary<int, string> optionalMap,
            CancellationToken cancellationToken) => TestOptionalRequiredFlatteningParamsAsync(
                requiredSingularInt32,
                requiredSingularInt64,
                requiredSingularFloat,
                requiredSingularDouble,
                requiredSingularBool,
                requiredSingularEnum,
                requiredSingularString,
                requiredSingularBytes,
                requiredSingularMessage,
                requiredSingularResourceName,
                requiredSingularResourceNameOneof,
                requiredSingularFixed32,
                requiredSingularFixed64,
                requiredRepeatedInt32,
                requiredRepeatedInt64,
                requiredRepeatedFloat,
                requiredRepeatedDouble,
                requiredRepeatedBool,
                requiredRepeatedEnum,
                requiredRepeatedString,
                requiredRepeatedBytes,
                requiredRepeatedMessage,
                requiredRepeatedResourceName,
                requiredRepeatedResourceNameOneof,
                requiredRepeatedFixed32,
                requiredRepeatedFixed64,
                requiredMap,
                optionalSingularInt32,
                optionalSingularInt64,
                optionalSingularFloat,
                optionalSingularDouble,
                optionalSingularBool,
                optionalSingularEnum,
                optionalSingularString,
                optionalSingularBytes,
                optionalSingularMessage,
                optionalSingularResourceName,
                optionalSingularResourceNameOneof,
                optionalSingularFixed32,
                optionalSingularFixed64,
                optionalRepeatedInt32,
                optionalRepeatedInt64,
                optionalRepeatedFloat,
                optionalRepeatedDouble,
                optionalRepeatedBool,
                optionalRepeatedEnum,
                optionalRepeatedString,
                optionalRepeatedBytes,
                optionalRepeatedMessage,
                optionalRepeatedResourceName,
                optionalRepeatedResourceNameOneof,
                optionalRepeatedFixed32,
                optionalRepeatedFixed64,
                optionalMap,
                CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="requiredSingularInt32">
        ///
        /// </param>
        /// <param name="requiredSingularInt64">
        ///
        /// </param>
        /// <param name="requiredSingularFloat">
        ///
        /// </param>
        /// <param name="requiredSingularDouble">
        ///
        /// </param>
        /// <param name="requiredSingularBool">
        ///
        /// </param>
        /// <param name="requiredSingularEnum">
        ///
        /// </param>
        /// <param name="requiredSingularString">
        ///
        /// </param>
        /// <param name="requiredSingularBytes">
        ///
        /// </param>
        /// <param name="requiredSingularMessage">
        ///
        /// </param>
        /// <param name="requiredSingularResourceName">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredSingularFixed32">
        ///
        /// </param>
        /// <param name="requiredSingularFixed64">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloat">
        ///
        /// </param>
        /// <param name="requiredRepeatedDouble">
        ///
        /// </param>
        /// <param name="requiredRepeatedBool">
        ///
        /// </param>
        /// <param name="requiredRepeatedEnum">
        ///
        /// </param>
        /// <param name="requiredRepeatedString">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytes">
        ///
        /// </param>
        /// <param name="requiredRepeatedMessage">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceName">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed32">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed64">
        ///
        /// </param>
        /// <param name="requiredMap">
        ///
        /// </param>
        /// <param name="optionalSingularInt32">
        ///
        /// </param>
        /// <param name="optionalSingularInt64">
        ///
        /// </param>
        /// <param name="optionalSingularFloat">
        ///
        /// </param>
        /// <param name="optionalSingularDouble">
        ///
        /// </param>
        /// <param name="optionalSingularBool">
        ///
        /// </param>
        /// <param name="optionalSingularEnum">
        ///
        /// </param>
        /// <param name="optionalSingularString">
        ///
        /// </param>
        /// <param name="optionalSingularBytes">
        ///
        /// </param>
        /// <param name="optionalSingularMessage">
        ///
        /// </param>
        /// <param name="optionalSingularResourceName">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalSingularFixed32">
        ///
        /// </param>
        /// <param name="optionalSingularFixed64">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt32">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt64">
        ///
        /// </param>
        /// <param name="optionalRepeatedFloat">
        ///
        /// </param>
        /// <param name="optionalRepeatedDouble">
        ///
        /// </param>
        /// <param name="optionalRepeatedBool">
        ///
        /// </param>
        /// <param name="optionalRepeatedEnum">
        ///
        /// </param>
        /// <param name="optionalRepeatedString">
        ///
        /// </param>
        /// <param name="optionalRepeatedBytes">
        ///
        /// </param>
        /// <param name="optionalRepeatedMessage">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceName">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed32">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed64">
        ///
        /// </param>
        /// <param name="optionalMap">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual TestOptionalRequiredFlatteningParamsResponse TestOptionalRequiredFlatteningParams(
            int requiredSingularInt32,
            long requiredSingularInt64,
            float requiredSingularFloat,
            double requiredSingularDouble,
            bool requiredSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum,
            string requiredSingularString,
            ByteString requiredSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage,
            BookName requiredSingularResourceName,
            BookNameOneof requiredSingularResourceNameOneof,
            int requiredSingularFixed32,
            long requiredSingularFixed64,
            IEnumerable<int> requiredRepeatedInt32,
            IEnumerable<long> requiredRepeatedInt64,
            IEnumerable<float> requiredRepeatedFloat,
            IEnumerable<double> requiredRepeatedDouble,
            IEnumerable<bool> requiredRepeatedBool,
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum,
            IEnumerable<string> requiredRepeatedString,
            IEnumerable<ByteString> requiredRepeatedBytes,
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage,
            IEnumerable<BookName> requiredRepeatedResourceName,
            IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof,
            IEnumerable<int> requiredRepeatedFixed32,
            IEnumerable<long> requiredRepeatedFixed64,
            IDictionary<int, string> requiredMap,
            int? optionalSingularInt32,
            long? optionalSingularInt64,
            float? optionalSingularFloat,
            double? optionalSingularDouble,
            bool? optionalSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum? optionalSingularEnum,
            string optionalSingularString,
            ByteString optionalSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage,
            BookName optionalSingularResourceName,
            BookNameOneof optionalSingularResourceNameOneof,
            int? optionalSingularFixed32,
            long? optionalSingularFixed64,
            IEnumerable<int> optionalRepeatedInt32,
            IEnumerable<long> optionalRepeatedInt64,
            IEnumerable<float> optionalRepeatedFloat,
            IEnumerable<double> optionalRepeatedDouble,
            IEnumerable<bool> optionalRepeatedBool,
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum,
            IEnumerable<string> optionalRepeatedString,
            IEnumerable<ByteString> optionalRepeatedBytes,
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage,
            IEnumerable<BookName> optionalRepeatedResourceName,
            IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof,
            IEnumerable<int> optionalRepeatedFixed32,
            IEnumerable<long> optionalRepeatedFixed64,
            IDictionary<int, string> optionalMap,
            CallSettings callSettings = null) => TestOptionalRequiredFlatteningParams(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                    RequiredSingularInt32 = requiredSingularInt32,
                    RequiredSingularInt64 = requiredSingularInt64,
                    RequiredSingularFloat = requiredSingularFloat,
                    RequiredSingularDouble = requiredSingularDouble,
                    RequiredSingularBool = requiredSingularBool,
                    RequiredSingularEnum = requiredSingularEnum,
                    RequiredSingularString = GaxPreconditions.CheckNotNullOrEmpty(requiredSingularString, nameof(requiredSingularString)),
                    RequiredSingularBytes = GaxPreconditions.CheckNotNull(requiredSingularBytes, nameof(requiredSingularBytes)),
                    RequiredSingularMessage = GaxPreconditions.CheckNotNull(requiredSingularMessage, nameof(requiredSingularMessage)),
                    RequiredSingularResourceNameAsBookName = GaxPreconditions.CheckNotNull(requiredSingularResourceName, nameof(requiredSingularResourceName)),
                    RequiredSingularResourceNameOneofAsBookNameOneof = GaxPreconditions.CheckNotNull(requiredSingularResourceNameOneof, nameof(requiredSingularResourceNameOneof)),
                    RequiredSingularFixed32 = requiredSingularFixed32,
                    RequiredSingularFixed64 = requiredSingularFixed64,
                    RequiredRepeatedInt32 = { GaxPreconditions.CheckNotNull(requiredRepeatedInt32, nameof(requiredRepeatedInt32)) },
                    RequiredRepeatedInt64 = { GaxPreconditions.CheckNotNull(requiredRepeatedInt64, nameof(requiredRepeatedInt64)) },
                    RequiredRepeatedFloat = { GaxPreconditions.CheckNotNull(requiredRepeatedFloat, nameof(requiredRepeatedFloat)) },
                    RequiredRepeatedDouble = { GaxPreconditions.CheckNotNull(requiredRepeatedDouble, nameof(requiredRepeatedDouble)) },
                    RequiredRepeatedBool = { GaxPreconditions.CheckNotNull(requiredRepeatedBool, nameof(requiredRepeatedBool)) },
                    RequiredRepeatedEnum = { GaxPreconditions.CheckNotNull(requiredRepeatedEnum, nameof(requiredRepeatedEnum)) },
                    RequiredRepeatedString = { GaxPreconditions.CheckNotNull(requiredRepeatedString, nameof(requiredRepeatedString)) },
                    RequiredRepeatedBytes = { GaxPreconditions.CheckNotNull(requiredRepeatedBytes, nameof(requiredRepeatedBytes)) },
                    RequiredRepeatedMessage = { GaxPreconditions.CheckNotNull(requiredRepeatedMessage, nameof(requiredRepeatedMessage)) },
                    RequiredRepeatedResourceNameAsBookNames = { GaxPreconditions.CheckNotNull(requiredRepeatedResourceName, nameof(requiredRepeatedResourceName)) },
                    RequiredRepeatedResourceNameOneofAsBookNameOneofs = { GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameOneof, nameof(requiredRepeatedResourceNameOneof)) },
                    RequiredRepeatedFixed32 = { GaxPreconditions.CheckNotNull(requiredRepeatedFixed32, nameof(requiredRepeatedFixed32)) },
                    RequiredRepeatedFixed64 = { GaxPreconditions.CheckNotNull(requiredRepeatedFixed64, nameof(requiredRepeatedFixed64)) },
                    RequiredMap = { GaxPreconditions.CheckNotNull(requiredMap, nameof(requiredMap)) },
                    OptionalSingularInt32 = optionalSingularInt32 ?? 0, // Optional
                    OptionalSingularInt64 = optionalSingularInt64 ?? 0L, // Optional
                    OptionalSingularFloat = optionalSingularFloat ?? 0.0f, // Optional
                    OptionalSingularDouble = optionalSingularDouble ?? 0.0, // Optional
                    OptionalSingularBool = optionalSingularBool ?? false, // Optional
                    OptionalSingularEnum = optionalSingularEnum ?? TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero, // Optional
                    OptionalSingularString = optionalSingularString ?? "", // Optional
                    OptionalSingularBytes = optionalSingularBytes ?? ByteString.Empty, // Optional
                    OptionalSingularMessage = optionalSingularMessage, // Optional
                    OptionalSingularResourceNameAsBookName = optionalSingularResourceName, // Optional
                    OptionalSingularResourceNameOneofAsBookNameOneof = optionalSingularResourceNameOneof, // Optional
                    OptionalSingularFixed32 = optionalSingularFixed32 ?? 0, // Optional
                    OptionalSingularFixed64 = optionalSingularFixed64 ?? 0L, // Optional
                    OptionalRepeatedInt32 = { optionalRepeatedInt32 ?? Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedInt64 = { optionalRepeatedInt64 ?? Enumerable.Empty<long>() }, // Optional
                    OptionalRepeatedFloat = { optionalRepeatedFloat ?? Enumerable.Empty<float>() }, // Optional
                    OptionalRepeatedDouble = { optionalRepeatedDouble ?? Enumerable.Empty<double>() }, // Optional
                    OptionalRepeatedBool = { optionalRepeatedBool ?? Enumerable.Empty<bool>() }, // Optional
                    OptionalRepeatedEnum = { optionalRepeatedEnum ?? Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>() }, // Optional
                    OptionalRepeatedString = { optionalRepeatedString ?? Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedBytes = { optionalRepeatedBytes ?? Enumerable.Empty<ByteString>() }, // Optional
                    OptionalRepeatedMessage = { optionalRepeatedMessage ?? Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>() }, // Optional
                    OptionalRepeatedResourceNameAsBookNames = { optionalRepeatedResourceName ?? Enumerable.Empty<BookName>() }, // Optional
                    OptionalRepeatedResourceNameOneofAsBookNameOneofs = { optionalRepeatedResourceNameOneof ?? Enumerable.Empty<BookNameOneof>() }, // Optional
                    OptionalRepeatedFixed32 = { optionalRepeatedFixed32 ?? Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedFixed64 = { optionalRepeatedFixed64 ?? Enumerable.Empty<long>() }, // Optional
                    OptionalMap = { optionalMap ?? EmptyDictionary<int, string>.Instance }, // Optional
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            TestOptionalRequiredFlatteningParamsRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual TestOptionalRequiredFlatteningParamsResponse TestOptionalRequiredFlatteningParams(
            TestOptionalRequiredFlatteningParamsRequest request,
            CallSettings callSettings = null)
        {
            throw new NotImplementedException();
        }

    }

    /// <summary>
    /// LibraryService client wrapper implementation, for convenient use.
    /// </summary>
    public sealed partial class LibraryServiceClientImpl : LibraryServiceClient
    {
        private readonly ApiCall<CreateShelfRequest, Shelf> _callCreateShelf;
        private readonly ApiCall<GetShelfRequest, Shelf> _callGetShelf;
        private readonly ApiCall<ListShelvesRequest, ListShelvesResponse> _callListShelves;
        private readonly ApiCall<DeleteShelfRequest, Empty> _callDeleteShelf;
        private readonly ApiCall<MergeShelvesRequest, Shelf> _callMergeShelves;
        private readonly ApiCall<CreateBookRequest, Book> _callCreateBook;
        private readonly ApiCall<PublishSeriesRequest, PublishSeriesResponse> _callPublishSeries;
        private readonly ApiCall<GetBookRequest, Book> _callGetBook;
        private readonly ApiCall<ListBooksRequest, ListBooksResponse> _callListBooks;
        private readonly ApiCall<DeleteBookRequest, Empty> _callDeleteBook;
        private readonly ApiCall<UpdateBookRequest, Book> _callUpdateBook;
        private readonly ApiCall<MoveBookRequest, Book> _callMoveBook;
        private readonly ApiCall<ListStringsRequest, ListStringsResponse> _callListStrings;
        private readonly ApiCall<AddCommentsRequest, Empty> _callAddComments;
        private readonly ApiCall<GetBookFromArchiveRequest, BookFromArchive> _callGetBookFromArchive;
        private readonly ApiCall<GetBookFromAnywhereRequest, BookFromAnywhere> _callGetBookFromAnywhere;
        private readonly ApiCall<GetBookFromAbsolutelyAnywhereRequest, BookFromAnywhere> _callGetBookFromAbsolutelyAnywhere;
        private readonly ApiCall<UpdateBookIndexRequest, Empty> _callUpdateBookIndex;
        private readonly ApiServerStreamingCall<StreamShelvesRequest, StreamShelvesResponse> _callStreamShelves;
        private readonly ApiServerStreamingCall<StreamBooksRequest, Book> _callStreamBooks;
        private readonly ApiBidirectionalStreamingCall<DiscussBookRequest, Comment> _callDiscussBook;
        private readonly ApiCall<FindRelatedBooksRequest, FindRelatedBooksResponse> _callFindRelatedBooks;
        private readonly ApiCall<AddTagRequest, AddTagResponse> _callAddTag;
        private readonly ApiCall<AddLabelRequest, AddLabelResponse> _callAddLabel;
        private readonly ApiCall<GetBookRequest, Operation> _callGetBigBook;
        private readonly ApiCall<GetBookRequest, Operation> _callGetBigNothing;
        private readonly ApiCall<TestOptionalRequiredFlatteningParamsRequest, TestOptionalRequiredFlatteningParamsResponse> _callTestOptionalRequiredFlatteningParams;

        /// <summary>
        /// Constructs a client wrapper for the LibraryService service, with the specified gRPC client and settings.
        /// </summary>
        /// <param name="grpcClient">The underlying gRPC client.</param>
        /// <param name="settings">The base <see cref="LibraryServiceSettings"/> used within this client </param>
        public LibraryServiceClientImpl(LibraryService.LibraryServiceClient grpcClient, LibraryServiceSettings settings)
        {
            GrpcClient = grpcClient;
            LibraryServiceSettings effectiveSettings = settings ?? LibraryServiceSettings.GetDefault();
            ClientHelper clientHelper = new ClientHelper(effectiveSettings);
            Labeler.LabelerClient grpcLabelerClient = grpcClient.CreateLabelerClient();
            GetBigBookOperationsClient = new OperationsClientImpl(
                grpcClient.CreateOperationsClient(), effectiveSettings.GetBigBookOperationsSettings);
            GetBigNothingOperationsClient = new OperationsClientImpl(
                grpcClient.CreateOperationsClient(), effectiveSettings.GetBigNothingOperationsSettings);
            _callCreateShelf = clientHelper.BuildApiCall<CreateShelfRequest, Shelf>(
                GrpcClient.CreateShelfAsync, GrpcClient.CreateShelf, effectiveSettings.CreateShelfSettings);
            _callGetShelf = clientHelper.BuildApiCall<GetShelfRequest, Shelf>(
                GrpcClient.GetShelfAsync, GrpcClient.GetShelf, effectiveSettings.GetShelfSettings);
            _callListShelves = clientHelper.BuildApiCall<ListShelvesRequest, ListShelvesResponse>(
                GrpcClient.ListShelvesAsync, GrpcClient.ListShelves, effectiveSettings.ListShelvesSettings);
            _callDeleteShelf = clientHelper.BuildApiCall<DeleteShelfRequest, Empty>(
                GrpcClient.DeleteShelfAsync, GrpcClient.DeleteShelf, effectiveSettings.DeleteShelfSettings);
            _callMergeShelves = clientHelper.BuildApiCall<MergeShelvesRequest, Shelf>(
                GrpcClient.MergeShelvesAsync, GrpcClient.MergeShelves, effectiveSettings.MergeShelvesSettings);
            _callCreateBook = clientHelper.BuildApiCall<CreateBookRequest, Book>(
                GrpcClient.CreateBookAsync, GrpcClient.CreateBook, effectiveSettings.CreateBookSettings)
                .WithCallSettingsOverlay(request => CallSettings.FromHeader("x-goog-request-params", $"name={request.Name}&book.read={request.Book.Read}"));
            _callPublishSeries = clientHelper.BuildApiCall<PublishSeriesRequest, PublishSeriesResponse>(
                GrpcClient.PublishSeriesAsync, GrpcClient.PublishSeries, effectiveSettings.PublishSeriesSettings);
            _callGetBook = clientHelper.BuildApiCall<GetBookRequest, Book>(
                GrpcClient.GetBookAsync, GrpcClient.GetBook, effectiveSettings.GetBookSettings);
            _callListBooks = clientHelper.BuildApiCall<ListBooksRequest, ListBooksResponse>(
                GrpcClient.ListBooksAsync, GrpcClient.ListBooks, effectiveSettings.ListBooksSettings);
            _callDeleteBook = clientHelper.BuildApiCall<DeleteBookRequest, Empty>(
                GrpcClient.DeleteBookAsync, GrpcClient.DeleteBook, effectiveSettings.DeleteBookSettings);
            _callUpdateBook = clientHelper.BuildApiCall<UpdateBookRequest, Book>(
                GrpcClient.UpdateBookAsync, GrpcClient.UpdateBook, effectiveSettings.UpdateBookSettings);
            _callMoveBook = clientHelper.BuildApiCall<MoveBookRequest, Book>(
                GrpcClient.MoveBookAsync, GrpcClient.MoveBook, effectiveSettings.MoveBookSettings);
            _callListStrings = clientHelper.BuildApiCall<ListStringsRequest, ListStringsResponse>(
                GrpcClient.ListStringsAsync, GrpcClient.ListStrings, effectiveSettings.ListStringsSettings);
            _callAddComments = clientHelper.BuildApiCall<AddCommentsRequest, Empty>(
                GrpcClient.AddCommentsAsync, GrpcClient.AddComments, effectiveSettings.AddCommentsSettings);
            _callGetBookFromArchive = clientHelper.BuildApiCall<GetBookFromArchiveRequest, BookFromArchive>(
                GrpcClient.GetBookFromArchiveAsync, GrpcClient.GetBookFromArchive, effectiveSettings.GetBookFromArchiveSettings);
            _callGetBookFromAnywhere = clientHelper.BuildApiCall<GetBookFromAnywhereRequest, BookFromAnywhere>(
                GrpcClient.GetBookFromAnywhereAsync, GrpcClient.GetBookFromAnywhere, effectiveSettings.GetBookFromAnywhereSettings);
            _callGetBookFromAbsolutelyAnywhere = clientHelper.BuildApiCall<GetBookFromAbsolutelyAnywhereRequest, BookFromAnywhere>(
                GrpcClient.GetBookFromAbsolutelyAnywhereAsync, GrpcClient.GetBookFromAbsolutelyAnywhere, effectiveSettings.GetBookFromAbsolutelyAnywhereSettings);
            _callUpdateBookIndex = clientHelper.BuildApiCall<UpdateBookIndexRequest, Empty>(
                GrpcClient.UpdateBookIndexAsync, GrpcClient.UpdateBookIndex, effectiveSettings.UpdateBookIndexSettings);
            _callStreamShelves = clientHelper.BuildApiCall<StreamShelvesRequest, StreamShelvesResponse>(
                GrpcClient.StreamShelves, effectiveSettings.StreamShelvesSettings);
            _callStreamBooks = clientHelper.BuildApiCall<StreamBooksRequest, Book>(
                GrpcClient.StreamBooks, effectiveSettings.StreamBooksSettings);
            _callDiscussBook = clientHelper.BuildApiCall<DiscussBookRequest, Comment>(
                GrpcClient.DiscussBook, effectiveSettings.DiscussBookSettings, effectiveSettings.DiscussBookStreamingSettings);
            _callFindRelatedBooks = clientHelper.BuildApiCall<FindRelatedBooksRequest, FindRelatedBooksResponse>(
                GrpcClient.FindRelatedBooksAsync, GrpcClient.FindRelatedBooks, effectiveSettings.FindRelatedBooksSettings);
            _callAddTag = clientHelper.BuildApiCall<AddTagRequest, AddTagResponse>(
                GrpcClient.AddTagAsync, GrpcClient.AddTag, effectiveSettings.AddTagSettings);
            _callAddLabel = clientHelper.BuildApiCall<AddLabelRequest, AddLabelResponse>(
                grpcLabelerClient.AddLabelAsync, grpcLabelerClient.AddLabel, effectiveSettings.AddLabelSettings);
            _callGetBigBook = clientHelper.BuildApiCall<GetBookRequest, Operation>(
                GrpcClient.GetBigBookAsync, GrpcClient.GetBigBook, effectiveSettings.GetBigBookSettings);
            _callGetBigNothing = clientHelper.BuildApiCall<GetBookRequest, Operation>(
                GrpcClient.GetBigNothingAsync, GrpcClient.GetBigNothing, effectiveSettings.GetBigNothingSettings);
            _callTestOptionalRequiredFlatteningParams = clientHelper.BuildApiCall<TestOptionalRequiredFlatteningParamsRequest, TestOptionalRequiredFlatteningParamsResponse>(
                GrpcClient.TestOptionalRequiredFlatteningParamsAsync, GrpcClient.TestOptionalRequiredFlatteningParams, effectiveSettings.TestOptionalRequiredFlatteningParamsSettings);
            OnConstruction(grpcClient, effectiveSettings, clientHelper);
        }

        partial void OnConstruction(LibraryService.LibraryServiceClient grpcClient, LibraryServiceSettings effectiveSettings, ClientHelper clientHelper);

        /// <summary>
        /// The underlying gRPC LibraryService client.
        /// </summary>
        public override LibraryService.LibraryServiceClient GrpcClient { get; }

        // Partial modifier methods contain '_' to ensure no name conflicts with RPC methods.
        partial void Modify_CreateShelfRequest(ref CreateShelfRequest request, ref CallSettings settings);
        partial void Modify_GetShelfRequest(ref GetShelfRequest request, ref CallSettings settings);
        partial void Modify_ListShelvesRequest(ref ListShelvesRequest request, ref CallSettings settings);
        partial void Modify_DeleteShelfRequest(ref DeleteShelfRequest request, ref CallSettings settings);
        partial void Modify_MergeShelvesRequest(ref MergeShelvesRequest request, ref CallSettings settings);
        partial void Modify_CreateBookRequest(ref CreateBookRequest request, ref CallSettings settings);
        partial void Modify_PublishSeriesRequest(ref PublishSeriesRequest request, ref CallSettings settings);
        partial void Modify_GetBookRequest(ref GetBookRequest request, ref CallSettings settings);
        partial void Modify_ListBooksRequest(ref ListBooksRequest request, ref CallSettings settings);
        partial void Modify_DeleteBookRequest(ref DeleteBookRequest request, ref CallSettings settings);
        partial void Modify_UpdateBookRequest(ref UpdateBookRequest request, ref CallSettings settings);
        partial void Modify_MoveBookRequest(ref MoveBookRequest request, ref CallSettings settings);
        partial void Modify_ListStringsRequest(ref ListStringsRequest request, ref CallSettings settings);
        partial void Modify_AddCommentsRequest(ref AddCommentsRequest request, ref CallSettings settings);
        partial void Modify_GetBookFromArchiveRequest(ref GetBookFromArchiveRequest request, ref CallSettings settings);
        partial void Modify_GetBookFromAnywhereRequest(ref GetBookFromAnywhereRequest request, ref CallSettings settings);
        partial void Modify_GetBookFromAbsolutelyAnywhereRequest(ref GetBookFromAbsolutelyAnywhereRequest request, ref CallSettings settings);
        partial void Modify_UpdateBookIndexRequest(ref UpdateBookIndexRequest request, ref CallSettings settings);
        partial void Modify_StreamShelvesRequest(ref StreamShelvesRequest request, ref CallSettings settings);
        partial void Modify_StreamBooksRequest(ref StreamBooksRequest request, ref CallSettings settings);
        partial void Modify_DiscussBookRequestCallSettings(ref CallSettings settings);
        partial void Modify_DiscussBookRequestRequest(ref DiscussBookRequest request);
        partial void Modify_FindRelatedBooksRequest(ref FindRelatedBooksRequest request, ref CallSettings settings);
        partial void Modify_AddTagRequest(ref AddTagRequest request, ref CallSettings settings);
        partial void Modify_AddLabelRequest(ref AddLabelRequest request, ref CallSettings settings);
        partial void Modify_TestOptionalRequiredFlatteningParamsRequest(ref TestOptionalRequiredFlatteningParamsRequest request, ref CallSettings settings);

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override Task<Shelf> CreateShelfAsync(
            CreateShelfRequest request,
            CallSettings callSettings = null)
        {
            Modify_CreateShelfRequest(ref request, ref callSettings);
            return _callCreateShelf.Async(request, callSettings);
        }

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Shelf CreateShelf(
            CreateShelfRequest request,
            CallSettings callSettings = null)
        {
            Modify_CreateShelfRequest(ref request, ref callSettings);
            return _callCreateShelf.Sync(request, callSettings);
        }

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override Task<Shelf> GetShelfAsync(
            GetShelfRequest request,
            CallSettings callSettings = null)
        {
            Modify_GetShelfRequest(ref request, ref callSettings);
            return _callGetShelf.Async(request, callSettings);
        }

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Shelf GetShelf(
            GetShelfRequest request,
            CallSettings callSettings = null)
        {
            Modify_GetShelfRequest(ref request, ref callSettings);
            return _callGetShelf.Sync(request, callSettings);
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public override PagedAsyncEnumerable<ListShelvesResponse, Shelf> ListShelvesAsync(
            ListShelvesRequest request,
            CallSettings callSettings = null)
        {
            Modify_ListShelvesRequest(ref request, ref callSettings);
            return new GrpcPagedAsyncEnumerable<ListShelvesRequest, ListShelvesResponse, Shelf>(_callListShelves, request, callSettings);
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public override PagedEnumerable<ListShelvesResponse, Shelf> ListShelves(
            ListShelvesRequest request,
            CallSettings callSettings = null)
        {
            Modify_ListShelvesRequest(ref request, ref callSettings);
            return new GrpcPagedEnumerable<ListShelvesRequest, ListShelvesResponse, Shelf>(_callListShelves, request, callSettings);
        }

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override Task DeleteShelfAsync(
            DeleteShelfRequest request,
            CallSettings callSettings = null)
        {
            Modify_DeleteShelfRequest(ref request, ref callSettings);
            return _callDeleteShelf.Async(request, callSettings);
        }

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override void DeleteShelf(
            DeleteShelfRequest request,
            CallSettings callSettings = null)
        {
            Modify_DeleteShelfRequest(ref request, ref callSettings);
            _callDeleteShelf.Sync(request, callSettings);
        }

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override Task<Shelf> MergeShelvesAsync(
            MergeShelvesRequest request,
            CallSettings callSettings = null)
        {
            Modify_MergeShelvesRequest(ref request, ref callSettings);
            return _callMergeShelves.Async(request, callSettings);
        }

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Shelf MergeShelves(
            MergeShelvesRequest request,
            CallSettings callSettings = null)
        {
            Modify_MergeShelvesRequest(ref request, ref callSettings);
            return _callMergeShelves.Sync(request, callSettings);
        }

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override Task<Book> CreateBookAsync(
            CreateBookRequest request,
            CallSettings callSettings = null)
        {
            Modify_CreateBookRequest(ref request, ref callSettings);
            return _callCreateBook.Async(request, callSettings);
        }

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Book CreateBook(
            CreateBookRequest request,
            CallSettings callSettings = null)
        {
            Modify_CreateBookRequest(ref request, ref callSettings);
            return _callCreateBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override Task<PublishSeriesResponse> PublishSeriesAsync(
            PublishSeriesRequest request,
            CallSettings callSettings = null)
        {
            Modify_PublishSeriesRequest(ref request, ref callSettings);
            return _callPublishSeries.Async(request, callSettings);
        }

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override PublishSeriesResponse PublishSeries(
            PublishSeriesRequest request,
            CallSettings callSettings = null)
        {
            Modify_PublishSeriesRequest(ref request, ref callSettings);
            return _callPublishSeries.Sync(request, callSettings);
        }

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override Task<Book> GetBookAsync(
            GetBookRequest request,
            CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return _callGetBook.Async(request, callSettings);
        }

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Book GetBook(
            GetBookRequest request,
            CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return _callGetBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Book"/> resources.
        /// </returns>
        public override PagedAsyncEnumerable<ListBooksResponse, Book> ListBooksAsync(
            ListBooksRequest request,
            CallSettings callSettings = null)
        {
            Modify_ListBooksRequest(ref request, ref callSettings);
            return new GrpcPagedAsyncEnumerable<ListBooksRequest, ListBooksResponse, Book>(_callListBooks, request, callSettings);
        }

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Book"/> resources.
        /// </returns>
        public override PagedEnumerable<ListBooksResponse, Book> ListBooks(
            ListBooksRequest request,
            CallSettings callSettings = null)
        {
            Modify_ListBooksRequest(ref request, ref callSettings);
            return new GrpcPagedEnumerable<ListBooksRequest, ListBooksResponse, Book>(_callListBooks, request, callSettings);
        }

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override Task DeleteBookAsync(
            DeleteBookRequest request,
            CallSettings callSettings = null)
        {
            Modify_DeleteBookRequest(ref request, ref callSettings);
            return _callDeleteBook.Async(request, callSettings);
        }

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override void DeleteBook(
            DeleteBookRequest request,
            CallSettings callSettings = null)
        {
            Modify_DeleteBookRequest(ref request, ref callSettings);
            _callDeleteBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override Task<Book> UpdateBookAsync(
            UpdateBookRequest request,
            CallSettings callSettings = null)
        {
            Modify_UpdateBookRequest(ref request, ref callSettings);
            return _callUpdateBook.Async(request, callSettings);
        }

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Book UpdateBook(
            UpdateBookRequest request,
            CallSettings callSettings = null)
        {
            Modify_UpdateBookRequest(ref request, ref callSettings);
            return _callUpdateBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override Task<Book> MoveBookAsync(
            MoveBookRequest request,
            CallSettings callSettings = null)
        {
            Modify_MoveBookRequest(ref request, ref callSettings);
            return _callMoveBook.Async(request, callSettings);
        }

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Book MoveBook(
            MoveBookRequest request,
            CallSettings callSettings = null)
        {
            Modify_MoveBookRequest(ref request, ref callSettings);
            return _callMoveBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public override PagedAsyncEnumerable<ListStringsResponse, IResourceName> ListStringsAsync(
            ListStringsRequest request,
            CallSettings callSettings = null)
        {
            Modify_ListStringsRequest(ref request, ref callSettings);
            return new GrpcPagedAsyncEnumerable<ListStringsRequest, ListStringsResponse, IResourceName>(_callListStrings, request, callSettings);
        }

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public override PagedEnumerable<ListStringsResponse, IResourceName> ListStrings(
            ListStringsRequest request,
            CallSettings callSettings = null)
        {
            Modify_ListStringsRequest(ref request, ref callSettings);
            return new GrpcPagedEnumerable<ListStringsRequest, ListStringsResponse, IResourceName>(_callListStrings, request, callSettings);
        }

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override Task AddCommentsAsync(
            AddCommentsRequest request,
            CallSettings callSettings = null)
        {
            Modify_AddCommentsRequest(ref request, ref callSettings);
            return _callAddComments.Async(request, callSettings);
        }

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override void AddComments(
            AddCommentsRequest request,
            CallSettings callSettings = null)
        {
            Modify_AddCommentsRequest(ref request, ref callSettings);
            _callAddComments.Sync(request, callSettings);
        }

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override Task<BookFromArchive> GetBookFromArchiveAsync(
            GetBookFromArchiveRequest request,
            CallSettings callSettings = null)
        {
            Modify_GetBookFromArchiveRequest(ref request, ref callSettings);
            return _callGetBookFromArchive.Async(request, callSettings);
        }

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override BookFromArchive GetBookFromArchive(
            GetBookFromArchiveRequest request,
            CallSettings callSettings = null)
        {
            Modify_GetBookFromArchiveRequest(ref request, ref callSettings);
            return _callGetBookFromArchive.Sync(request, callSettings);
        }

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            GetBookFromAnywhereRequest request,
            CallSettings callSettings = null)
        {
            Modify_GetBookFromAnywhereRequest(ref request, ref callSettings);
            return _callGetBookFromAnywhere.Async(request, callSettings);
        }

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override BookFromAnywhere GetBookFromAnywhere(
            GetBookFromAnywhereRequest request,
            CallSettings callSettings = null)
        {
            Modify_GetBookFromAnywhereRequest(ref request, ref callSettings);
            return _callGetBookFromAnywhere.Sync(request, callSettings);
        }

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            GetBookFromAbsolutelyAnywhereRequest request,
            CallSettings callSettings = null)
        {
            Modify_GetBookFromAbsolutelyAnywhereRequest(ref request, ref callSettings);
            return _callGetBookFromAbsolutelyAnywhere.Async(request, callSettings);
        }

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override BookFromAnywhere GetBookFromAbsolutelyAnywhere(
            GetBookFromAbsolutelyAnywhereRequest request,
            CallSettings callSettings = null)
        {
            Modify_GetBookFromAbsolutelyAnywhereRequest(ref request, ref callSettings);
            return _callGetBookFromAbsolutelyAnywhere.Sync(request, callSettings);
        }

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override Task UpdateBookIndexAsync(
            UpdateBookIndexRequest request,
            CallSettings callSettings = null)
        {
            Modify_UpdateBookIndexRequest(ref request, ref callSettings);
            return _callUpdateBookIndex.Async(request, callSettings);
        }

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override void UpdateBookIndex(
            UpdateBookIndexRequest request,
            CallSettings callSettings = null)
        {
            Modify_UpdateBookIndexRequest(ref request, ref callSettings);
            _callUpdateBookIndex.Sync(request, callSettings);
        }

        /// <summary>
        /// Test server streaming
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The server stream.
        /// </returns>
        public override StreamShelvesStream StreamShelves(
            StreamShelvesRequest request,
            CallSettings callSettings = null)
        {
            Modify_StreamShelvesRequest(ref request, ref callSettings);
            return new StreamShelvesStreamImpl(_callStreamShelves.Call(request, callSettings));
        }

        internal sealed partial class StreamShelvesStreamImpl : StreamShelvesStream
        {
            /// <summary>
            /// Construct the server-streaming method for <c>StreamShelves</c>.
            /// </summary>
            /// <param name="call">The underlying gRPC server-streaming call.</param>
            internal StreamShelvesStreamImpl(AsyncServerStreamingCall<StreamShelvesResponse> call)
            {
                GrpcCall = call;
            }

            /// <inheritdoc/>
            public override AsyncServerStreamingCall<StreamShelvesResponse> GrpcCall { get; }

            /// <inheritdoc/>
            public override IAsyncEnumerator<StreamShelvesResponse> ResponseStream => GrpcCall.ResponseStream;
        }

        /// <summary>
        /// Test server streaming, non-paged responses.
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The server stream.
        /// </returns>
        public override StreamBooksStream StreamBooks(
            StreamBooksRequest request,
            CallSettings callSettings = null)
        {
            Modify_StreamBooksRequest(ref request, ref callSettings);
            return new StreamBooksStreamImpl(_callStreamBooks.Call(request, callSettings));
        }

        internal sealed partial class StreamBooksStreamImpl : StreamBooksStream
        {
            /// <summary>
            /// Construct the server-streaming method for <c>StreamBooks</c>.
            /// </summary>
            /// <param name="call">The underlying gRPC server-streaming call.</param>
            internal StreamBooksStreamImpl(AsyncServerStreamingCall<Book> call)
            {
                GrpcCall = call;
            }

            /// <inheritdoc/>
            public override AsyncServerStreamingCall<Book> GrpcCall { get; }

            /// <inheritdoc/>
            public override IAsyncEnumerator<Book> ResponseStream => GrpcCall.ResponseStream;
        }

        /// <summary>
        /// Test bidi-streaming.
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <param name="streamingSettings">
        /// If not null, applies streaming overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The client-server stream.
        /// </returns>
        public override DiscussBookStream DiscussBook(
            CallSettings callSettings = null,
            BidirectionalStreamingSettings streamingSettings = null)
        {
            Modify_DiscussBookRequestCallSettings(ref callSettings);
            BidirectionalStreamingSettings effectiveStreamingSettings =
                streamingSettings ?? _callDiscussBook.StreamingSettings;
            AsyncDuplexStreamingCall<DiscussBookRequest, Comment> call =
                _callDiscussBook.Call(callSettings);
            BufferedClientStreamWriter<DiscussBookRequest> writeBuffer =
                new BufferedClientStreamWriter<DiscussBookRequest>(
                    call.RequestStream, effectiveStreamingSettings.BufferedClientWriterCapacity);
            return new DiscussBookStreamImpl(this, call, writeBuffer);
        }

        internal sealed partial class DiscussBookStreamImpl : DiscussBookStream
        {
            /// <summary>
            /// Construct the bidirectional streaming method for <c>DiscussBook</c>.
            /// </summary>
            /// <param name="service">The service containing this streaming method.</param>
            /// <param name="call">The underlying gRPC duplex streaming call.</param>
            /// <param name="writeBuffer">The <see cref="BufferedClientStreamWriter{DiscussBookRequest}"/>
            /// instance associated with this streaming call.</param>
            public DiscussBookStreamImpl(
                LibraryServiceClientImpl service,
                AsyncDuplexStreamingCall<DiscussBookRequest, Comment> call,
                BufferedClientStreamWriter<DiscussBookRequest> writeBuffer)
            {
                _service = service;
                GrpcCall = call;
                _writeBuffer = writeBuffer;
            }

            private LibraryServiceClientImpl _service;
            private BufferedClientStreamWriter<DiscussBookRequest> _writeBuffer;

            private DiscussBookRequest ModifyRequest(DiscussBookRequest request)
            {
                _service.Modify_DiscussBookRequestRequest(ref request);
                return request;
            }

            /// <inheritdoc/>
            public override AsyncDuplexStreamingCall<DiscussBookRequest, Comment> GrpcCall { get; }

            /// <inheritdoc/>
            public override Task TryWriteAsync(DiscussBookRequest message) =>
                _writeBuffer.TryWriteAsync(ModifyRequest(message));

            /// <inheritdoc/>
            public override Task WriteAsync(DiscussBookRequest message) =>
                _writeBuffer.WriteAsync(ModifyRequest(message));

            /// <inheritdoc/>
            public override Task TryWriteAsync(DiscussBookRequest message, WriteOptions options) =>
                _writeBuffer.TryWriteAsync(ModifyRequest(message), options);

            /// <inheritdoc/>
            public override Task WriteAsync(DiscussBookRequest message, WriteOptions options) =>
                _writeBuffer.WriteAsync(ModifyRequest(message), options);

            /// <inheritdoc/>
            public override Task TryWriteCompleteAsync() =>
                _writeBuffer.TryWriteCompleteAsync();

            /// <inheritdoc/>
            public override Task WriteCompleteAsync() =>
                _writeBuffer.WriteCompleteAsync();

            /// <inheritdoc/>
            public override IAsyncEnumerator<Comment> ResponseStream =>
                GrpcCall.ResponseStream;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public override PagedAsyncEnumerable<FindRelatedBooksResponse, BookName> FindRelatedBooksAsync(
            FindRelatedBooksRequest request,
            CallSettings callSettings = null)
        {
            Modify_FindRelatedBooksRequest(ref request, ref callSettings);
            return new GrpcPagedAsyncEnumerable<FindRelatedBooksRequest, FindRelatedBooksResponse, BookName>(_callFindRelatedBooks, request, callSettings);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public override PagedEnumerable<FindRelatedBooksResponse, BookName> FindRelatedBooks(
            FindRelatedBooksRequest request,
            CallSettings callSettings = null)
        {
            Modify_FindRelatedBooksRequest(ref request, ref callSettings);
            return new GrpcPagedEnumerable<FindRelatedBooksRequest, FindRelatedBooksResponse, BookName>(_callFindRelatedBooks, request, callSettings);
        }

        /// <summary>
        /// Adds a tag to the book. This RPC is a mixin.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override Task<AddTagResponse> AddTagAsync(
            AddTagRequest request,
            CallSettings callSettings = null)
        {
            Modify_AddTagRequest(ref request, ref callSettings);
            return _callAddTag.Async(request, callSettings);
        }

        /// <summary>
        /// Adds a tag to the book. This RPC is a mixin.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override AddTagResponse AddTag(
            AddTagRequest request,
            CallSettings callSettings = null)
        {
            Modify_AddTagRequest(ref request, ref callSettings);
            return _callAddTag.Sync(request, callSettings);
        }

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override Task<AddLabelResponse> AddLabelAsync(
            AddLabelRequest request,
            CallSettings callSettings = null)
        {
            Modify_AddLabelRequest(ref request, ref callSettings);
            return _callAddLabel.Async(request, callSettings);
        }

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override AddLabelResponse AddLabel(
            AddLabelRequest request,
            CallSettings callSettings = null)
        {
            Modify_AddLabelRequest(ref request, ref callSettings);
            return _callAddLabel.Sync(request, callSettings);
        }

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override async Task<Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            GetBookRequest request,
            CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return new Operation<Book, GetBigBookMetadata>(
                await _callGetBigBook.Async(request, callSettings).ConfigureAwait(false), GetBigBookOperationsClient);
        }

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Operation<Book, GetBigBookMetadata> GetBigBook(
            GetBookRequest request,
            CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return new Operation<Book, GetBigBookMetadata>(
                _callGetBigBook.Sync(request, callSettings), GetBigBookOperationsClient);
        }

        /// <summary>
        /// The long-running operations client for <c>GetBigBook</c>.
        /// </summary>
        public override OperationsClient GetBigBookOperationsClient { get; }

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override async Task<Operation<Empty, GetBigBookMetadata>> GetBigNothingAsync(
            GetBookRequest request,
            CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return new Operation<Empty, GetBigBookMetadata>(
                await _callGetBigNothing.Async(request, callSettings).ConfigureAwait(false), GetBigNothingOperationsClient);
        }

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Operation<Empty, GetBigBookMetadata> GetBigNothing(
            GetBookRequest request,
            CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return new Operation<Empty, GetBigBookMetadata>(
                _callGetBigNothing.Sync(request, callSettings), GetBigNothingOperationsClient);
        }

        /// <summary>
        /// The long-running operations client for <c>GetBigNothing</c>.
        /// </summary>
        public override OperationsClient GetBigNothingOperationsClient { get; }

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            TestOptionalRequiredFlatteningParamsRequest request,
            CallSettings callSettings = null)
        {
            Modify_TestOptionalRequiredFlatteningParamsRequest(ref request, ref callSettings);
            return _callTestOptionalRequiredFlatteningParams.Async(request, callSettings);
        }

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override TestOptionalRequiredFlatteningParamsResponse TestOptionalRequiredFlatteningParams(
            TestOptionalRequiredFlatteningParamsRequest request,
            CallSettings callSettings = null)
        {
            Modify_TestOptionalRequiredFlatteningParamsRequest(ref request, ref callSettings);
            return _callTestOptionalRequiredFlatteningParams.Sync(request, callSettings);
        }

    }

    // Partial classes to enable page-streaming

    public partial class ListShelvesRequest : IPageRequest { }
    public partial class ListShelvesResponse : IPageResponse<Shelf>
    {
        /// <summary>
        /// Returns an enumerator that iterates through the resources in this response.
        /// </summary>
        public IEnumerator<Shelf> GetEnumerator() => Shelves.GetEnumerator();

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    }

    public partial class ListBooksRequest : IPageRequest { }
    public partial class ListBooksResponse : IPageResponse<Book>
    {
        /// <summary>
        /// Returns an enumerator that iterates through the resources in this response.
        /// </summary>
        public IEnumerator<Book> GetEnumerator() => Books.GetEnumerator();

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    }

    public partial class ListStringsRequest : IPageRequest { }
    public partial class ListStringsResponse : IPageResponse<IResourceName>
    {
        /// <summary>
        /// Returns an enumerator that iterates through the resources in this response.
        /// </summary>
        public IEnumerator<IResourceName> GetEnumerator() => StringsAsResourceNames.GetEnumerator();

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    }

    public partial class FindRelatedBooksRequest : IPageRequest { }
    public partial class FindRelatedBooksResponse : IPageResponse<BookName>
    {
        /// <summary>
        /// Returns an enumerator that iterates through the resources in this response.
        /// </summary>
        public IEnumerator<BookName> GetEnumerator() => BookNames.GetEnumerator();

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    }

    // Partial Grpc class to enable LRO client creation
    public static partial class LibraryService
    {
        public partial class LibraryServiceClient
        {
            /// <summary>
            /// Creates a new instance of <see cref="Operations.OperationsClient"/> using the same call invoker as this client.
            /// </summary>
            /// <returns>A new Operations client for the same target as this client.</returns>
            public virtual Operations.OperationsClient CreateOperationsClient() => new Operations.OperationsClient(CallInvoker);
        }
    }

    // Partial Grpc class to enable Labeler.LabelerClient client creation
    public static partial class LibraryService
    {
        public partial class LibraryServiceClient
        {
            /// <summary>
            /// Creates a new instance of <see cref="Labeler.LabelerClient"/> using the same call invoker as this client.
            /// </summary>
            /// <returns>A new Labeler.LabelerClient for the same target as this client.</returns>
            public virtual Labeler.LabelerClient CreateLabelerClient() => new Labeler.LabelerClient(CallInvoker);
        }
    }


}

============== file: Google.Example.Library.V1/Google.Example.Library.V1/ResourceNames.cs ==============
// Copyright 2017, Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

using Google.Api.Gax;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Google.Example.Library.V1
{
    /// <summary>
    /// Resource name for the 'shelf' resource.
    /// </summary>
    public sealed partial class ShelfName : IResourceName, IEquatable<ShelfName>
    {
        private static readonly PathTemplate s_template = new PathTemplate("shelves/{shelf_id}");

        /// <summary>
        /// Parses the given shelf resource name in string form into a new
        /// <see cref="ShelfName"/> instance.
        /// </summary>
        /// <param name="shelfName">The shelf resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="ShelfName"/> if successful.</returns>
        public static ShelfName Parse(string shelfName)
        {
            GaxPreconditions.CheckNotNull(shelfName, nameof(shelfName));
            TemplatedResourceName resourceName = s_template.ParseName(shelfName);
            return new ShelfName(resourceName[0]);
        }

        /// <summary>
        /// Tries to parse the given shelf resource name in string form into a new
        /// <see cref="ShelfName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="ArgumentNullException"/> if <paramref name="shelfName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="shelfName">The shelf resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="ShelfName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed succssfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string shelfName, out ShelfName result)
        {
            GaxPreconditions.CheckNotNull(shelfName, nameof(shelfName));
            TemplatedResourceName resourceName;
            if (s_template.TryParseName(shelfName, out resourceName))
            {
                result = new ShelfName(resourceName[0]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>
        /// Constructs a new instance of the <see cref="ShelfName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="shelfId">The shelf ID. Must not be <c>null</c>.</param>
        public ShelfName(string shelfId)
        {
            ShelfId = GaxPreconditions.CheckNotNull(shelfId, nameof(shelfId));
        }

        /// <summary>
        /// The shelf ID. Never <c>null</c>.
        /// </summary>
        public string ShelfId { get; }

        /// <inheritdoc />
        public ResourceNameKind Kind => ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ShelfId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as ShelfName);

        /// <inheritdoc />
        public bool Equals(ShelfName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(ShelfName a, ShelfName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(ShelfName a, ShelfName b) => !(a == b);
    }

    /// <summary>
    /// Resource name for the 'archived_book' resource.
    /// </summary>
    public sealed partial class ArchivedBookName : IResourceName, IEquatable<ArchivedBookName>
    {
        private static readonly PathTemplate s_template = new PathTemplate("archives/{archive_path}/books/{book_id=**}");

        /// <summary>
        /// Parses the given archived_book resource name in string form into a new
        /// <see cref="ArchivedBookName"/> instance.
        /// </summary>
        /// <param name="archivedBookName">The archived_book resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="ArchivedBookName"/> if successful.</returns>
        public static ArchivedBookName Parse(string archivedBookName)
        {
            GaxPreconditions.CheckNotNull(archivedBookName, nameof(archivedBookName));
            TemplatedResourceName resourceName = s_template.ParseName(archivedBookName);
            return new ArchivedBookName(resourceName[0], resourceName[1]);
        }

        /// <summary>
        /// Tries to parse the given archived_book resource name in string form into a new
        /// <see cref="ArchivedBookName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="ArgumentNullException"/> if <paramref name="archivedBookName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="archivedBookName">The archived_book resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="ArchivedBookName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed succssfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string archivedBookName, out ArchivedBookName result)
        {
            GaxPreconditions.CheckNotNull(archivedBookName, nameof(archivedBookName));
            TemplatedResourceName resourceName;
            if (s_template.TryParseName(archivedBookName, out resourceName))
            {
                result = new ArchivedBookName(resourceName[0], resourceName[1]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>
        /// Constructs a new instance of the <see cref="ArchivedBookName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="archivePathId">The archivePath ID. Must not be <c>null</c>.</param>
        /// <param name="bookId">The book ID. Must not be <c>null</c>.</param>
        public ArchivedBookName(string archivePathId, string bookId)
        {
            ArchivePathId = GaxPreconditions.CheckNotNull(archivePathId, nameof(archivePathId));
            BookId = GaxPreconditions.CheckNotNull(bookId, nameof(bookId));
        }

        /// <summary>
        /// The archivePath ID. Never <c>null</c>.
        /// </summary>
        public string ArchivePathId { get; }

        /// <summary>
        /// The book ID. Never <c>null</c>.
        /// </summary>
        public string BookId { get; }

        /// <inheritdoc />
        public ResourceNameKind Kind => ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ArchivePathId, BookId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as ArchivedBookName);

        /// <inheritdoc />
        public bool Equals(ArchivedBookName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(ArchivedBookName a, ArchivedBookName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(ArchivedBookName a, ArchivedBookName b) => !(a == b);
    }

    /// <summary>
    /// Resource name for the 'book' resource.
    /// </summary>
    public sealed partial class BookName : IResourceName, IEquatable<BookName>
    {
        private static readonly PathTemplate s_template = new PathTemplate("shelves/{shelf_id}/books/{book_id}");

        /// <summary>
        /// Parses the given book resource name in string form into a new
        /// <see cref="BookName"/> instance.
        /// </summary>
        /// <param name="bookName">The book resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="BookName"/> if successful.</returns>
        public static BookName Parse(string bookName)
        {
            GaxPreconditions.CheckNotNull(bookName, nameof(bookName));
            TemplatedResourceName resourceName = s_template.ParseName(bookName);
            return new BookName(resourceName[0], resourceName[1]);
        }

        /// <summary>
        /// Tries to parse the given book resource name in string form into a new
        /// <see cref="BookName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="ArgumentNullException"/> if <paramref name="bookName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="bookName">The book resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="BookName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed succssfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string bookName, out BookName result)
        {
            GaxPreconditions.CheckNotNull(bookName, nameof(bookName));
            TemplatedResourceName resourceName;
            if (s_template.TryParseName(bookName, out resourceName))
            {
                result = new BookName(resourceName[0], resourceName[1]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>
        /// Constructs a new instance of the <see cref="BookName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="shelfId">The shelf ID. Must not be <c>null</c>.</param>
        /// <param name="bookId">The book ID. Must not be <c>null</c>.</param>
        public BookName(string shelfId, string bookId)
        {
            ShelfId = GaxPreconditions.CheckNotNull(shelfId, nameof(shelfId));
            BookId = GaxPreconditions.CheckNotNull(bookId, nameof(bookId));
        }

        /// <summary>
        /// The shelf ID. Never <c>null</c>.
        /// </summary>
        public string ShelfId { get; }

        /// <summary>
        /// The book ID. Never <c>null</c>.
        /// </summary>
        public string BookId { get; }

        /// <inheritdoc />
        public ResourceNameKind Kind => ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ShelfId, BookId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as BookName);

        /// <inheritdoc />
        public bool Equals(BookName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(BookName a, BookName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(BookName a, BookName b) => !(a == b);
    }

    /// <summary>
    /// Resource name for the 'return' resource.
    /// </summary>
    public sealed partial class ReturnName : IResourceName, IEquatable<ReturnName>
    {
        private static readonly PathTemplate s_template = new PathTemplate("shelves/{shelf}/books/{book}/returns/{return}");

        /// <summary>
        /// Parses the given return resource name in string form into a new
        /// <see cref="ReturnName"/> instance.
        /// </summary>
        /// <param name="returnName">The return resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="ReturnName"/> if successful.</returns>
        public static ReturnName Parse(string returnName)
        {
            GaxPreconditions.CheckNotNull(returnName, nameof(returnName));
            TemplatedResourceName resourceName = s_template.ParseName(returnName);
            return new ReturnName(resourceName[0], resourceName[1], resourceName[2]);
        }

        /// <summary>
        /// Tries to parse the given return resource name in string form into a new
        /// <see cref="ReturnName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="ArgumentNullException"/> if <paramref name="returnName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="returnName">The return resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="ReturnName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed succssfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string returnName, out ReturnName result)
        {
            GaxPreconditions.CheckNotNull(returnName, nameof(returnName));
            TemplatedResourceName resourceName;
            if (s_template.TryParseName(returnName, out resourceName))
            {
                result = new ReturnName(resourceName[0], resourceName[1], resourceName[2]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>
        /// Constructs a new instance of the <see cref="ReturnName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="shelfId">The shelf ID. Must not be <c>null</c>.</param>
        /// <param name="bookId">The book ID. Must not be <c>null</c>.</param>
        /// <param name="returnId">The return ID. Must not be <c>null</c>.</param>
        public ReturnName(string shelfId, string bookId, string returnId)
        {
            ShelfId = GaxPreconditions.CheckNotNull(shelfId, nameof(shelfId));
            BookId = GaxPreconditions.CheckNotNull(bookId, nameof(bookId));
            ReturnId = GaxPreconditions.CheckNotNull(returnId, nameof(returnId));
        }

        /// <summary>
        /// The shelf ID. Never <c>null</c>.
        /// </summary>
        public string ShelfId { get; }

        /// <summary>
        /// The book ID. Never <c>null</c>.
        /// </summary>
        public string BookId { get; }

        /// <summary>
        /// The return ID. Never <c>null</c>.
        /// </summary>
        public string ReturnId { get; }

        /// <inheritdoc />
        public ResourceNameKind Kind => ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ShelfId, BookId, ReturnId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as ReturnName);

        /// <inheritdoc />
        public bool Equals(ReturnName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(ReturnName a, ReturnName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(ReturnName a, ReturnName b) => !(a == b);
    }

    /// <summary>
    /// Resource name which will contain one of a choice of resource names.
    /// </summary>
    /// <remarks>
    /// This resource name will contain one of the following:
    /// <list type="bullet">
    /// <item><description>BookName: A resource of type 'book'.</description></item>
    /// <item><description>ArchivedBookName: A resource of type 'archived_book'.</description></item>
    /// <item><description>DeletedBookNameFixed: A resource of type 'deleted_book'.</description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BookNameOneof : IResourceName, IEquatable<BookNameOneof>
    {
        /// <summary>
        /// The possible contents of <see cref="BookNameOneof"/>.
        /// </summary>
        public enum OneofType
        {
            /// <summary>
            /// A resource of an unknown type.
            /// </summary>
            Unknown = 0,

            /// <summary>
            /// A resource of type 'book'.
            /// </summary>
            BookName = 1,

            /// <summary>
            /// A resource of type 'archived_book'.
            /// </summary>
            ArchivedBookName = 2,

            /// <summary>
            /// A resource of type 'deleted_book'.
            /// </summary>
            DeletedBookNameFixed = 3,
        }

        /// <summary>
        /// Parses a resource name in string form into a new <see cref="BookNameOneof"/> instance.
        /// </summary>
        /// <remarks>
        /// To parse successfully the resource name must be one of the following:
        /// <list type="bullet">
        /// <item><description>BookName: A resource of type 'book'.</description></item>
        /// <item><description>ArchivedBookName: A resource of type 'archived_book'.</description></item>
        /// <item><description>DeletedBookNameFixed: A resource of type 'deleted_book'.</description></item>
        /// </list>
        /// Or an <see cref="UnknownResourceName"/> if <paramref name="allowUnknown"/> is <c>true</c>.
        /// </remarks>
        /// <param name="name">The resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="allowUnknown">If true, will successfully parse an unknown resource name
        /// into an <see cref="UnknownResourceName"/>; otherwise will throw an
        /// <see cref="ArgumentException"/> if an unknown resource name is given.</param>
        /// <returns>The parsed <see cref="BookNameOneof"/> if successful.</returns>
        public static BookNameOneof Parse(string name, bool allowUnknown)
        {
            BookNameOneof result;
            if (TryParse(name, allowUnknown, out result))
            {
                return result;
            }
            throw new ArgumentException("Invalid name", nameof(name));
        }

        /// <summary>
        /// Tries to parse a resource name in string form into a new <see cref="BookNameOneof"/> instance.
        /// </summary>
        /// <remarks>
        /// To parse successfully the resource name must be one of the following:
        /// <list type="bullet">
        /// <item><description>BookName: A resource of type 'book'.</description></item>
        /// <item><description>ArchivedBookName: A resource of type 'archived_book'.</description></item>
        /// <item><description>DeletedBookNameFixed: A resource of type 'deleted_book'.</description></item>
        /// </list>
        /// Or an <see cref="UnknownResourceName"/> if <paramref name="allowUnknown"/> is <c>true</c>.
        /// </remarks>
        /// <param name="name">The resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="allowUnknown">If true, will successfully parse an unknown resource name
        /// into an <see cref="UnknownResourceName"/>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="BookNameOneof"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed succssfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string name, bool allowUnknown, out BookNameOneof result)
        {
            GaxPreconditions.CheckNotNull(name, nameof(name));
            BookName bookName;
            if (BookName.TryParse(name, out bookName))
            {
                result = new BookNameOneof(OneofType.BookName, bookName);
                return true;
            }
            ArchivedBookName archivedBookName;
            if (ArchivedBookName.TryParse(name, out archivedBookName))
            {
                result = new BookNameOneof(OneofType.ArchivedBookName, archivedBookName);
                return true;
            }
            DeletedBookNameFixed deletedBookNameFixed;
            if (DeletedBookNameFixed.TryParse(name, out deletedBookNameFixed))
            {
                result = new BookNameOneof(OneofType.DeletedBookNameFixed, deletedBookNameFixed);
                return true;
            }
            if (allowUnknown)
            {
                UnknownResourceName unknownResourceName;
                if (UnknownResourceName.TryParse(name, out unknownResourceName))
                {
                    result = new BookNameOneof(OneofType.Unknown, unknownResourceName);
                    return true;
                }
            }
            result = null;
            return false;
        }

        /// <summary>
        /// Construct a new instance of <see cref="BookNameOneof"/> from the provided <see cref="BookName"/>
        /// </summary>
        /// <param name="bookName">The <see cref="BookName"/> to be contained within
        /// the returned <see cref="BookNameOneof"/>. Must not be <c>null</c>.</param>
        /// <returns>A new <see cref="BookNameOneof"/>, containing <paramref name="bookName"/>.</returns>
        public static BookNameOneof From(BookName bookName) => new BookNameOneof(OneofType.BookName, bookName);

        /// <summary>
        /// Construct a new instance of <see cref="BookNameOneof"/> from the provided <see cref="ArchivedBookName"/>
        /// </summary>
        /// <param name="archivedBookName">The <see cref="ArchivedBookName"/> to be contained within
        /// the returned <see cref="BookNameOneof"/>. Must not be <c>null</c>.</param>
        /// <returns>A new <see cref="BookNameOneof"/>, containing <paramref name="archivedBookName"/>.</returns>
        public static BookNameOneof From(ArchivedBookName archivedBookName) => new BookNameOneof(OneofType.ArchivedBookName, archivedBookName);

        /// <summary>
        /// Construct a new instance of <see cref="BookNameOneof"/> from the provided <see cref="DeletedBookNameFixed"/>
        /// </summary>
        /// <param name="deletedBookNameFixed">The <see cref="DeletedBookNameFixed"/> to be contained within
        /// the returned <see cref="BookNameOneof"/>. Must not be <c>null</c>.</param>
        /// <returns>A new <see cref="BookNameOneof"/>, containing <paramref name="deletedBookNameFixed"/>.</returns>
        public static BookNameOneof From(DeletedBookNameFixed deletedBookNameFixed) => new BookNameOneof(OneofType.DeletedBookNameFixed, deletedBookNameFixed);

        private static bool IsValid(OneofType type, IResourceName name)
        {
            switch (type)
            {
                case OneofType.Unknown: return true; // Anything goes with Unknown.
                case OneofType.BookName: return name is BookName;
                case OneofType.ArchivedBookName: return name is ArchivedBookName;
                case OneofType.DeletedBookNameFixed: return name is DeletedBookNameFixed;
                default: return false;
            }
        }

        /// <summary>
        /// Constructs a new instance of the <see cref="BookNameOneof"/> resource name class
        /// from a suitable <see cref="IResourceName"/> instance.
        /// </summary>
        public BookNameOneof(OneofType type, IResourceName name)
        {
            Type = GaxPreconditions.CheckEnumValue<OneofType>(type, nameof(type));
            Name = GaxPreconditions.CheckNotNull(name, nameof(name));
            if (!IsValid(type, name))
            {
                throw new ArgumentException($"Mismatched OneofType '{type}' and resource name '{name}'");
            }
        }

        /// <summary>
        /// The <see cref="OneofType"/> of the Name contained in this instance.
        /// </summary>
        public OneofType Type { get; }

        /// <summary>
        /// The <see cref="IResourceName"/> contained in this instance.
        /// </summary>
        public IResourceName Name { get; }

        private T CheckAndReturn<T>(OneofType type)
        {
            if (Type != type)
            {
                throw new InvalidOperationException($"Requested type {type}, but this one-of contains type {Type}");
            }
            return (T)Name;
        }

        /// <summary>
        /// Get the contained <see cref="IResourceName"/> as <see cref="BookName"/>.
        /// </summary>
        /// <remarks>
        /// An <see cref="InvalidOperationException"/> will be thrown if this does not
        /// contain an instance of <see cref="BookName"/>.
        /// </remarks>
        public BookName BookName => CheckAndReturn<BookName>(OneofType.BookName);

        /// <summary>
        /// Get the contained <see cref="IResourceName"/> as <see cref="ArchivedBookName"/>.
        /// </summary>
        /// <remarks>
        /// An <see cref="InvalidOperationException"/> will be thrown if this does not
        /// contain an instance of <see cref="ArchivedBookName"/>.
        /// </remarks>
        public ArchivedBookName ArchivedBookName => CheckAndReturn<ArchivedBookName>(OneofType.ArchivedBookName);

        /// <summary>
        /// Get the contained <see cref="IResourceName"/> as <see cref="DeletedBookNameFixed"/>.
        /// </summary>
        /// <remarks>
        /// An <see cref="InvalidOperationException"/> will be thrown if this does not
        /// contain an instance of <see cref="DeletedBookNameFixed"/>.
        /// </remarks>
        public DeletedBookNameFixed DeletedBookNameFixed => CheckAndReturn<DeletedBookNameFixed>(OneofType.DeletedBookNameFixed);

        /// <inheritdoc />
        public ResourceNameKind Kind => ResourceNameKind.Oneof;

        /// <inheritdoc />
        public override string ToString() => Name.ToString();

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as BookNameOneof);

        /// <inheritdoc />
        public bool Equals(BookNameOneof other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(BookNameOneof a, BookNameOneof b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(BookNameOneof a, BookNameOneof b) => !(a == b);
    }

    /// <summary>
    /// Resource name to represent the fixed string "_deleted-book_".
    /// </summary>
    public sealed partial class DeletedBookNameFixed : IResourceName, IEquatable<DeletedBookNameFixed>
    {
        /// <summary>
        /// The fixed string value: "_deleted-book_".
        /// </summary>
        public const string FixedValue = "_deleted-book_";

        /// <summary>
        /// An instance of <see cref="DeletedBookNameFixed"/>.
        /// </summary>
        public static DeletedBookNameFixed Instance => new DeletedBookNameFixed();

        /// <summary>
        /// Parses the given string into a new <see cref="DeletedBookNameFixed"/> instance.
        /// Only succeeds if the string is equal to "_deleted-book_".
        /// </summary>
        public static DeletedBookNameFixed Parse(string deletedBookNameFixed)
        {
            DeletedBookNameFixed result;
            if (!TryParse(deletedBookNameFixed, out result))
            {
                throw new ArgumentException($"Invalid resource name, must be \"{FixedValue}\"", nameof(deletedBookNameFixed));
            }
            return result;
        }

        /// <summary>
        /// Tries to parse the given string into a new <see cref="DeletedBookNameFixed"/> instance.
        /// Only succeeds if the string is equal to "_deleted-book_".
        /// </summary>
        public static bool TryParse(string deletedBookNameFixed, out DeletedBookNameFixed result)
        {
            GaxPreconditions.CheckNotNull(deletedBookNameFixed, nameof(deletedBookNameFixed));
            if (deletedBookNameFixed == FixedValue)
            {
                result = Instance;
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        private DeletedBookNameFixed() { }

        /// <inheritdoc />
        public ResourceNameKind Kind => ResourceNameKind.Fixed;

        /// <inheritdoc />
        public override string ToString() => FixedValue;

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as DeletedBookNameFixed);

        /// <inheritdoc />
        public bool Equals(DeletedBookNameFixed other) => other != null;

        /// <inheritdoc />
        public static bool operator ==(DeletedBookNameFixed a, DeletedBookNameFixed b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(DeletedBookNameFixed a, DeletedBookNameFixed b) => !(a == b);
    }


    public partial class Book
    {
        /// <summary>
        /// <see cref="BookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public BookName BookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class BookFromAnywhere
    {
        /// <summary>
        /// <see cref="BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class BookFromArchive
    {
        /// <summary>
        /// <see cref="ArchivedBookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public ArchivedBookName ArchivedBookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ArchivedBookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class CreateBookRequest
    {
        /// <summary>
        /// <see cref="ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class DeleteBookRequest
    {
        /// <summary>
        /// <see cref="BookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public BookName BookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class DeleteShelfRequest
    {
        /// <summary>
        /// <see cref="ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class FindRelatedBooksRequest
    {
        /// <summary>
        /// <see cref="ResourceNameList{BookName}"/>-typed view over the <see cref="Names"/> resource name property.
        /// </summary>
        public ResourceNameList<BookName> BookNames =>
            new ResourceNameList<BookName>(Names,
                str => BookName.Parse(str));

        /// <summary>
        /// <see cref="ResourceNameList{ShelfName}"/>-typed view over the <see cref="Shelves"/> resource name property.
        /// </summary>
        public ResourceNameList<ShelfName> ShelvesAsShelfNames =>
            new ResourceNameList<ShelfName>(Shelves,
                str => ShelfName.Parse(str));

    }

    public partial class FindRelatedBooksResponse
    {
        /// <summary>
        /// <see cref="ResourceNameList{BookName}"/>-typed view over the <see cref="Names"/> resource name property.
        /// </summary>
        public ResourceNameList<BookName> BookNames =>
            new ResourceNameList<BookName>(Names,
                str => BookName.Parse(str));

    }

    public partial class GetBookFromAbsolutelyAnywhereRequest
    {
        /// <summary>
        /// <see cref="IResourceName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public IResourceName AsResourceName
        {
            get { return string.IsNullOrEmpty(Name) ? null : UnknownResourceName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class GetBookFromAnywhereRequest
    {
        /// <summary>
        /// <see cref="BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="BookNameOneof"/>-typed view over the <see cref="AltBookName"/> resource name property.
        /// </summary>
        public BookNameOneof AltBookNameAsBookNameOneof
        {
            get { return string.IsNullOrEmpty(AltBookName) ? null : Google.Example.Library.V1.BookNameOneof.Parse(AltBookName, true); }
            set { AltBookName = value != null ? value.ToString() : ""; }
        }

    }

    public partial class GetBookFromArchiveRequest
    {
        /// <summary>
        /// <see cref="ArchivedBookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public ArchivedBookName ArchivedBookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ArchivedBookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class GetBookRequest
    {
        /// <summary>
        /// <see cref="BookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public BookName BookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class GetShelfRequest
    {
        /// <summary>
        /// <see cref="ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class ListBooksRequest
    {
        /// <summary>
        /// <see cref="ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class ListStringsRequest
    {
        /// <summary>
        /// <see cref="IResourceName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public IResourceName AsResourceName
        {
            get { return string.IsNullOrEmpty(Name) ? null : UnknownResourceName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class ListStringsResponse
    {
        /// <summary>
        /// <see cref="ResourceNameList{IResourceName}"/>-typed view over the <see cref="Strings"/> resource name property.
        /// </summary>
        public ResourceNameList<IResourceName> StringsAsResourceNames =>
            new ResourceNameList<IResourceName>(Strings,
                str => UnknownResourceName.Parse(str));

    }

    public partial class MergeShelvesRequest
    {
        /// <summary>
        /// <see cref="ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="ShelfName"/>-typed view over the <see cref="OtherShelfName"/> resource name property.
        /// </summary>
        public ShelfName OtherShelfNameAsShelfName
        {
            get { return string.IsNullOrEmpty(OtherShelfName) ? null : Google.Example.Library.V1.ShelfName.Parse(OtherShelfName); }
            set { OtherShelfName = value != null ? value.ToString() : ""; }
        }

    }

    public partial class MoveBookRequest
    {
        /// <summary>
        /// <see cref="BookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public BookName BookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="ShelfName"/>-typed view over the <see cref="OtherShelfName"/> resource name property.
        /// </summary>
        public ShelfName OtherShelfNameAsShelfName
        {
            get { return string.IsNullOrEmpty(OtherShelfName) ? null : Google.Example.Library.V1.ShelfName.Parse(OtherShelfName); }
            set { OtherShelfName = value != null ? value.ToString() : ""; }
        }

    }

    public partial class Shelf
    {
        /// <summary>
        /// <see cref="ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class TestOptionalRequiredFlatteningParamsRequest
    {
        /// <summary>
        /// <see cref="BookName"/>-typed view over the <see cref="RequiredSingularResourceName"/> resource name property.
        /// </summary>
        public BookName RequiredSingularResourceNameAsBookName
        {
            get { return string.IsNullOrEmpty(RequiredSingularResourceName) ? null : Google.Example.Library.V1.BookName.Parse(RequiredSingularResourceName); }
            set { RequiredSingularResourceName = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="BookNameOneof"/>-typed view over the <see cref="RequiredSingularResourceNameOneof"/> resource name property.
        /// </summary>
        public BookNameOneof RequiredSingularResourceNameOneofAsBookNameOneof
        {
            get { return string.IsNullOrEmpty(RequiredSingularResourceNameOneof) ? null : Google.Example.Library.V1.BookNameOneof.Parse(RequiredSingularResourceNameOneof, true); }
            set { RequiredSingularResourceNameOneof = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="ResourceNameList{BookName}"/>-typed view over the <see cref="RequiredRepeatedResourceName"/> resource name property.
        /// </summary>
        public ResourceNameList<BookName> RequiredRepeatedResourceNameAsBookNames =>
            new ResourceNameList<BookName>(RequiredRepeatedResourceName,
                str => BookName.Parse(str));

        /// <summary>
        /// <see cref="ResourceNameList{BookNameOneof}"/>-typed view over the <see cref="RequiredRepeatedResourceNameOneof"/> resource name property.
        /// </summary>
        public ResourceNameList<BookNameOneof> RequiredRepeatedResourceNameOneofAsBookNameOneofs =>
            new ResourceNameList<BookNameOneof>(RequiredRepeatedResourceNameOneof,
                str => BookNameOneof.Parse(str, true));

        /// <summary>
        /// <see cref="BookName"/>-typed view over the <see cref="OptionalSingularResourceName"/> resource name property.
        /// </summary>
        public BookName OptionalSingularResourceNameAsBookName
        {
            get { return string.IsNullOrEmpty(OptionalSingularResourceName) ? null : Google.Example.Library.V1.BookName.Parse(OptionalSingularResourceName); }
            set { OptionalSingularResourceName = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="BookNameOneof"/>-typed view over the <see cref="OptionalSingularResourceNameOneof"/> resource name property.
        /// </summary>
        public BookNameOneof OptionalSingularResourceNameOneofAsBookNameOneof
        {
            get { return string.IsNullOrEmpty(OptionalSingularResourceNameOneof) ? null : Google.Example.Library.V1.BookNameOneof.Parse(OptionalSingularResourceNameOneof, true); }
            set { OptionalSingularResourceNameOneof = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="ResourceNameList{BookName}"/>-typed view over the <see cref="OptionalRepeatedResourceName"/> resource name property.
        /// </summary>
        public ResourceNameList<BookName> OptionalRepeatedResourceNameAsBookNames =>
            new ResourceNameList<BookName>(OptionalRepeatedResourceName,
                str => BookName.Parse(str));

        /// <summary>
        /// <see cref="ResourceNameList{BookNameOneof}"/>-typed view over the <see cref="OptionalRepeatedResourceNameOneof"/> resource name property.
        /// </summary>
        public ResourceNameList<BookNameOneof> OptionalRepeatedResourceNameOneofAsBookNameOneofs =>
            new ResourceNameList<BookNameOneof>(OptionalRepeatedResourceNameOneof,
                str => BookNameOneof.Parse(str, true));

    }

    public partial class UpdateBookIndexRequest
    {
        /// <summary>
        /// <see cref="BookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public BookName BookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class UpdateBookRequest
    {
        /// <summary>
        /// <see cref="BookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public BookName BookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

}
