============== file: Google.Example.Library.V1/Google.Example.Library.V1.SmokeTests/Google.Example.Library.V1.SmokeTests.csproj ==============
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netcoreapp1.0</TargetFramework>
    <OutputType>Exe</OutputType>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="../Google.Example.Library.V1/Google.Example.Library.V1.csproj" />
  </ItemGroup>

</Project>

============== file: Google.Example.Library.V1/Google.Example.Library.V1.SmokeTests/LibraryServiceSmokeTest.g.cs ==============
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

namespace Google.Example.Library.V1.SmokeTests
{
    using Google.Api.Gax;
    using Google.Api.Gax.Grpc;
    using Google.Protobuf.WellKnownTypes;
    using Grpc.Core;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Threading;
    using System.Threading.Tasks;

    public class LibraryServiceSmokeTest
    {
        public static int Main(string[] args)
        {
            // Read projectId from args
            if (args.Length != 1)
            {
                Console.WriteLine("Usage: Project ID must be passed as first argument.");
                Console.WriteLine();
                return 1;
            }
            string projectId = args[0];

            // Create client
            LibraryServiceClient client = LibraryServiceClient.Create();

            // Initialize request argument(s)
            BookName name = new BookName($"testShelf-{Guid.NewGuid()}", projectId);
            string optionalFoo = "";
            Book book = new Book
            {
                Rating = Book.Types.Rating.Good,
            };
            FieldMask updateMask = new FieldMask();
            FieldMask physicalMask = new FieldMask();

            // Call API method
            Book response = client.UpdateBook(name, optionalFoo, book, updateMask, physicalMask);
            // Show the result
            Console.WriteLine(response);

            // Success
            Console.WriteLine("Smoke test passed OK");
            return 0;
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Snippets/Google.Example.Library.V1.Snippets.csproj ==============
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>netcoreapp1.0;netcoreapp2.0;net452</TargetFrameworks>
    <TargetFrameworks Condition=" '$(OS)' != 'Windows_NT' ">netcoreapp1.0;netcoreapp2.0</TargetFrameworks>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="../Google.Example.Library.V1/Google.Example.Library.V1.csproj" />
  </ItemGroup>

</Project>

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Snippets/LibraryServiceClientSnippets.g.cs ==============
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

namespace Google.Example.Library.V1.Snippets
{
    using Google.Api.Gax;
    using Google.Api.Gax.Grpc;
    using Google.Api.Gax.ResourceNames;
    using apis = Google.Example.Library.V1;
    using Google.LongRunning;
    using Google.Protobuf;
    using Google.Protobuf.WellKnownTypes;
    using Google.Tagger.V1;
    using Grpc.Core;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Linq;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>Generated snippets</summary>
    public class GeneratedLibraryServiceClientSnippets
    {
        /// <summary>Snippet for CreateShelfAsync</summary>
        public async Task CreateShelfAsync()
        {
            // Snippet: CreateShelfAsync(Shelf,CallSettings)
            // Additional: CreateShelfAsync(Shelf,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            Shelf shelf = new Shelf();
            // Make the request
            Shelf response = await libraryServiceClient.CreateShelfAsync(shelf);
            // End snippet
        }

        /// <summary>Snippet for CreateShelf</summary>
        public void CreateShelf()
        {
            // Snippet: CreateShelf(Shelf,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            Shelf shelf = new Shelf();
            // Make the request
            Shelf response = libraryServiceClient.CreateShelf(shelf);
            // End snippet
        }

        /// <summary>Snippet for CreateShelfAsync</summary>
        public async Task CreateShelfAsync_RequestObject()
        {
            // Snippet: CreateShelfAsync(CreateShelfRequest,CallSettings)
            // Additional: CreateShelfAsync(CreateShelfRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            CreateShelfRequest request = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            // Make the request
            Shelf response = await libraryServiceClient.CreateShelfAsync(request);
            // End snippet
        }

        /// <summary>Snippet for CreateShelf</summary>
        public void CreateShelf_RequestObject()
        {
            // Snippet: CreateShelf(CreateShelfRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            CreateShelfRequest request = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            // Make the request
            Shelf response = libraryServiceClient.CreateShelf(request);
            // End snippet
        }

        /// <summary>Snippet for GetShelfAsync</summary>
        public async Task GetShelfAsync1()
        {
            // Snippet: GetShelfAsync(ShelfName,CallSettings)
            // Additional: GetShelfAsync(ShelfName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            // Make the request
            Shelf response = await libraryServiceClient.GetShelfAsync(name);
            // End snippet
        }

        /// <summary>Snippet for GetShelf</summary>
        public void GetShelf1()
        {
            // Snippet: GetShelf(ShelfName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            // Make the request
            Shelf response = libraryServiceClient.GetShelf(name);
            // End snippet
        }

        /// <summary>Snippet for GetShelfAsync</summary>
        public async Task GetShelfAsync2()
        {
            // Snippet: GetShelfAsync(string,SomeMessage,CallSettings)
            // Additional: GetShelfAsync(string,SomeMessage,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            string formattedName = new ShelfName("[SHELF_ID]").ToString();
            SomeMessage message = new SomeMessage();
            // Make the request
            Shelf response = await libraryServiceClient.GetShelfAsync(formattedName, message);
            // End snippet
        }

        /// <summary>Snippet for GetShelf</summary>
        public void GetShelf2()
        {
            // Snippet: GetShelf(string,SomeMessage,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            string formattedName = new ShelfName("[SHELF_ID]").ToString();
            SomeMessage message = new SomeMessage();
            // Make the request
            Shelf response = libraryServiceClient.GetShelf(formattedName, message);
            // End snippet
        }

        /// <summary>Snippet for GetShelfAsync</summary>
        public async Task GetShelfAsync3()
        {
            // Snippet: GetShelfAsync(string,SomeMessage,StringBuilder,CallSettings)
            // Additional: GetShelfAsync(string,SomeMessage,StringBuilder,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            string formattedName = new ShelfName("[SHELF_ID]").ToString();
            SomeMessage message = new SomeMessage();
            StringBuilder stringBuilder = new StringBuilder();
            // Make the request
            Shelf response = await libraryServiceClient.GetShelfAsync(formattedName, message, stringBuilder);
            // End snippet
        }

        /// <summary>Snippet for GetShelf</summary>
        public void GetShelf3()
        {
            // Snippet: GetShelf(string,SomeMessage,StringBuilder,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            string formattedName = new ShelfName("[SHELF_ID]").ToString();
            SomeMessage message = new SomeMessage();
            StringBuilder stringBuilder = new StringBuilder();
            // Make the request
            Shelf response = libraryServiceClient.GetShelf(formattedName, message, stringBuilder);
            // End snippet
        }

        /// <summary>Snippet for GetShelfAsync</summary>
        public async Task GetShelfAsync_RequestObject()
        {
            // Snippet: GetShelfAsync(GetShelfRequest,CallSettings)
            // Additional: GetShelfAsync(GetShelfRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetShelfRequest request = new GetShelfRequest
            {
                Name = new ShelfName("[SHELF_ID]").ToString(),
                Options = "",
            };
            // Make the request
            Shelf response = await libraryServiceClient.GetShelfAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetShelf</summary>
        public void GetShelf_RequestObject()
        {
            // Snippet: GetShelf(GetShelfRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetShelfRequest request = new GetShelfRequest
            {
                Name = new ShelfName("[SHELF_ID]").ToString(),
                Options = "",
            };
            // Make the request
            Shelf response = libraryServiceClient.GetShelf(request);
            // End snippet
        }

        /// <summary>Snippet for ListShelvesAsync</summary>
        public async Task ListShelvesAsync()
        {
            // Snippet: ListShelvesAsync(string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Make the request
            PagedAsyncEnumerable<ListShelvesResponse, Shelf> response =
                libraryServiceClient.ListShelvesAsync();

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((Shelf item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListShelvesResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Shelf item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Shelf> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Shelf item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListShelves</summary>
        public void ListShelves()
        {
            // Snippet: ListShelves(string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Make the request
            PagedEnumerable<ListShelvesResponse, Shelf> response =
                libraryServiceClient.ListShelves();

            // Iterate over all response items, lazily performing RPCs as required
            foreach (Shelf item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListShelvesResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Shelf item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Shelf> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Shelf item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListShelvesAsync</summary>
        public async Task ListShelvesAsync_RequestObject()
        {
            // Snippet: ListShelvesAsync(ListShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ListShelvesRequest request = new ListShelvesRequest();
            // Make the request
            PagedAsyncEnumerable<ListShelvesResponse, Shelf> response =
                libraryServiceClient.ListShelvesAsync(request);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((Shelf item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListShelvesResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Shelf item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Shelf> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Shelf item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListShelves</summary>
        public void ListShelves_RequestObject()
        {
            // Snippet: ListShelves(ListShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ListShelvesRequest request = new ListShelvesRequest();
            // Make the request
            PagedEnumerable<ListShelvesResponse, Shelf> response =
                libraryServiceClient.ListShelves(request);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (Shelf item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListShelvesResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Shelf item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Shelf> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Shelf item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for DeleteShelfAsync</summary>
        public async Task DeleteShelfAsync()
        {
            // Snippet: DeleteShelfAsync(ShelfName,CallSettings)
            // Additional: DeleteShelfAsync(ShelfName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            // Make the request
            await libraryServiceClient.DeleteShelfAsync(name);
            // End snippet
        }

        /// <summary>Snippet for DeleteShelf</summary>
        public void DeleteShelf()
        {
            // Snippet: DeleteShelf(ShelfName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            // Make the request
            libraryServiceClient.DeleteShelf(name);
            // End snippet
        }

        /// <summary>Snippet for DeleteShelfAsync</summary>
        public async Task DeleteShelfAsync_RequestObject()
        {
            // Snippet: DeleteShelfAsync(DeleteShelfRequest,CallSettings)
            // Additional: DeleteShelfAsync(DeleteShelfRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            DeleteShelfRequest request = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            await libraryServiceClient.DeleteShelfAsync(request);
            // End snippet
        }

        /// <summary>Snippet for DeleteShelf</summary>
        public void DeleteShelf_RequestObject()
        {
            // Snippet: DeleteShelf(DeleteShelfRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            DeleteShelfRequest request = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            libraryServiceClient.DeleteShelf(request);
            // End snippet
        }

        /// <summary>Snippet for MergeShelvesAsync</summary>
        public async Task MergeShelvesAsync()
        {
            // Snippet: MergeShelvesAsync(ShelfName,ShelfName,CallSettings)
            // Additional: MergeShelvesAsync(ShelfName,ShelfName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            // Make the request
            Shelf response = await libraryServiceClient.MergeShelvesAsync(name, otherShelfName);
            // End snippet
        }

        /// <summary>Snippet for MergeShelves</summary>
        public void MergeShelves()
        {
            // Snippet: MergeShelves(ShelfName,ShelfName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            // Make the request
            Shelf response = libraryServiceClient.MergeShelves(name, otherShelfName);
            // End snippet
        }

        /// <summary>Snippet for MergeShelvesAsync</summary>
        public async Task MergeShelvesAsync_RequestObject()
        {
            // Snippet: MergeShelvesAsync(MergeShelvesRequest,CallSettings)
            // Additional: MergeShelvesAsync(MergeShelvesRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            MergeShelvesRequest request = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            Shelf response = await libraryServiceClient.MergeShelvesAsync(request);
            // End snippet
        }

        /// <summary>Snippet for MergeShelves</summary>
        public void MergeShelves_RequestObject()
        {
            // Snippet: MergeShelves(MergeShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            MergeShelvesRequest request = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            Shelf response = libraryServiceClient.MergeShelves(request);
            // End snippet
        }

        /// <summary>Snippet for CreateBookAsync</summary>
        public async Task CreateBookAsync()
        {
            // Snippet: CreateBookAsync(string,Book,CallSettings)
            // Additional: CreateBookAsync(string,Book,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            string formattedName = new ShelfName("[SHELF_ID]").ToString();
            Book book = new Book();
            // Make the request
            Book response = await libraryServiceClient.CreateBookAsync(formattedName, book);
            // End snippet
        }

        /// <summary>Snippet for CreateBook</summary>
        public void CreateBook()
        {
            // Snippet: CreateBook(string,Book,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            string formattedName = new ShelfName("[SHELF_ID]").ToString();
            Book book = new Book();
            // Make the request
            Book response = libraryServiceClient.CreateBook(formattedName, book);
            // End snippet
        }

        /// <summary>Snippet for CreateBookAsync</summary>
        public async Task CreateBookAsync_RequestObject()
        {
            // Snippet: CreateBookAsync(CreateBookRequest,CallSettings)
            // Additional: CreateBookAsync(CreateBookRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            CreateBookRequest request = new CreateBookRequest
            {
                Name = new ShelfName("[SHELF_ID]").ToString(),
                Book = new Book(),
            };
            // Make the request
            Book response = await libraryServiceClient.CreateBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for CreateBook</summary>
        public void CreateBook_RequestObject()
        {
            // Snippet: CreateBook(CreateBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            CreateBookRequest request = new CreateBookRequest
            {
                Name = new ShelfName("[SHELF_ID]").ToString(),
                Book = new Book(),
            };
            // Make the request
            Book response = libraryServiceClient.CreateBook(request);
            // End snippet
        }

        /// <summary>Snippet for PublishSeriesAsync</summary>
        public async Task PublishSeriesAsync()
        {
            // Snippet: PublishSeriesAsync(Shelf,IEnumerable<Book>,uint?,SeriesUuid,CallSettings)
            // Additional: PublishSeriesAsync(Shelf,IEnumerable<Book>,uint?,SeriesUuid,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            Shelf shelf = new Shelf();
            IEnumerable<Book> books = new List<Book>();
            uint edition = 0;
            SeriesUuid seriesUuid = new SeriesUuid
            {
                SeriesString = "foobar",
            };
            // Make the request
            PublishSeriesResponse response = await libraryServiceClient.PublishSeriesAsync(shelf, books, edition, seriesUuid);
            // End snippet
        }

        /// <summary>Snippet for PublishSeries</summary>
        public void PublishSeries()
        {
            // Snippet: PublishSeries(Shelf,IEnumerable<Book>,uint?,SeriesUuid,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            Shelf shelf = new Shelf();
            IEnumerable<Book> books = new List<Book>();
            uint edition = 0;
            SeriesUuid seriesUuid = new SeriesUuid
            {
                SeriesString = "foobar",
            };
            // Make the request
            PublishSeriesResponse response = libraryServiceClient.PublishSeries(shelf, books, edition, seriesUuid);
            // End snippet
        }

        /// <summary>Snippet for PublishSeriesAsync</summary>
        public async Task PublishSeriesAsync_RequestObject()
        {
            // Snippet: PublishSeriesAsync(PublishSeriesRequest,CallSettings)
            // Additional: PublishSeriesAsync(PublishSeriesRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                SeriesUuid = new SeriesUuid
                             {
                                 SeriesString = "foobar",
                             },
            };
            // Make the request
            PublishSeriesResponse response = await libraryServiceClient.PublishSeriesAsync(request);
            // End snippet
        }

        /// <summary>Snippet for PublishSeries</summary>
        public void PublishSeries_RequestObject()
        {
            // Snippet: PublishSeries(PublishSeriesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                SeriesUuid = new SeriesUuid
                             {
                                 SeriesString = "foobar",
                             },
            };
            // Make the request
            PublishSeriesResponse response = libraryServiceClient.PublishSeries(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookAsync</summary>
        public async Task GetBookAsync()
        {
            // Snippet: GetBookAsync(BookName,CallSettings)
            // Additional: GetBookAsync(BookName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            Book response = await libraryServiceClient.GetBookAsync(name);
            // End snippet
        }

        /// <summary>Snippet for GetBook</summary>
        public void GetBook()
        {
            // Snippet: GetBook(BookName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            Book response = libraryServiceClient.GetBook(name);
            // End snippet
        }

        /// <summary>Snippet for GetBookAsync</summary>
        public async Task GetBookAsync_RequestObject()
        {
            // Snippet: GetBookAsync(GetBookRequest,CallSettings)
            // Additional: GetBookAsync(GetBookRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            // Make the request
            Book response = await libraryServiceClient.GetBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetBook</summary>
        public void GetBook_RequestObject()
        {
            // Snippet: GetBook(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            // Make the request
            Book response = libraryServiceClient.GetBook(request);
            // End snippet
        }

        /// <summary>Snippet for ListBooksAsync</summary>
        public async Task ListBooksAsync()
        {
            // Snippet: ListBooksAsync(ShelfName,string,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            string filter = "book-filter-string";
            // Make the request
            PagedAsyncEnumerable<ListBooksResponse, Book> response =
                libraryServiceClient.ListBooksAsync(name, filter);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((Book item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListBooksResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Book item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Book> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Book item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListBooks</summary>
        public void ListBooks()
        {
            // Snippet: ListBooks(ShelfName,string,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            string filter = "book-filter-string";
            // Make the request
            PagedEnumerable<ListBooksResponse, Book> response =
                libraryServiceClient.ListBooks(name, filter);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (Book item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListBooksResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Book item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Book> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Book item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListBooksAsync</summary>
        public async Task ListBooksAsync_RequestObject()
        {
            // Snippet: ListBooksAsync(ListBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ListBooksRequest request = new ListBooksRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Filter = "book-filter-string",
            };
            // Make the request
            PagedAsyncEnumerable<ListBooksResponse, Book> response =
                libraryServiceClient.ListBooksAsync(request);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((Book item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListBooksResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Book item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Book> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Book item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListBooks</summary>
        public void ListBooks_RequestObject()
        {
            // Snippet: ListBooks(ListBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ListBooksRequest request = new ListBooksRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Filter = "book-filter-string",
            };
            // Make the request
            PagedEnumerable<ListBooksResponse, Book> response =
                libraryServiceClient.ListBooks(request);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (Book item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListBooksResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Book item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Book> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Book item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for DeleteBookAsync</summary>
        public async Task DeleteBookAsync()
        {
            // Snippet: DeleteBookAsync(BookName,CallSettings)
            // Additional: DeleteBookAsync(BookName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            await libraryServiceClient.DeleteBookAsync(name);
            // End snippet
        }

        /// <summary>Snippet for DeleteBook</summary>
        public void DeleteBook()
        {
            // Snippet: DeleteBook(BookName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            libraryServiceClient.DeleteBook(name);
            // End snippet
        }

        /// <summary>Snippet for DeleteBookAsync</summary>
        public async Task DeleteBookAsync_RequestObject()
        {
            // Snippet: DeleteBookAsync(DeleteBookRequest,CallSettings)
            // Additional: DeleteBookAsync(DeleteBookRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            DeleteBookRequest request = new DeleteBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            // Make the request
            await libraryServiceClient.DeleteBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for DeleteBook</summary>
        public void DeleteBook_RequestObject()
        {
            // Snippet: DeleteBook(DeleteBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            DeleteBookRequest request = new DeleteBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            // Make the request
            libraryServiceClient.DeleteBook(request);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookAsync</summary>
        public async Task UpdateBookAsync1()
        {
            // Snippet: UpdateBookAsync(BookName,Book,CallSettings)
            // Additional: UpdateBookAsync(BookName,Book,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            Book book = new Book();
            // Make the request
            Book response = await libraryServiceClient.UpdateBookAsync(name, book);
            // End snippet
        }

        /// <summary>Snippet for UpdateBook</summary>
        public void UpdateBook1()
        {
            // Snippet: UpdateBook(BookName,Book,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            Book book = new Book();
            // Make the request
            Book response = libraryServiceClient.UpdateBook(name, book);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookAsync</summary>
        public async Task UpdateBookAsync2()
        {
            // Snippet: UpdateBookAsync(BookName,string,Book,FieldMask,apis::FieldMask,CallSettings)
            // Additional: UpdateBookAsync(BookName,string,Book,FieldMask,apis::FieldMask,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            string optionalFoo = "";
            Book book = new Book();
            FieldMask updateMask = new FieldMask();
            apis::FieldMask physicalMask = new apis::FieldMask();
            // Make the request
            Book response = await libraryServiceClient.UpdateBookAsync(name, optionalFoo, book, updateMask, physicalMask);
            // End snippet
        }

        /// <summary>Snippet for UpdateBook</summary>
        public void UpdateBook2()
        {
            // Snippet: UpdateBook(BookName,string,Book,FieldMask,apis::FieldMask,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            string optionalFoo = "";
            Book book = new Book();
            FieldMask updateMask = new FieldMask();
            apis::FieldMask physicalMask = new apis::FieldMask();
            // Make the request
            Book response = libraryServiceClient.UpdateBook(name, optionalFoo, book, updateMask, physicalMask);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookAsync</summary>
        public async Task UpdateBookAsync_RequestObject()
        {
            // Snippet: UpdateBookAsync(UpdateBookRequest,CallSettings)
            // Additional: UpdateBookAsync(UpdateBookRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            UpdateBookRequest request = new UpdateBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Book = new Book(),
            };
            // Make the request
            Book response = await libraryServiceClient.UpdateBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for UpdateBook</summary>
        public void UpdateBook_RequestObject()
        {
            // Snippet: UpdateBook(UpdateBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            UpdateBookRequest request = new UpdateBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Book = new Book(),
            };
            // Make the request
            Book response = libraryServiceClient.UpdateBook(request);
            // End snippet
        }

        /// <summary>Snippet for MoveBookAsync</summary>
        public async Task MoveBookAsync()
        {
            // Snippet: MoveBookAsync(BookName,ShelfName,CallSettings)
            // Additional: MoveBookAsync(BookName,ShelfName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            // Make the request
            Book response = await libraryServiceClient.MoveBookAsync(name, otherShelfName);
            // End snippet
        }

        /// <summary>Snippet for MoveBook</summary>
        public void MoveBook()
        {
            // Snippet: MoveBook(BookName,ShelfName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            // Make the request
            Book response = libraryServiceClient.MoveBook(name, otherShelfName);
            // End snippet
        }

        /// <summary>Snippet for MoveBookAsync</summary>
        public async Task MoveBookAsync_RequestObject()
        {
            // Snippet: MoveBookAsync(MoveBookRequest,CallSettings)
            // Additional: MoveBookAsync(MoveBookRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            MoveBookRequest request = new MoveBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            Book response = await libraryServiceClient.MoveBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for MoveBook</summary>
        public void MoveBook_RequestObject()
        {
            // Snippet: MoveBook(MoveBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            MoveBookRequest request = new MoveBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            Book response = libraryServiceClient.MoveBook(request);
            // End snippet
        }

        /// <summary>Snippet for ListStringsAsync</summary>
        public async Task ListStringsAsync1()
        {
            // Snippet: ListStringsAsync(string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Make the request
            PagedAsyncEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStringsAsync();

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((IResourceName item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListStringsResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStrings</summary>
        public void ListStrings1()
        {
            // Snippet: ListStrings(string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Make the request
            PagedEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStrings();

            // Iterate over all response items, lazily performing RPCs as required
            foreach (IResourceName item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListStringsResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStringsAsync</summary>
        public async Task ListStringsAsync2()
        {
            // Snippet: ListStringsAsync(IResourceName,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            IResourceName name = new ShelfName("[SHELF_ID]");
            // Make the request
            PagedAsyncEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStringsAsync(name);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((IResourceName item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListStringsResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStrings</summary>
        public void ListStrings2()
        {
            // Snippet: ListStrings(IResourceName,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            IResourceName name = new ShelfName("[SHELF_ID]");
            // Make the request
            PagedEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStrings(name);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (IResourceName item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListStringsResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStringsAsync</summary>
        public async Task ListStringsAsync_RequestObject()
        {
            // Snippet: ListStringsAsync(ListStringsRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ListStringsRequest request = new ListStringsRequest();
            // Make the request
            PagedAsyncEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStringsAsync(request);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((IResourceName item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListStringsResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStrings</summary>
        public void ListStrings_RequestObject()
        {
            // Snippet: ListStrings(ListStringsRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ListStringsRequest request = new ListStringsRequest();
            // Make the request
            PagedEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStrings(request);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (IResourceName item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListStringsResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for AddCommentsAsync</summary>
        public async Task AddCommentsAsync()
        {
            // Snippet: AddCommentsAsync(string,IEnumerable<Comment>,CallSettings)
            // Additional: AddCommentsAsync(string,IEnumerable<Comment>,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            string formattedName = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString();
            IEnumerable<Comment> comments = new[]
            {
                new Comment
                {
                    Comment = ByteString.Empty,
                    Stage = Comment.Types.Stage.Unset,
                    Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                },
            };
            // Make the request
            await libraryServiceClient.AddCommentsAsync(formattedName, comments);
            // End snippet
        }

        /// <summary>Snippet for AddComments</summary>
        public void AddComments()
        {
            // Snippet: AddComments(string,IEnumerable<Comment>,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            string formattedName = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString();
            IEnumerable<Comment> comments = new[]
            {
                new Comment
                {
                    Comment = ByteString.Empty,
                    Stage = Comment.Types.Stage.Unset,
                    Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                },
            };
            // Make the request
            libraryServiceClient.AddComments(formattedName, comments);
            // End snippet
        }

        /// <summary>Snippet for AddCommentsAsync</summary>
        public async Task AddCommentsAsync_RequestObject()
        {
            // Snippet: AddCommentsAsync(AddCommentsRequest,CallSettings)
            // Additional: AddCommentsAsync(AddCommentsRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            AddCommentsRequest request = new AddCommentsRequest
            {
                Name = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Comments = {
                               new Comment
                               {
                                   Comment = ByteString.Empty,
                                   Stage = Comment.Types.Stage.Unset,
                                   Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                               },
                           },
            };
            // Make the request
            await libraryServiceClient.AddCommentsAsync(request);
            // End snippet
        }

        /// <summary>Snippet for AddComments</summary>
        public void AddComments_RequestObject()
        {
            // Snippet: AddComments(AddCommentsRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            AddCommentsRequest request = new AddCommentsRequest
            {
                Name = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Comments = {
                               new Comment
                               {
                                   Comment = ByteString.Empty,
                                   Stage = Comment.Types.Stage.Unset,
                                   Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                               },
                           },
            };
            // Make the request
            libraryServiceClient.AddComments(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromArchiveAsync</summary>
        public async Task GetBookFromArchiveAsync()
        {
            // Snippet: GetBookFromArchiveAsync(ArchivedBookName,CallSettings)
            // Additional: GetBookFromArchiveAsync(ArchivedBookName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ArchivedBookName name = new ArchivedBookName("[ARCHIVE_PATH]", "[BOOK_ID]");
            // Make the request
            BookFromArchive response = await libraryServiceClient.GetBookFromArchiveAsync(name);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromArchive</summary>
        public void GetBookFromArchive()
        {
            // Snippet: GetBookFromArchive(ArchivedBookName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ArchivedBookName name = new ArchivedBookName("[ARCHIVE_PATH]", "[BOOK_ID]");
            // Make the request
            BookFromArchive response = libraryServiceClient.GetBookFromArchive(name);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromArchiveAsync</summary>
        public async Task GetBookFromArchiveAsync_RequestObject()
        {
            // Snippet: GetBookFromArchiveAsync(GetBookFromArchiveRequest,CallSettings)
            // Additional: GetBookFromArchiveAsync(GetBookFromArchiveRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookFromArchiveRequest request = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE_PATH]", "[BOOK_ID]"),
            };
            // Make the request
            BookFromArchive response = await libraryServiceClient.GetBookFromArchiveAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromArchive</summary>
        public void GetBookFromArchive_RequestObject()
        {
            // Snippet: GetBookFromArchive(GetBookFromArchiveRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookFromArchiveRequest request = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE_PATH]", "[BOOK_ID]"),
            };
            // Make the request
            BookFromArchive response = libraryServiceClient.GetBookFromArchive(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAnywhereAsync</summary>
        public async Task GetBookFromAnywhereAsync()
        {
            // Snippet: GetBookFromAnywhereAsync(BookNameOneof,BookName,CallSettings)
            // Additional: GetBookFromAnywhereAsync(BookNameOneof,BookName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            BookName altBookName = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            BookFromAnywhere response = await libraryServiceClient.GetBookFromAnywhereAsync(name, altBookName);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAnywhere</summary>
        public void GetBookFromAnywhere()
        {
            // Snippet: GetBookFromAnywhere(BookNameOneof,BookName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            BookName altBookName = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            BookFromAnywhere response = libraryServiceClient.GetBookFromAnywhere(name, altBookName);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAnywhereAsync</summary>
        public async Task GetBookFromAnywhereAsync_RequestObject()
        {
            // Snippet: GetBookFromAnywhereAsync(GetBookFromAnywhereRequest,CallSettings)
            // Additional: GetBookFromAnywhereAsync(GetBookFromAnywhereRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookFromAnywhereRequest request = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
            };
            // Make the request
            BookFromAnywhere response = await libraryServiceClient.GetBookFromAnywhereAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAnywhere</summary>
        public void GetBookFromAnywhere_RequestObject()
        {
            // Snippet: GetBookFromAnywhere(GetBookFromAnywhereRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookFromAnywhereRequest request = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
            };
            // Make the request
            BookFromAnywhere response = libraryServiceClient.GetBookFromAnywhere(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAbsolutelyAnywhereAsync</summary>
        public async Task GetBookFromAbsolutelyAnywhereAsync()
        {
            // Snippet: GetBookFromAbsolutelyAnywhereAsync(BookNameOneof,CallSettings)
            // Additional: GetBookFromAbsolutelyAnywhereAsync(BookNameOneof,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            // Make the request
            BookFromAnywhere response = await libraryServiceClient.GetBookFromAbsolutelyAnywhereAsync(name);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAbsolutelyAnywhere</summary>
        public void GetBookFromAbsolutelyAnywhere()
        {
            // Snippet: GetBookFromAbsolutelyAnywhere(BookNameOneof,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            // Make the request
            BookFromAnywhere response = libraryServiceClient.GetBookFromAbsolutelyAnywhere(name);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAbsolutelyAnywhereAsync</summary>
        public async Task GetBookFromAbsolutelyAnywhereAsync_RequestObject()
        {
            // Snippet: GetBookFromAbsolutelyAnywhereAsync(GetBookFromAbsolutelyAnywhereRequest,CallSettings)
            // Additional: GetBookFromAbsolutelyAnywhereAsync(GetBookFromAbsolutelyAnywhereRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookFromAbsolutelyAnywhereRequest request = new GetBookFromAbsolutelyAnywhereRequest
            {
                AsResourceName = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
            };
            // Make the request
            BookFromAnywhere response = await libraryServiceClient.GetBookFromAbsolutelyAnywhereAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAbsolutelyAnywhere</summary>
        public void GetBookFromAbsolutelyAnywhere_RequestObject()
        {
            // Snippet: GetBookFromAbsolutelyAnywhere(GetBookFromAbsolutelyAnywhereRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookFromAbsolutelyAnywhereRequest request = new GetBookFromAbsolutelyAnywhereRequest
            {
                AsResourceName = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
            };
            // Make the request
            BookFromAnywhere response = libraryServiceClient.GetBookFromAbsolutelyAnywhere(request);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookIndexAsync</summary>
        public async Task UpdateBookIndexAsync()
        {
            // Snippet: UpdateBookIndexAsync(BookName,string,IDictionary<string, string>,CallSettings)
            // Additional: UpdateBookIndexAsync(BookName,string,IDictionary<string, string>,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            string indexName = "default index";
            IDictionary<string, string> indexMap = new Dictionary<string, string>
            {
                { "default_key", "" },
            };
            // Make the request
            await libraryServiceClient.UpdateBookIndexAsync(name, indexName, indexMap);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookIndex</summary>
        public void UpdateBookIndex()
        {
            // Snippet: UpdateBookIndex(BookName,string,IDictionary<string, string>,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            string indexName = "default index";
            IDictionary<string, string> indexMap = new Dictionary<string, string>
            {
                { "default_key", "" },
            };
            // Make the request
            libraryServiceClient.UpdateBookIndex(name, indexName, indexMap);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookIndexAsync</summary>
        public async Task UpdateBookIndexAsync_RequestObject()
        {
            // Snippet: UpdateBookIndexAsync(UpdateBookIndexRequest,CallSettings)
            // Additional: UpdateBookIndexAsync(UpdateBookIndexRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            UpdateBookIndexRequest request = new UpdateBookIndexRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                IndexName = "default index",
                IndexMap = {
                               { "default_key", "" },
                           },
            };
            // Make the request
            await libraryServiceClient.UpdateBookIndexAsync(request);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookIndex</summary>
        public void UpdateBookIndex_RequestObject()
        {
            // Snippet: UpdateBookIndex(UpdateBookIndexRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            UpdateBookIndexRequest request = new UpdateBookIndexRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                IndexName = "default index",
                IndexMap = {
                               { "default_key", "" },
                           },
            };
            // Make the request
            libraryServiceClient.UpdateBookIndex(request);
            // End snippet
        }

        /// <summary>Snippet for StreamShelves</summary>
        public async Task StreamShelves()
        {
            // Snippet: StreamShelves(StreamShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument
            StreamShelvesRequest request = new StreamShelvesRequest();
            // Make the request, returning a streaming response
            LibraryServiceClient.StreamShelvesStream streamingResponse = libraryServiceClient.StreamShelves(request);

            // Read streaming responses from server until complete
            IAsyncEnumerator<StreamShelvesResponse> responseStream = streamingResponse.ResponseStream;
            while (await responseStream.MoveNext())
            {
                StreamShelvesResponse response = responseStream.Current;
                // Do something with streamed response
            }
            // The response stream has completed
            // End snippet
        }

        /// <summary>Snippet for StreamBooks</summary>
        public async Task StreamBooks()
        {
            // Snippet: StreamBooks(StreamBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument
            StreamBooksRequest request = new StreamBooksRequest
            {
                Name = "",
            };
            // Make the request, returning a streaming response
            LibraryServiceClient.StreamBooksStream streamingResponse = libraryServiceClient.StreamBooks(request);

            // Read streaming responses from server until complete
            IAsyncEnumerator<Book> responseStream = streamingResponse.ResponseStream;
            while (await responseStream.MoveNext())
            {
                Book response = responseStream.Current;
                // Do something with streamed response
            }
            // The response stream has completed
            // End snippet
        }

        /// <summary>Snippet for DiscussBook</summary>
        public async Task DiscussBook()
        {
            // Snippet: DiscussBook(CallSettings,BidirectionalStreamingSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize streaming call, retrieving the stream object
            LibraryServiceClient.DiscussBookStream duplexStream = libraryServiceClient.DiscussBook();

            // Sending requests and retrieving responses can be arbitrarily interleaved.
            // Exact sequence will depend on client/server behavior.

            // Create task to do something with responses from server
            Task responseHandlerTask = Task.Run(async () =>
            {
                IAsyncEnumerator<Comment> responseStream = duplexStream.ResponseStream;
                while (await responseStream.MoveNext())
                {
                    Comment response = responseStream.Current;
                    // Do something with streamed response
                }
                // The response stream has completed
            });

            // Send requests to the server
            bool done = false;
            while (!done)
            {
                // Initialize a request
                DiscussBookRequest request = new DiscussBookRequest
                {
                    Name = "",
                };
                // Stream a request to the server
                await duplexStream.WriteAsync(request);

                // Set "done" to true when sending requests is complete
            }
            // Complete writing requests to the stream
            await duplexStream.WriteCompleteAsync();
            // Await the response handler.
            // This will complete once all server responses have been processed.
            await responseHandlerTask;
            // End snippet
        }

        /// <summary>Snippet for FindRelatedBooksAsync</summary>
        public async Task FindRelatedBooksAsync()
        {
            // Snippet: FindRelatedBooksAsync(IEnumerable<BookName>,IEnumerable<ShelfName>,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            IEnumerable<BookName> names = new[]
            {
                new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            IEnumerable<ShelfName> shelves = new List<ShelfName>();
            // Make the request
            PagedAsyncEnumerable<FindRelatedBooksResponse, BookName> response =
                libraryServiceClient.FindRelatedBooksAsync(names, shelves);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((BookName item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((FindRelatedBooksResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (BookName item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookName> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (BookName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for FindRelatedBooks</summary>
        public void FindRelatedBooks()
        {
            // Snippet: FindRelatedBooks(IEnumerable<BookName>,IEnumerable<ShelfName>,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            IEnumerable<BookName> names = new[]
            {
                new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            IEnumerable<ShelfName> shelves = new List<ShelfName>();
            // Make the request
            PagedEnumerable<FindRelatedBooksResponse, BookName> response =
                libraryServiceClient.FindRelatedBooks(names, shelves);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (BookName item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (FindRelatedBooksResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (BookName item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookName> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (BookName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for FindRelatedBooksAsync</summary>
        public async Task FindRelatedBooksAsync_RequestObject()
        {
            // Snippet: FindRelatedBooksAsync(FindRelatedBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            FindRelatedBooksRequest request = new FindRelatedBooksRequest
            {
                BookNames = {
                                new BookName("[SHELF_ID]", "[BOOK_ID]"),
                            },
                ShelvesAsShelfNames = { },
            };
            // Make the request
            PagedAsyncEnumerable<FindRelatedBooksResponse, BookName> response =
                libraryServiceClient.FindRelatedBooksAsync(request);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((BookName item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((FindRelatedBooksResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (BookName item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookName> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (BookName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for FindRelatedBooks</summary>
        public void FindRelatedBooks_RequestObject()
        {
            // Snippet: FindRelatedBooks(FindRelatedBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            FindRelatedBooksRequest request = new FindRelatedBooksRequest
            {
                BookNames = {
                                new BookName("[SHELF_ID]", "[BOOK_ID]"),
                            },
                ShelvesAsShelfNames = { },
            };
            // Make the request
            PagedEnumerable<FindRelatedBooksResponse, BookName> response =
                libraryServiceClient.FindRelatedBooks(request);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (BookName item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (FindRelatedBooksResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (BookName item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookName> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (BookName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for AddTagAsync</summary>
        public async Task AddTagAsync()
        {
            // Snippet: AddTagAsync(string,string,CallSettings)
            // Additional: AddTagAsync(string,string,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            string formattedResource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString();
            string tag = "";
            // Make the request
            AddTagResponse response = await libraryServiceClient.AddTagAsync(formattedResource, tag);
            // End snippet
        }

        /// <summary>Snippet for AddTag</summary>
        public void AddTag()
        {
            // Snippet: AddTag(string,string,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            string formattedResource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString();
            string tag = "";
            // Make the request
            AddTagResponse response = libraryServiceClient.AddTag(formattedResource, tag);
            // End snippet
        }

        /// <summary>Snippet for AddTagAsync</summary>
        public async Task AddTagAsync_RequestObject()
        {
            // Snippet: AddTagAsync(AddTagRequest,CallSettings)
            // Additional: AddTagAsync(AddTagRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            AddTagRequest request = new AddTagRequest
            {
                Resource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Tag = "",
            };
            // Make the request
            AddTagResponse response = await libraryServiceClient.AddTagAsync(request);
            // End snippet
        }

        /// <summary>Snippet for AddTag</summary>
        public void AddTag_RequestObject()
        {
            // Snippet: AddTag(AddTagRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            AddTagRequest request = new AddTagRequest
            {
                Resource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Tag = "",
            };
            // Make the request
            AddTagResponse response = libraryServiceClient.AddTag(request);
            // End snippet
        }

        /// <summary>Snippet for AddLabelAsync</summary>
        public async Task AddLabelAsync()
        {
            // Snippet: AddLabelAsync(string,string,CallSettings)
            // Additional: AddLabelAsync(string,string,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            string formattedResource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString();
            string label = "";
            // Make the request
            AddLabelResponse response = await libraryServiceClient.AddLabelAsync(formattedResource, label);
            // End snippet
        }

        /// <summary>Snippet for AddLabel</summary>
        public void AddLabel()
        {
            // Snippet: AddLabel(string,string,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            string formattedResource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString();
            string label = "";
            // Make the request
            AddLabelResponse response = libraryServiceClient.AddLabel(formattedResource, label);
            // End snippet
        }

        /// <summary>Snippet for AddLabelAsync</summary>
        public async Task AddLabelAsync_RequestObject()
        {
            // Snippet: AddLabelAsync(AddLabelRequest,CallSettings)
            // Additional: AddLabelAsync(AddLabelRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            AddLabelRequest request = new AddLabelRequest
            {
                Resource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Label = "",
            };
            // Make the request
            AddLabelResponse response = await libraryServiceClient.AddLabelAsync(request);
            // End snippet
        }

        /// <summary>Snippet for AddLabel</summary>
        public void AddLabel_RequestObject()
        {
            // Snippet: AddLabel(AddLabelRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            AddLabelRequest request = new AddLabelRequest
            {
                Resource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Label = "",
            };
            // Make the request
            AddLabelResponse response = libraryServiceClient.AddLabel(request);
            // End snippet
        }

        /// <summary>Snippet for GetBigBookAsync</summary>
        public async Task GetBigBookAsync()
        {
            // Snippet: GetBigBookAsync(BookName,CallSettings)
            // Additional: GetBigBookAsync(BookName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            Operation<Book, GetBigBookMetadata> response =
                await libraryServiceClient.GetBigBookAsync(name);

            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> completedResponse =
                await response.PollUntilCompletedAsync();
            // Retrieve the operation result
            Book result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Book, GetBigBookMetadata> retrievedResponse =
                await libraryServiceClient.PollOnceGetBigBookAsync(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                Book retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigBook</summary>
        public void GetBigBook()
        {
            // Snippet: GetBigBook(BookName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            Operation<Book, GetBigBookMetadata> response =
                libraryServiceClient.GetBigBook(name);

            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> completedResponse =
                response.PollUntilCompleted();
            // Retrieve the operation result
            Book result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Book, GetBigBookMetadata> retrievedResponse =
                libraryServiceClient.PollOnceGetBigBook(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                Book retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigBookAsync</summary>
        public async Task GetBigBookAsync_RequestObject()
        {
            // Snippet: GetBigBookAsync(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            // Make the request
            Operation<Book, GetBigBookMetadata> response =
                await libraryServiceClient.GetBigBookAsync(request);

            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> completedResponse =
                await response.PollUntilCompletedAsync();
            // Retrieve the operation result
            Book result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Book, GetBigBookMetadata> retrievedResponse =
                await libraryServiceClient.PollOnceGetBigBookAsync(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                Book retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigBook</summary>
        public void GetBigBook_RequestObject()
        {
            // Snippet: GetBigBook(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            // Make the request
            Operation<Book, GetBigBookMetadata> response =
                libraryServiceClient.GetBigBook(request);

            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> completedResponse =
                response.PollUntilCompleted();
            // Retrieve the operation result
            Book result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Book, GetBigBookMetadata> retrievedResponse =
                libraryServiceClient.PollOnceGetBigBook(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                Book retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigNothingAsync</summary>
        public async Task GetBigNothingAsync()
        {
            // Snippet: GetBigNothingAsync(BookName,CallSettings)
            // Additional: GetBigNothingAsync(BookName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            Operation<Empty, GetBigBookMetadata> response =
                await libraryServiceClient.GetBigNothingAsync(name);

            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> completedResponse =
                await response.PollUntilCompletedAsync();
            // The long-running operation is now complete.

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Empty, GetBigBookMetadata> retrievedResponse =
                await libraryServiceClient.PollOnceGetBigNothingAsync(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // The long-running operation is now complete.
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigNothing</summary>
        public void GetBigNothing()
        {
            // Snippet: GetBigNothing(BookName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            // Make the request
            Operation<Empty, GetBigBookMetadata> response =
                libraryServiceClient.GetBigNothing(name);

            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> completedResponse =
                response.PollUntilCompleted();
            // The long-running operation is now complete.

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Empty, GetBigBookMetadata> retrievedResponse =
                libraryServiceClient.PollOnceGetBigNothing(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // The long-running operation is now complete.
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigNothingAsync</summary>
        public async Task GetBigNothingAsync_RequestObject()
        {
            // Snippet: GetBigNothingAsync(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            // Make the request
            Operation<Empty, GetBigBookMetadata> response =
                await libraryServiceClient.GetBigNothingAsync(request);

            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> completedResponse =
                await response.PollUntilCompletedAsync();
            // The long-running operation is now complete.

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Empty, GetBigBookMetadata> retrievedResponse =
                await libraryServiceClient.PollOnceGetBigNothingAsync(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // The long-running operation is now complete.
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigNothing</summary>
        public void GetBigNothing_RequestObject()
        {
            // Snippet: GetBigNothing(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            // Make the request
            Operation<Empty, GetBigBookMetadata> response =
                libraryServiceClient.GetBigNothing(request);

            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> completedResponse =
                response.PollUntilCompleted();
            // The long-running operation is now complete.

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Empty, GetBigBookMetadata> retrievedResponse =
                libraryServiceClient.PollOnceGetBigNothing(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // The long-running operation is now complete.
            }
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParamsAsync</summary>
        public async Task TestOptionalRequiredFlatteningParamsAsync1()
        {
            // Snippet: TestOptionalRequiredFlatteningParamsAsync(,CallSettings)
            // Additional: TestOptionalRequiredFlatteningParamsAsync(,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = await libraryServiceClient.TestOptionalRequiredFlatteningParamsAsync();
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParams</summary>
        public void TestOptionalRequiredFlatteningParams1()
        {
            // Snippet: TestOptionalRequiredFlatteningParams(,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = libraryServiceClient.TestOptionalRequiredFlatteningParams();
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParamsAsync</summary>
        public async Task TestOptionalRequiredFlatteningParamsAsync2()
        {
            // Snippet: TestOptionalRequiredFlatteningParamsAsync(int,long,float,double,bool,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookName,BookNameOneof,ProjectName,int,long,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookName>,IEnumerable<BookNameOneof>,IEnumerable<ProjectName>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,int?,long?,float?,double?,bool?,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum?,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookName,BookNameOneof,ProjectName,int?,long?,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookName>,IEnumerable<BookNameOneof>,IEnumerable<ProjectName>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,CallSettings)
            // Additional: TestOptionalRequiredFlatteningParamsAsync(int,long,float,double,bool,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookName,BookNameOneof,ProjectName,int,long,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookName>,IEnumerable<BookNameOneof>,IEnumerable<ProjectName>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,int?,long?,float?,double?,bool?,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum?,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookName,BookNameOneof,ProjectName,int?,long?,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookName>,IEnumerable<BookNameOneof>,IEnumerable<ProjectName>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            int requiredSingularInt32 = 0;
            long requiredSingularInt64 = 0L;
            float requiredSingularFloat = 0.0f;
            double requiredSingularDouble = 0.0;
            bool requiredSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string requiredSingularString = "";
            ByteString requiredSingularBytes = ByteString.Empty;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookName requiredSingularResourceName = new BookName("[SHELF_ID]", "[BOOK_ID]");
            BookNameOneof requiredSingularResourceNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            ProjectName requiredSingularResourceNameCommon = new ProjectName("[PROJECT]");
            int requiredSingularFixed32 = 0;
            long requiredSingularFixed64 = 0L;
            IEnumerable<int> requiredRepeatedInt32 = new List<int>();
            IEnumerable<long> requiredRepeatedInt64 = new List<long>();
            IEnumerable<float> requiredRepeatedFloat = new List<float>();
            IEnumerable<double> requiredRepeatedDouble = new List<double>();
            IEnumerable<bool> requiredRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> requiredRepeatedString = new List<string>();
            IEnumerable<ByteString> requiredRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookName> requiredRepeatedResourceName = new List<BookName>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<ProjectName> requiredRepeatedResourceNameCommon = new List<ProjectName>();
            IEnumerable<int> requiredRepeatedFixed32 = new List<int>();
            IEnumerable<long> requiredRepeatedFixed64 = new List<long>();
            IDictionary<int, string> requiredMap = new Dictionary<int, string>();
            int optionalSingularInt32 = 0;
            long optionalSingularInt64 = 0L;
            float optionalSingularFloat = 0.0f;
            double optionalSingularDouble = 0.0;
            bool optionalSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum optionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string optionalSingularString = "";
            ByteString optionalSingularBytes = ByteString.Empty;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookName optionalSingularResourceName = new BookName("[SHELF_ID]", "[BOOK_ID]");
            BookNameOneof optionalSingularResourceNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            ProjectName optionalSingularResourceNameCommon = new ProjectName("[PROJECT]");
            int optionalSingularFixed32 = 0;
            long optionalSingularFixed64 = 0L;
            IEnumerable<int> optionalRepeatedInt32 = new List<int>();
            IEnumerable<long> optionalRepeatedInt64 = new List<long>();
            IEnumerable<float> optionalRepeatedFloat = new List<float>();
            IEnumerable<double> optionalRepeatedDouble = new List<double>();
            IEnumerable<bool> optionalRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> optionalRepeatedString = new List<string>();
            IEnumerable<ByteString> optionalRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookName> optionalRepeatedResourceName = new List<BookName>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<ProjectName> optionalRepeatedResourceNameCommon = new List<ProjectName>();
            IEnumerable<int> optionalRepeatedFixed32 = new List<int>();
            IEnumerable<long> optionalRepeatedFixed64 = new List<long>();
            IDictionary<int, string> optionalMap = new Dictionary<int, string>();
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = await libraryServiceClient.TestOptionalRequiredFlatteningParamsAsync(requiredSingularInt32, requiredSingularInt64, requiredSingularFloat, requiredSingularDouble, requiredSingularBool, requiredSingularEnum, requiredSingularString, requiredSingularBytes, requiredSingularMessage, requiredSingularResourceName, requiredSingularResourceNameOneof, requiredSingularResourceNameCommon, requiredSingularFixed32, requiredSingularFixed64, requiredRepeatedInt32, requiredRepeatedInt64, requiredRepeatedFloat, requiredRepeatedDouble, requiredRepeatedBool, requiredRepeatedEnum, requiredRepeatedString, requiredRepeatedBytes, requiredRepeatedMessage, requiredRepeatedResourceName, requiredRepeatedResourceNameOneof, requiredRepeatedResourceNameCommon, requiredRepeatedFixed32, requiredRepeatedFixed64, requiredMap, optionalSingularInt32, optionalSingularInt64, optionalSingularFloat, optionalSingularDouble, optionalSingularBool, optionalSingularEnum, optionalSingularString, optionalSingularBytes, optionalSingularMessage, optionalSingularResourceName, optionalSingularResourceNameOneof, optionalSingularResourceNameCommon, optionalSingularFixed32, optionalSingularFixed64, optionalRepeatedInt32, optionalRepeatedInt64, optionalRepeatedFloat, optionalRepeatedDouble, optionalRepeatedBool, optionalRepeatedEnum, optionalRepeatedString, optionalRepeatedBytes, optionalRepeatedMessage, optionalRepeatedResourceName, optionalRepeatedResourceNameOneof, optionalRepeatedResourceNameCommon, optionalRepeatedFixed32, optionalRepeatedFixed64, optionalMap);
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParams</summary>
        public void TestOptionalRequiredFlatteningParams2()
        {
            // Snippet: TestOptionalRequiredFlatteningParams(int,long,float,double,bool,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookName,BookNameOneof,ProjectName,int,long,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookName>,IEnumerable<BookNameOneof>,IEnumerable<ProjectName>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,int?,long?,float?,double?,bool?,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum?,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookName,BookNameOneof,ProjectName,int?,long?,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookName>,IEnumerable<BookNameOneof>,IEnumerable<ProjectName>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            int requiredSingularInt32 = 0;
            long requiredSingularInt64 = 0L;
            float requiredSingularFloat = 0.0f;
            double requiredSingularDouble = 0.0;
            bool requiredSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string requiredSingularString = "";
            ByteString requiredSingularBytes = ByteString.Empty;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookName requiredSingularResourceName = new BookName("[SHELF_ID]", "[BOOK_ID]");
            BookNameOneof requiredSingularResourceNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            ProjectName requiredSingularResourceNameCommon = new ProjectName("[PROJECT]");
            int requiredSingularFixed32 = 0;
            long requiredSingularFixed64 = 0L;
            IEnumerable<int> requiredRepeatedInt32 = new List<int>();
            IEnumerable<long> requiredRepeatedInt64 = new List<long>();
            IEnumerable<float> requiredRepeatedFloat = new List<float>();
            IEnumerable<double> requiredRepeatedDouble = new List<double>();
            IEnumerable<bool> requiredRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> requiredRepeatedString = new List<string>();
            IEnumerable<ByteString> requiredRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookName> requiredRepeatedResourceName = new List<BookName>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<ProjectName> requiredRepeatedResourceNameCommon = new List<ProjectName>();
            IEnumerable<int> requiredRepeatedFixed32 = new List<int>();
            IEnumerable<long> requiredRepeatedFixed64 = new List<long>();
            IDictionary<int, string> requiredMap = new Dictionary<int, string>();
            int optionalSingularInt32 = 0;
            long optionalSingularInt64 = 0L;
            float optionalSingularFloat = 0.0f;
            double optionalSingularDouble = 0.0;
            bool optionalSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum optionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string optionalSingularString = "";
            ByteString optionalSingularBytes = ByteString.Empty;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookName optionalSingularResourceName = new BookName("[SHELF_ID]", "[BOOK_ID]");
            BookNameOneof optionalSingularResourceNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            ProjectName optionalSingularResourceNameCommon = new ProjectName("[PROJECT]");
            int optionalSingularFixed32 = 0;
            long optionalSingularFixed64 = 0L;
            IEnumerable<int> optionalRepeatedInt32 = new List<int>();
            IEnumerable<long> optionalRepeatedInt64 = new List<long>();
            IEnumerable<float> optionalRepeatedFloat = new List<float>();
            IEnumerable<double> optionalRepeatedDouble = new List<double>();
            IEnumerable<bool> optionalRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> optionalRepeatedString = new List<string>();
            IEnumerable<ByteString> optionalRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookName> optionalRepeatedResourceName = new List<BookName>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<ProjectName> optionalRepeatedResourceNameCommon = new List<ProjectName>();
            IEnumerable<int> optionalRepeatedFixed32 = new List<int>();
            IEnumerable<long> optionalRepeatedFixed64 = new List<long>();
            IDictionary<int, string> optionalMap = new Dictionary<int, string>();
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = libraryServiceClient.TestOptionalRequiredFlatteningParams(requiredSingularInt32, requiredSingularInt64, requiredSingularFloat, requiredSingularDouble, requiredSingularBool, requiredSingularEnum, requiredSingularString, requiredSingularBytes, requiredSingularMessage, requiredSingularResourceName, requiredSingularResourceNameOneof, requiredSingularResourceNameCommon, requiredSingularFixed32, requiredSingularFixed64, requiredRepeatedInt32, requiredRepeatedInt64, requiredRepeatedFloat, requiredRepeatedDouble, requiredRepeatedBool, requiredRepeatedEnum, requiredRepeatedString, requiredRepeatedBytes, requiredRepeatedMessage, requiredRepeatedResourceName, requiredRepeatedResourceNameOneof, requiredRepeatedResourceNameCommon, requiredRepeatedFixed32, requiredRepeatedFixed64, requiredMap, optionalSingularInt32, optionalSingularInt64, optionalSingularFloat, optionalSingularDouble, optionalSingularBool, optionalSingularEnum, optionalSingularString, optionalSingularBytes, optionalSingularMessage, optionalSingularResourceName, optionalSingularResourceNameOneof, optionalSingularResourceNameCommon, optionalSingularFixed32, optionalSingularFixed64, optionalRepeatedInt32, optionalRepeatedInt64, optionalRepeatedFloat, optionalRepeatedDouble, optionalRepeatedBool, optionalRepeatedEnum, optionalRepeatedString, optionalRepeatedBytes, optionalRepeatedMessage, optionalRepeatedResourceName, optionalRepeatedResourceNameOneof, optionalRepeatedResourceNameCommon, optionalRepeatedFixed32, optionalRepeatedFixed64, optionalMap);
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParamsAsync</summary>
        public async Task TestOptionalRequiredFlatteningParamsAsync_RequestObject()
        {
            // Snippet: TestOptionalRequiredFlatteningParamsAsync(TestOptionalRequiredFlatteningParamsRequest,CallSettings)
            // Additional: TestOptionalRequiredFlatteningParamsAsync(TestOptionalRequiredFlatteningParamsRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            TestOptionalRequiredFlatteningParamsRequest request = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 0,
                RequiredSingularInt64 = 0L,
                RequiredSingularFloat = 0.0f,
                RequiredSingularDouble = 0.0,
                RequiredSingularBool = false,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "",
                RequiredSingularBytes = ByteString.Empty,
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                RequiredSingularResourceNameCommonAsProjectName = new ProjectName("[PROJECT]"),
                RequiredSingularFixed32 = 0,
                RequiredSingularFixed64 = 0L,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNames = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedResourceNameCommonAsProjectNames = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
            };
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = await libraryServiceClient.TestOptionalRequiredFlatteningParamsAsync(request);
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParams</summary>
        public void TestOptionalRequiredFlatteningParams_RequestObject()
        {
            // Snippet: TestOptionalRequiredFlatteningParams(TestOptionalRequiredFlatteningParamsRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            TestOptionalRequiredFlatteningParamsRequest request = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 0,
                RequiredSingularInt64 = 0L,
                RequiredSingularFloat = 0.0f,
                RequiredSingularDouble = 0.0,
                RequiredSingularBool = false,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "",
                RequiredSingularBytes = ByteString.Empty,
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                RequiredSingularResourceNameCommonAsProjectName = new ProjectName("[PROJECT]"),
                RequiredSingularFixed32 = 0,
                RequiredSingularFixed64 = 0L,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNames = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedResourceNameCommonAsProjectNames = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
            };
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = libraryServiceClient.TestOptionalRequiredFlatteningParams(request);
            // End snippet
        }

    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Tests/Google.Example.Library.V1.Tests.csproj ==============
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>netcoreapp1.0;netcoreapp2.0;net452</TargetFrameworks>
    <TargetFrameworks Condition=" '$(OS)' != 'Windows_NT' ">netcoreapp1.0;netcoreapp2.0</TargetFrameworks>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="15.5.0" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.3.1" />
    <DotNetCliToolReference Include="dotnet-xunit" Version="2.3.1" />
    <PackageReference Include="Moq" Version="4.7.145" />
    <PackageReference Include="xunit" Version="2.3.1" />
    <ProjectReference Include="../Google.Example.Library.V1/Google.Example.Library.V1.csproj" />
  </ItemGroup>

</Project>

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Tests/LibraryServiceClientTest.g.cs ==============
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

namespace Google.Example.Library.V1.Tests
{
    using Google.Api.Gax;
    using Google.Api.Gax.Grpc;
    using Google.Api.Gax.ResourceNames;
    using Google.Cloud.Tagger.V1;
    using apis = Google.Example.Library.V1;
    using Google.LongRunning;
    using Google.Protobuf;
    using Google.Protobuf.WellKnownTypes;
    using Google.Tagger.V1;
    using Grpc.Core;
    using Moq;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Threading;
    using System.Threading.Tasks;
    using Xunit;

    /// <summary>Generated unit tests</summary>
    public class GeneratedLibraryServiceClientTest
    {
        [Fact]
        public void CreateShelf()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateShelfRequest expectedRequest = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.CreateShelf(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf shelf = new Shelf();
            Shelf response = client.CreateShelf(shelf);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task CreateShelfAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateShelfRequest expectedRequest = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.CreateShelfAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf shelf = new Shelf();
            Shelf response = await client.CreateShelfAsync(shelf);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void CreateShelf2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateShelfRequest request = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.CreateShelf(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf response = client.CreateShelf(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task CreateShelfAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateShelfRequest request = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.CreateShelfAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf response = await client.CreateShelfAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetShelf()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest expectedRequest = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelf(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF_ID]");
            Shelf response = client.GetShelf(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetShelfAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest expectedRequest = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelfAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF_ID]");
            Shelf response = await client.GetShelfAsync(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetShelf2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest expectedRequest = new GetShelfRequest
            {
                Name = new ShelfName("[SHELF_ID]").ToString(),
                Message = new SomeMessage(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelf(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            string formattedName = new ShelfName("[SHELF_ID]").ToString();
            SomeMessage message = new SomeMessage();
            Shelf response = client.GetShelf(formattedName, message);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetShelfAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest expectedRequest = new GetShelfRequest
            {
                Name = new ShelfName("[SHELF_ID]").ToString(),
                Message = new SomeMessage(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelfAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            string formattedName = new ShelfName("[SHELF_ID]").ToString();
            SomeMessage message = new SomeMessage();
            Shelf response = await client.GetShelfAsync(formattedName, message);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetShelf3()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest expectedRequest = new GetShelfRequest
            {
                Name = new ShelfName("[SHELF_ID]").ToString(),
                Message = new SomeMessage(),
                StringBuilder = new StringBuilder(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelf(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            string formattedName = new ShelfName("[SHELF_ID]").ToString();
            SomeMessage message = new SomeMessage();
            StringBuilder stringBuilder = new StringBuilder();
            Shelf response = client.GetShelf(formattedName, message, stringBuilder);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetShelfAsync3()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest expectedRequest = new GetShelfRequest
            {
                Name = new ShelfName("[SHELF_ID]").ToString(),
                Message = new SomeMessage(),
                StringBuilder = new StringBuilder(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelfAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            string formattedName = new ShelfName("[SHELF_ID]").ToString();
            SomeMessage message = new SomeMessage();
            StringBuilder stringBuilder = new StringBuilder();
            Shelf response = await client.GetShelfAsync(formattedName, message, stringBuilder);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetShelf4()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest request = new GetShelfRequest
            {
                Name = new ShelfName("[SHELF_ID]").ToString(),
                Options = "options-1249474914",
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelf(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf response = client.GetShelf(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetShelfAsync4()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest request = new GetShelfRequest
            {
                Name = new ShelfName("[SHELF_ID]").ToString(),
                Options = "options-1249474914",
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelfAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf response = await client.GetShelfAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void DeleteShelf()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteShelfRequest expectedRequest = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteShelf(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF_ID]");
            client.DeleteShelf(name);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task DeleteShelfAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteShelfRequest expectedRequest = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteShelfAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF_ID]");
            await client.DeleteShelfAsync(name);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void DeleteShelf2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteShelfRequest request = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteShelf(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            client.DeleteShelf(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task DeleteShelfAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteShelfRequest request = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteShelfAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            await client.DeleteShelfAsync(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void MergeShelves()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MergeShelvesRequest expectedRequest = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.MergeShelves(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF_ID]");
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            Shelf response = client.MergeShelves(name, otherShelfName);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task MergeShelvesAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MergeShelvesRequest expectedRequest = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.MergeShelvesAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF_ID]");
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            Shelf response = await client.MergeShelvesAsync(name, otherShelfName);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void MergeShelves2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MergeShelvesRequest request = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.MergeShelves(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf response = client.MergeShelves(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task MergeShelvesAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MergeShelvesRequest request = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.MergeShelvesAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf response = await client.MergeShelvesAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void CreateBook()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateBookRequest expectedRequest = new CreateBookRequest
            {
                Name = new ShelfName("[SHELF_ID]").ToString(),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.CreateBook(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            string formattedName = new ShelfName("[SHELF_ID]").ToString();
            Book book = new Book();
            Book response = client.CreateBook(formattedName, book);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task CreateBookAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateBookRequest expectedRequest = new CreateBookRequest
            {
                Name = new ShelfName("[SHELF_ID]").ToString(),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.CreateBookAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            string formattedName = new ShelfName("[SHELF_ID]").ToString();
            Book book = new Book();
            Book response = await client.CreateBookAsync(formattedName, book);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void CreateBook2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateBookRequest request = new CreateBookRequest
            {
                Name = new ShelfName("[SHELF_ID]").ToString(),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.CreateBook(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = client.CreateBook(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task CreateBookAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateBookRequest request = new CreateBookRequest
            {
                Name = new ShelfName("[SHELF_ID]").ToString(),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.CreateBookAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = await client.CreateBookAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void PublishSeries()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            PublishSeriesRequest expectedRequest = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                Edition = 1887963714,
                SeriesUuid = new SeriesUuid
                             {
                                 SeriesString = "foobar",
                             },
            };
            PublishSeriesResponse expectedResponse = new PublishSeriesResponse
            {
                BookNames = {
                                "bookNamesElement1491670575",
                            },
            };
            mockGrpcClient.Setup(x => x.PublishSeries(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf shelf = new Shelf();
            IEnumerable<Book> books = new List<Book>();
            uint edition = 1887963714;
            SeriesUuid seriesUuid = new SeriesUuid
            {
                SeriesString = "foobar",
            };
            PublishSeriesResponse response = client.PublishSeries(shelf, books, edition, seriesUuid);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task PublishSeriesAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            PublishSeriesRequest expectedRequest = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                Edition = 1887963714,
                SeriesUuid = new SeriesUuid
                             {
                                 SeriesString = "foobar",
                             },
            };
            PublishSeriesResponse expectedResponse = new PublishSeriesResponse
            {
                BookNames = {
                                "bookNamesElement1491670575",
                            },
            };
            mockGrpcClient.Setup(x => x.PublishSeriesAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<PublishSeriesResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf shelf = new Shelf();
            IEnumerable<Book> books = new List<Book>();
            uint edition = 1887963714;
            SeriesUuid seriesUuid = new SeriesUuid
            {
                SeriesString = "foobar",
            };
            PublishSeriesResponse response = await client.PublishSeriesAsync(shelf, books, edition, seriesUuid);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void PublishSeries2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                SeriesUuid = new SeriesUuid
                             {
                                 SeriesString = "foobar",
                             },
            };
            PublishSeriesResponse expectedResponse = new PublishSeriesResponse
            {
                BookNames = {
                                "bookNamesElement1491670575",
                            },
            };
            mockGrpcClient.Setup(x => x.PublishSeries(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            PublishSeriesResponse response = client.PublishSeries(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task PublishSeriesAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                SeriesUuid = new SeriesUuid
                             {
                                 SeriesString = "foobar",
                             },
            };
            PublishSeriesResponse expectedResponse = new PublishSeriesResponse
            {
                BookNames = {
                                "bookNamesElement1491670575",
                            },
            };
            mockGrpcClient.Setup(x => x.PublishSeriesAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<PublishSeriesResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            PublishSeriesResponse response = await client.PublishSeriesAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBook()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookRequest expectedRequest = new GetBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            Book expectedResponse = new Book
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBook(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            Book response = client.GetBook(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookRequest expectedRequest = new GetBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            Book expectedResponse = new Book
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            Book response = await client.GetBookAsync(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBook2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookRequest request = new GetBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            Book expectedResponse = new Book
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBook(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = client.GetBook(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookRequest request = new GetBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            Book expectedResponse = new Book
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = await client.GetBookAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void DeleteBook()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteBookRequest expectedRequest = new DeleteBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteBook(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            client.DeleteBook(name);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task DeleteBookAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteBookRequest expectedRequest = new DeleteBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteBookAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            await client.DeleteBookAsync(name);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void DeleteBook2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteBookRequest request = new DeleteBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteBook(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            client.DeleteBook(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task DeleteBookAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteBookRequest request = new DeleteBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteBookAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            await client.DeleteBookAsync(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void UpdateBook()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookRequest expectedRequest = new UpdateBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.UpdateBook(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            Book book = new Book();
            Book response = client.UpdateBook(name, book);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task UpdateBookAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookRequest expectedRequest = new UpdateBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.UpdateBookAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            Book book = new Book();
            Book response = await client.UpdateBookAsync(name, book);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void UpdateBook2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookRequest expectedRequest = new UpdateBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                OptionalFoo = "optionalFoo1822578535",
                Book = new Book(),
                UpdateMask = new FieldMask(),
                PhysicalMask = new apis::FieldMask(),
            };
            Book expectedResponse = new Book
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.UpdateBook(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            string optionalFoo = "optionalFoo1822578535";
            Book book = new Book();
            FieldMask updateMask = new FieldMask();
            apis::FieldMask physicalMask = new apis::FieldMask();
            Book response = client.UpdateBook(name, optionalFoo, book, updateMask, physicalMask);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task UpdateBookAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookRequest expectedRequest = new UpdateBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                OptionalFoo = "optionalFoo1822578535",
                Book = new Book(),
                UpdateMask = new FieldMask(),
                PhysicalMask = new apis::FieldMask(),
            };
            Book expectedResponse = new Book
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.UpdateBookAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            string optionalFoo = "optionalFoo1822578535";
            Book book = new Book();
            FieldMask updateMask = new FieldMask();
            apis::FieldMask physicalMask = new apis::FieldMask();
            Book response = await client.UpdateBookAsync(name, optionalFoo, book, updateMask, physicalMask);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void UpdateBook3()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookRequest request = new UpdateBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.UpdateBook(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = client.UpdateBook(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task UpdateBookAsync3()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookRequest request = new UpdateBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.UpdateBookAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = await client.UpdateBookAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void MoveBook()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MoveBookRequest expectedRequest = new MoveBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            Book expectedResponse = new Book
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.MoveBook(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            Book response = client.MoveBook(name, otherShelfName);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task MoveBookAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MoveBookRequest expectedRequest = new MoveBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            Book expectedResponse = new Book
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.MoveBookAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            Book response = await client.MoveBookAsync(name, otherShelfName);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void MoveBook2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MoveBookRequest request = new MoveBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            Book expectedResponse = new Book
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.MoveBook(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = client.MoveBook(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task MoveBookAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MoveBookRequest request = new MoveBookRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            Book expectedResponse = new Book
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.MoveBookAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = await client.MoveBookAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void AddComments()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            AddCommentsRequest expectedRequest = new AddCommentsRequest
            {
                Name = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Comments = {
                               new Comment
                               {
                                   Comment = ByteString.CopyFromUtf8("95"),
                                   Stage = Comment.Types.Stage.Unset,
                                   Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                               },
                           },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.AddComments(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            string formattedName = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString();
            IEnumerable<Comment> comments = new[]
            {
                new Comment
                {
                    Comment = ByteString.CopyFromUtf8("95"),
                    Stage = Comment.Types.Stage.Unset,
                    Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                },
            };
            client.AddComments(formattedName, comments);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task AddCommentsAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            AddCommentsRequest expectedRequest = new AddCommentsRequest
            {
                Name = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Comments = {
                               new Comment
                               {
                                   Comment = ByteString.CopyFromUtf8("95"),
                                   Stage = Comment.Types.Stage.Unset,
                                   Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                               },
                           },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.AddCommentsAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            string formattedName = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString();
            IEnumerable<Comment> comments = new[]
            {
                new Comment
                {
                    Comment = ByteString.CopyFromUtf8("95"),
                    Stage = Comment.Types.Stage.Unset,
                    Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                },
            };
            await client.AddCommentsAsync(formattedName, comments);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void AddComments2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            AddCommentsRequest request = new AddCommentsRequest
            {
                Name = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Comments = {
                               new Comment
                               {
                                   Comment = ByteString.CopyFromUtf8("95"),
                                   Stage = Comment.Types.Stage.Unset,
                                   Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                               },
                           },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.AddComments(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            client.AddComments(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task AddCommentsAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            AddCommentsRequest request = new AddCommentsRequest
            {
                Name = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Comments = {
                               new Comment
                               {
                                   Comment = ByteString.CopyFromUtf8("95"),
                                   Stage = Comment.Types.Stage.Unset,
                                   Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                               },
                           },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.AddCommentsAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            await client.AddCommentsAsync(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBookFromArchive()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromArchiveRequest expectedRequest = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE_PATH]", "[BOOK_ID]"),
            };
            BookFromArchive expectedResponse = new BookFromArchive
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE_PATH]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromArchive(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ArchivedBookName name = new ArchivedBookName("[ARCHIVE_PATH]", "[BOOK_ID]");
            BookFromArchive response = client.GetBookFromArchive(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookFromArchiveAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromArchiveRequest expectedRequest = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE_PATH]", "[BOOK_ID]"),
            };
            BookFromArchive expectedResponse = new BookFromArchive
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE_PATH]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromArchiveAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<BookFromArchive>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ArchivedBookName name = new ArchivedBookName("[ARCHIVE_PATH]", "[BOOK_ID]");
            BookFromArchive response = await client.GetBookFromArchiveAsync(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBookFromArchive2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromArchiveRequest request = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE_PATH]", "[BOOK_ID]"),
            };
            BookFromArchive expectedResponse = new BookFromArchive
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE_PATH]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromArchive(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookFromArchive response = client.GetBookFromArchive(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookFromArchiveAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromArchiveRequest request = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE_PATH]", "[BOOK_ID]"),
            };
            BookFromArchive expectedResponse = new BookFromArchive
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE_PATH]", "[BOOK_ID]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromArchiveAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<BookFromArchive>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookFromArchive response = await client.GetBookFromArchiveAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBookFromAnywhere()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAnywhereRequest expectedRequest = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAnywhere(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            BookName altBookName = new BookName("[SHELF_ID]", "[BOOK_ID]");
            BookFromAnywhere response = client.GetBookFromAnywhere(name, altBookName);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookFromAnywhereAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAnywhereRequest expectedRequest = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAnywhereAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<BookFromAnywhere>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            BookName altBookName = new BookName("[SHELF_ID]", "[BOOK_ID]");
            BookFromAnywhere response = await client.GetBookFromAnywhereAsync(name, altBookName);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBookFromAnywhere2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAnywhereRequest request = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAnywhere(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookFromAnywhere response = client.GetBookFromAnywhere(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookFromAnywhereAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAnywhereRequest request = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAnywhereAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<BookFromAnywhere>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookFromAnywhere response = await client.GetBookFromAnywhereAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBookFromAbsolutelyAnywhere()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAbsolutelyAnywhereRequest expectedRequest = new GetBookFromAbsolutelyAnywhereRequest
            {
                AsResourceName = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAbsolutelyAnywhere(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            BookFromAnywhere response = client.GetBookFromAbsolutelyAnywhere(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookFromAbsolutelyAnywhereAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAbsolutelyAnywhereRequest expectedRequest = new GetBookFromAbsolutelyAnywhereRequest
            {
                AsResourceName = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAbsolutelyAnywhereAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<BookFromAnywhere>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            BookFromAnywhere response = await client.GetBookFromAbsolutelyAnywhereAsync(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBookFromAbsolutelyAnywhere2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAbsolutelyAnywhereRequest request = new GetBookFromAbsolutelyAnywhereRequest
            {
                AsResourceName = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAbsolutelyAnywhere(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookFromAnywhere response = client.GetBookFromAbsolutelyAnywhere(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookFromAbsolutelyAnywhereAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAbsolutelyAnywhereRequest request = new GetBookFromAbsolutelyAnywhereRequest
            {
                AsResourceName = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAbsolutelyAnywhereAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<BookFromAnywhere>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookFromAnywhere response = await client.GetBookFromAbsolutelyAnywhereAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void UpdateBookIndex()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookIndexRequest expectedRequest = new UpdateBookIndexRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                IndexName = "default index",
                IndexMap = {
                               { "default_key", "indexMapItem1918721251" },
                           },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.UpdateBookIndex(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            string indexName = "default index";
            IDictionary<string, string> indexMap = new Dictionary<string, string>
            {
                { "default_key", "indexMapItem1918721251" },
            };
            client.UpdateBookIndex(name, indexName, indexMap);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task UpdateBookIndexAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookIndexRequest expectedRequest = new UpdateBookIndexRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                IndexName = "default index",
                IndexMap = {
                               { "default_key", "indexMapItem1918721251" },
                           },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.UpdateBookIndexAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookName name = new BookName("[SHELF_ID]", "[BOOK_ID]");
            string indexName = "default index";
            IDictionary<string, string> indexMap = new Dictionary<string, string>
            {
                { "default_key", "indexMapItem1918721251" },
            };
            await client.UpdateBookIndexAsync(name, indexName, indexMap);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void UpdateBookIndex2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookIndexRequest request = new UpdateBookIndexRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                IndexName = "default index",
                IndexMap = {
                               { "default_key", "indexMapItem1918721251" },
                           },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.UpdateBookIndex(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            client.UpdateBookIndex(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task UpdateBookIndexAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookIndexRequest request = new UpdateBookIndexRequest
            {
                BookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                IndexName = "default index",
                IndexMap = {
                               { "default_key", "indexMapItem1918721251" },
                           },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.UpdateBookIndexAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            await client.UpdateBookIndexAsync(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void AddTag()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            AddTagRequest expectedRequest = new AddTagRequest
            {
                Resource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Tag = "tag114586",
            };
            AddTagResponse expectedResponse = new AddTagResponse();
            mockGrpcClient.Setup(x => x.AddTag(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            string formattedResource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString();
            string tag = "tag114586";
            AddTagResponse response = client.AddTag(formattedResource, tag);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task AddTagAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            AddTagRequest expectedRequest = new AddTagRequest
            {
                Resource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Tag = "tag114586",
            };
            AddTagResponse expectedResponse = new AddTagResponse();
            mockGrpcClient.Setup(x => x.AddTagAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<AddTagResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            string formattedResource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString();
            string tag = "tag114586";
            AddTagResponse response = await client.AddTagAsync(formattedResource, tag);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void AddTag2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            AddTagRequest request = new AddTagRequest
            {
                Resource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Tag = "tag114586",
            };
            AddTagResponse expectedResponse = new AddTagResponse();
            mockGrpcClient.Setup(x => x.AddTag(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            AddTagResponse response = client.AddTag(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task AddTagAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            AddTagRequest request = new AddTagRequest
            {
                Resource = new BookName("[SHELF_ID]", "[BOOK_ID]").ToString(),
                Tag = "tag114586",
            };
            AddTagResponse expectedResponse = new AddTagResponse();
            mockGrpcClient.Setup(x => x.AddTagAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<AddTagResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            AddTagResponse response = await client.AddTagAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void TestOptionalRequiredFlatteningParams()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            TestOptionalRequiredFlatteningParamsRequest expectedRequest = new TestOptionalRequiredFlatteningParamsRequest();
            TestOptionalRequiredFlatteningParamsResponse expectedResponse = new TestOptionalRequiredFlatteningParamsResponse();
            mockGrpcClient.Setup(x => x.TestOptionalRequiredFlatteningParams(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);

            TestOptionalRequiredFlatteningParamsResponse response = client.TestOptionalRequiredFlatteningParams();
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task TestOptionalRequiredFlatteningParamsAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            TestOptionalRequiredFlatteningParamsRequest expectedRequest = new TestOptionalRequiredFlatteningParamsRequest();
            TestOptionalRequiredFlatteningParamsResponse expectedResponse = new TestOptionalRequiredFlatteningParamsResponse();
            mockGrpcClient.Setup(x => x.TestOptionalRequiredFlatteningParamsAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<TestOptionalRequiredFlatteningParamsResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);

            TestOptionalRequiredFlatteningParamsResponse response = await client.TestOptionalRequiredFlatteningParamsAsync();
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void TestOptionalRequiredFlatteningParams2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            TestOptionalRequiredFlatteningParamsRequest expectedRequest = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 72313594,
                RequiredSingularInt64 = 72313499L,
                RequiredSingularFloat = -7514705.0f,
                RequiredSingularDouble = 1.9111005E8,
                RequiredSingularBool = true,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "requiredSingularString-1949894503",
                RequiredSingularBytes = ByteString.CopyFromUtf8("-29"),
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                RequiredSingularResourceNameCommonAsProjectName = new ProjectName("[PROJECT]"),
                RequiredSingularFixed32 = 720656715,
                RequiredSingularFixed64 = 720656810,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNames = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedResourceNameCommonAsProjectNames = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
                OptionalSingularInt32 = 1196565723,
                OptionalSingularInt64 = 1196565628L,
                OptionalSingularFloat = -1.19939918E8f,
                OptionalSingularDouble = 1.41902287E8,
                OptionalSingularBool = false,
                OptionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                OptionalSingularString = "optionalSingularString1852995162",
                OptionalSingularBytes = ByteString.CopyFromUtf8("2"),
                OptionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                OptionalSingularResourceNameAsBookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                OptionalSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                OptionalSingularResourceNameCommonAsProjectName = new ProjectName("[PROJECT]"),
                OptionalSingularFixed32 = 1648847958,
                OptionalSingularFixed64 = 1648847863,
                OptionalRepeatedInt32 = { },
                OptionalRepeatedInt64 = { },
                OptionalRepeatedFloat = { },
                OptionalRepeatedDouble = { },
                OptionalRepeatedBool = { },
                OptionalRepeatedEnum = { },
                OptionalRepeatedString = { },
                OptionalRepeatedBytes = { },
                OptionalRepeatedMessage = { },
                OptionalRepeatedResourceNameAsBookNames = { },
                OptionalRepeatedResourceNameOneofAsBookNameOneofs = { },
                OptionalRepeatedResourceNameCommonAsProjectNames = { },
                OptionalRepeatedFixed32 = { },
                OptionalRepeatedFixed64 = { },
                OptionalMap = { },
            };
            TestOptionalRequiredFlatteningParamsResponse expectedResponse = new TestOptionalRequiredFlatteningParamsResponse();
            mockGrpcClient.Setup(x => x.TestOptionalRequiredFlatteningParams(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            int requiredSingularInt32 = 72313594;
            long requiredSingularInt64 = 72313499L;
            float requiredSingularFloat = -7514705.0f;
            double requiredSingularDouble = 1.9111005E8;
            bool requiredSingularBool = true;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string requiredSingularString = "requiredSingularString-1949894503";
            ByteString requiredSingularBytes = ByteString.CopyFromUtf8("-29");
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookName requiredSingularResourceName = new BookName("[SHELF_ID]", "[BOOK_ID]");
            BookNameOneof requiredSingularResourceNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            ProjectName requiredSingularResourceNameCommon = new ProjectName("[PROJECT]");
            int requiredSingularFixed32 = 720656715;
            long requiredSingularFixed64 = 720656810;
            IEnumerable<int> requiredRepeatedInt32 = new List<int>();
            IEnumerable<long> requiredRepeatedInt64 = new List<long>();
            IEnumerable<float> requiredRepeatedFloat = new List<float>();
            IEnumerable<double> requiredRepeatedDouble = new List<double>();
            IEnumerable<bool> requiredRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> requiredRepeatedString = new List<string>();
            IEnumerable<ByteString> requiredRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookName> requiredRepeatedResourceName = new List<BookName>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<ProjectName> requiredRepeatedResourceNameCommon = new List<ProjectName>();
            IEnumerable<int> requiredRepeatedFixed32 = new List<int>();
            IEnumerable<long> requiredRepeatedFixed64 = new List<long>();
            IDictionary<int, string> requiredMap = new Dictionary<int, string>();
            int optionalSingularInt32 = 1196565723;
            long optionalSingularInt64 = 1196565628L;
            float optionalSingularFloat = -1.19939918E8f;
            double optionalSingularDouble = 1.41902287E8;
            bool optionalSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum optionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string optionalSingularString = "optionalSingularString1852995162";
            ByteString optionalSingularBytes = ByteString.CopyFromUtf8("2");
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookName optionalSingularResourceName = new BookName("[SHELF_ID]", "[BOOK_ID]");
            BookNameOneof optionalSingularResourceNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            ProjectName optionalSingularResourceNameCommon = new ProjectName("[PROJECT]");
            int optionalSingularFixed32 = 1648847958;
            long optionalSingularFixed64 = 1648847863;
            IEnumerable<int> optionalRepeatedInt32 = new List<int>();
            IEnumerable<long> optionalRepeatedInt64 = new List<long>();
            IEnumerable<float> optionalRepeatedFloat = new List<float>();
            IEnumerable<double> optionalRepeatedDouble = new List<double>();
            IEnumerable<bool> optionalRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> optionalRepeatedString = new List<string>();
            IEnumerable<ByteString> optionalRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookName> optionalRepeatedResourceName = new List<BookName>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<ProjectName> optionalRepeatedResourceNameCommon = new List<ProjectName>();
            IEnumerable<int> optionalRepeatedFixed32 = new List<int>();
            IEnumerable<long> optionalRepeatedFixed64 = new List<long>();
            IDictionary<int, string> optionalMap = new Dictionary<int, string>();
            TestOptionalRequiredFlatteningParamsResponse response = client.TestOptionalRequiredFlatteningParams(requiredSingularInt32, requiredSingularInt64, requiredSingularFloat, requiredSingularDouble, requiredSingularBool, requiredSingularEnum, requiredSingularString, requiredSingularBytes, requiredSingularMessage, requiredSingularResourceName, requiredSingularResourceNameOneof, requiredSingularResourceNameCommon, requiredSingularFixed32, requiredSingularFixed64, requiredRepeatedInt32, requiredRepeatedInt64, requiredRepeatedFloat, requiredRepeatedDouble, requiredRepeatedBool, requiredRepeatedEnum, requiredRepeatedString, requiredRepeatedBytes, requiredRepeatedMessage, requiredRepeatedResourceName, requiredRepeatedResourceNameOneof, requiredRepeatedResourceNameCommon, requiredRepeatedFixed32, requiredRepeatedFixed64, requiredMap, optionalSingularInt32, optionalSingularInt64, optionalSingularFloat, optionalSingularDouble, optionalSingularBool, optionalSingularEnum, optionalSingularString, optionalSingularBytes, optionalSingularMessage, optionalSingularResourceName, optionalSingularResourceNameOneof, optionalSingularResourceNameCommon, optionalSingularFixed32, optionalSingularFixed64, optionalRepeatedInt32, optionalRepeatedInt64, optionalRepeatedFloat, optionalRepeatedDouble, optionalRepeatedBool, optionalRepeatedEnum, optionalRepeatedString, optionalRepeatedBytes, optionalRepeatedMessage, optionalRepeatedResourceName, optionalRepeatedResourceNameOneof, optionalRepeatedResourceNameCommon, optionalRepeatedFixed32, optionalRepeatedFixed64, optionalMap);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task TestOptionalRequiredFlatteningParamsAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            TestOptionalRequiredFlatteningParamsRequest expectedRequest = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 72313594,
                RequiredSingularInt64 = 72313499L,
                RequiredSingularFloat = -7514705.0f,
                RequiredSingularDouble = 1.9111005E8,
                RequiredSingularBool = true,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "requiredSingularString-1949894503",
                RequiredSingularBytes = ByteString.CopyFromUtf8("-29"),
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                RequiredSingularResourceNameCommonAsProjectName = new ProjectName("[PROJECT]"),
                RequiredSingularFixed32 = 720656715,
                RequiredSingularFixed64 = 720656810,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNames = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedResourceNameCommonAsProjectNames = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
                OptionalSingularInt32 = 1196565723,
                OptionalSingularInt64 = 1196565628L,
                OptionalSingularFloat = -1.19939918E8f,
                OptionalSingularDouble = 1.41902287E8,
                OptionalSingularBool = false,
                OptionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                OptionalSingularString = "optionalSingularString1852995162",
                OptionalSingularBytes = ByteString.CopyFromUtf8("2"),
                OptionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                OptionalSingularResourceNameAsBookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                OptionalSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                OptionalSingularResourceNameCommonAsProjectName = new ProjectName("[PROJECT]"),
                OptionalSingularFixed32 = 1648847958,
                OptionalSingularFixed64 = 1648847863,
                OptionalRepeatedInt32 = { },
                OptionalRepeatedInt64 = { },
                OptionalRepeatedFloat = { },
                OptionalRepeatedDouble = { },
                OptionalRepeatedBool = { },
                OptionalRepeatedEnum = { },
                OptionalRepeatedString = { },
                OptionalRepeatedBytes = { },
                OptionalRepeatedMessage = { },
                OptionalRepeatedResourceNameAsBookNames = { },
                OptionalRepeatedResourceNameOneofAsBookNameOneofs = { },
                OptionalRepeatedResourceNameCommonAsProjectNames = { },
                OptionalRepeatedFixed32 = { },
                OptionalRepeatedFixed64 = { },
                OptionalMap = { },
            };
            TestOptionalRequiredFlatteningParamsResponse expectedResponse = new TestOptionalRequiredFlatteningParamsResponse();
            mockGrpcClient.Setup(x => x.TestOptionalRequiredFlatteningParamsAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<TestOptionalRequiredFlatteningParamsResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            int requiredSingularInt32 = 72313594;
            long requiredSingularInt64 = 72313499L;
            float requiredSingularFloat = -7514705.0f;
            double requiredSingularDouble = 1.9111005E8;
            bool requiredSingularBool = true;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string requiredSingularString = "requiredSingularString-1949894503";
            ByteString requiredSingularBytes = ByteString.CopyFromUtf8("-29");
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookName requiredSingularResourceName = new BookName("[SHELF_ID]", "[BOOK_ID]");
            BookNameOneof requiredSingularResourceNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            ProjectName requiredSingularResourceNameCommon = new ProjectName("[PROJECT]");
            int requiredSingularFixed32 = 720656715;
            long requiredSingularFixed64 = 720656810;
            IEnumerable<int> requiredRepeatedInt32 = new List<int>();
            IEnumerable<long> requiredRepeatedInt64 = new List<long>();
            IEnumerable<float> requiredRepeatedFloat = new List<float>();
            IEnumerable<double> requiredRepeatedDouble = new List<double>();
            IEnumerable<bool> requiredRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> requiredRepeatedString = new List<string>();
            IEnumerable<ByteString> requiredRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookName> requiredRepeatedResourceName = new List<BookName>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<ProjectName> requiredRepeatedResourceNameCommon = new List<ProjectName>();
            IEnumerable<int> requiredRepeatedFixed32 = new List<int>();
            IEnumerable<long> requiredRepeatedFixed64 = new List<long>();
            IDictionary<int, string> requiredMap = new Dictionary<int, string>();
            int optionalSingularInt32 = 1196565723;
            long optionalSingularInt64 = 1196565628L;
            float optionalSingularFloat = -1.19939918E8f;
            double optionalSingularDouble = 1.41902287E8;
            bool optionalSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum optionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string optionalSingularString = "optionalSingularString1852995162";
            ByteString optionalSingularBytes = ByteString.CopyFromUtf8("2");
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookName optionalSingularResourceName = new BookName("[SHELF_ID]", "[BOOK_ID]");
            BookNameOneof optionalSingularResourceNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]"));
            ProjectName optionalSingularResourceNameCommon = new ProjectName("[PROJECT]");
            int optionalSingularFixed32 = 1648847958;
            long optionalSingularFixed64 = 1648847863;
            IEnumerable<int> optionalRepeatedInt32 = new List<int>();
            IEnumerable<long> optionalRepeatedInt64 = new List<long>();
            IEnumerable<float> optionalRepeatedFloat = new List<float>();
            IEnumerable<double> optionalRepeatedDouble = new List<double>();
            IEnumerable<bool> optionalRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> optionalRepeatedString = new List<string>();
            IEnumerable<ByteString> optionalRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookName> optionalRepeatedResourceName = new List<BookName>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<ProjectName> optionalRepeatedResourceNameCommon = new List<ProjectName>();
            IEnumerable<int> optionalRepeatedFixed32 = new List<int>();
            IEnumerable<long> optionalRepeatedFixed64 = new List<long>();
            IDictionary<int, string> optionalMap = new Dictionary<int, string>();
            TestOptionalRequiredFlatteningParamsResponse response = await client.TestOptionalRequiredFlatteningParamsAsync(requiredSingularInt32, requiredSingularInt64, requiredSingularFloat, requiredSingularDouble, requiredSingularBool, requiredSingularEnum, requiredSingularString, requiredSingularBytes, requiredSingularMessage, requiredSingularResourceName, requiredSingularResourceNameOneof, requiredSingularResourceNameCommon, requiredSingularFixed32, requiredSingularFixed64, requiredRepeatedInt32, requiredRepeatedInt64, requiredRepeatedFloat, requiredRepeatedDouble, requiredRepeatedBool, requiredRepeatedEnum, requiredRepeatedString, requiredRepeatedBytes, requiredRepeatedMessage, requiredRepeatedResourceName, requiredRepeatedResourceNameOneof, requiredRepeatedResourceNameCommon, requiredRepeatedFixed32, requiredRepeatedFixed64, requiredMap, optionalSingularInt32, optionalSingularInt64, optionalSingularFloat, optionalSingularDouble, optionalSingularBool, optionalSingularEnum, optionalSingularString, optionalSingularBytes, optionalSingularMessage, optionalSingularResourceName, optionalSingularResourceNameOneof, optionalSingularResourceNameCommon, optionalSingularFixed32, optionalSingularFixed64, optionalRepeatedInt32, optionalRepeatedInt64, optionalRepeatedFloat, optionalRepeatedDouble, optionalRepeatedBool, optionalRepeatedEnum, optionalRepeatedString, optionalRepeatedBytes, optionalRepeatedMessage, optionalRepeatedResourceName, optionalRepeatedResourceNameOneof, optionalRepeatedResourceNameCommon, optionalRepeatedFixed32, optionalRepeatedFixed64, optionalMap);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void TestOptionalRequiredFlatteningParams3()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            TestOptionalRequiredFlatteningParamsRequest request = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 72313594,
                RequiredSingularInt64 = 72313499L,
                RequiredSingularFloat = -7514705.0f,
                RequiredSingularDouble = 1.9111005E8,
                RequiredSingularBool = true,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "requiredSingularString-1949894503",
                RequiredSingularBytes = ByteString.CopyFromUtf8("-29"),
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                RequiredSingularResourceNameCommonAsProjectName = new ProjectName("[PROJECT]"),
                RequiredSingularFixed32 = 720656715,
                RequiredSingularFixed64 = 720656810,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNames = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedResourceNameCommonAsProjectNames = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
            };
            TestOptionalRequiredFlatteningParamsResponse expectedResponse = new TestOptionalRequiredFlatteningParamsResponse();
            mockGrpcClient.Setup(x => x.TestOptionalRequiredFlatteningParams(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            TestOptionalRequiredFlatteningParamsResponse response = client.TestOptionalRequiredFlatteningParams(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task TestOptionalRequiredFlatteningParamsAsync3()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            TestOptionalRequiredFlatteningParamsRequest request = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 72313594,
                RequiredSingularInt64 = 72313499L,
                RequiredSingularFloat = -7514705.0f,
                RequiredSingularDouble = 1.9111005E8,
                RequiredSingularBool = true,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "requiredSingularString-1949894503",
                RequiredSingularBytes = ByteString.CopyFromUtf8("-29"),
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookName = new BookName("[SHELF_ID]", "[BOOK_ID]"),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookName("[SHELF_ID]", "[BOOK_ID]")),
                RequiredSingularResourceNameCommonAsProjectName = new ProjectName("[PROJECT]"),
                RequiredSingularFixed32 = 720656715,
                RequiredSingularFixed64 = 720656810,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNames = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedResourceNameCommonAsProjectNames = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
            };
            TestOptionalRequiredFlatteningParamsResponse expectedResponse = new TestOptionalRequiredFlatteningParamsResponse();
            mockGrpcClient.Setup(x => x.TestOptionalRequiredFlatteningParamsAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<TestOptionalRequiredFlatteningParamsResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            TestOptionalRequiredFlatteningParamsResponse response = await client.TestOptionalRequiredFlatteningParamsAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1/Google.Example.Library.V1.csproj ==============
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>

    <!-- TODO: Version defaults to 1.0.0, edit as required -->
    <Version>1.0.0</Version>

    <!-- TODO: NuGet packaging options -->
    <!--
      <Description>
        Google Example Library API
        A simple Google Example Library API.
      </Description>
      <PackageTags>PubSub;Google;Cloud</PackageTags>
      <Copyright>Copyright 2018 Google LLC</Copyright>
      <Authors>Google LLC</Authors>
      *** TODO: These Icon, License, Project, and repo settings *MUST* be checked and edited ***
      *** The values given are just examples ***
      <PackageIconUrl>TODO: https://cloud.google.com/images/gcp-icon-64x64.png</PackageIconUrl>
      <PackageLicenseUrl>TODO: https://www.apache.org/licenses/LICENSE-2.0</PackageLicenseUrl>
      <PackageProjectUrl>TODO: https://github.com/GoogleCloudPlatform/google-cloud-dotnet</PackageProjectUrl>
      <RepositoryType>TODO: git</RepositoryType>
      <RepositoryUrl>TODO: https://github.com/GoogleCloudPlatform/google-cloud-dotnet</RepositoryUrl>
    -->

    <!-- TODO: Configure package signing -->
    <!--
      <AssemblyOriginatorKeyFile>...</AssemblyOriginatorKeyFile>
      <SignAssembly>true</SignAssembly>
      <PublicSign Condition=" '$(OS)' != 'Windows_NT' ">true</PublicSign>
    -->

    <!-- These items should not require editing -->
    <TargetFrameworks>netstandard1.5;net45</TargetFrameworks>
    <TargetFrameworks Condition=" '$(OS)' != 'Windows_NT' ">netstandard1.5</TargetFrameworks>
    <LangVersion>latest</LangVersion>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <Deterministic>true</Deterministic>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>

  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Google.Api.Gax.Grpc" Version="2.1.0" />
    <PackageReference Include="Grpc.Core" Version="1.6.1" />
  </ItemGroup>

</Project>

============== file: Google.Example.Library.V1/Google.Example.Library.V1/LibraryServiceClient.cs ==============
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

using gax = Google.Api.Gax;
using gaxgrpc = Google.Api.Gax.Grpc;
using gaxres = Google.Api.Gax.ResourceNames;
using gctv = Google.Cloud.Tagger.V1;
using lro = Google.LongRunning;
using pb = Google.Protobuf;
using pbwkt = Google.Protobuf.WellKnownTypes;
using gtv = Google.Tagger.V1;
using grpccore = Grpc.Core;
using sys = System;
using sc = System.Collections;
using scg = System.Collections.Generic;
using sco = System.Collections.ObjectModel;
using linq = System.Linq;
using st = System.Threading;
using stt = System.Threading.Tasks;

namespace Google.Example.Library.V1
{
    /// <summary>
    /// Settings for a <see cref="LibraryServiceClient"/>.
    /// </summary>
    public sealed partial class LibraryServiceSettings : gaxgrpc::ServiceSettingsBase
    {
        /// <summary>
        /// Get a new instance of the default <see cref="LibraryServiceSettings"/>.
        /// </summary>
        /// <returns>
        /// A new instance of the default <see cref="LibraryServiceSettings"/>.
        /// </returns>
        public static LibraryServiceSettings GetDefault() => new LibraryServiceSettings();

        /// <summary>
        /// Constructs a new <see cref="LibraryServiceSettings"/> object with default settings.
        /// </summary>
        public LibraryServiceSettings() { }

        private LibraryServiceSettings(LibraryServiceSettings existing) : base(existing)
        {
            gax::GaxPreconditions.CheckNotNull(existing, nameof(existing));
            CreateShelfSettings = existing.CreateShelfSettings;
            GetShelfSettings = existing.GetShelfSettings;
            ListShelvesSettings = existing.ListShelvesSettings;
            DeleteShelfSettings = existing.DeleteShelfSettings;
            MergeShelvesSettings = existing.MergeShelvesSettings;
            CreateBookSettings = existing.CreateBookSettings;
            PublishSeriesSettings = existing.PublishSeriesSettings;
            GetBookSettings = existing.GetBookSettings;
            ListBooksSettings = existing.ListBooksSettings;
            DeleteBookSettings = existing.DeleteBookSettings;
            UpdateBookSettings = existing.UpdateBookSettings;
            MoveBookSettings = existing.MoveBookSettings;
            ListStringsSettings = existing.ListStringsSettings;
            AddCommentsSettings = existing.AddCommentsSettings;
            GetBookFromArchiveSettings = existing.GetBookFromArchiveSettings;
            GetBookFromAnywhereSettings = existing.GetBookFromAnywhereSettings;
            GetBookFromAbsolutelyAnywhereSettings = existing.GetBookFromAbsolutelyAnywhereSettings;
            UpdateBookIndexSettings = existing.UpdateBookIndexSettings;
            StreamShelvesSettings = existing.StreamShelvesSettings;
            StreamBooksSettings = existing.StreamBooksSettings;
            DiscussBookSettings = existing.DiscussBookSettings;
            DiscussBookStreamingSettings = existing.DiscussBookStreamingSettings;
            FindRelatedBooksSettings = existing.FindRelatedBooksSettings;
            AddTagSettings = existing.AddTagSettings;
            AddLabelSettings = existing.AddLabelSettings;
            GetBigBookSettings = existing.GetBigBookSettings;
            GetBigBookOperationsSettings = existing.GetBigBookOperationsSettings?.Clone();
            GetBigNothingSettings = existing.GetBigNothingSettings;
            GetBigNothingOperationsSettings = existing.GetBigNothingOperationsSettings?.Clone();
            TestOptionalRequiredFlatteningParamsSettings = existing.TestOptionalRequiredFlatteningParamsSettings;
            OnCopy(existing);
        }

        partial void OnCopy(LibraryServiceSettings existing);

        /// <summary>
        /// The filter specifying which RPC <see cref="grpccore::StatusCode"/>s are eligible for retry
        /// for "Idempotent" <see cref="LibraryServiceClient"/> RPC methods.
        /// </summary>
        /// <remarks>
        /// The eligible RPC <see cref="grpccore::StatusCode"/>s for retry for "Idempotent" RPC methods are:
        /// <list type="bullet">
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// </remarks>
        public static sys::Predicate<grpccore::RpcException> IdempotentRetryFilter { get; } =
            gaxgrpc::RetrySettings.FilterForStatusCodes(grpccore::StatusCode.DeadlineExceeded, grpccore::StatusCode.Unavailable);

        /// <summary>
        /// The filter specifying which RPC <see cref="grpccore::StatusCode"/>s are eligible for retry
        /// for "NonIdempotent" <see cref="LibraryServiceClient"/> RPC methods.
        /// </summary>
        /// <remarks>
        /// There are no RPC <see cref="grpccore::StatusCode"/>s eligible for retry for "NonIdempotent" RPC methods.
        /// </remarks>
        public static sys::Predicate<grpccore::RpcException> NonIdempotentRetryFilter { get; } =
            gaxgrpc::RetrySettings.FilterForStatusCodes();

        /// <summary>
        /// "Default" retry backoff for <see cref="LibraryServiceClient"/> RPC methods.
        /// </summary>
        /// <returns>
        /// The "Default" retry backoff for <see cref="LibraryServiceClient"/> RPC methods.
        /// </returns>
        /// <remarks>
        /// The "Default" retry backoff for <see cref="LibraryServiceClient"/> RPC methods is defined as:
        /// <list type="bullet">
        /// <item><description>Initial delay: 100 milliseconds</description></item>
        /// <item><description>Maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Delay multiplier: 1.2</description></item>
        /// </list>
        /// </remarks>
        public static gaxgrpc::BackoffSettings GetDefaultRetryBackoff() => new gaxgrpc::BackoffSettings(
            delay: sys::TimeSpan.FromMilliseconds(100),
            maxDelay: sys::TimeSpan.FromMilliseconds(1000),
            delayMultiplier: 1.2
        );

        /// <summary>
        /// "Default" timeout backoff for <see cref="LibraryServiceClient"/> RPC methods.
        /// </summary>
        /// <returns>
        /// The "Default" timeout backoff for <see cref="LibraryServiceClient"/> RPC methods.
        /// </returns>
        /// <remarks>
        /// The "Default" timeout backoff for <see cref="LibraryServiceClient"/> RPC methods is defined as:
        /// <list type="bullet">
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Maximum timeout: 3000 milliseconds</description></item>
        /// </list>
        /// </remarks>
        public static gaxgrpc::BackoffSettings GetDefaultTimeoutBackoff() => new gaxgrpc::BackoffSettings(
            delay: sys::TimeSpan.FromMilliseconds(300),
            maxDelay: sys::TimeSpan.FromMilliseconds(3000),
            delayMultiplier: 1.3
        );

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.CreateShelf</c> and <c>LibraryServiceClient.CreateShelfAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.CreateShelf</c> and
        /// <c>LibraryServiceClient.CreateShelfAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings CreateShelfSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetShelf</c> and <c>LibraryServiceClient.GetShelfAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetShelf</c> and
        /// <c>LibraryServiceClient.GetShelfAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetShelfSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.ListShelves</c> and <c>LibraryServiceClient.ListShelvesAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.ListShelves</c> and
        /// <c>LibraryServiceClient.ListShelvesAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings ListShelvesSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.DeleteShelf</c> and <c>LibraryServiceClient.DeleteShelfAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.DeleteShelf</c> and
        /// <c>LibraryServiceClient.DeleteShelfAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings DeleteShelfSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.MergeShelves</c> and <c>LibraryServiceClient.MergeShelvesAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.MergeShelves</c> and
        /// <c>LibraryServiceClient.MergeShelvesAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings MergeShelvesSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.CreateBook</c> and <c>LibraryServiceClient.CreateBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.CreateBook</c> and
        /// <c>LibraryServiceClient.CreateBookAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings CreateBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.PublishSeries</c> and <c>LibraryServiceClient.PublishSeriesAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.PublishSeries</c> and
        /// <c>LibraryServiceClient.PublishSeriesAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings PublishSeriesSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBook</c> and <c>LibraryServiceClient.GetBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBook</c> and
        /// <c>LibraryServiceClient.GetBookAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.ListBooks</c> and <c>LibraryServiceClient.ListBooksAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.ListBooks</c> and
        /// <c>LibraryServiceClient.ListBooksAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings ListBooksSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.DeleteBook</c> and <c>LibraryServiceClient.DeleteBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.DeleteBook</c> and
        /// <c>LibraryServiceClient.DeleteBookAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings DeleteBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.UpdateBook</c> and <c>LibraryServiceClient.UpdateBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.UpdateBook</c> and
        /// <c>LibraryServiceClient.UpdateBookAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings UpdateBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.MoveBook</c> and <c>LibraryServiceClient.MoveBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.MoveBook</c> and
        /// <c>LibraryServiceClient.MoveBookAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings MoveBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.ListStrings</c> and <c>LibraryServiceClient.ListStringsAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.ListStrings</c> and
        /// <c>LibraryServiceClient.ListStringsAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings ListStringsSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.AddComments</c> and <c>LibraryServiceClient.AddCommentsAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.AddComments</c> and
        /// <c>LibraryServiceClient.AddCommentsAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings AddCommentsSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBookFromArchive</c> and <c>LibraryServiceClient.GetBookFromArchiveAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBookFromArchive</c> and
        /// <c>LibraryServiceClient.GetBookFromArchiveAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetBookFromArchiveSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBookFromAnywhere</c> and <c>LibraryServiceClient.GetBookFromAnywhereAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBookFromAnywhere</c> and
        /// <c>LibraryServiceClient.GetBookFromAnywhereAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetBookFromAnywhereSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBookFromAbsolutelyAnywhere</c> and <c>LibraryServiceClient.GetBookFromAbsolutelyAnywhereAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBookFromAbsolutelyAnywhere</c> and
        /// <c>LibraryServiceClient.GetBookFromAbsolutelyAnywhereAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetBookFromAbsolutelyAnywhereSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.UpdateBookIndex</c> and <c>LibraryServiceClient.UpdateBookIndexAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.UpdateBookIndex</c> and
        /// <c>LibraryServiceClient.UpdateBookIndexAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings UpdateBookIndexSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for calls to <c>LibraryServiceClient.StreamShelves</c>.
        /// </summary>
        /// <remarks>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings StreamShelvesSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for calls to <c>LibraryServiceClient.StreamBooks</c>.
        /// </summary>
        /// <remarks>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings StreamBooksSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for calls to <c>LibraryServiceClient.DiscussBook</c>.
        /// </summary>
        /// <remarks>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings DiscussBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)));

        /// <summary>
        /// <see cref="gaxgrpc::BidirectionalStreamingSettings"/> for calls to
        /// <c>LibraryServiceClient.DiscussBook</c>.
        /// </summary>
        /// <remarks>
        /// The default local send queue size is 100.
        /// </remarks>
        public gaxgrpc::BidirectionalStreamingSettings DiscussBookStreamingSettings { get; set; } =
            new gaxgrpc::BidirectionalStreamingSettings(100);

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.FindRelatedBooks</c> and <c>LibraryServiceClient.FindRelatedBooksAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.FindRelatedBooks</c> and
        /// <c>LibraryServiceClient.FindRelatedBooksAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings FindRelatedBooksSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.AddTag</c> and <c>LibraryServiceClient.AddTagAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.AddTag</c> and
        /// <c>LibraryServiceClient.AddTagAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings AddTagSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.AddLabel</c> and <c>LibraryServiceClient.AddLabelAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.AddLabel</c> and
        /// <c>LibraryServiceClient.AddLabelAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings AddLabelSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBigBook</c> and <c>LibraryServiceClient.GetBigBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBigBook</c> and
        /// <c>LibraryServiceClient.GetBigBookAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetBigBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// Long Running Operation settings for calls to <c>LibraryServiceClient.GetBigBook</c>.
        /// </summary>
        /// <remarks>
        /// Uses default <see cref="gax::PollSettings"/> of:
        /// <list type="bullet">
        /// <item><description>Initial delay: 3000 milliseconds</description></item>
        /// <item><description>Delay multiplier: 1.3</description></item>
        /// <item><description>Maximum delay: 30000 milliseconds</description></item>
        /// <item><description>Total timeout: 86400000 milliseconds</description></item>
        /// </list>
        /// </remarks>
        public lro::OperationsSettings GetBigBookOperationsSettings { get; set; } = new lro::OperationsSettings
        {
            DefaultPollSettings = new gax::PollSettings(
                gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(86400000L)),
                sys::TimeSpan.FromMilliseconds(3000L),
                1.3,
                sys::TimeSpan.FromMilliseconds(30000L))
        };

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBigNothing</c> and <c>LibraryServiceClient.GetBigNothingAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBigNothing</c> and
        /// <c>LibraryServiceClient.GetBigNothingAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetBigNothingSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// Long Running Operation settings for calls to <c>LibraryServiceClient.GetBigNothing</c>.
        /// </summary>
        /// <remarks>
        /// Uses default <see cref="gax::PollSettings"/> of:
        /// <list type="bullet">
        /// <item><description>Initial delay: 3000 milliseconds</description></item>
        /// <item><description>Delay multiplier: 1.3</description></item>
        /// <item><description>Maximum delay: 60000 milliseconds</description></item>
        /// <item><description>Total timeout: 600000 milliseconds</description></item>
        /// </list>
        /// </remarks>
        public lro::OperationsSettings GetBigNothingOperationsSettings { get; set; } = new lro::OperationsSettings
        {
            DefaultPollSettings = new gax::PollSettings(
                gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(600000L)),
                sys::TimeSpan.FromMilliseconds(3000L),
                1.3,
                sys::TimeSpan.FromMilliseconds(60000L))
        };

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.TestOptionalRequiredFlatteningParams</c> and <c>LibraryServiceClient.TestOptionalRequiredFlatteningParamsAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.TestOptionalRequiredFlatteningParams</c> and
        /// <c>LibraryServiceClient.TestOptionalRequiredFlatteningParamsAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings TestOptionalRequiredFlatteningParamsSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// Creates a deep clone of this object, with all the same property values.
        /// </summary>
        /// <returns>A deep clone of this <see cref="LibraryServiceSettings"/> object.</returns>
        public LibraryServiceSettings Clone() => new LibraryServiceSettings(this);
    }

    /// <summary>
    /// LibraryService client wrapper, for convenient use.
    /// </summary>
    public abstract partial class LibraryServiceClient
    {
        /// <summary>
        /// The default endpoint for the LibraryService service, which is a host of "library-example.googleapis.com" and a port of 443.
        /// </summary>
        public static gaxgrpc::ServiceEndpoint DefaultEndpoint { get; } = new gaxgrpc::ServiceEndpoint("library-example.googleapis.com", 443);

        /// <summary>
        /// The default LibraryService scopes.
        /// </summary>
        /// <remarks>
        /// The default LibraryService scopes are:
        /// <list type="bullet">
        /// <item><description>"https://www.googleapis.com/auth/cloud-platform"</description></item>
        /// <item><description>"https://www.googleapis.com/auth/library"</description></item>
        /// </list>
        /// </remarks>
        public static scg::IReadOnlyList<string> DefaultScopes { get; } = new sco::ReadOnlyCollection<string>(new string[] {
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/library",
        });

        private static readonly gaxgrpc::ChannelPool s_channelPool = new gaxgrpc::ChannelPool(DefaultScopes);

        /// <summary>
        /// Asynchronously creates a <see cref="LibraryServiceClient"/>, applying defaults for all unspecified settings,
        /// and creating a channel connecting to the given endpoint with application default credentials where
        /// necessary. See the example for how to use custom credentials.
        /// </summary>
        /// <example>
        /// This sample shows how to create a client using default credentials:
        /// <code>
        /// using Google.Example.Library.V1;
        /// ...
        /// // When running on Google Cloud Platform this will use the project Compute Credential.
        /// // Or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to the path of a JSON
        /// // credential file to use that credential.
        /// LibraryServiceClient client = await LibraryServiceClient.CreateAsync();
        /// </code>
        /// This sample shows how to create a client using credentials loaded from a JSON file:
        /// <code>
        /// using Google.Example.Library.V1;
        /// using Google.Apis.Auth.OAuth2;
        /// using Grpc.Auth;
        /// using Grpc.Core;
        /// ...
        /// GoogleCredential cred = GoogleCredential.FromFile("/path/to/credentials.json");
        /// Channel channel = new Channel(
        ///     LibraryServiceClient.DefaultEndpoint.Host, LibraryServiceClient.DefaultEndpoint.Port, cred.ToChannelCredentials());
        /// LibraryServiceClient client = LibraryServiceClient.Create(channel);
        /// ...
        /// // Shutdown the channel when it is no longer required.
        /// await channel.ShutdownAsync();
        /// </code>
        /// </example>
        /// <param name="endpoint">Optional <see cref="gaxgrpc::ServiceEndpoint"/>.</param>
        /// <param name="settings">Optional <see cref="LibraryServiceSettings"/>.</param>
        /// <returns>The task representing the created <see cref="LibraryServiceClient"/>.</returns>
        public static async stt::Task<LibraryServiceClient> CreateAsync(gaxgrpc::ServiceEndpoint endpoint = null, LibraryServiceSettings settings = null)
        {
            grpccore::Channel channel = await s_channelPool.GetChannelAsync(endpoint ?? DefaultEndpoint).ConfigureAwait(false);
            return Create(channel, settings);
        }

        /// <summary>
        /// Synchronously creates a <see cref="LibraryServiceClient"/>, applying defaults for all unspecified settings,
        /// and creating a channel connecting to the given endpoint with application default credentials where
        /// necessary. See the example for how to use custom credentials.
        /// </summary>
        /// <example>
        /// This sample shows how to create a client using default credentials:
        /// <code>
        /// using Google.Example.Library.V1;
        /// ...
        /// // When running on Google Cloud Platform this will use the project Compute Credential.
        /// // Or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to the path of a JSON
        /// // credential file to use that credential.
        /// LibraryServiceClient client = LibraryServiceClient.Create();
        /// </code>
        /// This sample shows how to create a client using credentials loaded from a JSON file:
        /// <code>
        /// using Google.Example.Library.V1;
        /// using Google.Apis.Auth.OAuth2;
        /// using Grpc.Auth;
        /// using Grpc.Core;
        /// ...
        /// GoogleCredential cred = GoogleCredential.FromFile("/path/to/credentials.json");
        /// Channel channel = new Channel(
        ///     LibraryServiceClient.DefaultEndpoint.Host, LibraryServiceClient.DefaultEndpoint.Port, cred.ToChannelCredentials());
        /// LibraryServiceClient client = LibraryServiceClient.Create(channel);
        /// ...
        /// // Shutdown the channel when it is no longer required.
        /// channel.ShutdownAsync().Wait();
        /// </code>
        /// </example>
        /// <param name="endpoint">Optional <see cref="gaxgrpc::ServiceEndpoint"/>.</param>
        /// <param name="settings">Optional <see cref="LibraryServiceSettings"/>.</param>
        /// <returns>The created <see cref="LibraryServiceClient"/>.</returns>
        public static LibraryServiceClient Create(gaxgrpc::ServiceEndpoint endpoint = null, LibraryServiceSettings settings = null)
        {
            grpccore::Channel channel = s_channelPool.GetChannel(endpoint ?? DefaultEndpoint);
            return Create(channel, settings);
        }

        /// <summary>
        /// Creates a <see cref="LibraryServiceClient"/> which uses the specified channel for remote operations.
        /// </summary>
        /// <param name="channel">The <see cref="grpccore::Channel"/> for remote operations. Must not be null.</param>
        /// <param name="settings">Optional <see cref="LibraryServiceSettings"/>.</param>
        /// <returns>The created <see cref="LibraryServiceClient"/>.</returns>
        public static LibraryServiceClient Create(grpccore::Channel channel, LibraryServiceSettings settings = null)
        {
            gax::GaxPreconditions.CheckNotNull(channel, nameof(channel));
            return Create(new grpccore::DefaultCallInvoker(channel), settings);
        }

        /// <summary>
        /// Creates a <see cref="LibraryServiceClient"/> which uses the specified call invoker for remote operations.
        /// </summary>
        /// <param name="callInvoker">The <see cref="grpccore::CallInvoker"/> for remote operations. Must not be null.</param>
        /// <param name="settings">Optional <see cref="LibraryServiceSettings"/>.</param>
        /// <returns>The created <see cref="LibraryServiceClient"/>.</returns>
        public static LibraryServiceClient Create(grpccore::CallInvoker callInvoker, LibraryServiceSettings settings = null)
        {
            gax::GaxPreconditions.CheckNotNull(callInvoker, nameof(callInvoker));
            LibraryService.LibraryServiceClient grpcClient = new LibraryService.LibraryServiceClient(callInvoker);
            return new LibraryServiceClientImpl(grpcClient, settings);
        }

        /// <summary>
        /// Shuts down any channels automatically created by <see cref="Create(gaxgrpc::ServiceEndpoint, LibraryServiceSettings)"/>
        /// and <see cref="CreateAsync(gaxgrpc::ServiceEndpoint, LibraryServiceSettings)"/>. Channels which weren't automatically
        /// created are not affected.
        /// </summary>
        /// <remarks>After calling this method, further calls to <see cref="Create(gaxgrpc::ServiceEndpoint, LibraryServiceSettings)"/>
        /// and <see cref="CreateAsync(gaxgrpc::ServiceEndpoint, LibraryServiceSettings)"/> will create new channels, which could
        /// in turn be shut down by another call to this method.</remarks>
        /// <returns>A task representing the asynchronous shutdown operation.</returns>
        public static stt::Task ShutdownDefaultChannelsAsync() => s_channelPool.ShutdownChannelsAsync();

        /// <summary>
        /// The underlying gRPC LibraryService client.
        /// </summary>
        public virtual LibraryService.LibraryServiceClient GrpcClient
        {
            get { throw new sys::NotImplementedException(); }
        }

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="shelf">
        /// The shelf to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> CreateShelfAsync(
            Shelf shelf,
            gaxgrpc::CallSettings callSettings = null) => CreateShelfAsync(
                new CreateShelfRequest
                {
                    Shelf = gax::GaxPreconditions.CheckNotNull(shelf, nameof(shelf)),
                },
                callSettings);

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="shelf">
        /// The shelf to create.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> CreateShelfAsync(
            Shelf shelf,
            st::CancellationToken cancellationToken) => CreateShelfAsync(
                shelf,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="shelf">
        /// The shelf to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf CreateShelf(
            Shelf shelf,
            gaxgrpc::CallSettings callSettings = null) => CreateShelf(
                new CreateShelfRequest
                {
                    Shelf = gax::GaxPreconditions.CheckNotNull(shelf, nameof(shelf)),
                },
                callSettings);

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> CreateShelfAsync(
            CreateShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> CreateShelfAsync(
            CreateShelfRequest request,
            st::CancellationToken cancellationToken) => CreateShelfAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf CreateShelf(
            CreateShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            ShelfName name,
            gaxgrpc::CallSettings callSettings = null) => GetShelfAsync(
                new GetShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            ShelfName name,
            st::CancellationToken cancellationToken) => GetShelfAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            ShelfName name,
            gaxgrpc::CallSettings callSettings = null) => GetShelf(
                new GetShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            string name,
            SomeMessage message,
            gaxgrpc::CallSettings callSettings = null) => GetShelfAsync(
                new GetShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Message = message, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            string name,
            SomeMessage message,
            st::CancellationToken cancellationToken) => GetShelfAsync(
                name,
                message,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            string name,
            SomeMessage message,
            gaxgrpc::CallSettings callSettings = null) => GetShelf(
                new GetShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Message = message, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="stringBuilder">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            string name,
            SomeMessage message,
            StringBuilder stringBuilder,
            gaxgrpc::CallSettings callSettings = null) => GetShelfAsync(
                new GetShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Message = message, // Optional
                    StringBuilder = stringBuilder, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="stringBuilder">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            string name,
            SomeMessage message,
            StringBuilder stringBuilder,
            st::CancellationToken cancellationToken) => GetShelfAsync(
                name,
                message,
                stringBuilder,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="stringBuilder">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            string name,
            SomeMessage message,
            StringBuilder stringBuilder,
            gaxgrpc::CallSettings callSettings = null) => GetShelf(
                new GetShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Message = message, // Optional
                    StringBuilder = stringBuilder, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            GetShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            GetShelfRequest request,
            st::CancellationToken cancellationToken) => GetShelfAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            GetShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListShelvesResponse, Shelf> ListShelvesAsync(
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListShelvesAsync(
                new ListShelvesRequest
                {
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListShelvesResponse, Shelf> ListShelves(
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListShelves(
                new ListShelvesRequest
                {
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListShelvesResponse, Shelf> ListShelvesAsync(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListShelvesResponse, Shelf> ListShelves(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteShelfAsync(
            ShelfName name,
            gaxgrpc::CallSettings callSettings = null) => DeleteShelfAsync(
                new DeleteShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to delete.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteShelfAsync(
            ShelfName name,
            st::CancellationToken cancellationToken) => DeleteShelfAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void DeleteShelf(
            ShelfName name,
            gaxgrpc::CallSettings callSettings = null) => DeleteShelf(
                new DeleteShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteShelfAsync(
            DeleteShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteShelfAsync(
            DeleteShelfRequest request,
            st::CancellationToken cancellationToken) => DeleteShelfAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void DeleteShelf(
            DeleteShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf we're adding books to.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the shelf we're removing books from and deleting.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> MergeShelvesAsync(
            ShelfName name,
            ShelfName otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MergeShelvesAsync(
                new MergeShelvesRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OtherShelfNameAsShelfName = gax::GaxPreconditions.CheckNotNull(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf we're adding books to.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the shelf we're removing books from and deleting.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> MergeShelvesAsync(
            ShelfName name,
            ShelfName otherShelfName,
            st::CancellationToken cancellationToken) => MergeShelvesAsync(
                name,
                otherShelfName,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf we're adding books to.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the shelf we're removing books from and deleting.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf MergeShelves(
            ShelfName name,
            ShelfName otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MergeShelves(
                new MergeShelvesRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OtherShelfNameAsShelfName = gax::GaxPreconditions.CheckNotNull(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> MergeShelvesAsync(
            MergeShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> MergeShelvesAsync(
            MergeShelvesRequest request,
            st::CancellationToken cancellationToken) => MergeShelvesAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf MergeShelves(
            MergeShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf in which the book is created.
        /// </param>
        /// <param name="book">
        /// The book to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> CreateBookAsync(
            string name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => CreateBookAsync(
                new CreateBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf in which the book is created.
        /// </param>
        /// <param name="book">
        /// The book to create.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> CreateBookAsync(
            string name,
            Book book,
            st::CancellationToken cancellationToken) => CreateBookAsync(
                name,
                book,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf in which the book is created.
        /// </param>
        /// <param name="book">
        /// The book to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book CreateBook(
            string name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => CreateBook(
                new CreateBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> CreateBookAsync(
            CreateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> CreateBookAsync(
            CreateBookRequest request,
            st::CancellationToken cancellationToken) => CreateBookAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book CreateBook(
            CreateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="shelf">
        /// The shelf in which the series is created.
        /// </param>
        /// <param name="books">
        /// The books to publish in the series.
        /// </param>
        /// <param name="edition">
        /// The edition of the series
        /// </param>
        /// <param name="seriesUuid">
        /// Uniquely identifies the series to the publishing house.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<PublishSeriesResponse> PublishSeriesAsync(
            Shelf shelf,
            scg::IEnumerable<Book> books,
            uint? edition,
            SeriesUuid seriesUuid,
            gaxgrpc::CallSettings callSettings = null) => PublishSeriesAsync(
                new PublishSeriesRequest
                {
                    Shelf = gax::GaxPreconditions.CheckNotNull(shelf, nameof(shelf)),
                    Books = { gax::GaxPreconditions.CheckNotNull(books, nameof(books)) },
                    Edition = edition ?? 0, // Optional
                    SeriesUuid = gax::GaxPreconditions.CheckNotNull(seriesUuid, nameof(seriesUuid)),
                },
                callSettings);

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="shelf">
        /// The shelf in which the series is created.
        /// </param>
        /// <param name="books">
        /// The books to publish in the series.
        /// </param>
        /// <param name="edition">
        /// The edition of the series
        /// </param>
        /// <param name="seriesUuid">
        /// Uniquely identifies the series to the publishing house.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<PublishSeriesResponse> PublishSeriesAsync(
            Shelf shelf,
            scg::IEnumerable<Book> books,
            uint? edition,
            SeriesUuid seriesUuid,
            st::CancellationToken cancellationToken) => PublishSeriesAsync(
                shelf,
                books,
                edition,
                seriesUuid,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="shelf">
        /// The shelf in which the series is created.
        /// </param>
        /// <param name="books">
        /// The books to publish in the series.
        /// </param>
        /// <param name="edition">
        /// The edition of the series
        /// </param>
        /// <param name="seriesUuid">
        /// Uniquely identifies the series to the publishing house.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual PublishSeriesResponse PublishSeries(
            Shelf shelf,
            scg::IEnumerable<Book> books,
            uint? edition,
            SeriesUuid seriesUuid,
            gaxgrpc::CallSettings callSettings = null) => PublishSeries(
                new PublishSeriesRequest
                {
                    Shelf = gax::GaxPreconditions.CheckNotNull(shelf, nameof(shelf)),
                    Books = { gax::GaxPreconditions.CheckNotNull(books, nameof(books)) },
                    Edition = edition ?? 0, // Optional
                    SeriesUuid = gax::GaxPreconditions.CheckNotNull(seriesUuid, nameof(seriesUuid)),
                },
                callSettings);

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<PublishSeriesResponse> PublishSeriesAsync(
            PublishSeriesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<PublishSeriesResponse> PublishSeriesAsync(
            PublishSeriesRequest request,
            st::CancellationToken cancellationToken) => PublishSeriesAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual PublishSeriesResponse PublishSeries(
            PublishSeriesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> GetBookAsync(
            BookName name,
            gaxgrpc::CallSettings callSettings = null) => GetBookAsync(
                new GetBookRequest
                {
                    BookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> GetBookAsync(
            BookName name,
            st::CancellationToken cancellationToken) => GetBookAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book GetBook(
            BookName name,
            gaxgrpc::CallSettings callSettings = null) => GetBook(
                new GetBookRequest
                {
                    BookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> GetBookAsync(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> GetBookAsync(
            GetBookRequest request,
            st::CancellationToken cancellationToken) => GetBookAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book GetBook(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf whose books we'd like to list.
        /// </param>
        /// <param name="filter">
        /// To test python built-in wrapping.
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListBooksResponse, Book> ListBooksAsync(
            ShelfName name,
            string filter,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListBooksAsync(
                new ListBooksRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Filter = filter ?? "", // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf whose books we'd like to list.
        /// </param>
        /// <param name="filter">
        /// To test python built-in wrapping.
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListBooksResponse, Book> ListBooks(
            ShelfName name,
            string filter,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListBooks(
                new ListBooksRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Filter = filter ?? "", // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListBooksResponse, Book> ListBooksAsync(
            ListBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListBooksResponse, Book> ListBooks(
            ListBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteBookAsync(
            BookName name,
            gaxgrpc::CallSettings callSettings = null) => DeleteBookAsync(
                new DeleteBookRequest
                {
                    BookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to delete.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteBookAsync(
            BookName name,
            st::CancellationToken cancellationToken) => DeleteBookAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void DeleteBook(
            BookName name,
            gaxgrpc::CallSettings callSettings = null) => DeleteBook(
                new DeleteBookRequest
                {
                    BookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteBookAsync(
            DeleteBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteBookAsync(
            DeleteBookRequest request,
            st::CancellationToken cancellationToken) => DeleteBookAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void DeleteBook(
            DeleteBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            BookName name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookAsync(
                new UpdateBookRequest
                {
                    BookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            BookName name,
            Book book,
            st::CancellationToken cancellationToken) => UpdateBookAsync(
                name,
                book,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book UpdateBook(
            BookName name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => UpdateBook(
                new UpdateBookRequest
                {
                    BookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="optionalFoo">
        /// An optional foo.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="updateMask">
        /// A field mask to apply, rendered as an HTTP parameter.
        /// </param>
        /// <param name="physicalMask">
        /// To test Python import clash resolution.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            BookName name,
            string optionalFoo,
            Book book,
            pbwkt::FieldMask updateMask,
            FieldMask physicalMask,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookAsync(
                new UpdateBookRequest
                {
                    BookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OptionalFoo = optionalFoo ?? "", // Optional
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                    UpdateMask = updateMask, // Optional
                    PhysicalMask = physicalMask, // Optional
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="optionalFoo">
        /// An optional foo.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="updateMask">
        /// A field mask to apply, rendered as an HTTP parameter.
        /// </param>
        /// <param name="physicalMask">
        /// To test Python import clash resolution.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            BookName name,
            string optionalFoo,
            Book book,
            pbwkt::FieldMask updateMask,
            FieldMask physicalMask,
            st::CancellationToken cancellationToken) => UpdateBookAsync(
                name,
                optionalFoo,
                book,
                updateMask,
                physicalMask,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="optionalFoo">
        /// An optional foo.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="updateMask">
        /// A field mask to apply, rendered as an HTTP parameter.
        /// </param>
        /// <param name="physicalMask">
        /// To test Python import clash resolution.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book UpdateBook(
            BookName name,
            string optionalFoo,
            Book book,
            pbwkt::FieldMask updateMask,
            FieldMask physicalMask,
            gaxgrpc::CallSettings callSettings = null) => UpdateBook(
                new UpdateBookRequest
                {
                    BookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OptionalFoo = optionalFoo ?? "", // Optional
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                    UpdateMask = updateMask, // Optional
                    PhysicalMask = physicalMask, // Optional
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            UpdateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            UpdateBookRequest request,
            st::CancellationToken cancellationToken) => UpdateBookAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book UpdateBook(
            UpdateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to move.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the destination shelf.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> MoveBookAsync(
            BookName name,
            ShelfName otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MoveBookAsync(
                new MoveBookRequest
                {
                    BookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OtherShelfNameAsShelfName = gax::GaxPreconditions.CheckNotNull(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to move.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the destination shelf.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> MoveBookAsync(
            BookName name,
            ShelfName otherShelfName,
            st::CancellationToken cancellationToken) => MoveBookAsync(
                name,
                otherShelfName,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to move.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the destination shelf.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book MoveBook(
            BookName name,
            ShelfName otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MoveBook(
                new MoveBookRequest
                {
                    BookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OtherShelfNameAsShelfName = gax::GaxPreconditions.CheckNotNull(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> MoveBookAsync(
            MoveBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> MoveBookAsync(
            MoveBookRequest request,
            st::CancellationToken cancellationToken) => MoveBookAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book MoveBook(
            MoveBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListStringsResponse, IResourceName> ListStringsAsync(
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListStringsAsync(
                new ListStringsRequest
                {
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListStringsResponse, IResourceName> ListStrings(
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListStrings(
                new ListStringsRequest
                {
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListStringsResponse, IResourceName> ListStringsAsync(
            IResourceName name,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListStringsAsync(
                new ListStringsRequest
                {
                    AsResourceName = name, // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListStringsResponse, IResourceName> ListStrings(
            IResourceName name,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListStrings(
                new ListStringsRequest
                {
                    AsResourceName = name, // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListStringsResponse, IResourceName> ListStringsAsync(
            ListStringsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListStringsResponse, IResourceName> ListStrings(
            ListStringsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="comments">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task AddCommentsAsync(
            string name,
            scg::IEnumerable<Comment> comments,
            gaxgrpc::CallSettings callSettings = null) => AddCommentsAsync(
                new AddCommentsRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Comments = { gax::GaxPreconditions.CheckNotNull(comments, nameof(comments)) },
                },
                callSettings);

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="comments">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task AddCommentsAsync(
            string name,
            scg::IEnumerable<Comment> comments,
            st::CancellationToken cancellationToken) => AddCommentsAsync(
                name,
                comments,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="comments">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void AddComments(
            string name,
            scg::IEnumerable<Comment> comments,
            gaxgrpc::CallSettings callSettings = null) => AddComments(
                new AddCommentsRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Comments = { gax::GaxPreconditions.CheckNotNull(comments, nameof(comments)) },
                },
                callSettings);

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task AddCommentsAsync(
            AddCommentsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task AddCommentsAsync(
            AddCommentsRequest request,
            st::CancellationToken cancellationToken) => AddCommentsAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void AddComments(
            AddCommentsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromArchive> GetBookFromArchiveAsync(
            ArchivedBookName name,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromArchiveAsync(
                new GetBookFromArchiveRequest
                {
                    ArchivedBookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromArchive> GetBookFromArchiveAsync(
            ArchivedBookName name,
            st::CancellationToken cancellationToken) => GetBookFromArchiveAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromArchive GetBookFromArchive(
            ArchivedBookName name,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromArchive(
                new GetBookFromArchiveRequest
                {
                    ArchivedBookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromArchive> GetBookFromArchiveAsync(
            GetBookFromArchiveRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromArchive> GetBookFromArchiveAsync(
            GetBookFromArchiveRequest request,
            st::CancellationToken cancellationToken) => GetBookFromArchiveAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromArchive GetBookFromArchive(
            GetBookFromArchiveRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="altBookName">
        /// An alternate book name, used to test restricting flattened field to a
        /// single resource name type in a oneof.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            BookNameOneof name,
            BookName altBookName,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAnywhereAsync(
                new GetBookFromAnywhereRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    AltBookNameAsBookNameOneof = BookNameOneof.From(gax::GaxPreconditions.CheckNotNull(altBookName, nameof(altBookName))),
                },
                callSettings);

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="altBookName">
        /// An alternate book name, used to test restricting flattened field to a
        /// single resource name type in a oneof.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            BookNameOneof name,
            BookName altBookName,
            st::CancellationToken cancellationToken) => GetBookFromAnywhereAsync(
                name,
                altBookName,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="altBookName">
        /// An alternate book name, used to test restricting flattened field to a
        /// single resource name type in a oneof.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAnywhere(
            BookNameOneof name,
            BookName altBookName,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAnywhere(
                new GetBookFromAnywhereRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    AltBookNameAsBookNameOneof = BookNameOneof.From(gax::GaxPreconditions.CheckNotNull(altBookName, nameof(altBookName))),
                },
                callSettings);

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            GetBookFromAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            GetBookFromAnywhereRequest request,
            st::CancellationToken cancellationToken) => GetBookFromAnywhereAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAnywhere(
            GetBookFromAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAbsolutelyAnywhereAsync(
                new GetBookFromAbsolutelyAnywhereRequest
                {
                    AsResourceName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            BookNameOneof name,
            st::CancellationToken cancellationToken) => GetBookFromAbsolutelyAnywhereAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAbsolutelyAnywhere(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAbsolutelyAnywhere(
                new GetBookFromAbsolutelyAnywhereRequest
                {
                    AsResourceName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            GetBookFromAbsolutelyAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            GetBookFromAbsolutelyAnywhereRequest request,
            st::CancellationToken cancellationToken) => GetBookFromAbsolutelyAnywhereAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAbsolutelyAnywhere(
            GetBookFromAbsolutelyAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="indexName">
        /// The name of the index for the book
        /// </param>
        /// <param name="indexMap">
        /// The index to update the book with
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task UpdateBookIndexAsync(
            BookName name,
            string indexName,
            scg::IDictionary<string, string> indexMap,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookIndexAsync(
                new UpdateBookIndexRequest
                {
                    BookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    IndexName = gax::GaxPreconditions.CheckNotNullOrEmpty(indexName, nameof(indexName)),
                    IndexMap = { gax::GaxPreconditions.CheckNotNull(indexMap, nameof(indexMap)) },
                },
                callSettings);

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="indexName">
        /// The name of the index for the book
        /// </param>
        /// <param name="indexMap">
        /// The index to update the book with
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task UpdateBookIndexAsync(
            BookName name,
            string indexName,
            scg::IDictionary<string, string> indexMap,
            st::CancellationToken cancellationToken) => UpdateBookIndexAsync(
                name,
                indexName,
                indexMap,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="indexName">
        /// The name of the index for the book
        /// </param>
        /// <param name="indexMap">
        /// The index to update the book with
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void UpdateBookIndex(
            BookName name,
            string indexName,
            scg::IDictionary<string, string> indexMap,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookIndex(
                new UpdateBookIndexRequest
                {
                    BookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    IndexName = gax::GaxPreconditions.CheckNotNullOrEmpty(indexName, nameof(indexName)),
                    IndexMap = { gax::GaxPreconditions.CheckNotNull(indexMap, nameof(indexMap)) },
                },
                callSettings);

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task UpdateBookIndexAsync(
            UpdateBookIndexRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task UpdateBookIndexAsync(
            UpdateBookIndexRequest request,
            st::CancellationToken cancellationToken) => UpdateBookIndexAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void UpdateBookIndex(
            UpdateBookIndexRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Test server streaming
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The server stream.
        /// </returns>
        public virtual StreamShelvesStream StreamShelves(
            StreamShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Server streaming methods for <c>StreamShelves</c>.
        /// </summary>
        public abstract partial class StreamShelvesStream : gaxgrpc::ServerStreamingBase<StreamShelvesResponse>
        {
        }

        /// <summary>
        /// Test server streaming, non-paged responses.
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf whose books we'd like to list.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The server stream.
        /// </returns>
        public virtual StreamBooksStream StreamBooks(
            string name,
            gaxgrpc::CallSettings callSettings = null) => StreamBooks(
                new StreamBooksRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test server streaming, non-paged responses.
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The server stream.
        /// </returns>
        public virtual StreamBooksStream StreamBooks(
            StreamBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Server streaming methods for <c>StreamBooks</c>.
        /// </summary>
        public abstract partial class StreamBooksStream : gaxgrpc::ServerStreamingBase<Book>
        {
        }

        /// <summary>
        /// Test bidi-streaming.
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <param name="streamingSettings">
        /// If not null, applies streaming overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The client-server stream.
        /// </returns>
        public virtual DiscussBookStream DiscussBook(
            gaxgrpc::CallSettings callSettings = null,
            gaxgrpc::BidirectionalStreamingSettings streamingSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Bidirectional streaming methods for <c>DiscussBook</c>.
        /// </summary>
        public abstract partial class DiscussBookStream : gaxgrpc::BidirectionalStreamingBase<DiscussBookRequest, Comment>
        {
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="names">
        ///
        /// </param>
        /// <param name="shelves">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<FindRelatedBooksResponse, BookName> FindRelatedBooksAsync(
            scg::IEnumerable<BookName> names,
            scg::IEnumerable<ShelfName> shelves,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => FindRelatedBooksAsync(
                new FindRelatedBooksRequest
                {
                    BookNames = { gax::GaxPreconditions.CheckNotNull(names, nameof(names)) },
                    ShelvesAsShelfNames = { gax::GaxPreconditions.CheckNotNull(shelves, nameof(shelves)) },
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="names">
        ///
        /// </param>
        /// <param name="shelves">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<FindRelatedBooksResponse, BookName> FindRelatedBooks(
            scg::IEnumerable<BookName> names,
            scg::IEnumerable<ShelfName> shelves,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => FindRelatedBooks(
                new FindRelatedBooksRequest
                {
                    BookNames = { gax::GaxPreconditions.CheckNotNull(names, nameof(names)) },
                    ShelvesAsShelfNames = { gax::GaxPreconditions.CheckNotNull(shelves, nameof(shelves)) },
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<FindRelatedBooksResponse, BookName> FindRelatedBooksAsync(
            FindRelatedBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<FindRelatedBooksResponse, BookName> FindRelatedBooks(
            FindRelatedBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Adds a tag to the book. This RPC is a mixin.
        /// </summary>
        /// <param name="resource">
        /// REQUIRED: The resource which the tag is being added to.
        /// Resource is usually specified as a path, such as,
        /// projects/{project}/zones/{zone}/disks/{disk}.
        /// </param>
        /// <param name="tag">
        /// REQUIRED: The tag to add.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<gtv::AddTagResponse> AddTagAsync(
            string resource,
            string tag,
            gaxgrpc::CallSettings callSettings = null) => AddTagAsync(
                new gtv::AddTagRequest
                {
                    Resource = gax::GaxPreconditions.CheckNotNullOrEmpty(resource, nameof(resource)),
                    Tag = gax::GaxPreconditions.CheckNotNullOrEmpty(tag, nameof(tag)),
                },
                callSettings);

        /// <summary>
        /// Adds a tag to the book. This RPC is a mixin.
        /// </summary>
        /// <param name="resource">
        /// REQUIRED: The resource which the tag is being added to.
        /// Resource is usually specified as a path, such as,
        /// projects/{project}/zones/{zone}/disks/{disk}.
        /// </param>
        /// <param name="tag">
        /// REQUIRED: The tag to add.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<gtv::AddTagResponse> AddTagAsync(
            string resource,
            string tag,
            st::CancellationToken cancellationToken) => AddTagAsync(
                resource,
                tag,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Adds a tag to the book. This RPC is a mixin.
        /// </summary>
        /// <param name="resource">
        /// REQUIRED: The resource which the tag is being added to.
        /// Resource is usually specified as a path, such as,
        /// projects/{project}/zones/{zone}/disks/{disk}.
        /// </param>
        /// <param name="tag">
        /// REQUIRED: The tag to add.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual gtv::AddTagResponse AddTag(
            string resource,
            string tag,
            gaxgrpc::CallSettings callSettings = null) => AddTag(
                new gtv::AddTagRequest
                {
                    Resource = gax::GaxPreconditions.CheckNotNullOrEmpty(resource, nameof(resource)),
                    Tag = gax::GaxPreconditions.CheckNotNullOrEmpty(tag, nameof(tag)),
                },
                callSettings);

        /// <summary>
        /// Adds a tag to the book. This RPC is a mixin.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<gtv::AddTagResponse> AddTagAsync(
            gtv::AddTagRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Adds a tag to the book. This RPC is a mixin.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<gtv::AddTagResponse> AddTagAsync(
            gtv::AddTagRequest request,
            st::CancellationToken cancellationToken) => AddTagAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Adds a tag to the book. This RPC is a mixin.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual gtv::AddTagResponse AddTag(
            gtv::AddTagRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="resource">
        /// REQUIRED: The resource which the label is being added to.
        /// Resource is usually specified as a path, such as,
        /// projects/{project}/zones/{zone}/disks/{disk}.
        /// </param>
        /// <param name="label">
        /// REQUIRED: The label to add.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<gtv::AddLabelResponse> AddLabelAsync(
            string resource,
            string label,
            gaxgrpc::CallSettings callSettings = null) => AddLabelAsync(
                new gtv::AddLabelRequest
                {
                    Resource = gax::GaxPreconditions.CheckNotNullOrEmpty(resource, nameof(resource)),
                    Label = gax::GaxPreconditions.CheckNotNullOrEmpty(label, nameof(label)),
                },
                callSettings);

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="resource">
        /// REQUIRED: The resource which the label is being added to.
        /// Resource is usually specified as a path, such as,
        /// projects/{project}/zones/{zone}/disks/{disk}.
        /// </param>
        /// <param name="label">
        /// REQUIRED: The label to add.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<gtv::AddLabelResponse> AddLabelAsync(
            string resource,
            string label,
            st::CancellationToken cancellationToken) => AddLabelAsync(
                resource,
                label,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="resource">
        /// REQUIRED: The resource which the label is being added to.
        /// Resource is usually specified as a path, such as,
        /// projects/{project}/zones/{zone}/disks/{disk}.
        /// </param>
        /// <param name="label">
        /// REQUIRED: The label to add.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual gtv::AddLabelResponse AddLabel(
            string resource,
            string label,
            gaxgrpc::CallSettings callSettings = null) => AddLabel(
                new gtv::AddLabelRequest
                {
                    Resource = gax::GaxPreconditions.CheckNotNullOrEmpty(resource, nameof(resource)),
                    Label = gax::GaxPreconditions.CheckNotNullOrEmpty(label, nameof(label)),
                },
                callSettings);

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<gtv::AddLabelResponse> AddLabelAsync(
            gtv::AddLabelRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<gtv::AddLabelResponse> AddLabelAsync(
            gtv::AddLabelRequest request,
            st::CancellationToken cancellationToken) => AddLabelAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual gtv::AddLabelResponse AddLabel(
            gtv::AddLabelRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            BookName name,
            gaxgrpc::CallSettings callSettings = null) => GetBigBookAsync(
                new GetBookRequest
                {
                    BookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            BookName name,
            st::CancellationToken cancellationToken) => GetBigBookAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<Book, GetBigBookMetadata> GetBigBook(
            BookName name,
            gaxgrpc::CallSettings callSettings = null) => GetBigBook(
                new GetBookRequest
                {
                    BookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Asynchronously poll an operation once, using an <c>operationName</c> from a previous invocation of <c>GetBigBookAsync</c>.
        /// </summary>
        /// <param name="operationName">The name of a previously invoked operation. Must not be <c>null</c> or empty.</param>
        /// <param name="callSettings">If not null, applies overrides to this RPC call.</param>
        /// <returns>A task representing the result of polling the operation.</returns>
        public virtual stt::Task<lro::Operation<Book, GetBigBookMetadata>> PollOnceGetBigBookAsync(
            string operationName,
            gaxgrpc::CallSettings callSettings = null) => lro::Operation<Book, GetBigBookMetadata>.PollOnceFromNameAsync(
                gax::GaxPreconditions.CheckNotNullOrEmpty(operationName, nameof(operationName)),
                GetBigBookOperationsClient,
                callSettings);

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<Book, GetBigBookMetadata> GetBigBook(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// The long-running operations client for <c>GetBigBook</c>.
        /// </summary>
        public virtual lro::OperationsClient GetBigBookOperationsClient
        {
            get { throw new sys::NotImplementedException(); }
        }

        /// <summary>
        /// Poll an operation once, using an <c>operationName</c> from a previous invocation of <c>GetBigBook</c>.
        /// </summary>
        /// <param name="operationName">The name of a previously invoked operation. Must not be <c>null</c> or empty.</param>
        /// <param name="callSettings">If not null, applies overrides to this RPC call.</param>
        /// <returns>The result of polling the operation.</returns>
        public virtual lro::Operation<Book, GetBigBookMetadata> PollOnceGetBigBook(
            string operationName,
            gaxgrpc::CallSettings callSettings = null) => lro::Operation<Book, GetBigBookMetadata>.PollOnceFromName(
                gax::GaxPreconditions.CheckNotNullOrEmpty(operationName, nameof(operationName)),
                GetBigBookOperationsClient,
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<pbwkt::Empty, GetBigBookMetadata>> GetBigNothingAsync(
            BookName name,
            gaxgrpc::CallSettings callSettings = null) => GetBigNothingAsync(
                new GetBookRequest
                {
                    BookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<pbwkt::Empty, GetBigBookMetadata>> GetBigNothingAsync(
            BookName name,
            st::CancellationToken cancellationToken) => GetBigNothingAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<pbwkt::Empty, GetBigBookMetadata> GetBigNothing(
            BookName name,
            gaxgrpc::CallSettings callSettings = null) => GetBigNothing(
                new GetBookRequest
                {
                    BookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<pbwkt::Empty, GetBigBookMetadata>> GetBigNothingAsync(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Asynchronously poll an operation once, using an <c>operationName</c> from a previous invocation of <c>GetBigNothingAsync</c>.
        /// </summary>
        /// <param name="operationName">The name of a previously invoked operation. Must not be <c>null</c> or empty.</param>
        /// <param name="callSettings">If not null, applies overrides to this RPC call.</param>
        /// <returns>A task representing the result of polling the operation.</returns>
        public virtual stt::Task<lro::Operation<pbwkt::Empty, GetBigBookMetadata>> PollOnceGetBigNothingAsync(
            string operationName,
            gaxgrpc::CallSettings callSettings = null) => lro::Operation<pbwkt::Empty, GetBigBookMetadata>.PollOnceFromNameAsync(
                gax::GaxPreconditions.CheckNotNullOrEmpty(operationName, nameof(operationName)),
                GetBigNothingOperationsClient,
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<pbwkt::Empty, GetBigBookMetadata> GetBigNothing(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// The long-running operations client for <c>GetBigNothing</c>.
        /// </summary>
        public virtual lro::OperationsClient GetBigNothingOperationsClient
        {
            get { throw new sys::NotImplementedException(); }
        }

        /// <summary>
        /// Poll an operation once, using an <c>operationName</c> from a previous invocation of <c>GetBigNothing</c>.
        /// </summary>
        /// <param name="operationName">The name of a previously invoked operation. Must not be <c>null</c> or empty.</param>
        /// <param name="callSettings">If not null, applies overrides to this RPC call.</param>
        /// <returns>The result of polling the operation.</returns>
        public virtual lro::Operation<pbwkt::Empty, GetBigBookMetadata> PollOnceGetBigNothing(
            string operationName,
            gaxgrpc::CallSettings callSettings = null) => lro::Operation<pbwkt::Empty, GetBigBookMetadata>.PollOnceFromName(
                gax::GaxPreconditions.CheckNotNullOrEmpty(operationName, nameof(operationName)),
                GetBigNothingOperationsClient,
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            gaxgrpc::CallSettings callSettings = null) => TestOptionalRequiredFlatteningParamsAsync(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            st::CancellationToken cancellationToken) => TestOptionalRequiredFlatteningParamsAsync(
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual TestOptionalRequiredFlatteningParamsResponse TestOptionalRequiredFlatteningParams(
            gaxgrpc::CallSettings callSettings = null) => TestOptionalRequiredFlatteningParams(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="requiredSingularInt32">
        ///
        /// </param>
        /// <param name="requiredSingularInt64">
        ///
        /// </param>
        /// <param name="requiredSingularFloat">
        ///
        /// </param>
        /// <param name="requiredSingularDouble">
        ///
        /// </param>
        /// <param name="requiredSingularBool">
        ///
        /// </param>
        /// <param name="requiredSingularEnum">
        ///
        /// </param>
        /// <param name="requiredSingularString">
        ///
        /// </param>
        /// <param name="requiredSingularBytes">
        ///
        /// </param>
        /// <param name="requiredSingularMessage">
        ///
        /// </param>
        /// <param name="requiredSingularResourceName">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredSingularFixed32">
        ///
        /// </param>
        /// <param name="requiredSingularFixed64">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloat">
        ///
        /// </param>
        /// <param name="requiredRepeatedDouble">
        ///
        /// </param>
        /// <param name="requiredRepeatedBool">
        ///
        /// </param>
        /// <param name="requiredRepeatedEnum">
        ///
        /// </param>
        /// <param name="requiredRepeatedString">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytes">
        ///
        /// </param>
        /// <param name="requiredRepeatedMessage">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceName">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed32">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed64">
        ///
        /// </param>
        /// <param name="requiredMap">
        ///
        /// </param>
        /// <param name="optionalSingularInt32">
        ///
        /// </param>
        /// <param name="optionalSingularInt64">
        ///
        /// </param>
        /// <param name="optionalSingularFloat">
        ///
        /// </param>
        /// <param name="optionalSingularDouble">
        ///
        /// </param>
        /// <param name="optionalSingularBool">
        ///
        /// </param>
        /// <param name="optionalSingularEnum">
        ///
        /// </param>
        /// <param name="optionalSingularString">
        ///
        /// </param>
        /// <param name="optionalSingularBytes">
        ///
        /// </param>
        /// <param name="optionalSingularMessage">
        ///
        /// </param>
        /// <param name="optionalSingularResourceName">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalSingularFixed32">
        ///
        /// </param>
        /// <param name="optionalSingularFixed64">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt32">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt64">
        ///
        /// </param>
        /// <param name="optionalRepeatedFloat">
        ///
        /// </param>
        /// <param name="optionalRepeatedDouble">
        ///
        /// </param>
        /// <param name="optionalRepeatedBool">
        ///
        /// </param>
        /// <param name="optionalRepeatedEnum">
        ///
        /// </param>
        /// <param name="optionalRepeatedString">
        ///
        /// </param>
        /// <param name="optionalRepeatedBytes">
        ///
        /// </param>
        /// <param name="optionalRepeatedMessage">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceName">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed32">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed64">
        ///
        /// </param>
        /// <param name="optionalMap">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            int requiredSingularInt32,
            long requiredSingularInt64,
            float requiredSingularFloat,
            double requiredSingularDouble,
            bool requiredSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum,
            string requiredSingularString,
            pb::ByteString requiredSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage,
            BookName requiredSingularResourceName,
            BookNameOneof requiredSingularResourceNameOneof,
            gaxres::ProjectName requiredSingularResourceNameCommon,
            int requiredSingularFixed32,
            long requiredSingularFixed64,
            scg::IEnumerable<int> requiredRepeatedInt32,
            scg::IEnumerable<long> requiredRepeatedInt64,
            scg::IEnumerable<float> requiredRepeatedFloat,
            scg::IEnumerable<double> requiredRepeatedDouble,
            scg::IEnumerable<bool> requiredRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum,
            scg::IEnumerable<string> requiredRepeatedString,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage,
            scg::IEnumerable<BookName> requiredRepeatedResourceName,
            scg::IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof,
            scg::IEnumerable<gaxres::ProjectName> requiredRepeatedResourceNameCommon,
            scg::IEnumerable<int> requiredRepeatedFixed32,
            scg::IEnumerable<long> requiredRepeatedFixed64,
            scg::IDictionary<int, string> requiredMap,
            int? optionalSingularInt32,
            long? optionalSingularInt64,
            float? optionalSingularFloat,
            double? optionalSingularDouble,
            bool? optionalSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum? optionalSingularEnum,
            string optionalSingularString,
            pb::ByteString optionalSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage,
            BookName optionalSingularResourceName,
            BookNameOneof optionalSingularResourceNameOneof,
            gaxres::ProjectName optionalSingularResourceNameCommon,
            int? optionalSingularFixed32,
            long? optionalSingularFixed64,
            scg::IEnumerable<int> optionalRepeatedInt32,
            scg::IEnumerable<long> optionalRepeatedInt64,
            scg::IEnumerable<float> optionalRepeatedFloat,
            scg::IEnumerable<double> optionalRepeatedDouble,
            scg::IEnumerable<bool> optionalRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum,
            scg::IEnumerable<string> optionalRepeatedString,
            scg::IEnumerable<pb::ByteString> optionalRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage,
            scg::IEnumerable<BookName> optionalRepeatedResourceName,
            scg::IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof,
            scg::IEnumerable<gaxres::ProjectName> optionalRepeatedResourceNameCommon,
            scg::IEnumerable<int> optionalRepeatedFixed32,
            scg::IEnumerable<long> optionalRepeatedFixed64,
            scg::IDictionary<int, string> optionalMap,
            gaxgrpc::CallSettings callSettings = null) => TestOptionalRequiredFlatteningParamsAsync(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                    RequiredSingularInt32 = requiredSingularInt32,
                    RequiredSingularInt64 = requiredSingularInt64,
                    RequiredSingularFloat = requiredSingularFloat,
                    RequiredSingularDouble = requiredSingularDouble,
                    RequiredSingularBool = requiredSingularBool,
                    RequiredSingularEnum = requiredSingularEnum,
                    RequiredSingularString = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularString, nameof(requiredSingularString)),
                    RequiredSingularBytes = gax::GaxPreconditions.CheckNotNull(requiredSingularBytes, nameof(requiredSingularBytes)),
                    RequiredSingularMessage = gax::GaxPreconditions.CheckNotNull(requiredSingularMessage, nameof(requiredSingularMessage)),
                    RequiredSingularResourceNameAsBookName = gax::GaxPreconditions.CheckNotNull(requiredSingularResourceName, nameof(requiredSingularResourceName)),
                    RequiredSingularResourceNameOneofAsBookNameOneof = gax::GaxPreconditions.CheckNotNull(requiredSingularResourceNameOneof, nameof(requiredSingularResourceNameOneof)),
                    RequiredSingularResourceNameCommonAsProjectName = gax::GaxPreconditions.CheckNotNull(requiredSingularResourceNameCommon, nameof(requiredSingularResourceNameCommon)),
                    RequiredSingularFixed32 = requiredSingularFixed32,
                    RequiredSingularFixed64 = requiredSingularFixed64,
                    RequiredRepeatedInt32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt32, nameof(requiredRepeatedInt32)) },
                    RequiredRepeatedInt64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt64, nameof(requiredRepeatedInt64)) },
                    RequiredRepeatedFloat = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFloat, nameof(requiredRepeatedFloat)) },
                    RequiredRepeatedDouble = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedDouble, nameof(requiredRepeatedDouble)) },
                    RequiredRepeatedBool = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBool, nameof(requiredRepeatedBool)) },
                    RequiredRepeatedEnum = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedEnum, nameof(requiredRepeatedEnum)) },
                    RequiredRepeatedString = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedString, nameof(requiredRepeatedString)) },
                    RequiredRepeatedBytes = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBytes, nameof(requiredRepeatedBytes)) },
                    RequiredRepeatedMessage = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedMessage, nameof(requiredRepeatedMessage)) },
                    RequiredRepeatedResourceNameAsBookNames = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceName, nameof(requiredRepeatedResourceName)) },
                    RequiredRepeatedResourceNameOneofAsBookNameOneofs = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameOneof, nameof(requiredRepeatedResourceNameOneof)) },
                    RequiredRepeatedResourceNameCommonAsProjectNames = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameCommon, nameof(requiredRepeatedResourceNameCommon)) },
                    RequiredRepeatedFixed32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed32, nameof(requiredRepeatedFixed32)) },
                    RequiredRepeatedFixed64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed64, nameof(requiredRepeatedFixed64)) },
                    RequiredMap = { gax::GaxPreconditions.CheckNotNull(requiredMap, nameof(requiredMap)) },
                    OptionalSingularInt32 = optionalSingularInt32 ?? 0, // Optional
                    OptionalSingularInt64 = optionalSingularInt64 ?? 0L, // Optional
                    OptionalSingularFloat = optionalSingularFloat ?? 0.0f, // Optional
                    OptionalSingularDouble = optionalSingularDouble ?? 0.0, // Optional
                    OptionalSingularBool = optionalSingularBool ?? false, // Optional
                    OptionalSingularEnum = optionalSingularEnum ?? TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero, // Optional
                    OptionalSingularString = optionalSingularString ?? "", // Optional
                    OptionalSingularBytes = optionalSingularBytes ?? pb::ByteString.Empty, // Optional
                    OptionalSingularMessage = optionalSingularMessage, // Optional
                    OptionalSingularResourceNameAsBookName = optionalSingularResourceName, // Optional
                    OptionalSingularResourceNameOneofAsBookNameOneof = optionalSingularResourceNameOneof, // Optional
                    OptionalSingularResourceNameCommonAsProjectName = optionalSingularResourceNameCommon, // Optional
                    OptionalSingularFixed32 = optionalSingularFixed32 ?? 0, // Optional
                    OptionalSingularFixed64 = optionalSingularFixed64 ?? 0L, // Optional
                    OptionalRepeatedInt32 = { optionalRepeatedInt32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedInt64 = { optionalRepeatedInt64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalRepeatedFloat = { optionalRepeatedFloat ?? linq::Enumerable.Empty<float>() }, // Optional
                    OptionalRepeatedDouble = { optionalRepeatedDouble ?? linq::Enumerable.Empty<double>() }, // Optional
                    OptionalRepeatedBool = { optionalRepeatedBool ?? linq::Enumerable.Empty<bool>() }, // Optional
                    OptionalRepeatedEnum = { optionalRepeatedEnum ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>() }, // Optional
                    OptionalRepeatedString = { optionalRepeatedString ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedBytes = { optionalRepeatedBytes ?? linq::Enumerable.Empty<pb::ByteString>() }, // Optional
                    OptionalRepeatedMessage = { optionalRepeatedMessage ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>() }, // Optional
                    OptionalRepeatedResourceNameAsBookNames = { optionalRepeatedResourceName ?? linq::Enumerable.Empty<BookName>() }, // Optional
                    OptionalRepeatedResourceNameOneofAsBookNameOneofs = { optionalRepeatedResourceNameOneof ?? linq::Enumerable.Empty<BookNameOneof>() }, // Optional
                    OptionalRepeatedResourceNameCommonAsProjectNames = { optionalRepeatedResourceNameCommon ?? linq::Enumerable.Empty<gaxres::ProjectName>() }, // Optional
                    OptionalRepeatedFixed32 = { optionalRepeatedFixed32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedFixed64 = { optionalRepeatedFixed64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalMap = { optionalMap ?? gax::EmptyDictionary<int, string>.Instance }, // Optional
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="requiredSingularInt32">
        ///
        /// </param>
        /// <param name="requiredSingularInt64">
        ///
        /// </param>
        /// <param name="requiredSingularFloat">
        ///
        /// </param>
        /// <param name="requiredSingularDouble">
        ///
        /// </param>
        /// <param name="requiredSingularBool">
        ///
        /// </param>
        /// <param name="requiredSingularEnum">
        ///
        /// </param>
        /// <param name="requiredSingularString">
        ///
        /// </param>
        /// <param name="requiredSingularBytes">
        ///
        /// </param>
        /// <param name="requiredSingularMessage">
        ///
        /// </param>
        /// <param name="requiredSingularResourceName">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredSingularFixed32">
        ///
        /// </param>
        /// <param name="requiredSingularFixed64">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloat">
        ///
        /// </param>
        /// <param name="requiredRepeatedDouble">
        ///
        /// </param>
        /// <param name="requiredRepeatedBool">
        ///
        /// </param>
        /// <param name="requiredRepeatedEnum">
        ///
        /// </param>
        /// <param name="requiredRepeatedString">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytes">
        ///
        /// </param>
        /// <param name="requiredRepeatedMessage">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceName">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed32">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed64">
        ///
        /// </param>
        /// <param name="requiredMap">
        ///
        /// </param>
        /// <param name="optionalSingularInt32">
        ///
        /// </param>
        /// <param name="optionalSingularInt64">
        ///
        /// </param>
        /// <param name="optionalSingularFloat">
        ///
        /// </param>
        /// <param name="optionalSingularDouble">
        ///
        /// </param>
        /// <param name="optionalSingularBool">
        ///
        /// </param>
        /// <param name="optionalSingularEnum">
        ///
        /// </param>
        /// <param name="optionalSingularString">
        ///
        /// </param>
        /// <param name="optionalSingularBytes">
        ///
        /// </param>
        /// <param name="optionalSingularMessage">
        ///
        /// </param>
        /// <param name="optionalSingularResourceName">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalSingularFixed32">
        ///
        /// </param>
        /// <param name="optionalSingularFixed64">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt32">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt64">
        ///
        /// </param>
        /// <param name="optionalRepeatedFloat">
        ///
        /// </param>
        /// <param name="optionalRepeatedDouble">
        ///
        /// </param>
        /// <param name="optionalRepeatedBool">
        ///
        /// </param>
        /// <param name="optionalRepeatedEnum">
        ///
        /// </param>
        /// <param name="optionalRepeatedString">
        ///
        /// </param>
        /// <param name="optionalRepeatedBytes">
        ///
        /// </param>
        /// <param name="optionalRepeatedMessage">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceName">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed32">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed64">
        ///
        /// </param>
        /// <param name="optionalMap">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            int requiredSingularInt32,
            long requiredSingularInt64,
            float requiredSingularFloat,
            double requiredSingularDouble,
            bool requiredSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum,
            string requiredSingularString,
            pb::ByteString requiredSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage,
            BookName requiredSingularResourceName,
            BookNameOneof requiredSingularResourceNameOneof,
            gaxres::ProjectName requiredSingularResourceNameCommon,
            int requiredSingularFixed32,
            long requiredSingularFixed64,
            scg::IEnumerable<int> requiredRepeatedInt32,
            scg::IEnumerable<long> requiredRepeatedInt64,
            scg::IEnumerable<float> requiredRepeatedFloat,
            scg::IEnumerable<double> requiredRepeatedDouble,
            scg::IEnumerable<bool> requiredRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum,
            scg::IEnumerable<string> requiredRepeatedString,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage,
            scg::IEnumerable<BookName> requiredRepeatedResourceName,
            scg::IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof,
            scg::IEnumerable<gaxres::ProjectName> requiredRepeatedResourceNameCommon,
            scg::IEnumerable<int> requiredRepeatedFixed32,
            scg::IEnumerable<long> requiredRepeatedFixed64,
            scg::IDictionary<int, string> requiredMap,
            int? optionalSingularInt32,
            long? optionalSingularInt64,
            float? optionalSingularFloat,
            double? optionalSingularDouble,
            bool? optionalSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum? optionalSingularEnum,
            string optionalSingularString,
            pb::ByteString optionalSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage,
            BookName optionalSingularResourceName,
            BookNameOneof optionalSingularResourceNameOneof,
            gaxres::ProjectName optionalSingularResourceNameCommon,
            int? optionalSingularFixed32,
            long? optionalSingularFixed64,
            scg::IEnumerable<int> optionalRepeatedInt32,
            scg::IEnumerable<long> optionalRepeatedInt64,
            scg::IEnumerable<float> optionalRepeatedFloat,
            scg::IEnumerable<double> optionalRepeatedDouble,
            scg::IEnumerable<bool> optionalRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum,
            scg::IEnumerable<string> optionalRepeatedString,
            scg::IEnumerable<pb::ByteString> optionalRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage,
            scg::IEnumerable<BookName> optionalRepeatedResourceName,
            scg::IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof,
            scg::IEnumerable<gaxres::ProjectName> optionalRepeatedResourceNameCommon,
            scg::IEnumerable<int> optionalRepeatedFixed32,
            scg::IEnumerable<long> optionalRepeatedFixed64,
            scg::IDictionary<int, string> optionalMap,
            st::CancellationToken cancellationToken) => TestOptionalRequiredFlatteningParamsAsync(
                requiredSingularInt32,
                requiredSingularInt64,
                requiredSingularFloat,
                requiredSingularDouble,
                requiredSingularBool,
                requiredSingularEnum,
                requiredSingularString,
                requiredSingularBytes,
                requiredSingularMessage,
                requiredSingularResourceName,
                requiredSingularResourceNameOneof,
                requiredSingularResourceNameCommon,
                requiredSingularFixed32,
                requiredSingularFixed64,
                requiredRepeatedInt32,
                requiredRepeatedInt64,
                requiredRepeatedFloat,
                requiredRepeatedDouble,
                requiredRepeatedBool,
                requiredRepeatedEnum,
                requiredRepeatedString,
                requiredRepeatedBytes,
                requiredRepeatedMessage,
                requiredRepeatedResourceName,
                requiredRepeatedResourceNameOneof,
                requiredRepeatedResourceNameCommon,
                requiredRepeatedFixed32,
                requiredRepeatedFixed64,
                requiredMap,
                optionalSingularInt32,
                optionalSingularInt64,
                optionalSingularFloat,
                optionalSingularDouble,
                optionalSingularBool,
                optionalSingularEnum,
                optionalSingularString,
                optionalSingularBytes,
                optionalSingularMessage,
                optionalSingularResourceName,
                optionalSingularResourceNameOneof,
                optionalSingularResourceNameCommon,
                optionalSingularFixed32,
                optionalSingularFixed64,
                optionalRepeatedInt32,
                optionalRepeatedInt64,
                optionalRepeatedFloat,
                optionalRepeatedDouble,
                optionalRepeatedBool,
                optionalRepeatedEnum,
                optionalRepeatedString,
                optionalRepeatedBytes,
                optionalRepeatedMessage,
                optionalRepeatedResourceName,
                optionalRepeatedResourceNameOneof,
                optionalRepeatedResourceNameCommon,
                optionalRepeatedFixed32,
                optionalRepeatedFixed64,
                optionalMap,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="requiredSingularInt32">
        ///
        /// </param>
        /// <param name="requiredSingularInt64">
        ///
        /// </param>
        /// <param name="requiredSingularFloat">
        ///
        /// </param>
        /// <param name="requiredSingularDouble">
        ///
        /// </param>
        /// <param name="requiredSingularBool">
        ///
        /// </param>
        /// <param name="requiredSingularEnum">
        ///
        /// </param>
        /// <param name="requiredSingularString">
        ///
        /// </param>
        /// <param name="requiredSingularBytes">
        ///
        /// </param>
        /// <param name="requiredSingularMessage">
        ///
        /// </param>
        /// <param name="requiredSingularResourceName">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredSingularFixed32">
        ///
        /// </param>
        /// <param name="requiredSingularFixed64">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloat">
        ///
        /// </param>
        /// <param name="requiredRepeatedDouble">
        ///
        /// </param>
        /// <param name="requiredRepeatedBool">
        ///
        /// </param>
        /// <param name="requiredRepeatedEnum">
        ///
        /// </param>
        /// <param name="requiredRepeatedString">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytes">
        ///
        /// </param>
        /// <param name="requiredRepeatedMessage">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceName">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed32">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed64">
        ///
        /// </param>
        /// <param name="requiredMap">
        ///
        /// </param>
        /// <param name="optionalSingularInt32">
        ///
        /// </param>
        /// <param name="optionalSingularInt64">
        ///
        /// </param>
        /// <param name="optionalSingularFloat">
        ///
        /// </param>
        /// <param name="optionalSingularDouble">
        ///
        /// </param>
        /// <param name="optionalSingularBool">
        ///
        /// </param>
        /// <param name="optionalSingularEnum">
        ///
        /// </param>
        /// <param name="optionalSingularString">
        ///
        /// </param>
        /// <param name="optionalSingularBytes">
        ///
        /// </param>
        /// <param name="optionalSingularMessage">
        ///
        /// </param>
        /// <param name="optionalSingularResourceName">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalSingularFixed32">
        ///
        /// </param>
        /// <param name="optionalSingularFixed64">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt32">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt64">
        ///
        /// </param>
        /// <param name="optionalRepeatedFloat">
        ///
        /// </param>
        /// <param name="optionalRepeatedDouble">
        ///
        /// </param>
        /// <param name="optionalRepeatedBool">
        ///
        /// </param>
        /// <param name="optionalRepeatedEnum">
        ///
        /// </param>
        /// <param name="optionalRepeatedString">
        ///
        /// </param>
        /// <param name="optionalRepeatedBytes">
        ///
        /// </param>
        /// <param name="optionalRepeatedMessage">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceName">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed32">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed64">
        ///
        /// </param>
        /// <param name="optionalMap">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual TestOptionalRequiredFlatteningParamsResponse TestOptionalRequiredFlatteningParams(
            int requiredSingularInt32,
            long requiredSingularInt64,
            float requiredSingularFloat,
            double requiredSingularDouble,
            bool requiredSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum,
            string requiredSingularString,
            pb::ByteString requiredSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage,
            BookName requiredSingularResourceName,
            BookNameOneof requiredSingularResourceNameOneof,
            gaxres::ProjectName requiredSingularResourceNameCommon,
            int requiredSingularFixed32,
            long requiredSingularFixed64,
            scg::IEnumerable<int> requiredRepeatedInt32,
            scg::IEnumerable<long> requiredRepeatedInt64,
            scg::IEnumerable<float> requiredRepeatedFloat,
            scg::IEnumerable<double> requiredRepeatedDouble,
            scg::IEnumerable<bool> requiredRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum,
            scg::IEnumerable<string> requiredRepeatedString,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage,
            scg::IEnumerable<BookName> requiredRepeatedResourceName,
            scg::IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof,
            scg::IEnumerable<gaxres::ProjectName> requiredRepeatedResourceNameCommon,
            scg::IEnumerable<int> requiredRepeatedFixed32,
            scg::IEnumerable<long> requiredRepeatedFixed64,
            scg::IDictionary<int, string> requiredMap,
            int? optionalSingularInt32,
            long? optionalSingularInt64,
            float? optionalSingularFloat,
            double? optionalSingularDouble,
            bool? optionalSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum? optionalSingularEnum,
            string optionalSingularString,
            pb::ByteString optionalSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage,
            BookName optionalSingularResourceName,
            BookNameOneof optionalSingularResourceNameOneof,
            gaxres::ProjectName optionalSingularResourceNameCommon,
            int? optionalSingularFixed32,
            long? optionalSingularFixed64,
            scg::IEnumerable<int> optionalRepeatedInt32,
            scg::IEnumerable<long> optionalRepeatedInt64,
            scg::IEnumerable<float> optionalRepeatedFloat,
            scg::IEnumerable<double> optionalRepeatedDouble,
            scg::IEnumerable<bool> optionalRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum,
            scg::IEnumerable<string> optionalRepeatedString,
            scg::IEnumerable<pb::ByteString> optionalRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage,
            scg::IEnumerable<BookName> optionalRepeatedResourceName,
            scg::IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof,
            scg::IEnumerable<gaxres::ProjectName> optionalRepeatedResourceNameCommon,
            scg::IEnumerable<int> optionalRepeatedFixed32,
            scg::IEnumerable<long> optionalRepeatedFixed64,
            scg::IDictionary<int, string> optionalMap,
            gaxgrpc::CallSettings callSettings = null) => TestOptionalRequiredFlatteningParams(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                    RequiredSingularInt32 = requiredSingularInt32,
                    RequiredSingularInt64 = requiredSingularInt64,
                    RequiredSingularFloat = requiredSingularFloat,
                    RequiredSingularDouble = requiredSingularDouble,
                    RequiredSingularBool = requiredSingularBool,
                    RequiredSingularEnum = requiredSingularEnum,
                    RequiredSingularString = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularString, nameof(requiredSingularString)),
                    RequiredSingularBytes = gax::GaxPreconditions.CheckNotNull(requiredSingularBytes, nameof(requiredSingularBytes)),
                    RequiredSingularMessage = gax::GaxPreconditions.CheckNotNull(requiredSingularMessage, nameof(requiredSingularMessage)),
                    RequiredSingularResourceNameAsBookName = gax::GaxPreconditions.CheckNotNull(requiredSingularResourceName, nameof(requiredSingularResourceName)),
                    RequiredSingularResourceNameOneofAsBookNameOneof = gax::GaxPreconditions.CheckNotNull(requiredSingularResourceNameOneof, nameof(requiredSingularResourceNameOneof)),
                    RequiredSingularResourceNameCommonAsProjectName = gax::GaxPreconditions.CheckNotNull(requiredSingularResourceNameCommon, nameof(requiredSingularResourceNameCommon)),
                    RequiredSingularFixed32 = requiredSingularFixed32,
                    RequiredSingularFixed64 = requiredSingularFixed64,
                    RequiredRepeatedInt32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt32, nameof(requiredRepeatedInt32)) },
                    RequiredRepeatedInt64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt64, nameof(requiredRepeatedInt64)) },
                    RequiredRepeatedFloat = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFloat, nameof(requiredRepeatedFloat)) },
                    RequiredRepeatedDouble = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedDouble, nameof(requiredRepeatedDouble)) },
                    RequiredRepeatedBool = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBool, nameof(requiredRepeatedBool)) },
                    RequiredRepeatedEnum = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedEnum, nameof(requiredRepeatedEnum)) },
                    RequiredRepeatedString = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedString, nameof(requiredRepeatedString)) },
                    RequiredRepeatedBytes = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBytes, nameof(requiredRepeatedBytes)) },
                    RequiredRepeatedMessage = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedMessage, nameof(requiredRepeatedMessage)) },
                    RequiredRepeatedResourceNameAsBookNames = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceName, nameof(requiredRepeatedResourceName)) },
                    RequiredRepeatedResourceNameOneofAsBookNameOneofs = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameOneof, nameof(requiredRepeatedResourceNameOneof)) },
                    RequiredRepeatedResourceNameCommonAsProjectNames = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameCommon, nameof(requiredRepeatedResourceNameCommon)) },
                    RequiredRepeatedFixed32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed32, nameof(requiredRepeatedFixed32)) },
                    RequiredRepeatedFixed64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed64, nameof(requiredRepeatedFixed64)) },
                    RequiredMap = { gax::GaxPreconditions.CheckNotNull(requiredMap, nameof(requiredMap)) },
                    OptionalSingularInt32 = optionalSingularInt32 ?? 0, // Optional
                    OptionalSingularInt64 = optionalSingularInt64 ?? 0L, // Optional
                    OptionalSingularFloat = optionalSingularFloat ?? 0.0f, // Optional
                    OptionalSingularDouble = optionalSingularDouble ?? 0.0, // Optional
                    OptionalSingularBool = optionalSingularBool ?? false, // Optional
                    OptionalSingularEnum = optionalSingularEnum ?? TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero, // Optional
                    OptionalSingularString = optionalSingularString ?? "", // Optional
                    OptionalSingularBytes = optionalSingularBytes ?? pb::ByteString.Empty, // Optional
                    OptionalSingularMessage = optionalSingularMessage, // Optional
                    OptionalSingularResourceNameAsBookName = optionalSingularResourceName, // Optional
                    OptionalSingularResourceNameOneofAsBookNameOneof = optionalSingularResourceNameOneof, // Optional
                    OptionalSingularResourceNameCommonAsProjectName = optionalSingularResourceNameCommon, // Optional
                    OptionalSingularFixed32 = optionalSingularFixed32 ?? 0, // Optional
                    OptionalSingularFixed64 = optionalSingularFixed64 ?? 0L, // Optional
                    OptionalRepeatedInt32 = { optionalRepeatedInt32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedInt64 = { optionalRepeatedInt64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalRepeatedFloat = { optionalRepeatedFloat ?? linq::Enumerable.Empty<float>() }, // Optional
                    OptionalRepeatedDouble = { optionalRepeatedDouble ?? linq::Enumerable.Empty<double>() }, // Optional
                    OptionalRepeatedBool = { optionalRepeatedBool ?? linq::Enumerable.Empty<bool>() }, // Optional
                    OptionalRepeatedEnum = { optionalRepeatedEnum ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>() }, // Optional
                    OptionalRepeatedString = { optionalRepeatedString ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedBytes = { optionalRepeatedBytes ?? linq::Enumerable.Empty<pb::ByteString>() }, // Optional
                    OptionalRepeatedMessage = { optionalRepeatedMessage ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>() }, // Optional
                    OptionalRepeatedResourceNameAsBookNames = { optionalRepeatedResourceName ?? linq::Enumerable.Empty<BookName>() }, // Optional
                    OptionalRepeatedResourceNameOneofAsBookNameOneofs = { optionalRepeatedResourceNameOneof ?? linq::Enumerable.Empty<BookNameOneof>() }, // Optional
                    OptionalRepeatedResourceNameCommonAsProjectNames = { optionalRepeatedResourceNameCommon ?? linq::Enumerable.Empty<gaxres::ProjectName>() }, // Optional
                    OptionalRepeatedFixed32 = { optionalRepeatedFixed32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedFixed64 = { optionalRepeatedFixed64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalMap = { optionalMap ?? gax::EmptyDictionary<int, string>.Instance }, // Optional
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            TestOptionalRequiredFlatteningParamsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            TestOptionalRequiredFlatteningParamsRequest request,
            st::CancellationToken cancellationToken) => TestOptionalRequiredFlatteningParamsAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual TestOptionalRequiredFlatteningParamsResponse TestOptionalRequiredFlatteningParams(
            TestOptionalRequiredFlatteningParamsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

    }

    /// <summary>
    /// LibraryService client wrapper implementation, for convenient use.
    /// </summary>
    public sealed partial class LibraryServiceClientImpl : LibraryServiceClient
    {
        private readonly gaxgrpc::ApiCall<CreateShelfRequest, Shelf> _callCreateShelf;
        private readonly gaxgrpc::ApiCall<GetShelfRequest, Shelf> _callGetShelf;
        private readonly gaxgrpc::ApiCall<ListShelvesRequest, ListShelvesResponse> _callListShelves;
        private readonly gaxgrpc::ApiCall<DeleteShelfRequest, pbwkt::Empty> _callDeleteShelf;
        private readonly gaxgrpc::ApiCall<MergeShelvesRequest, Shelf> _callMergeShelves;
        private readonly gaxgrpc::ApiCall<CreateBookRequest, Book> _callCreateBook;
        private readonly gaxgrpc::ApiCall<PublishSeriesRequest, PublishSeriesResponse> _callPublishSeries;
        private readonly gaxgrpc::ApiCall<GetBookRequest, Book> _callGetBook;
        private readonly gaxgrpc::ApiCall<ListBooksRequest, ListBooksResponse> _callListBooks;
        private readonly gaxgrpc::ApiCall<DeleteBookRequest, pbwkt::Empty> _callDeleteBook;
        private readonly gaxgrpc::ApiCall<UpdateBookRequest, Book> _callUpdateBook;
        private readonly gaxgrpc::ApiCall<MoveBookRequest, Book> _callMoveBook;
        private readonly gaxgrpc::ApiCall<ListStringsRequest, ListStringsResponse> _callListStrings;
        private readonly gaxgrpc::ApiCall<AddCommentsRequest, pbwkt::Empty> _callAddComments;
        private readonly gaxgrpc::ApiCall<GetBookFromArchiveRequest, BookFromArchive> _callGetBookFromArchive;
        private readonly gaxgrpc::ApiCall<GetBookFromAnywhereRequest, BookFromAnywhere> _callGetBookFromAnywhere;
        private readonly gaxgrpc::ApiCall<GetBookFromAbsolutelyAnywhereRequest, BookFromAnywhere> _callGetBookFromAbsolutelyAnywhere;
        private readonly gaxgrpc::ApiCall<UpdateBookIndexRequest, pbwkt::Empty> _callUpdateBookIndex;
        private readonly gaxgrpc::ApiServerStreamingCall<StreamShelvesRequest, StreamShelvesResponse> _callStreamShelves;
        private readonly gaxgrpc::ApiServerStreamingCall<StreamBooksRequest, Book> _callStreamBooks;
        private readonly gaxgrpc::ApiBidirectionalStreamingCall<DiscussBookRequest, Comment> _callDiscussBook;
        private readonly gaxgrpc::ApiCall<FindRelatedBooksRequest, FindRelatedBooksResponse> _callFindRelatedBooks;
        private readonly gaxgrpc::ApiCall<gtv::AddTagRequest, gtv::AddTagResponse> _callAddTag;
        private readonly gaxgrpc::ApiCall<gtv::AddLabelRequest, gtv::AddLabelResponse> _callAddLabel;
        private readonly gaxgrpc::ApiCall<GetBookRequest, lro::Operation> _callGetBigBook;
        private readonly gaxgrpc::ApiCall<GetBookRequest, lro::Operation> _callGetBigNothing;
        private readonly gaxgrpc::ApiCall<TestOptionalRequiredFlatteningParamsRequest, TestOptionalRequiredFlatteningParamsResponse> _callTestOptionalRequiredFlatteningParams;

        /// <summary>
        /// Constructs a client wrapper for the LibraryService service, with the specified gRPC client and settings.
        /// </summary>
        /// <param name="grpcClient">The underlying gRPC client.</param>
        /// <param name="settings">The base <see cref="LibraryServiceSettings"/> used within this client </param>
        public LibraryServiceClientImpl(LibraryService.LibraryServiceClient grpcClient, LibraryServiceSettings settings)
        {
            GrpcClient = grpcClient;
            LibraryServiceSettings effectiveSettings = settings ?? LibraryServiceSettings.GetDefault();
            gaxgrpc::ClientHelper clientHelper = new gaxgrpc::ClientHelper(effectiveSettings);
            gctv::Labeler.LabelerClient grpcLabelerClient = grpcClient.CreateLabelerClient();
            GetBigBookOperationsClient = new lro::OperationsClientImpl(
                grpcClient.CreateOperationsClient(), effectiveSettings.GetBigBookOperationsSettings);
            GetBigNothingOperationsClient = new lro::OperationsClientImpl(
                grpcClient.CreateOperationsClient(), effectiveSettings.GetBigNothingOperationsSettings);
            _callCreateShelf = clientHelper.BuildApiCall<CreateShelfRequest, Shelf>(
                GrpcClient.CreateShelfAsync, GrpcClient.CreateShelf, effectiveSettings.CreateShelfSettings);
            _callGetShelf = clientHelper.BuildApiCall<GetShelfRequest, Shelf>(
                GrpcClient.GetShelfAsync, GrpcClient.GetShelf, effectiveSettings.GetShelfSettings);
            _callListShelves = clientHelper.BuildApiCall<ListShelvesRequest, ListShelvesResponse>(
                GrpcClient.ListShelvesAsync, GrpcClient.ListShelves, effectiveSettings.ListShelvesSettings);
            _callDeleteShelf = clientHelper.BuildApiCall<DeleteShelfRequest, pbwkt::Empty>(
                GrpcClient.DeleteShelfAsync, GrpcClient.DeleteShelf, effectiveSettings.DeleteShelfSettings);
            _callMergeShelves = clientHelper.BuildApiCall<MergeShelvesRequest, Shelf>(
                GrpcClient.MergeShelvesAsync, GrpcClient.MergeShelves, effectiveSettings.MergeShelvesSettings);
            _callCreateBook = clientHelper.BuildApiCall<CreateBookRequest, Book>(
                GrpcClient.CreateBookAsync, GrpcClient.CreateBook, effectiveSettings.CreateBookSettings)
                .WithCallSettingsOverlay(request => gaxgrpc::CallSettings.FromHeader("x-goog-request-params", $"name={request.Name}&book.read={request.Book.Read}"));
            _callPublishSeries = clientHelper.BuildApiCall<PublishSeriesRequest, PublishSeriesResponse>(
                GrpcClient.PublishSeriesAsync, GrpcClient.PublishSeries, effectiveSettings.PublishSeriesSettings);
            _callGetBook = clientHelper.BuildApiCall<GetBookRequest, Book>(
                GrpcClient.GetBookAsync, GrpcClient.GetBook, effectiveSettings.GetBookSettings);
            _callListBooks = clientHelper.BuildApiCall<ListBooksRequest, ListBooksResponse>(
                GrpcClient.ListBooksAsync, GrpcClient.ListBooks, effectiveSettings.ListBooksSettings);
            _callDeleteBook = clientHelper.BuildApiCall<DeleteBookRequest, pbwkt::Empty>(
                GrpcClient.DeleteBookAsync, GrpcClient.DeleteBook, effectiveSettings.DeleteBookSettings);
            _callUpdateBook = clientHelper.BuildApiCall<UpdateBookRequest, Book>(
                GrpcClient.UpdateBookAsync, GrpcClient.UpdateBook, effectiveSettings.UpdateBookSettings);
            _callMoveBook = clientHelper.BuildApiCall<MoveBookRequest, Book>(
                GrpcClient.MoveBookAsync, GrpcClient.MoveBook, effectiveSettings.MoveBookSettings);
            _callListStrings = clientHelper.BuildApiCall<ListStringsRequest, ListStringsResponse>(
                GrpcClient.ListStringsAsync, GrpcClient.ListStrings, effectiveSettings.ListStringsSettings);
            _callAddComments = clientHelper.BuildApiCall<AddCommentsRequest, pbwkt::Empty>(
                GrpcClient.AddCommentsAsync, GrpcClient.AddComments, effectiveSettings.AddCommentsSettings);
            _callGetBookFromArchive = clientHelper.BuildApiCall<GetBookFromArchiveRequest, BookFromArchive>(
                GrpcClient.GetBookFromArchiveAsync, GrpcClient.GetBookFromArchive, effectiveSettings.GetBookFromArchiveSettings);
            _callGetBookFromAnywhere = clientHelper.BuildApiCall<GetBookFromAnywhereRequest, BookFromAnywhere>(
                GrpcClient.GetBookFromAnywhereAsync, GrpcClient.GetBookFromAnywhere, effectiveSettings.GetBookFromAnywhereSettings);
            _callGetBookFromAbsolutelyAnywhere = clientHelper.BuildApiCall<GetBookFromAbsolutelyAnywhereRequest, BookFromAnywhere>(
                GrpcClient.GetBookFromAbsolutelyAnywhereAsync, GrpcClient.GetBookFromAbsolutelyAnywhere, effectiveSettings.GetBookFromAbsolutelyAnywhereSettings);
            _callUpdateBookIndex = clientHelper.BuildApiCall<UpdateBookIndexRequest, pbwkt::Empty>(
                GrpcClient.UpdateBookIndexAsync, GrpcClient.UpdateBookIndex, effectiveSettings.UpdateBookIndexSettings);
            _callStreamShelves = clientHelper.BuildApiCall<StreamShelvesRequest, StreamShelvesResponse>(
                GrpcClient.StreamShelves, effectiveSettings.StreamShelvesSettings);
            _callStreamBooks = clientHelper.BuildApiCall<StreamBooksRequest, Book>(
                GrpcClient.StreamBooks, effectiveSettings.StreamBooksSettings);
            _callDiscussBook = clientHelper.BuildApiCall<DiscussBookRequest, Comment>(
                GrpcClient.DiscussBook, effectiveSettings.DiscussBookSettings, effectiveSettings.DiscussBookStreamingSettings);
            _callFindRelatedBooks = clientHelper.BuildApiCall<FindRelatedBooksRequest, FindRelatedBooksResponse>(
                GrpcClient.FindRelatedBooksAsync, GrpcClient.FindRelatedBooks, effectiveSettings.FindRelatedBooksSettings);
            _callAddTag = clientHelper.BuildApiCall<gtv::AddTagRequest, gtv::AddTagResponse>(
                GrpcClient.AddTagAsync, GrpcClient.AddTag, effectiveSettings.AddTagSettings);
            _callAddLabel = clientHelper.BuildApiCall<gtv::AddLabelRequest, gtv::AddLabelResponse>(
                grpcLabelerClient.AddLabelAsync, grpcLabelerClient.AddLabel, effectiveSettings.AddLabelSettings);
            _callGetBigBook = clientHelper.BuildApiCall<GetBookRequest, lro::Operation>(
                GrpcClient.GetBigBookAsync, GrpcClient.GetBigBook, effectiveSettings.GetBigBookSettings);
            _callGetBigNothing = clientHelper.BuildApiCall<GetBookRequest, lro::Operation>(
                GrpcClient.GetBigNothingAsync, GrpcClient.GetBigNothing, effectiveSettings.GetBigNothingSettings);
            _callTestOptionalRequiredFlatteningParams = clientHelper.BuildApiCall<TestOptionalRequiredFlatteningParamsRequest, TestOptionalRequiredFlatteningParamsResponse>(
                GrpcClient.TestOptionalRequiredFlatteningParamsAsync, GrpcClient.TestOptionalRequiredFlatteningParams, effectiveSettings.TestOptionalRequiredFlatteningParamsSettings);
            Modify_ApiCall(ref _callCreateShelf);
            Modify_CreateShelfApiCall(ref _callCreateShelf);
            Modify_ApiCall(ref _callGetShelf);
            Modify_GetShelfApiCall(ref _callGetShelf);
            Modify_ApiCall(ref _callListShelves);
            Modify_ListShelvesApiCall(ref _callListShelves);
            Modify_ApiCall(ref _callDeleteShelf);
            Modify_DeleteShelfApiCall(ref _callDeleteShelf);
            Modify_ApiCall(ref _callMergeShelves);
            Modify_MergeShelvesApiCall(ref _callMergeShelves);
            Modify_ApiCall(ref _callCreateBook);
            Modify_CreateBookApiCall(ref _callCreateBook);
            Modify_ApiCall(ref _callPublishSeries);
            Modify_PublishSeriesApiCall(ref _callPublishSeries);
            Modify_ApiCall(ref _callGetBook);
            Modify_GetBookApiCall(ref _callGetBook);
            Modify_ApiCall(ref _callListBooks);
            Modify_ListBooksApiCall(ref _callListBooks);
            Modify_ApiCall(ref _callDeleteBook);
            Modify_DeleteBookApiCall(ref _callDeleteBook);
            Modify_ApiCall(ref _callUpdateBook);
            Modify_UpdateBookApiCall(ref _callUpdateBook);
            Modify_ApiCall(ref _callMoveBook);
            Modify_MoveBookApiCall(ref _callMoveBook);
            Modify_ApiCall(ref _callListStrings);
            Modify_ListStringsApiCall(ref _callListStrings);
            Modify_ApiCall(ref _callAddComments);
            Modify_AddCommentsApiCall(ref _callAddComments);
            Modify_ApiCall(ref _callGetBookFromArchive);
            Modify_GetBookFromArchiveApiCall(ref _callGetBookFromArchive);
            Modify_ApiCall(ref _callGetBookFromAnywhere);
            Modify_GetBookFromAnywhereApiCall(ref _callGetBookFromAnywhere);
            Modify_ApiCall(ref _callGetBookFromAbsolutelyAnywhere);
            Modify_GetBookFromAbsolutelyAnywhereApiCall(ref _callGetBookFromAbsolutelyAnywhere);
            Modify_ApiCall(ref _callUpdateBookIndex);
            Modify_UpdateBookIndexApiCall(ref _callUpdateBookIndex);
            Modify_ApiCall(ref _callStreamShelves);
            Modify_StreamShelvesApiCall(ref _callStreamShelves);
            Modify_ApiCall(ref _callStreamBooks);
            Modify_StreamBooksApiCall(ref _callStreamBooks);
            Modify_ApiCall(ref _callDiscussBook);
            Modify_DiscussBookApiCall(ref _callDiscussBook);
            Modify_ApiCall(ref _callFindRelatedBooks);
            Modify_FindRelatedBooksApiCall(ref _callFindRelatedBooks);
            Modify_ApiCall(ref _callAddTag);
            Modify_AddTagApiCall(ref _callAddTag);
            Modify_ApiCall(ref _callAddLabel);
            Modify_AddLabelApiCall(ref _callAddLabel);
            Modify_ApiCall(ref _callGetBigBook);
            Modify_GetBigBookApiCall(ref _callGetBigBook);
            Modify_ApiCall(ref _callGetBigNothing);
            Modify_GetBigNothingApiCall(ref _callGetBigNothing);
            Modify_ApiCall(ref _callTestOptionalRequiredFlatteningParams);
            Modify_TestOptionalRequiredFlatteningParamsApiCall(ref _callTestOptionalRequiredFlatteningParams);
            OnConstruction(grpcClient, effectiveSettings, clientHelper);
        }

        // Partial methods are named to (mostly) ensure there cannot be conflicts with RPC method names.

        // Partial methods called for every ApiCall on construction.
        // Allows modification of all the underlying ApiCall objects.
        partial void Modify_ApiCall<TRequest, TResponse>(ref gaxgrpc::ApiCall<TRequest, TResponse> call)
            where TRequest : class, pb::IMessage<TRequest>
            where TResponse : class, pb::IMessage<TResponse>;
        partial void Modify_ApiCall<TRequest, TResponse>(ref gaxgrpc::ApiServerStreamingCall<TRequest, TResponse> call)
            where TRequest : class, pb::IMessage<TRequest>
            where TResponse : class, pb::IMessage<TResponse>;
        partial void Modify_ApiCall<TRequest, TResponse>(ref gaxgrpc::ApiBidirectionalStreamingCall<TRequest, TResponse> call)
            where TRequest : class, pb::IMessage<TRequest>
            where TResponse : class, pb::IMessage<TResponse>;

        // Partial methods called for each ApiCall on construction.
        // Allows per-RPC-method modification of the underlying ApiCall object.
        partial void Modify_CreateShelfApiCall(ref gaxgrpc::ApiCall<CreateShelfRequest, Shelf> call);
        partial void Modify_GetShelfApiCall(ref gaxgrpc::ApiCall<GetShelfRequest, Shelf> call);
        partial void Modify_ListShelvesApiCall(ref gaxgrpc::ApiCall<ListShelvesRequest, ListShelvesResponse> call);
        partial void Modify_DeleteShelfApiCall(ref gaxgrpc::ApiCall<DeleteShelfRequest, pbwkt::Empty> call);
        partial void Modify_MergeShelvesApiCall(ref gaxgrpc::ApiCall<MergeShelvesRequest, Shelf> call);
        partial void Modify_CreateBookApiCall(ref gaxgrpc::ApiCall<CreateBookRequest, Book> call);
        partial void Modify_PublishSeriesApiCall(ref gaxgrpc::ApiCall<PublishSeriesRequest, PublishSeriesResponse> call);
        partial void Modify_GetBookApiCall(ref gaxgrpc::ApiCall<GetBookRequest, Book> call);
        partial void Modify_ListBooksApiCall(ref gaxgrpc::ApiCall<ListBooksRequest, ListBooksResponse> call);
        partial void Modify_DeleteBookApiCall(ref gaxgrpc::ApiCall<DeleteBookRequest, pbwkt::Empty> call);
        partial void Modify_UpdateBookApiCall(ref gaxgrpc::ApiCall<UpdateBookRequest, Book> call);
        partial void Modify_MoveBookApiCall(ref gaxgrpc::ApiCall<MoveBookRequest, Book> call);
        partial void Modify_ListStringsApiCall(ref gaxgrpc::ApiCall<ListStringsRequest, ListStringsResponse> call);
        partial void Modify_AddCommentsApiCall(ref gaxgrpc::ApiCall<AddCommentsRequest, pbwkt::Empty> call);
        partial void Modify_GetBookFromArchiveApiCall(ref gaxgrpc::ApiCall<GetBookFromArchiveRequest, BookFromArchive> call);
        partial void Modify_GetBookFromAnywhereApiCall(ref gaxgrpc::ApiCall<GetBookFromAnywhereRequest, BookFromAnywhere> call);
        partial void Modify_GetBookFromAbsolutelyAnywhereApiCall(ref gaxgrpc::ApiCall<GetBookFromAbsolutelyAnywhereRequest, BookFromAnywhere> call);
        partial void Modify_UpdateBookIndexApiCall(ref gaxgrpc::ApiCall<UpdateBookIndexRequest, pbwkt::Empty> call);
        partial void Modify_StreamShelvesApiCall(ref gaxgrpc::ApiServerStreamingCall<StreamShelvesRequest, StreamShelvesResponse> call);
        partial void Modify_StreamBooksApiCall(ref gaxgrpc::ApiServerStreamingCall<StreamBooksRequest, Book> call);
        partial void Modify_DiscussBookApiCall(ref gaxgrpc::ApiBidirectionalStreamingCall<DiscussBookRequest, Comment> call);
        partial void Modify_FindRelatedBooksApiCall(ref gaxgrpc::ApiCall<FindRelatedBooksRequest, FindRelatedBooksResponse> call);
        partial void Modify_AddTagApiCall(ref gaxgrpc::ApiCall<gtv::AddTagRequest, gtv::AddTagResponse> call);
        partial void Modify_AddLabelApiCall(ref gaxgrpc::ApiCall<gtv::AddLabelRequest, gtv::AddLabelResponse> call);
        partial void Modify_GetBigBookApiCall(ref gaxgrpc::ApiCall<GetBookRequest, lro::Operation> call);
        partial void Modify_GetBigNothingApiCall(ref gaxgrpc::ApiCall<GetBookRequest, lro::Operation> call);
        partial void Modify_TestOptionalRequiredFlatteningParamsApiCall(ref gaxgrpc::ApiCall<TestOptionalRequiredFlatteningParamsRequest, TestOptionalRequiredFlatteningParamsResponse> call);
        partial void OnConstruction(LibraryService.LibraryServiceClient grpcClient, LibraryServiceSettings effectiveSettings, gaxgrpc::ClientHelper clientHelper);

        /// <summary>
        /// The underlying gRPC LibraryService client.
        /// </summary>
        public override LibraryService.LibraryServiceClient GrpcClient { get; }

        // Partial methods called on each request.
        // Allows per-RPC-call modification to the request and CallSettings objects,
        // before the underlying RPC is performed.
        partial void Modify_CreateShelfRequest(ref CreateShelfRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_GetShelfRequest(ref GetShelfRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_ListShelvesRequest(ref ListShelvesRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_DeleteShelfRequest(ref DeleteShelfRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_MergeShelvesRequest(ref MergeShelvesRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_CreateBookRequest(ref CreateBookRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_PublishSeriesRequest(ref PublishSeriesRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_GetBookRequest(ref GetBookRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_ListBooksRequest(ref ListBooksRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_DeleteBookRequest(ref DeleteBookRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_UpdateBookRequest(ref UpdateBookRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_MoveBookRequest(ref MoveBookRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_ListStringsRequest(ref ListStringsRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_AddCommentsRequest(ref AddCommentsRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_GetBookFromArchiveRequest(ref GetBookFromArchiveRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_GetBookFromAnywhereRequest(ref GetBookFromAnywhereRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_GetBookFromAbsolutelyAnywhereRequest(ref GetBookFromAbsolutelyAnywhereRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_UpdateBookIndexRequest(ref UpdateBookIndexRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_StreamShelvesRequest(ref StreamShelvesRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_StreamBooksRequest(ref StreamBooksRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_DiscussBookRequestCallSettings(ref gaxgrpc::CallSettings settings);
        partial void Modify_DiscussBookRequestRequest(ref DiscussBookRequest request);
        partial void Modify_FindRelatedBooksRequest(ref FindRelatedBooksRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_AddTagRequest(ref gtv::AddTagRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_AddLabelRequest(ref gtv::AddLabelRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_TestOptionalRequiredFlatteningParamsRequest(ref TestOptionalRequiredFlatteningParamsRequest request, ref gaxgrpc::CallSettings settings);

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Shelf> CreateShelfAsync(
            CreateShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_CreateShelfRequest(ref request, ref callSettings);
            return _callCreateShelf.Async(request, callSettings);
        }

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Shelf CreateShelf(
            CreateShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_CreateShelfRequest(ref request, ref callSettings);
            return _callCreateShelf.Sync(request, callSettings);
        }

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Shelf> GetShelfAsync(
            GetShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetShelfRequest(ref request, ref callSettings);
            return _callGetShelf.Async(request, callSettings);
        }

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Shelf GetShelf(
            GetShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetShelfRequest(ref request, ref callSettings);
            return _callGetShelf.Sync(request, callSettings);
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public override gax::PagedAsyncEnumerable<ListShelvesResponse, Shelf> ListShelvesAsync(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListShelvesRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedAsyncEnumerable<ListShelvesRequest, ListShelvesResponse, Shelf>(_callListShelves, request, callSettings);
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public override gax::PagedEnumerable<ListShelvesResponse, Shelf> ListShelves(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListShelvesRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedEnumerable<ListShelvesRequest, ListShelvesResponse, Shelf>(_callListShelves, request, callSettings);
        }

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public override stt::Task DeleteShelfAsync(
            DeleteShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_DeleteShelfRequest(ref request, ref callSettings);
            return _callDeleteShelf.Async(request, callSettings);
        }

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public override void DeleteShelf(
            DeleteShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_DeleteShelfRequest(ref request, ref callSettings);
            _callDeleteShelf.Sync(request, callSettings);
        }

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Shelf> MergeShelvesAsync(
            MergeShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MergeShelvesRequest(ref request, ref callSettings);
            return _callMergeShelves.Async(request, callSettings);
        }

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Shelf MergeShelves(
            MergeShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MergeShelvesRequest(ref request, ref callSettings);
            return _callMergeShelves.Sync(request, callSettings);
        }

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Book> CreateBookAsync(
            CreateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_CreateBookRequest(ref request, ref callSettings);
            return _callCreateBook.Async(request, callSettings);
        }

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Book CreateBook(
            CreateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_CreateBookRequest(ref request, ref callSettings);
            return _callCreateBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<PublishSeriesResponse> PublishSeriesAsync(
            PublishSeriesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_PublishSeriesRequest(ref request, ref callSettings);
            return _callPublishSeries.Async(request, callSettings);
        }

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override PublishSeriesResponse PublishSeries(
            PublishSeriesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_PublishSeriesRequest(ref request, ref callSettings);
            return _callPublishSeries.Sync(request, callSettings);
        }

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Book> GetBookAsync(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return _callGetBook.Async(request, callSettings);
        }

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Book GetBook(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return _callGetBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Book"/> resources.
        /// </returns>
        public override gax::PagedAsyncEnumerable<ListBooksResponse, Book> ListBooksAsync(
            ListBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListBooksRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedAsyncEnumerable<ListBooksRequest, ListBooksResponse, Book>(_callListBooks, request, callSettings);
        }

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Book"/> resources.
        /// </returns>
        public override gax::PagedEnumerable<ListBooksResponse, Book> ListBooks(
            ListBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListBooksRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedEnumerable<ListBooksRequest, ListBooksResponse, Book>(_callListBooks, request, callSettings);
        }

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public override stt::Task DeleteBookAsync(
            DeleteBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_DeleteBookRequest(ref request, ref callSettings);
            return _callDeleteBook.Async(request, callSettings);
        }

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public override void DeleteBook(
            DeleteBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_DeleteBookRequest(ref request, ref callSettings);
            _callDeleteBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Book> UpdateBookAsync(
            UpdateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_UpdateBookRequest(ref request, ref callSettings);
            return _callUpdateBook.Async(request, callSettings);
        }

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Book UpdateBook(
            UpdateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_UpdateBookRequest(ref request, ref callSettings);
            return _callUpdateBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Book> MoveBookAsync(
            MoveBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MoveBookRequest(ref request, ref callSettings);
            return _callMoveBook.Async(request, callSettings);
        }

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Book MoveBook(
            MoveBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MoveBookRequest(ref request, ref callSettings);
            return _callMoveBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public override gax::PagedAsyncEnumerable<ListStringsResponse, IResourceName> ListStringsAsync(
            ListStringsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListStringsRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedAsyncEnumerable<ListStringsRequest, ListStringsResponse, IResourceName>(_callListStrings, request, callSettings);
        }

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public override gax::PagedEnumerable<ListStringsResponse, IResourceName> ListStrings(
            ListStringsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListStringsRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedEnumerable<ListStringsRequest, ListStringsResponse, IResourceName>(_callListStrings, request, callSettings);
        }

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public override stt::Task AddCommentsAsync(
            AddCommentsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_AddCommentsRequest(ref request, ref callSettings);
            return _callAddComments.Async(request, callSettings);
        }

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public override void AddComments(
            AddCommentsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_AddCommentsRequest(ref request, ref callSettings);
            _callAddComments.Sync(request, callSettings);
        }

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<BookFromArchive> GetBookFromArchiveAsync(
            GetBookFromArchiveRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookFromArchiveRequest(ref request, ref callSettings);
            return _callGetBookFromArchive.Async(request, callSettings);
        }

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override BookFromArchive GetBookFromArchive(
            GetBookFromArchiveRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookFromArchiveRequest(ref request, ref callSettings);
            return _callGetBookFromArchive.Sync(request, callSettings);
        }

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            GetBookFromAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookFromAnywhereRequest(ref request, ref callSettings);
            return _callGetBookFromAnywhere.Async(request, callSettings);
        }

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override BookFromAnywhere GetBookFromAnywhere(
            GetBookFromAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookFromAnywhereRequest(ref request, ref callSettings);
            return _callGetBookFromAnywhere.Sync(request, callSettings);
        }

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            GetBookFromAbsolutelyAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookFromAbsolutelyAnywhereRequest(ref request, ref callSettings);
            return _callGetBookFromAbsolutelyAnywhere.Async(request, callSettings);
        }

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override BookFromAnywhere GetBookFromAbsolutelyAnywhere(
            GetBookFromAbsolutelyAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookFromAbsolutelyAnywhereRequest(ref request, ref callSettings);
            return _callGetBookFromAbsolutelyAnywhere.Sync(request, callSettings);
        }

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public override stt::Task UpdateBookIndexAsync(
            UpdateBookIndexRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_UpdateBookIndexRequest(ref request, ref callSettings);
            return _callUpdateBookIndex.Async(request, callSettings);
        }

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public override void UpdateBookIndex(
            UpdateBookIndexRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_UpdateBookIndexRequest(ref request, ref callSettings);
            _callUpdateBookIndex.Sync(request, callSettings);
        }

        /// <summary>
        /// Test server streaming
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The server stream.
        /// </returns>
        public override StreamShelvesStream StreamShelves(
            StreamShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_StreamShelvesRequest(ref request, ref callSettings);
            return new StreamShelvesStreamImpl(_callStreamShelves.Call(request, callSettings));
        }

        internal sealed partial class StreamShelvesStreamImpl : StreamShelvesStream
        {
            /// <summary>
            /// Construct the server-streaming method for <c>StreamShelves</c>.
            /// </summary>
            /// <param name="call">The underlying gRPC server-streaming call.</param>
            internal StreamShelvesStreamImpl(grpccore::AsyncServerStreamingCall<StreamShelvesResponse> call)
            {
                GrpcCall = call;
            }

            /// <inheritdoc/>
            public override grpccore::AsyncServerStreamingCall<StreamShelvesResponse> GrpcCall { get; }

            /// <inheritdoc/>
            public override scg::IAsyncEnumerator<StreamShelvesResponse> ResponseStream => GrpcCall.ResponseStream;
        }

        /// <summary>
        /// Test server streaming, non-paged responses.
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The server stream.
        /// </returns>
        public override StreamBooksStream StreamBooks(
            StreamBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_StreamBooksRequest(ref request, ref callSettings);
            return new StreamBooksStreamImpl(_callStreamBooks.Call(request, callSettings));
        }

        internal sealed partial class StreamBooksStreamImpl : StreamBooksStream
        {
            /// <summary>
            /// Construct the server-streaming method for <c>StreamBooks</c>.
            /// </summary>
            /// <param name="call">The underlying gRPC server-streaming call.</param>
            internal StreamBooksStreamImpl(grpccore::AsyncServerStreamingCall<Book> call)
            {
                GrpcCall = call;
            }

            /// <inheritdoc/>
            public override grpccore::AsyncServerStreamingCall<Book> GrpcCall { get; }

            /// <inheritdoc/>
            public override scg::IAsyncEnumerator<Book> ResponseStream => GrpcCall.ResponseStream;
        }

        /// <summary>
        /// Test bidi-streaming.
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <param name="streamingSettings">
        /// If not null, applies streaming overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The client-server stream.
        /// </returns>
        public override DiscussBookStream DiscussBook(
            gaxgrpc::CallSettings callSettings = null,
            gaxgrpc::BidirectionalStreamingSettings streamingSettings = null)
        {
            Modify_DiscussBookRequestCallSettings(ref callSettings);
            gaxgrpc::BidirectionalStreamingSettings effectiveStreamingSettings =
                streamingSettings ?? _callDiscussBook.StreamingSettings;
            grpccore::AsyncDuplexStreamingCall<DiscussBookRequest, Comment> call =
                _callDiscussBook.Call(callSettings);
            gaxgrpc::BufferedClientStreamWriter<DiscussBookRequest> writeBuffer =
                new gaxgrpc::BufferedClientStreamWriter<DiscussBookRequest>(
                    call.RequestStream, effectiveStreamingSettings.BufferedClientWriterCapacity);
            return new DiscussBookStreamImpl(this, call, writeBuffer);
        }

        internal sealed partial class DiscussBookStreamImpl : DiscussBookStream
        {
            /// <summary>
            /// Construct the bidirectional streaming method for <c>DiscussBook</c>.
            /// </summary>
            /// <param name="service">The service containing this streaming method.</param>
            /// <param name="call">The underlying gRPC duplex streaming call.</param>
            /// <param name="writeBuffer">The <see cref="gaxgrpc::BufferedClientStreamWriter{DiscussBookRequest}"/>
            /// instance associated with this streaming call.</param>
            public DiscussBookStreamImpl(
                LibraryServiceClientImpl service,
                grpccore::AsyncDuplexStreamingCall<DiscussBookRequest, Comment> call,
                gaxgrpc::BufferedClientStreamWriter<DiscussBookRequest> writeBuffer)
            {
                _service = service;
                GrpcCall = call;
                _writeBuffer = writeBuffer;
            }

            private LibraryServiceClientImpl _service;
            private gaxgrpc::BufferedClientStreamWriter<DiscussBookRequest> _writeBuffer;

            private DiscussBookRequest ModifyRequest(DiscussBookRequest request)
            {
                _service.Modify_DiscussBookRequestRequest(ref request);
                return request;
            }

            /// <inheritdoc/>
            public override grpccore::AsyncDuplexStreamingCall<DiscussBookRequest, Comment> GrpcCall { get; }

            /// <inheritdoc/>
            public override stt::Task TryWriteAsync(DiscussBookRequest message) =>
                _writeBuffer.TryWriteAsync(ModifyRequest(message));

            /// <inheritdoc/>
            public override stt::Task WriteAsync(DiscussBookRequest message) =>
                _writeBuffer.WriteAsync(ModifyRequest(message));

            /// <inheritdoc/>
            public override stt::Task TryWriteAsync(DiscussBookRequest message, grpccore::WriteOptions options) =>
                _writeBuffer.TryWriteAsync(ModifyRequest(message), options);

            /// <inheritdoc/>
            public override stt::Task WriteAsync(DiscussBookRequest message, grpccore::WriteOptions options) =>
                _writeBuffer.WriteAsync(ModifyRequest(message), options);

            /// <inheritdoc/>
            public override stt::Task TryWriteCompleteAsync() =>
                _writeBuffer.TryWriteCompleteAsync();

            /// <inheritdoc/>
            public override stt::Task WriteCompleteAsync() =>
                _writeBuffer.WriteCompleteAsync();

            /// <inheritdoc/>
            public override scg::IAsyncEnumerator<Comment> ResponseStream =>
                GrpcCall.ResponseStream;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public override gax::PagedAsyncEnumerable<FindRelatedBooksResponse, BookName> FindRelatedBooksAsync(
            FindRelatedBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_FindRelatedBooksRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedAsyncEnumerable<FindRelatedBooksRequest, FindRelatedBooksResponse, BookName>(_callFindRelatedBooks, request, callSettings);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public override gax::PagedEnumerable<FindRelatedBooksResponse, BookName> FindRelatedBooks(
            FindRelatedBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_FindRelatedBooksRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedEnumerable<FindRelatedBooksRequest, FindRelatedBooksResponse, BookName>(_callFindRelatedBooks, request, callSettings);
        }

        /// <summary>
        /// Adds a tag to the book. This RPC is a mixin.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<gtv::AddTagResponse> AddTagAsync(
            gtv::AddTagRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_AddTagRequest(ref request, ref callSettings);
            return _callAddTag.Async(request, callSettings);
        }

        /// <summary>
        /// Adds a tag to the book. This RPC is a mixin.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override gtv::AddTagResponse AddTag(
            gtv::AddTagRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_AddTagRequest(ref request, ref callSettings);
            return _callAddTag.Sync(request, callSettings);
        }

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<gtv::AddLabelResponse> AddLabelAsync(
            gtv::AddLabelRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_AddLabelRequest(ref request, ref callSettings);
            return _callAddLabel.Async(request, callSettings);
        }

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override gtv::AddLabelResponse AddLabel(
            gtv::AddLabelRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_AddLabelRequest(ref request, ref callSettings);
            return _callAddLabel.Sync(request, callSettings);
        }

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override async stt::Task<lro::Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return new lro::Operation<Book, GetBigBookMetadata>(
                await _callGetBigBook.Async(request, callSettings).ConfigureAwait(false), GetBigBookOperationsClient);
        }

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override lro::Operation<Book, GetBigBookMetadata> GetBigBook(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return new lro::Operation<Book, GetBigBookMetadata>(
                _callGetBigBook.Sync(request, callSettings), GetBigBookOperationsClient);
        }

        /// <summary>
        /// The long-running operations client for <c>GetBigBook</c>.
        /// </summary>
        public override lro::OperationsClient GetBigBookOperationsClient { get; }

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override async stt::Task<lro::Operation<pbwkt::Empty, GetBigBookMetadata>> GetBigNothingAsync(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return new lro::Operation<pbwkt::Empty, GetBigBookMetadata>(
                await _callGetBigNothing.Async(request, callSettings).ConfigureAwait(false), GetBigNothingOperationsClient);
        }

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override lro::Operation<pbwkt::Empty, GetBigBookMetadata> GetBigNothing(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return new lro::Operation<pbwkt::Empty, GetBigBookMetadata>(
                _callGetBigNothing.Sync(request, callSettings), GetBigNothingOperationsClient);
        }

        /// <summary>
        /// The long-running operations client for <c>GetBigNothing</c>.
        /// </summary>
        public override lro::OperationsClient GetBigNothingOperationsClient { get; }

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            TestOptionalRequiredFlatteningParamsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_TestOptionalRequiredFlatteningParamsRequest(ref request, ref callSettings);
            return _callTestOptionalRequiredFlatteningParams.Async(request, callSettings);
        }

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override TestOptionalRequiredFlatteningParamsResponse TestOptionalRequiredFlatteningParams(
            TestOptionalRequiredFlatteningParamsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_TestOptionalRequiredFlatteningParamsRequest(ref request, ref callSettings);
            return _callTestOptionalRequiredFlatteningParams.Sync(request, callSettings);
        }

    }

    // Partial classes to enable page-streaming

    public partial class ListShelvesRequest : gaxgrpc::IPageRequest { }
    public partial class ListShelvesResponse : gaxgrpc::IPageResponse<Shelf>
    {
        /// <summary>
        /// Returns an enumerator that iterates through the resources in this response.
        /// </summary>
        public scg::IEnumerator<Shelf> GetEnumerator() => Shelves.GetEnumerator();

        /// <inheritdoc/>
        sc::IEnumerator sc::IEnumerable.GetEnumerator() => GetEnumerator();
    }

    public partial class ListBooksRequest : gaxgrpc::IPageRequest { }
    public partial class ListBooksResponse : gaxgrpc::IPageResponse<Book>
    {
        /// <summary>
        /// Returns an enumerator that iterates through the resources in this response.
        /// </summary>
        public scg::IEnumerator<Book> GetEnumerator() => Books.GetEnumerator();

        /// <inheritdoc/>
        sc::IEnumerator sc::IEnumerable.GetEnumerator() => GetEnumerator();
    }

    public partial class ListStringsRequest : gaxgrpc::IPageRequest { }
    public partial class ListStringsResponse : gaxgrpc::IPageResponse<IResourceName>
    {
        /// <summary>
        /// Returns an enumerator that iterates through the resources in this response.
        /// </summary>
        public scg::IEnumerator<IResourceName> GetEnumerator() => StringsAsResourceNames.GetEnumerator();

        /// <inheritdoc/>
        sc::IEnumerator sc::IEnumerable.GetEnumerator() => GetEnumerator();
    }

    public partial class FindRelatedBooksRequest : gaxgrpc::IPageRequest { }
    public partial class FindRelatedBooksResponse : gaxgrpc::IPageResponse<BookName>
    {
        /// <summary>
        /// Returns an enumerator that iterates through the resources in this response.
        /// </summary>
        public scg::IEnumerator<BookName> GetEnumerator() => BookNames.GetEnumerator();

        /// <inheritdoc/>
        sc::IEnumerator sc::IEnumerable.GetEnumerator() => GetEnumerator();
    }

    // Partial Grpc class to enable LRO client creation
    public static partial class LibraryService
    {
        public partial class LibraryServiceClient
        {
            /// <summary>
            /// Creates a new instance of <see cref="lro::Operations.OperationsClient"/> using the same call invoker as this client.
            /// </summary>
            /// <returns>A new Operations client for the same target as this client.</returns>
            public virtual lro::Operations.OperationsClient CreateOperationsClient() => new lro::Operations.OperationsClient(CallInvoker);
        }
    }

    // Partial Grpc class to enable gctv::Labeler.LabelerClient client creation
    public static partial class LibraryService
    {
        public partial class LibraryServiceClient
        {
            /// <summary>
            /// Creates a new instance of <see cref="gctv::Labeler.LabelerClient"/> using the same call invoker as this client.
            /// </summary>
            /// <returns>A new gctv::Labeler.LabelerClient for the same target as this client.</returns>
            public virtual gctv::Labeler.LabelerClient CreateLabelerClient() => new gctv::Labeler.LabelerClient(CallInvoker);
        }
    }


}

============== file: Google.Example.Library.V1/Google.Example.Library.V1/ResourceNames.cs ==============
// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

using gax = Google.Api.Gax;
using gaxres = Google.Api.Gax.ResourceNames;
using sys = System;
using scg = System.Collections.Generic;
using linq = System.Linq;

namespace Google.Example.Library.V1
{
    /// <summary>
    /// Resource name for the 'shelf' resource.
    /// </summary>
    public sealed partial class ShelfName : gax::IResourceName, sys::IEquatable<ShelfName>
    {
        private static readonly gax::PathTemplate s_template = new gax::PathTemplate("shelves/{shelf_id}");

        /// <summary>
        /// Parses the given shelf resource name in string form into a new
        /// <see cref="ShelfName"/> instance.
        /// </summary>
        /// <param name="shelfName">The shelf resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="ShelfName"/> if successful.</returns>
        public static ShelfName Parse(string shelfName)
        {
            gax::GaxPreconditions.CheckNotNull(shelfName, nameof(shelfName));
            gax::TemplatedResourceName resourceName = s_template.ParseName(shelfName);
            return new ShelfName(resourceName[0]);
        }

        /// <summary>
        /// Tries to parse the given shelf resource name in string form into a new
        /// <see cref="ShelfName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="sys::ArgumentNullException"/> if <paramref name="shelfName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="shelfName">The shelf resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="ShelfName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed successfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string shelfName, out ShelfName result)
        {
            gax::GaxPreconditions.CheckNotNull(shelfName, nameof(shelfName));
            gax::TemplatedResourceName resourceName;
            if (s_template.TryParseName(shelfName, out resourceName))
            {
                result = new ShelfName(resourceName[0]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>
        /// Constructs a new instance of the <see cref="ShelfName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="shelfId">The shelf ID. Must not be <c>null</c>.</param>
        public ShelfName(string shelfId)
        {
            ShelfId = gax::GaxPreconditions.CheckNotNull(shelfId, nameof(shelfId));
        }

        /// <summary>
        /// The shelf ID. Never <c>null</c>.
        /// </summary>
        public string ShelfId { get; }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ShelfId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as ShelfName);

        /// <inheritdoc />
        public bool Equals(ShelfName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(ShelfName a, ShelfName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(ShelfName a, ShelfName b) => !(a == b);
    }

    /// <summary>
    /// Resource name for the 'archived_book' resource.
    /// </summary>
    public sealed partial class ArchivedBookName : gax::IResourceName, sys::IEquatable<ArchivedBookName>
    {
        private static readonly gax::PathTemplate s_template = new gax::PathTemplate("archives/{archive_path}/books/{book_id=**}");

        /// <summary>
        /// Parses the given archived_book resource name in string form into a new
        /// <see cref="ArchivedBookName"/> instance.
        /// </summary>
        /// <param name="archivedBookName">The archived_book resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="ArchivedBookName"/> if successful.</returns>
        public static ArchivedBookName Parse(string archivedBookName)
        {
            gax::GaxPreconditions.CheckNotNull(archivedBookName, nameof(archivedBookName));
            gax::TemplatedResourceName resourceName = s_template.ParseName(archivedBookName);
            return new ArchivedBookName(resourceName[0], resourceName[1]);
        }

        /// <summary>
        /// Tries to parse the given archived_book resource name in string form into a new
        /// <see cref="ArchivedBookName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="sys::ArgumentNullException"/> if <paramref name="archivedBookName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="archivedBookName">The archived_book resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="ArchivedBookName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed successfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string archivedBookName, out ArchivedBookName result)
        {
            gax::GaxPreconditions.CheckNotNull(archivedBookName, nameof(archivedBookName));
            gax::TemplatedResourceName resourceName;
            if (s_template.TryParseName(archivedBookName, out resourceName))
            {
                result = new ArchivedBookName(resourceName[0], resourceName[1]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>
        /// Constructs a new instance of the <see cref="ArchivedBookName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="archivePathId">The archivePath ID. Must not be <c>null</c>.</param>
        /// <param name="bookId">The book ID. Must not be <c>null</c>.</param>
        public ArchivedBookName(string archivePathId, string bookId)
        {
            ArchivePathId = gax::GaxPreconditions.CheckNotNull(archivePathId, nameof(archivePathId));
            BookId = gax::GaxPreconditions.CheckNotNull(bookId, nameof(bookId));
        }

        /// <summary>
        /// The archivePath ID. Never <c>null</c>.
        /// </summary>
        public string ArchivePathId { get; }

        /// <summary>
        /// The book ID. Never <c>null</c>.
        /// </summary>
        public string BookId { get; }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ArchivePathId, BookId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as ArchivedBookName);

        /// <inheritdoc />
        public bool Equals(ArchivedBookName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(ArchivedBookName a, ArchivedBookName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(ArchivedBookName a, ArchivedBookName b) => !(a == b);
    }

    /// <summary>
    /// Resource name for the 'book' resource.
    /// </summary>
    public sealed partial class BookName : gax::IResourceName, sys::IEquatable<BookName>
    {
        private static readonly gax::PathTemplate s_template = new gax::PathTemplate("shelves/{shelf_id}/books/{book_id}");

        /// <summary>
        /// Parses the given book resource name in string form into a new
        /// <see cref="BookName"/> instance.
        /// </summary>
        /// <param name="bookName">The book resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="BookName"/> if successful.</returns>
        public static BookName Parse(string bookName)
        {
            gax::GaxPreconditions.CheckNotNull(bookName, nameof(bookName));
            gax::TemplatedResourceName resourceName = s_template.ParseName(bookName);
            return new BookName(resourceName[0], resourceName[1]);
        }

        /// <summary>
        /// Tries to parse the given book resource name in string form into a new
        /// <see cref="BookName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="sys::ArgumentNullException"/> if <paramref name="bookName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="bookName">The book resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="BookName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed successfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string bookName, out BookName result)
        {
            gax::GaxPreconditions.CheckNotNull(bookName, nameof(bookName));
            gax::TemplatedResourceName resourceName;
            if (s_template.TryParseName(bookName, out resourceName))
            {
                result = new BookName(resourceName[0], resourceName[1]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>
        /// Constructs a new instance of the <see cref="BookName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="shelfId">The shelf ID. Must not be <c>null</c>.</param>
        /// <param name="bookId">The book ID. Must not be <c>null</c>.</param>
        public BookName(string shelfId, string bookId)
        {
            ShelfId = gax::GaxPreconditions.CheckNotNull(shelfId, nameof(shelfId));
            BookId = gax::GaxPreconditions.CheckNotNull(bookId, nameof(bookId));
        }

        /// <summary>
        /// The shelf ID. Never <c>null</c>.
        /// </summary>
        public string ShelfId { get; }

        /// <summary>
        /// The book ID. Never <c>null</c>.
        /// </summary>
        public string BookId { get; }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ShelfId, BookId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as BookName);

        /// <inheritdoc />
        public bool Equals(BookName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(BookName a, BookName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(BookName a, BookName b) => !(a == b);
    }

    /// <summary>
    /// Resource name for the 'return' resource.
    /// </summary>
    public sealed partial class ReturnName : gax::IResourceName, sys::IEquatable<ReturnName>
    {
        private static readonly gax::PathTemplate s_template = new gax::PathTemplate("shelves/{shelf}/books/{book}/returns/{return}");

        /// <summary>
        /// Parses the given return resource name in string form into a new
        /// <see cref="ReturnName"/> instance.
        /// </summary>
        /// <param name="returnName">The return resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="ReturnName"/> if successful.</returns>
        public static ReturnName Parse(string returnName)
        {
            gax::GaxPreconditions.CheckNotNull(returnName, nameof(returnName));
            gax::TemplatedResourceName resourceName = s_template.ParseName(returnName);
            return new ReturnName(resourceName[0], resourceName[1], resourceName[2]);
        }

        /// <summary>
        /// Tries to parse the given return resource name in string form into a new
        /// <see cref="ReturnName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="sys::ArgumentNullException"/> if <paramref name="returnName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="returnName">The return resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="ReturnName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed successfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string returnName, out ReturnName result)
        {
            gax::GaxPreconditions.CheckNotNull(returnName, nameof(returnName));
            gax::TemplatedResourceName resourceName;
            if (s_template.TryParseName(returnName, out resourceName))
            {
                result = new ReturnName(resourceName[0], resourceName[1], resourceName[2]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>
        /// Constructs a new instance of the <see cref="ReturnName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="shelfId">The shelf ID. Must not be <c>null</c>.</param>
        /// <param name="bookId">The book ID. Must not be <c>null</c>.</param>
        /// <param name="returnId">The return ID. Must not be <c>null</c>.</param>
        public ReturnName(string shelfId, string bookId, string returnId)
        {
            ShelfId = gax::GaxPreconditions.CheckNotNull(shelfId, nameof(shelfId));
            BookId = gax::GaxPreconditions.CheckNotNull(bookId, nameof(bookId));
            ReturnId = gax::GaxPreconditions.CheckNotNull(returnId, nameof(returnId));
        }

        /// <summary>
        /// The shelf ID. Never <c>null</c>.
        /// </summary>
        public string ShelfId { get; }

        /// <summary>
        /// The book ID. Never <c>null</c>.
        /// </summary>
        public string BookId { get; }

        /// <summary>
        /// The return ID. Never <c>null</c>.
        /// </summary>
        public string ReturnId { get; }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ShelfId, BookId, ReturnId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as ReturnName);

        /// <inheritdoc />
        public bool Equals(ReturnName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(ReturnName a, ReturnName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(ReturnName a, ReturnName b) => !(a == b);
    }

    /// <summary>
    /// Resource name which will contain one of a choice of resource names.
    /// </summary>
    /// <remarks>
    /// This resource name will contain one of the following:
    /// <list type="bullet">
    /// <item><description>BookName: A resource of type 'book'.</description></item>
    /// <item><description>ArchivedBookName: A resource of type 'archived_book'.</description></item>
    /// <item><description>DeletedBookNameFixed: A resource of type 'deleted_book'.</description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BookNameOneof : gax::IResourceName, sys::IEquatable<BookNameOneof>
    {
        /// <summary>
        /// The possible contents of <see cref="BookNameOneof"/>.
        /// </summary>
        public enum OneofType
        {
            /// <summary>
            /// A resource of an unknown type.
            /// </summary>
            Unknown = 0,

            /// <summary>
            /// A resource of type 'book'.
            /// </summary>
            BookName = 1,

            /// <summary>
            /// A resource of type 'archived_book'.
            /// </summary>
            ArchivedBookName = 2,

            /// <summary>
            /// A resource of type 'deleted_book'.
            /// </summary>
            DeletedBookNameFixed = 3,
        }

        /// <summary>
        /// Parses a resource name in string form into a new <see cref="BookNameOneof"/> instance.
        /// </summary>
        /// <remarks>
        /// To parse successfully the resource name must be one of the following:
        /// <list type="bullet">
        /// <item><description>BookName: A resource of type 'book'.</description></item>
        /// <item><description>ArchivedBookName: A resource of type 'archived_book'.</description></item>
        /// <item><description>DeletedBookNameFixed: A resource of type 'deleted_book'.</description></item>
        /// </list>
        /// Or an <see cref="gax::UnknownResourceName"/> if <paramref name="allowUnknown"/> is <c>true</c>.
        /// </remarks>
        /// <param name="name">The resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="allowUnknown">If true, will successfully parse an unknown resource name
        /// into an <see cref="gax::UnknownResourceName"/>; otherwise will throw an
        /// <see cref="sys::ArgumentException"/> if an unknown resource name is given.</param>
        /// <returns>The parsed <see cref="BookNameOneof"/> if successful.</returns>
        public static BookNameOneof Parse(string name, bool allowUnknown)
        {
            BookNameOneof result;
            if (TryParse(name, allowUnknown, out result))
            {
                return result;
            }
            throw new sys::ArgumentException("Invalid name", nameof(name));
        }

        /// <summary>
        /// Tries to parse a resource name in string form into a new <see cref="BookNameOneof"/> instance.
        /// </summary>
        /// <remarks>
        /// To parse successfully the resource name must be one of the following:
        /// <list type="bullet">
        /// <item><description>BookName: A resource of type 'book'.</description></item>
        /// <item><description>ArchivedBookName: A resource of type 'archived_book'.</description></item>
        /// <item><description>DeletedBookNameFixed: A resource of type 'deleted_book'.</description></item>
        /// </list>
        /// Or an <see cref="gax::UnknownResourceName"/> if <paramref name="allowUnknown"/> is <c>true</c>.
        /// </remarks>
        /// <param name="name">The resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="allowUnknown">If true, will successfully parse an unknown resource name
        /// into an <see cref="gax::UnknownResourceName"/>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="BookNameOneof"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed succssfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string name, bool allowUnknown, out BookNameOneof result)
        {
            gax::GaxPreconditions.CheckNotNull(name, nameof(name));
            BookName bookName;
            if (BookName.TryParse(name, out bookName))
            {
                result = new BookNameOneof(OneofType.BookName, bookName);
                return true;
            }
            ArchivedBookName archivedBookName;
            if (ArchivedBookName.TryParse(name, out archivedBookName))
            {
                result = new BookNameOneof(OneofType.ArchivedBookName, archivedBookName);
                return true;
            }
            DeletedBookNameFixed deletedBookNameFixed;
            if (DeletedBookNameFixed.TryParse(name, out deletedBookNameFixed))
            {
                result = new BookNameOneof(OneofType.DeletedBookNameFixed, deletedBookNameFixed);
                return true;
            }
            if (allowUnknown)
            {
                gax::UnknownResourceName unknownResourceName;
                if (gax::UnknownResourceName.TryParse(name, out unknownResourceName))
                {
                    result = new BookNameOneof(OneofType.Unknown, unknownResourceName);
                    return true;
                }
            }
            result = null;
            return false;
        }

        /// <summary>
        /// Construct a new instance of <see cref="BookNameOneof"/> from the provided <see cref="BookName"/>
        /// </summary>
        /// <param name="bookName">The <see cref="BookName"/> to be contained within
        /// the returned <see cref="BookNameOneof"/>. Must not be <c>null</c>.</param>
        /// <returns>A new <see cref="BookNameOneof"/>, containing <paramref name="bookName"/>.</returns>
        public static BookNameOneof From(BookName bookName) => new BookNameOneof(OneofType.BookName, bookName);

        /// <summary>
        /// Construct a new instance of <see cref="BookNameOneof"/> from the provided <see cref="ArchivedBookName"/>
        /// </summary>
        /// <param name="archivedBookName">The <see cref="ArchivedBookName"/> to be contained within
        /// the returned <see cref="BookNameOneof"/>. Must not be <c>null</c>.</param>
        /// <returns>A new <see cref="BookNameOneof"/>, containing <paramref name="archivedBookName"/>.</returns>
        public static BookNameOneof From(ArchivedBookName archivedBookName) => new BookNameOneof(OneofType.ArchivedBookName, archivedBookName);

        /// <summary>
        /// Construct a new instance of <see cref="BookNameOneof"/> from the provided <see cref="DeletedBookNameFixed"/>
        /// </summary>
        /// <param name="deletedBookNameFixed">The <see cref="DeletedBookNameFixed"/> to be contained within
        /// the returned <see cref="BookNameOneof"/>. Must not be <c>null</c>.</param>
        /// <returns>A new <see cref="BookNameOneof"/>, containing <paramref name="deletedBookNameFixed"/>.</returns>
        public static BookNameOneof From(DeletedBookNameFixed deletedBookNameFixed) => new BookNameOneof(OneofType.DeletedBookNameFixed, deletedBookNameFixed);

        private static bool IsValid(OneofType type, gax::IResourceName name)
        {
            switch (type)
            {
                case OneofType.Unknown: return true; // Anything goes with Unknown.
                case OneofType.BookName: return name is BookName;
                case OneofType.ArchivedBookName: return name is ArchivedBookName;
                case OneofType.DeletedBookNameFixed: return name is DeletedBookNameFixed;
                default: return false;
            }
        }

        /// <summary>
        /// Constructs a new instance of the <see cref="BookNameOneof"/> resource name class
        /// from a suitable <see cref="gax::IResourceName"/> instance.
        /// </summary>
        public BookNameOneof(OneofType type, gax::IResourceName name)
        {
            Type = gax::GaxPreconditions.CheckEnumValue<OneofType>(type, nameof(type));
            Name = gax::GaxPreconditions.CheckNotNull(name, nameof(name));
            if (!IsValid(type, name))
            {
                throw new sys::ArgumentException($"Mismatched OneofType '{type}' and resource name '{name}'");
            }
        }

        /// <summary>
        /// The <see cref="OneofType"/> of the Name contained in this instance.
        /// </summary>
        public OneofType Type { get; }

        /// <summary>
        /// The <see cref="gax::IResourceName"/> contained in this instance.
        /// </summary>
        public gax::IResourceName Name { get; }

        private T CheckAndReturn<T>(OneofType type)
        {
            if (Type != type)
            {
                throw new sys::InvalidOperationException($"Requested type {type}, but this one-of contains type {Type}");
            }
            return (T)Name;
        }

        /// <summary>
        /// Get the contained <see cref="gax::IResourceName"/> as <see cref="BookName"/>.
        /// </summary>
        /// <remarks>
        /// An <see cref="sys::InvalidOperationException"/> will be thrown if this does not
        /// contain an instance of <see cref="BookName"/>.
        /// </remarks>
        public BookName BookName => CheckAndReturn<BookName>(OneofType.BookName);

        /// <summary>
        /// Get the contained <see cref="gax::IResourceName"/> as <see cref="ArchivedBookName"/>.
        /// </summary>
        /// <remarks>
        /// An <see cref="sys::InvalidOperationException"/> will be thrown if this does not
        /// contain an instance of <see cref="ArchivedBookName"/>.
        /// </remarks>
        public ArchivedBookName ArchivedBookName => CheckAndReturn<ArchivedBookName>(OneofType.ArchivedBookName);

        /// <summary>
        /// Get the contained <see cref="gax::IResourceName"/> as <see cref="DeletedBookNameFixed"/>.
        /// </summary>
        /// <remarks>
        /// An <see cref="sys::InvalidOperationException"/> will be thrown if this does not
        /// contain an instance of <see cref="DeletedBookNameFixed"/>.
        /// </remarks>
        public DeletedBookNameFixed DeletedBookNameFixed => CheckAndReturn<DeletedBookNameFixed>(OneofType.DeletedBookNameFixed);

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Oneof;

        /// <inheritdoc />
        public override string ToString() => Name.ToString();

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as BookNameOneof);

        /// <inheritdoc />
        public bool Equals(BookNameOneof other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(BookNameOneof a, BookNameOneof b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(BookNameOneof a, BookNameOneof b) => !(a == b);
    }

    /// <summary>
    /// Resource name to represent the fixed string "_deleted-book_".
    /// </summary>
    public sealed partial class DeletedBookNameFixed : gax::IResourceName, sys::IEquatable<DeletedBookNameFixed>
    {
        /// <summary>
        /// The fixed string value: "_deleted-book_".
        /// </summary>
        public const string FixedValue = "_deleted-book_";

        /// <summary>
        /// An instance of <see cref="DeletedBookNameFixed"/>.
        /// </summary>
        public static DeletedBookNameFixed Instance => new DeletedBookNameFixed();

        /// <summary>
        /// Parses the given string into a new <see cref="DeletedBookNameFixed"/> instance.
        /// Only succeeds if the string is equal to "_deleted-book_".
        /// </summary>
        public static DeletedBookNameFixed Parse(string deletedBookNameFixed)
        {
            DeletedBookNameFixed result;
            if (!TryParse(deletedBookNameFixed, out result))
            {
                throw new sys::ArgumentException($"Invalid resource name, must be \"{FixedValue}\"", nameof(deletedBookNameFixed));
            }
            return result;
        }

        /// <summary>
        /// Tries to parse the given string into a new <see cref="DeletedBookNameFixed"/> instance.
        /// Only succeeds if the string is equal to "_deleted-book_".
        /// </summary>
        public static bool TryParse(string deletedBookNameFixed, out DeletedBookNameFixed result)
        {
            gax::GaxPreconditions.CheckNotNull(deletedBookNameFixed, nameof(deletedBookNameFixed));
            if (deletedBookNameFixed == FixedValue)
            {
                result = Instance;
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        private DeletedBookNameFixed() { }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Fixed;

        /// <inheritdoc />
        public override string ToString() => FixedValue;

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as DeletedBookNameFixed);

        /// <inheritdoc />
        public bool Equals(DeletedBookNameFixed other) => other != null;

        /// <inheritdoc />
        public static bool operator ==(DeletedBookNameFixed a, DeletedBookNameFixed b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(DeletedBookNameFixed a, DeletedBookNameFixed b) => !(a == b);
    }


    public partial class Book
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookName BookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class BookFromAnywhere
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class BookFromArchive
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ArchivedBookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ArchivedBookName ArchivedBookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ArchivedBookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class CreateBookRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class DeleteBookRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookName BookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class DeleteShelfRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class FindRelatedBooksRequest
    {
        /// <summary>
        /// <see cref="gax::ResourceNameList{BookName}"/>-typed view over the <see cref="Names"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<BookName> BookNames =>
            new gax::ResourceNameList<BookName>(Names,
                str => BookName.Parse(str));

        /// <summary>
        /// <see cref="gax::ResourceNameList{ShelfName}"/>-typed view over the <see cref="Shelves"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<ShelfName> ShelvesAsShelfNames =>
            new gax::ResourceNameList<ShelfName>(Shelves,
                str => ShelfName.Parse(str));

    }

    public partial class FindRelatedBooksResponse
    {
        /// <summary>
        /// <see cref="gax::ResourceNameList{BookName}"/>-typed view over the <see cref="Names"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<BookName> BookNames =>
            new gax::ResourceNameList<BookName>(Names,
                str => BookName.Parse(str));

    }

    public partial class GetBookFromAbsolutelyAnywhereRequest
    {
        /// <summary>
        /// <see cref="gax::IResourceName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public gax::IResourceName AsResourceName
        {
            get { return string.IsNullOrEmpty(Name) ? null : gax::UnknownResourceName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class GetBookFromAnywhereRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="AltBookName"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof AltBookNameAsBookNameOneof
        {
            get { return string.IsNullOrEmpty(AltBookName) ? null : Google.Example.Library.V1.BookNameOneof.Parse(AltBookName, true); }
            set { AltBookName = value != null ? value.ToString() : ""; }
        }

    }

    public partial class GetBookFromArchiveRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ArchivedBookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ArchivedBookName ArchivedBookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ArchivedBookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class GetBookRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookName BookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class GetShelfRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class ListBooksRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class ListStringsRequest
    {
        /// <summary>
        /// <see cref="gax::IResourceName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public gax::IResourceName AsResourceName
        {
            get { return string.IsNullOrEmpty(Name) ? null : gax::UnknownResourceName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class ListStringsResponse
    {
        /// <summary>
        /// <see cref="gax::ResourceNameList{gax::IResourceName}"/>-typed view over the <see cref="Strings"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<gax::IResourceName> StringsAsResourceNames =>
            new gax::ResourceNameList<gax::IResourceName>(Strings,
                str => gax::UnknownResourceName.Parse(str));

    }

    public partial class MergeShelvesRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="OtherShelfName"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName OtherShelfNameAsShelfName
        {
            get { return string.IsNullOrEmpty(OtherShelfName) ? null : Google.Example.Library.V1.ShelfName.Parse(OtherShelfName); }
            set { OtherShelfName = value != null ? value.ToString() : ""; }
        }

    }

    public partial class MoveBookRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookName BookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="OtherShelfName"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName OtherShelfNameAsShelfName
        {
            get { return string.IsNullOrEmpty(OtherShelfName) ? null : Google.Example.Library.V1.ShelfName.Parse(OtherShelfName); }
            set { OtherShelfName = value != null ? value.ToString() : ""; }
        }

    }

    public partial class Shelf
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class TestOptionalRequiredFlatteningParamsRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookName"/>-typed view over the <see cref="RequiredSingularResourceName"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookName RequiredSingularResourceNameAsBookName
        {
            get { return string.IsNullOrEmpty(RequiredSingularResourceName) ? null : Google.Example.Library.V1.BookName.Parse(RequiredSingularResourceName); }
            set { RequiredSingularResourceName = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="RequiredSingularResourceNameOneof"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof RequiredSingularResourceNameOneofAsBookNameOneof
        {
            get { return string.IsNullOrEmpty(RequiredSingularResourceNameOneof) ? null : Google.Example.Library.V1.BookNameOneof.Parse(RequiredSingularResourceNameOneof, true); }
            set { RequiredSingularResourceNameOneof = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="gaxres::ProjectName"/>-typed view over the <see cref="RequiredSingularResourceNameCommon"/> resource name property.
        /// </summary>
        public gaxres::ProjectName RequiredSingularResourceNameCommonAsProjectName
        {
            get { return string.IsNullOrEmpty(RequiredSingularResourceNameCommon) ? null : gaxres::ProjectName.Parse(RequiredSingularResourceNameCommon); }
            set { RequiredSingularResourceNameCommon = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="gax::ResourceNameList{BookName}"/>-typed view over the <see cref="RequiredRepeatedResourceName"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<BookName> RequiredRepeatedResourceNameAsBookNames =>
            new gax::ResourceNameList<BookName>(RequiredRepeatedResourceName,
                str => BookName.Parse(str));

        /// <summary>
        /// <see cref="gax::ResourceNameList{BookNameOneof}"/>-typed view over the <see cref="RequiredRepeatedResourceNameOneof"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<BookNameOneof> RequiredRepeatedResourceNameOneofAsBookNameOneofs =>
            new gax::ResourceNameList<BookNameOneof>(RequiredRepeatedResourceNameOneof,
                str => BookNameOneof.Parse(str, true));

        /// <summary>
        /// <see cref="gax::ResourceNameList{gaxres::ProjectName}"/>-typed view over the <see cref="RequiredRepeatedResourceNameCommon"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<gaxres::ProjectName> RequiredRepeatedResourceNameCommonAsProjectNames =>
            new gax::ResourceNameList<gaxres::ProjectName>(RequiredRepeatedResourceNameCommon,
                str => gaxres::ProjectName.Parse(str));

        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookName"/>-typed view over the <see cref="OptionalSingularResourceName"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookName OptionalSingularResourceNameAsBookName
        {
            get { return string.IsNullOrEmpty(OptionalSingularResourceName) ? null : Google.Example.Library.V1.BookName.Parse(OptionalSingularResourceName); }
            set { OptionalSingularResourceName = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="OptionalSingularResourceNameOneof"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof OptionalSingularResourceNameOneofAsBookNameOneof
        {
            get { return string.IsNullOrEmpty(OptionalSingularResourceNameOneof) ? null : Google.Example.Library.V1.BookNameOneof.Parse(OptionalSingularResourceNameOneof, true); }
            set { OptionalSingularResourceNameOneof = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="gaxres::ProjectName"/>-typed view over the <see cref="OptionalSingularResourceNameCommon"/> resource name property.
        /// </summary>
        public gaxres::ProjectName OptionalSingularResourceNameCommonAsProjectName
        {
            get { return string.IsNullOrEmpty(OptionalSingularResourceNameCommon) ? null : gaxres::ProjectName.Parse(OptionalSingularResourceNameCommon); }
            set { OptionalSingularResourceNameCommon = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="gax::ResourceNameList{BookName}"/>-typed view over the <see cref="OptionalRepeatedResourceName"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<BookName> OptionalRepeatedResourceNameAsBookNames =>
            new gax::ResourceNameList<BookName>(OptionalRepeatedResourceName,
                str => BookName.Parse(str));

        /// <summary>
        /// <see cref="gax::ResourceNameList{BookNameOneof}"/>-typed view over the <see cref="OptionalRepeatedResourceNameOneof"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<BookNameOneof> OptionalRepeatedResourceNameOneofAsBookNameOneofs =>
            new gax::ResourceNameList<BookNameOneof>(OptionalRepeatedResourceNameOneof,
                str => BookNameOneof.Parse(str, true));

        /// <summary>
        /// <see cref="gax::ResourceNameList{gaxres::ProjectName}"/>-typed view over the <see cref="OptionalRepeatedResourceNameCommon"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<gaxres::ProjectName> OptionalRepeatedResourceNameCommonAsProjectNames =>
            new gax::ResourceNameList<gaxres::ProjectName>(OptionalRepeatedResourceNameCommon,
                str => gaxres::ProjectName.Parse(str));

    }

    public partial class UpdateBookIndexRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookName BookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class UpdateBookRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookName BookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

}
