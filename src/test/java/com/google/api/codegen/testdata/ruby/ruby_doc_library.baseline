============== file: .gitignore ==============
Gemfile.lock
coverage/*
doc/*
pkg/*
html/*
jsondoc/*

# Ignore YARD stuffs
.yardoc

# IDE settings
.idea
*.iml

============== file: .rubocop.yml ==============
AllCops:
  Exclude:
    - "library.gemspec"
    - "lib/google/**/*"
    - "Rakefile"
    - "test/**/*"

Documentation:
  Enabled: false

Style/StringLiterals:
  EnforcedStyle: double_quotes
Style/MethodDefParentheses:
  EnforcedStyle: require_no_parentheses
Style/NumericLiterals:
  Enabled: false
Style/SpaceAroundOperators:
  Enabled: false
Metrics/ClassLength:
  Enabled: false
Style/EmptyLines:
  Enabled: false
Style/EmptyElse:
  Enabled: false
Style/HashSyntax:
  Exclude:
    - "lib/library/v1/**/*"
Metrics/LineLength:
  Exclude:
    - "lib/library/v1/**/*"
Metrics/CyclomaticComplexity:
  Max: 10
Metrics/PerceivedComplexity:
  Max: 10
Metrics/AbcSize:
  Max: 25
  Exclude:
    - "lib/library/v1/**/*"
Metrics/MethodLength:
  Max: 20
  Exclude:
    - "lib/library/v1/**/*"
Metrics/ParameterLists:
  Enabled: false
Style/RescueModifier:
  Enabled: false
Style/ClassVars:
  Enabled: false
Style/TrivialAccessors:
  Enabled: false
Style/FileName:
  Enabled: false

============== file: .yardopts ==============
--no-private
--title=Google Example Library API
--exclude _pb\.rb$
--markup markdown

./lib/**/*.rb
-
README.md

============== file: Gemfile ==============
source "https://rubygems.org"

gemspec

gem "rake", "~> 11.0"
gem "gcloud-jsondoc",
    git: "https://github.com/GoogleCloudPlatform/google-cloud-ruby.git",
    branch: "gcloud-jsondoc"

# WORKAROUND: builds are having problems since the release of 3.0.0
# pin to the last known good version
gem "public_suffix", "~> 2.0"

# TEMP: rainbow (a dependency of rubocop) version 2.2 seems to have a problem,
# so pinning to 2.1 for now.
gem "rainbow", "~> 2.1.0"

============== file: LICENSE ==============
                            Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

============== file: README.md ==============
# Ruby Client for Google Example Library API ([Alpha](https://github.com/GoogleCloudPlatform/google-cloud-ruby#versioning))

[Google Example Library API][Product Documentation]:
A simple Google Example Library API.
- [Client Library Documentation][]
- [Product Documentation][]

## Quick Start
In order to use this library, you first need to go through the following
steps:

1. [Select or create a Cloud Platform project.](https://console.cloud.google.com/project)
2. [Enable the Google Example Library API.](https://console.cloud.google.com/apis/api/library)
3. [Setup Authentication.](https://googlecloudplatform.github.io/google-cloud-ruby/#/docs/google-cloud/master/guides/authentication)

### Installation
```
$ gem install library
```

### Preview
#### LibraryServiceClient
```rb
require "library"

library_service_client = Library.new
formatted_name = Library::V1::LibraryServiceClient.book_path("testShelf-" + Time.new.to_i.to_s, project_id)
optional_foo = ''
rating = :GOOD
book = { rating: rating }
update_mask = {}
physical_mask = {}
response = library_service_client.update_book(formatted_name, book, optional_foo: optional_foo, update_mask: update_mask, physical_mask: physical_mask)
```

### Next Steps
- Read the [Client Library Documentation][] for Google Example Library API
  to see other available methods on the client.
- Read the [Google Example Library API Product documentation][Product Documentation]
  to learn more about the product and see How-to Guides.
- View this [repository's main README](https://github.com/GoogleCloudPlatform/google-cloud-ruby/blob/master/README.md)
  to see the full list of Cloud APIs that we cover.

[Client Library Documentation]: https://googlecloudplatform.github.io/google-cloud-ruby/#/docs/library/latest/google/library
[Product Documentation]: https://cloud.google.com/library

============== file: Rakefile ==============
# Copyright 2017, Google Inc. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

require "bundler/setup"
require "bundler/gem_tasks"

require "rubocop/rake_task"
RuboCop::RakeTask.new

desc "Run tests."
task :test do
  $LOAD_PATH.unshift "lib", "test"
  Dir.glob("test/**/*test.rb")
    .reject { |file| file.include? "smoke_test" }
    .each { |file| require_relative file }
end

namespace :test do
  desc "Runs tests with coverage."
  task :coverage do
    require "simplecov"
    SimpleCov.start do
      command_name "library"
      track_files "lib/**/*.rb"
      add_filter "test/"
    end

    Rake::Task["test"].invoke
  end
end

desc "Runs the smoke tests."
task :smoke_test do
  if ENV["SMOKE_TEST_PROJECT"].nil?
    fail "The SMOKE_TEST_PROJECT environment variable must be set. "\
      "e.g SMOKE_TEST_PROJECT=test123 rake smoke_test"
  end

  $LOAD_PATH.unshift "lib", "smoke_test"
  Dir.glob("test/**/*smoke_test.rb").each { |file| require_relative file }
end

namespace :smoke_test do
  desc "Runs smoke tests with coverage."
  task :coverage do
    require "simplecov"
    SimpleCov.start do
      command_name "library"
      track_files "lib/**/*.rb"
      add_filter "test/"
    end

    Rake::Task["smoke_test"].invoke
  end
end

# Acceptance tests
desc "Run the library acceptance tests."
task :acceptance do
  puts "The library gem does not have acceptance tests."
end

namespace :acceptance do
  task :run do
    puts "This gem does not have acceptance tests."
  end

  desc "Run acceptance tests with coverage."
  task :coverage do
  end

  desc "Run acceptance cleanup."
  task :cleanup do
  end
end

require "yard"
require "yard/rake/yardoc_task"
YARD::Rake::YardocTask.new

desc "Generates JSON output from library .yardoc"
task :jsondoc => :yard do
  require "rubygems"
  require "gcloud/jsondoc"

  registry = YARD::Registry.load! ".yardoc"

  toc_config = {
    documents: [
      {
        type: "toc",
        title: "Google::Example::Library::V1::DataTypes",
        modules: [
          {
            title: "Google::Example::Library::V1",
            include: ["library/v1"]
          },
          {
            title: "Google::Protobuf",
            include: ["google/protobuf"]
          },
          {
            title: "Google::Rpc",
            include: ["google/rpc"]
          }
        ]
      }
    ]
  }

  generator = Gcloud::Jsondoc::Generator.new registry,
                                             "library",
                                             generate: toc_config
  rm_rf "jsondoc", verbose: true
  generator.write_to "jsondoc"
  cp ["docs/toc.json"], "jsondoc", verbose: true
end

desc "Run yard-doctest example tests."
task :doctest do
  puts "The library gem does not have doctest tests."
end

desc "Run the CI build"
task :ci do
  header "BUILDING library"
  header "library rubocop", "*"
  sh "bundle exec rake rubocop"
  header "library jsondoc", "*"
  sh "bundle exec rake jsondoc"
  header "library doctest", "*"
  sh "bundle exec rake doctest"
  header "library test", "*"
  sh "bundle exec rake test"
end

namespace :ci do
  desc "Run the CI build, with smoke_tests."
  task :acceptance do
    Rake::Task["ci"].invoke
    header "library smoke_test", "*"
    sh "bundle exec rake smoke_test -v"
  end
  task :a do
    # This is a handy shortcut to save typing
    Rake::Task["ci:acceptance"].invoke
  end
end

namespace :ci do
  desc "Run the CI build, with acceptance tests."
  task :smoke_test do
    Rake::Task["ci"].invoke
    header "library acceptance", "*"
    sh "bundle exec rake acceptance -v"
  end
  task :a do
    # This is a handy shortcut to save typing
    Rake::Task["ci:acceptance"].invoke
  end
end

task :default => :test

def header str, token = "#"
  line_length = str.length + 8
  puts ""
  puts token * line_length
  puts "#{token * 3} #{str} #{token * 3}"
  puts token * line_length
  puts ""
end

============== file: lib/library.rb ==============
# Copyright 2017, Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

require "google/gax"
require "pathname"

# rubocop:disable LineLength

##
# # Ruby Client for Google Example Library API ([Alpha](https://github.com/GoogleCloudPlatform/google-cloud-ruby#versioning))
#
# [Google Example Library API][Product Documentation]:
# A simple Google Example Library API.
# - [Product Documentation][]
#
# ## Quick Start
# In order to use this library, you first need to go through the following
# steps:
#
# 1. [Select or create a Cloud Platform project.](https://console.cloud.google.com/project)
# 2. [Enable the Google Example Library API.](https://console.cloud.google.com/apis/api/library)
# 3. [Setup Authentication.](https://googlecloudplatform.github.io/google-cloud-ruby/#/docs/google-cloud/master/guides/authentication)
#
# ### Preview
# #### LibraryServiceClient
# ```rb
# require "library"
#
# library_service_client = Library.new
# formatted_name = Library::V1::LibraryServiceClient.book_path("testShelf-" + Time.new.to_i.to_s, project_id)
# optional_foo = ''
# rating = :GOOD
# book = { rating: rating }
# update_mask = {}
# physical_mask = {}
# response = library_service_client.update_book(formatted_name, book, optional_foo: optional_foo, update_mask: update_mask, physical_mask: physical_mask)
# ```
#
# ### Next Steps
# - Read the [Google Example Library API Product documentation][Product Documentation]
#   to learn more about the product and see How-to Guides.
# - View this [repository's main README](https://github.com/GoogleCloudPlatform/google-cloud-ruby/blob/master/README.md)
#   to see the full list of Cloud APIs that we cover.
#
# [Product Documentation]: https://cloud.google.com/library
#
#
module Library
  # rubocop:enable LineLength

  FILE_DIR = File.realdirpath(Pathname.new(__FILE__).join("..").join("library"))

  AVAILABLE_VERSIONS = Dir["#{FILE_DIR}/*"]
    .select { |file| File.directory?(file) }
    .select { |dir| Google::Gax::VERSION_MATCHER.match(File.basename(dir)) }
    .select { |dir| File.exist?(dir + ".rb") }
    .map { |dir| File.basename(dir) }

  ##
  # This API represents a simple digital library.  It lets you manage Shelf
  # resources and Book resources in the library. It defines the following
  # resource model:
  #
  # * The API has a collection of {Google::Example::Library::V1::Shelf Shelf}
  #   resources, named +bookShelves/*+
  #
  # * Each Shelf has a collection of {Google::Example::Library::V1::Book Book}
  #   resources, named +bookShelves/*/books/*+
  #
  # Check out [cloud docs!](https://cloud.google.com/library/example/link).
  # This is [not a cloud link](http://www.google.com).
  #
  # Service comment may include special characters: <>&"+'@.
  #
  # @param version [Symbol, String]
  #   The major version of the service to be used. By default :v1
  #   is used.
  # @overload new(version:, credentials:, scopes:, client_config:, timeout:)
  #   @param credentials [Google::Auth::Credentials, String, Hash, GRPC::Core::Channel, GRPC::Core::ChannelCredentials, Proc]
  #     Provides the means for authenticating requests made by the client. This parameter can
  #     be many types.
  #     A `Google::Auth::Credentials` uses a the properties of its represented keyfile for
  #     authenticating requests made by this client.
  #     A `String` will be treated as the path to the keyfile to be used for the construction of
  #     credentials for this client.
  #     A `Hash` will be treated as the contents of a keyfile to be used for the construction of
  #     credentials for this client.
  #     A `GRPC::Core::Channel` will be used to make calls through.
  #     A `GRPC::Core::ChannelCredentials` for the setting up the RPC client. The channel credentials
  #     should already be composed with a `GRPC::Core::CallCredentials` object.
  #     A `Proc` will be used as an updater_proc for the Grpc channel. The proc transforms the
  #     metadata for requests, generally, to give OAuth credentials.
  #   @param scopes [Array<String>]
  #     The OAuth scopes for this service. This parameter is ignored if
  #     an updater_proc is supplied.
  #   @param client_config [Hash]
  #     A Hash for call options for each method. See
  #     Google::Gax#construct_settings for the structure of
  #     this data. Falls back to the default config if not specified
  #     or the specified config is missing data points.
  #   @param timeout [Numeric]
  #     The default timeout, in seconds, for calls made through this client.
  def self.new(*args, version: :v1, **kwargs)
    unless AVAILABLE_VERSIONS.include?(version.to_s.downcase)
      raise "The version: #{version} is not available. The available versions " \
        "are: [#{AVAILABLE_VERSIONS.join(", ")}]"
    end

    require "#{FILE_DIR}/#{version.to_s.downcase}"
    version_module = Library
      .constants
      .select {|sym| sym.to_s.downcase == version.to_s.downcase}
      .first
    Library.const_get(version_module).new(*args, **kwargs)
  end
end

============== file: lib/library/credentials.rb ==============
# Copyright 2017, Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

require "googleauth"

module Library
  class Credentials < Google::Auth::Credentials
    SCOPE = [
      "https://www.googleapis.com/auth/cloud-platform",
      "https://www.googleapis.com/auth/library"
    ].freeze
    PATH_ENV_VARS = %w(LIBRARY_KEYFILE, GOOGLE_CLOUD_KEYFILE, GCLOUD_KEYFILE)
    JSON_ENV_VARS = %w(LIBRARY_KEYFILE_JSON, GOOGLE_CLOUD_KEYFILE_JSON, GCLOUD_KEYFILE_JSON)
    DEFAULT_PATHS = ["~/.config/gcloud/application_default_credentials.json"]
  end
end

============== file: lib/library/v1.rb ==============
# Copyright 2017, Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

require "library/v1/library_service_client"

# rubocop:disable LineLength

##
# # Ruby Client for Google Example Library API ([Alpha](https://github.com/GoogleCloudPlatform/google-cloud-ruby#versioning))
#
# [Google Example Library API][Product Documentation]:
# A simple Google Example Library API.
# - [Product Documentation][]
#
# ## Quick Start
# In order to use this library, you first need to go through the following
# steps:
#
# 1. [Select or create a Cloud Platform project.](https://console.cloud.google.com/project)
# 2. [Enable the Google Example Library API.](https://console.cloud.google.com/apis/api/library)
# 3. [Setup Authentication.](https://googlecloudplatform.github.io/google-cloud-ruby/#/docs/google-cloud/master/guides/authentication)
#
# ### Preview
# #### LibraryServiceClient
# ```rb
# require "library/v1"
#
# library_service_client = Library::V1.new
# formatted_name = Library::V1::LibraryServiceClient.book_path("testShelf-" + Time.new.to_i.to_s, project_id)
# optional_foo = ''
# rating = :GOOD
# book = { rating: rating }
# update_mask = {}
# physical_mask = {}
# response = library_service_client.update_book(formatted_name, book, optional_foo: optional_foo, update_mask: update_mask, physical_mask: physical_mask)
# ```
#
# ### Next Steps
# - Read the [Google Example Library API Product documentation][Product Documentation]
#   to learn more about the product and see How-to Guides.
# - View this [repository's main README](https://github.com/GoogleCloudPlatform/google-cloud-ruby/blob/master/README.md)
#   to see the full list of Cloud APIs that we cover.
#
# [Product Documentation]: https://cloud.google.com/library
#
#
module Library
  module V1
    # rubocop:enable LineLength

    ##
    # This API represents a simple digital library.  It lets you manage Shelf
    # resources and Book resources in the library. It defines the following
    # resource model:
    #
    # * The API has a collection of {Google::Example::Library::V1::Shelf Shelf}
    #   resources, named +bookShelves/*+
    #
    # * Each Shelf has a collection of {Google::Example::Library::V1::Book Book}
    #   resources, named +bookShelves/*/books/*+
    #
    # Check out [cloud docs!](https://cloud.google.com/library/example/link).
    # This is [not a cloud link](http://www.google.com).
    #
    # Service comment may include special characters: <>&"+'@.
    #
    # @param credentials [Google::Auth::Credentials, String, Hash, GRPC::Core::Channel, GRPC::Core::ChannelCredentials, Proc]
    #   Provides the means for authenticating requests made by the client. This parameter can
    #   be many types.
    #   A `Google::Auth::Credentials` uses a the properties of its represented keyfile for
    #   authenticating requests made by this client.
    #   A `String` will be treated as the path to the keyfile to be used for the construction of
    #   credentials for this client.
    #   A `Hash` will be treated as the contents of a keyfile to be used for the construction of
    #   credentials for this client.
    #   A `GRPC::Core::Channel` will be used to make calls through.
    #   A `GRPC::Core::ChannelCredentials` for the setting up the RPC client. The channel credentials
    #   should already be composed with a `GRPC::Core::CallCredentials` object.
    #   A `Proc` will be used as an updater_proc for the Grpc channel. The proc transforms the
    #   metadata for requests, generally, to give OAuth credentials.
    # @param scopes [Array<String>]
    #   The OAuth scopes for this service. This parameter is ignored if
    #   an updater_proc is supplied.
    # @param client_config [Hash]
    #   A Hash for call options for each method. See
    #   Google::Gax#construct_settings for the structure of
    #   this data. Falls back to the default config if not specified
    #   or the specified config is missing data points.
    # @param timeout [Numeric]
    #   The default timeout, in seconds, for calls made through this client.
    def self.new \
        service_path: nil,
        port: nil,
        channel: nil,
        chan_creds: nil,
        updater_proc: nil,
        credentials: nil,
        scopes: nil,
        client_config: nil,
        timeout: nil,
        lib_name: nil,
        lib_version: nil
      kwargs = {
        service_path: service_path,
        port: port,
        channel: channel,
        chan_creds: chan_creds,
        updater_proc: updater_proc,
        credentials: credentials,
        scopes: scopes,
        client_config: client_config,
        timeout: timeout,
        lib_name: lib_name,
        lib_version: lib_version
      }.select { |_, v| v != nil }
      Library::V1::LibraryServiceClient.new(**kwargs)
    end
  end
end

============== file: lib/library/v1/doc/field_mask.rb ==============
# Copyright 2017, Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

module Google
  module Example
    module Library
      module V1
        # @!attribute [rw] materials
        #   @return [Array<Google::Example::Library::V1::FieldMask::Material>]
        class FieldMask
          module Material
            PAPIER_MACHE = 0

            WOOD = 1

            PORCELAIN = 2

            SEQUINS = 3

            CARDBOARD = 4
          end
        end
      end
    end
  end
end
============== file: lib/library/v1/doc/google/protobuf/any.rb ==============
# Copyright 2017, Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

module Google
  module Protobuf
    # +Any+ contains an arbitrary serialized protocol buffer message along with a
    # URL that describes the type of the serialized message.
    #
    # Protobuf library provides support to pack/unpack Any values in the form
    # of utility functions or additional generated methods of the Any type.
    #
    # Example 1: Pack and unpack a message in C++.
    #
    #     Foo foo = ...;
    #     Any any;
    #     any.PackFrom(foo);
    #     ...
    #     if (any.UnpackTo(&foo)) {
    #       ...
    #     }
    #
    # Example 2: Pack and unpack a message in Java.
    #
    #     Foo foo = ...;
    #     Any any = Any.pack(foo);
    #     ...
    #     if (any.is(Foo.class)) {
    #       foo = any.unpack(Foo.class);
    #     }
    #
    #  Example 3: Pack and unpack a message in Python.
    #
    #     foo = Foo(...)
    #     any = Any()
    #     any.Pack(foo)
    #     ...
    #     if any.Is(Foo.DESCRIPTOR):
    #       any.Unpack(foo)
    #       ...
    #
    #  Example 4: Pack and unpack a message in Go
    #
    #      foo := &pb.Foo{...}
    #      any, err := ptypes.MarshalAny(foo)
    #      ...
    #      foo := &pb.Foo{}
    #      if err := ptypes.UnmarshalAny(any, foo); err != nil {
    #        ...
    #      }
    #
    # The pack methods provided by protobuf library will by default use
    # 'type.googleapis.com/full.type.name' as the type URL and the unpack
    # methods only use the fully qualified type name after the last '/'
    # in the type URL, for example "foo.bar.com/x/y.z" will yield type
    # name "y.z".
    #
    #
    # = JSON
    #
    # The JSON representation of an +Any+ value uses the regular
    # representation of the deserialized, embedded message, with an
    # additional field +@type+ which contains the type URL. Example:
    #
    #     package google.profile;
    #     message Person {
    #       string first_name = 1;
    #       string last_name = 2;
    #     }
    #
    #     {
    #       "@type": "type.googleapis.com/google.profile.Person",
    #       "firstName": <string>,
    #       "lastName": <string>
    #     }
    #
    # If the embedded message type is well-known and has a custom JSON
    # representation, that representation will be embedded adding a field
    # +value+ which holds the custom JSON in addition to the +@type+
    # field. Example (for message {Google::Protobuf::Duration}):
    #
    #     {
    #       "@type": "type.googleapis.com/google.protobuf.Duration",
    #       "value": "1.212s"
    #     }
    # @!attribute [rw] type_url
    #   @return [String]
    #     A URL/resource name whose content describes the type of the
    #     serialized protocol buffer message.
    #
    #     For URLs which use the scheme +http+, +https+, or no scheme, the
    #     following restrictions and interpretations apply:
    #
    #     * If no scheme is provided, +https+ is assumed.
    #     * The last segment of the URL's path must represent the fully
    #       qualified name of the type (as in +path/google.protobuf.Duration+).
    #       The name should be in a canonical form (e.g., leading "." is
    #       not accepted).
    #     * An HTTP GET on the URL must yield a {Google::Protobuf::Type}
    #       value in binary format, or produce an error.
    #     * Applications are allowed to cache lookup results based on the
    #       URL, or have them precompiled into a binary to avoid any
    #       lookup. Therefore, binary compatibility needs to be preserved
    #       on changes to types. (Use versioned type names to manage
    #       breaking changes.)
    #
    #     Schemes other than +http+, +https+ (or the empty scheme) might be
    #     used with implementation specific semantics.
    # @!attribute [rw] value
    #   @return [String]
    #     Must be a valid serialized protocol buffer of the above specified type.
    class Any; end
  end
end
============== file: lib/library/v1/doc/google/protobuf/duration.rb ==============
# Copyright 2017, Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

module Google
  module Protobuf
    # A Duration represents a signed, fixed-length span of time represented
    # as a count of seconds and fractions of seconds at nanosecond
    # resolution. It is independent of any calendar and concepts like "day"
    # or "month". It is related to Timestamp in that the difference between
    # two Timestamp values is a Duration and it can be added or subtracted
    # from a Timestamp. Range is approximately +-10,000 years.
    #
    # = Examples
    #
    # Example 1: Compute Duration from two Timestamps in pseudo code.
    #
    #     Timestamp start = ...;
    #     Timestamp end = ...;
    #     Duration duration = ...;
    #
    #     duration.seconds = end.seconds - start.seconds;
    #     duration.nanos = end.nanos - start.nanos;
    #
    #     if (duration.seconds < 0 && duration.nanos > 0) {
    #       duration.seconds += 1;
    #       duration.nanos -= 1000000000;
    #     } else if (durations.seconds > 0 && duration.nanos < 0) {
    #       duration.seconds -= 1;
    #       duration.nanos += 1000000000;
    #     }
    #
    # Example 2: Compute Timestamp from Timestamp + Duration in pseudo code.
    #
    #     Timestamp start = ...;
    #     Duration duration = ...;
    #     Timestamp end = ...;
    #
    #     end.seconds = start.seconds + duration.seconds;
    #     end.nanos = start.nanos + duration.nanos;
    #
    #     if (end.nanos < 0) {
    #       end.seconds -= 1;
    #       end.nanos += 1000000000;
    #     } else if (end.nanos >= 1000000000) {
    #       end.seconds += 1;
    #       end.nanos -= 1000000000;
    #     }
    #
    # Example 3: Compute Duration from datetime.timedelta in Python.
    #
    #     td = datetime.timedelta(days=3, minutes=10)
    #     duration = Duration()
    #     duration.FromTimedelta(td)
    #
    # = JSON Mapping
    #
    # In JSON format, the Duration type is encoded as a string rather than an
    # object, where the string ends in the suffix "s" (indicating seconds) and
    # is preceded by the number of seconds, with nanoseconds expressed as
    # fractional seconds. For example, 3 seconds with 0 nanoseconds should be
    # encoded in JSON format as "3s", while 3 seconds and 1 nanosecond should
    # be expressed in JSON format as "3.000000001s", and 3 seconds and 1
    # microsecond should be expressed in JSON format as "3.000001s".
    # @!attribute [rw] seconds
    #   @return [Integer]
    #     Signed seconds of the span of time. Must be from -315,576,000,000
    #     to +315,576,000,000 inclusive. Note: these bounds are computed from:
    #     60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
    # @!attribute [rw] nanos
    #   @return [Integer]
    #     Signed fractions of a second at nanosecond resolution of the span
    #     of time. Durations less than one second are represented with a 0
    #     +seconds+ field and a positive or negative +nanos+ field. For durations
    #     of one second or more, a non-zero value for the +nanos+ field must be
    #     of the same sign as the +seconds+ field. Must be from -999,999,999
    #     to +999,999,999 inclusive.
    class Duration; end
  end
end
============== file: lib/library/v1/doc/google/protobuf/field_mask.rb ==============
# Copyright 2017, Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

module Google
  module Protobuf
    # +FieldMask+ represents a set of symbolic field paths, for example:
    #
    #     paths: "f.a"
    #     paths: "f.b.d"
    #
    # Here +f+ represents a field in some root message, +a+ and +b+
    # fields in the message found in +f+, and +d+ a field found in the
    # message in +f.b+.
    #
    # Field masks are used to specify a subset of fields that should be
    # returned by a get operation or modified by an update operation.
    # Field masks also have a custom JSON encoding (see below).
    #
    # = Field Masks in Projections
    #
    # When used in the context of a projection, a response message or
    # sub-message is filtered by the API to only contain those fields as
    # specified in the mask. For example, if the mask in the previous
    # example is applied to a response message as follows:
    #
    #     f {
    #       a : 22
    #       b {
    #         d : 1
    #         x : 2
    #       }
    #       y : 13
    #     }
    #     z: 8
    #
    # The result will not contain specific values for fields x,y and z
    # (their value will be set to the default, and omitted in proto text
    # output):
    #
    #
    #     f {
    #       a : 22
    #       b {
    #         d : 1
    #       }
    #     }
    #
    # A repeated field is not allowed except at the last position of a
    # paths string.
    #
    # If a FieldMask object is not present in a get operation, the
    # operation applies to all fields (as if a FieldMask of all fields
    # had been specified).
    #
    # Note that a field mask does not necessarily apply to the
    # top-level response message. In case of a REST get operation, the
    # field mask applies directly to the response, but in case of a REST
    # list operation, the mask instead applies to each individual message
    # in the returned resource list. In case of a REST custom method,
    # other definitions may be used. Where the mask applies will be
    # clearly documented together with its declaration in the API.  In
    # any case, the effect on the returned resource/resources is required
    # behavior for APIs.
    #
    # = Field Masks in Update Operations
    #
    # A field mask in update operations specifies which fields of the
    # targeted resource are going to be updated. The API is required
    # to only change the values of the fields as specified in the mask
    # and leave the others untouched. If a resource is passed in to
    # describe the updated values, the API ignores the values of all
    # fields not covered by the mask.
    #
    # If a repeated field is specified for an update operation, the existing
    # repeated values in the target resource will be overwritten by the new values.
    # Note that a repeated field is only allowed in the last position of a +paths+
    # string.
    #
    # If a sub-message is specified in the last position of the field mask for an
    # update operation, then the existing sub-message in the target resource is
    # overwritten. Given the target message:
    #
    #     f {
    #       b {
    #         d : 1
    #         x : 2
    #       }
    #       c : 1
    #     }
    #
    # And an update message:
    #
    #     f {
    #       b {
    #         d : 10
    #       }
    #     }
    #
    # then if the field mask is:
    #
    #  paths: "f.b"
    #
    # then the result will be:
    #
    #     f {
    #       b {
    #         d : 10
    #       }
    #       c : 1
    #     }
    #
    # However, if the update mask was:
    #
    #  paths: "f.b.d"
    #
    # then the result would be:
    #
    #     f {
    #       b {
    #         d : 10
    #         x : 2
    #       }
    #       c : 1
    #     }
    #
    # In order to reset a field's value to the default, the field must
    # be in the mask and set to the default value in the provided resource.
    # Hence, in order to reset all fields of a resource, provide a default
    # instance of the resource and set all fields in the mask, or do
    # not provide a mask as described below.
    #
    # If a field mask is not present on update, the operation applies to
    # all fields (as if a field mask of all fields has been specified).
    # Note that in the presence of schema evolution, this may mean that
    # fields the client does not know and has therefore not filled into
    # the request will be reset to their default. If this is unwanted
    # behavior, a specific service may require a client to always specify
    # a field mask, producing an error if not.
    #
    # As with get operations, the location of the resource which
    # describes the updated values in the request message depends on the
    # operation kind. In any case, the effect of the field mask is
    # required to be honored by the API.
    #
    # == Considerations for HTTP REST
    #
    # The HTTP kind of an update operation which uses a field mask must
    # be set to PATCH instead of PUT in order to satisfy HTTP semantics
    # (PUT must only be used for full updates).
    #
    # = JSON Encoding of Field Masks
    #
    # In JSON, a field mask is encoded as a single string where paths are
    # separated by a comma. Fields name in each path are converted
    # to/from lower-camel naming conventions.
    #
    # As an example, consider the following message declarations:
    #
    #     message Profile {
    #       User user = 1;
    #       Photo photo = 2;
    #     }
    #     message User {
    #       string display_name = 1;
    #       string address = 2;
    #     }
    #
    # In proto a field mask for +Profile+ may look as such:
    #
    #     mask {
    #       paths: "user.display_name"
    #       paths: "photo"
    #     }
    #
    # In JSON, the same mask is represented as below:
    #
    #     {
    #       mask: "user.displayName,photo"
    #     }
    #
    # = Field Masks and Oneof Fields
    #
    # Field masks treat fields in oneofs just as regular fields. Consider the
    # following message:
    #
    #     message SampleMessage {
    #       oneof test_oneof {
    #         string name = 4;
    #         SubMessage sub_message = 9;
    #       }
    #     }
    #
    # The field mask can be:
    #
    #     mask {
    #       paths: "name"
    #     }
    #
    # Or:
    #
    #     mask {
    #       paths: "sub_message"
    #     }
    #
    # Note that oneof type names ("test_oneof" in this case) cannot be used in
    # paths.
    # @!attribute [rw] paths
    #   @return [Array<String>]
    #     The set of field mask paths.
    class FieldMask; end
  end
end
============== file: lib/library/v1/doc/google/protobuf/struct.rb ==============
# Copyright 2017, Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

module Google
  module Protobuf
    # +Struct+ represents a structured data value, consisting of fields
    # which map to dynamically typed values. In some languages, +Struct+
    # might be supported by a native representation. For example, in
    # scripting languages like JS a struct is represented as an
    # object. The details of that representation are described together
    # with the proto support for the language.
    #
    # The JSON representation for +Struct+ is JSON object.
    # @!attribute [rw] fields
    #   @return [Hash{String => Google::Protobuf::Value}]
    #     Unordered map of dynamically typed values.
    class Struct; end

    # +Value+ represents a dynamically typed value which can be either
    # null, a number, a string, a boolean, a recursive struct value, or a
    # list of values. A producer of value is expected to set one of that
    # variants, absence of any variant indicates an error.
    #
    # The JSON representation for +Value+ is JSON value.
    # @!attribute [rw] null_value
    #   @return [Google::Protobuf::NullValue]
    #     Represents a null value.
    # @!attribute [rw] number_value
    #   @return [Float]
    #     Represents a double value.
    # @!attribute [rw] string_value
    #   @return [String]
    #     Represents a string value.
    # @!attribute [rw] bool_value
    #   @return [true, false]
    #     Represents a boolean value.
    # @!attribute [rw] struct_value
    #   @return [Google::Protobuf::Struct]
    #     Represents a structured value.
    # @!attribute [rw] list_value
    #   @return [Google::Protobuf::ListValue]
    #     Represents a repeated +Value+.
    class Value; end

    # +ListValue+ is a wrapper around a repeated field of values.
    #
    # The JSON representation for +ListValue+ is JSON array.
    # @!attribute [rw] values
    #   @return [Array<Google::Protobuf::Value>]
    #     Repeated field of dynamically typed values.
    class ListValue; end

    # +NullValue+ is a singleton enumeration to represent the null value for the
    # +Value+ type union.
    #
    #  The JSON representation for +NullValue+ is JSON +null+.
    module NullValue
      # Null value.
      NULL_VALUE = 0
    end
  end
end
============== file: lib/library/v1/doc/google/protobuf/timestamp.rb ==============
# Copyright 2017, Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

module Google
  module Protobuf
    # A Timestamp represents a point in time independent of any time zone
    # or calendar, represented as seconds and fractions of seconds at
    # nanosecond resolution in UTC Epoch time. It is encoded using the
    # Proleptic Gregorian Calendar which extends the Gregorian calendar
    # backwards to year one. It is encoded assuming all minutes are 60
    # seconds long, i.e. leap seconds are "smeared" so that no leap second
    # table is needed for interpretation. Range is from
    # 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z.
    # By restricting to that range, we ensure that we can convert to
    # and from  RFC 3339 date strings.
    # See [https://www.ietf.org/rfc/rfc3339.txt](https://www.ietf.org/rfc/rfc3339.txt).
    #
    # = Examples
    #
    # Example 1: Compute Timestamp from POSIX +time()+.
    #
    #     Timestamp timestamp;
    #     timestamp.set_seconds(time(NULL));
    #     timestamp.set_nanos(0);
    #
    # Example 2: Compute Timestamp from POSIX +gettimeofday()+.
    #
    #     struct timeval tv;
    #     gettimeofday(&tv, NULL);
    #
    #     Timestamp timestamp;
    #     timestamp.set_seconds(tv.tv_sec);
    #     timestamp.set_nanos(tv.tv_usec * 1000);
    #
    # Example 3: Compute Timestamp from Win32 +GetSystemTimeAsFileTime()+.
    #
    #     FILETIME ft;
    #     GetSystemTimeAsFileTime(&ft);
    #     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;
    #
    #     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z
    #     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.
    #     Timestamp timestamp;
    #     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));
    #     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));
    #
    # Example 4: Compute Timestamp from Java +System.currentTimeMillis()+.
    #
    #     long millis = System.currentTimeMillis();
    #
    #     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)
    #         .setNanos((int) ((millis % 1000) * 1000000)).build();
    #
    #
    # Example 5: Compute Timestamp from current time in Python.
    #
    #     timestamp = Timestamp()
    #     timestamp.GetCurrentTime()
    #
    # = JSON Mapping
    #
    # In JSON format, the Timestamp type is encoded as a string in the
    # [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the
    # format is "{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z"
    # where {year} is always expressed using four digits while {month}, {day},
    # {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional
    # seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),
    # are optional. The "Z" suffix indicates the timezone ("UTC"); the timezone
    # is required, though only UTC (as indicated by "Z") is presently supported.
    #
    # For example, "2017-01-15T01:30:15.01Z" encodes 15.01 seconds past
    # 01:30 UTC on January 15, 2017.
    #
    # In JavaScript, one can convert a Date object to this format using the
    # standard [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString]
    # method. In Python, a standard +datetime.datetime+ object can be converted
    # to this format using [+strftime+](https://docs.python.org/2/library/time.html#time.strftime)
    # with the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one
    # can use the Joda Time's [+ISODateTimeFormat.dateTime()+](
    # http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime())
    # to obtain a formatter capable of generating timestamps in this format.
    # @!attribute [rw] seconds
    #   @return [Integer]
    #     Represents seconds of UTC time since Unix epoch
    #     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
    #     9999-12-31T23:59:59Z inclusive.
    # @!attribute [rw] nanos
    #   @return [Integer]
    #     Non-negative fractions of a second at nanosecond resolution. Negative
    #     second values with fractions must still have non-negative nanos values
    #     that count forward in time. Must be from 0 to 999,999,999
    #     inclusive.
    class Timestamp; end
  end
end
============== file: lib/library/v1/doc/google/protobuf/wrappers.rb ==============
# Copyright 2017, Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

module Google
  module Protobuf
    # Wrapper message for +double+.
    #
    # The JSON representation for +DoubleValue+ is JSON number.
    # @!attribute [rw] value
    #   @return [Float]
    #     The double value.
    class DoubleValue; end

    # Wrapper message for +float+.
    #
    # The JSON representation for +FloatValue+ is JSON number.
    # @!attribute [rw] value
    #   @return [Float]
    #     The float value.
    class FloatValue; end

    # Wrapper message for +int64+.
    #
    # The JSON representation for +Int64Value+ is JSON string.
    # @!attribute [rw] value
    #   @return [Integer]
    #     The int64 value.
    class Int64Value; end

    # Wrapper message for +uint64+.
    #
    # The JSON representation for +UInt64Value+ is JSON string.
    # @!attribute [rw] value
    #   @return [Integer]
    #     The uint64 value.
    class UInt64Value; end

    # Wrapper message for +int32+.
    #
    # The JSON representation for +Int32Value+ is JSON number.
    # @!attribute [rw] value
    #   @return [Integer]
    #     The int32 value.
    class Int32Value; end

    # Wrapper message for +uint32+.
    #
    # The JSON representation for +UInt32Value+ is JSON number.
    # @!attribute [rw] value
    #   @return [Integer]
    #     The uint32 value.
    class UInt32Value; end

    # Wrapper message for +bool+.
    #
    # The JSON representation for +BoolValue+ is JSON +true+ and +false+.
    # @!attribute [rw] value
    #   @return [true, false]
    #     The bool value.
    class BoolValue; end

    # Wrapper message for +string+.
    #
    # The JSON representation for +StringValue+ is JSON string.
    # @!attribute [rw] value
    #   @return [String]
    #     The string value.
    class StringValue; end

    # Wrapper message for +bytes+.
    #
    # The JSON representation for +BytesValue+ is JSON string.
    # @!attribute [rw] value
    #   @return [String]
    #     The bytes value.
    class BytesValue; end
  end
end
============== file: lib/library/v1/doc/google/rpc/status.rb ==============
# Copyright 2017, Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

module Google
  module Rpc
    # The +Status+ type defines a logical error model that is suitable for different
    # programming environments, including REST APIs and RPC APIs. It is used by
    # [gRPC](https://github.com/grpc). The error model is designed to be:
    #
    # * Simple to use and understand for most users
    # * Flexible enough to meet unexpected needs
    #
    # = Overview
    #
    # The +Status+ message contains three pieces of data: error code, error message,
    # and error details. The error code should be an enum value of
    # {Google::Rpc::Code}, but it may accept additional error codes if needed.  The
    # error message should be a developer-facing English message that helps
    # developers *understand* and *resolve* the error. If a localized user-facing
    # error message is needed, put the localized message in the error details or
    # localize it in the client. The optional error details may contain arbitrary
    # information about the error. There is a predefined set of error detail types
    # in the package +google.rpc+ which can be used for common error conditions.
    #
    # = Language mapping
    #
    # The +Status+ message is the logical representation of the error model, but it
    # is not necessarily the actual wire format. When the +Status+ message is
    # exposed in different client libraries and different wire protocols, it can be
    # mapped differently. For example, it will likely be mapped to some exceptions
    # in Java, but more likely mapped to some error codes in C.
    #
    # = Other uses
    #
    # The error model and the +Status+ message can be used in a variety of
    # environments, either with or without APIs, to provide a
    # consistent developer experience across different environments.
    #
    # Example uses of this error model include:
    #
    # * Partial errors. If a service needs to return partial errors to the client,
    #   it may embed the +Status+ in the normal response to indicate the partial
    #   errors.
    #
    # * Workflow errors. A typical workflow has multiple steps. Each step may
    #   have a +Status+ message for error reporting purpose.
    #
    # * Batch operations. If a client uses batch request and batch response, the
    #   +Status+ message should be used directly inside batch response, one for
    #   each error sub-response.
    #
    # * Asynchronous operations. If an API call embeds asynchronous operation
    #   results in its response, the status of those operations should be
    #   represented directly using the +Status+ message.
    #
    # * Logging. If some API errors are stored in logs, the message +Status+ could
    #   be used directly after any stripping needed for security/privacy reasons.
    # @!attribute [rw] code
    #   @return [Integer]
    #     The status code, which should be an enum value of {Google::Rpc::Code}.
    # @!attribute [rw] message
    #   @return [String]
    #     A developer-facing error message, which should be in English. Any
    #     user-facing error message should be localized and sent in the
    #     {Google::Rpc::Status#details} field, or localized by the client.
    # @!attribute [rw] details
    #   @return [Array<Google::Protobuf::Any>]
    #     A list of messages that carry the error details.  There will be a
    #     common set of message types for APIs to use.
    class Status; end
  end
end
============== file: lib/library/v1/doc/library.rb ==============
# Copyright 2017, Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

module Google
  module Example
    module Library
      ##
      # # Google Example Library API Contents
      #
      # | Class | Description |
      # | ----- | ----------- |
      # | [LibraryServiceClient][] | A simple Google Example Library API. |
      # | [Data Types][] | Data types for Library::V1 |
      #
      # [LibraryServiceClient]: https://googlecloudplatform.github.io/google-cloud-ruby/#/docs/library/latest/google/example/library/v1/libraryserviceclient
      # [Data Types]: https://googlecloudplatform.github.io/google-cloud-ruby/#/docs/library/latest/google/example/library/v1/datatypes
      #
      module V1
        # A single book in the library.
        # Message comment may include special characters: <>&"+'@.
        # @!attribute [rw] name
        #   @return [String]
        #     The resource name of the book.
        #     Book names have the form +bookShelves/{shelf_id}/books/{book_id}+.
        #     Message field comment may include special characters: <>&"+'@.
        # @!attribute [rw] author
        #   @return [String]
        #     The name of the book author.
        # @!attribute [rw] title
        #   @return [String]
        #     The title of the book.
        # @!attribute [rw] read
        #   @return [true, false]
        #     Value indicating whether the book has been read.
        # @!attribute [rw] rating
        #   @return [Google::Example::Library::V1::Book::Rating]
        #     For testing enums.
        # @!attribute [rw] any_value
        #   @return [Google::Protobuf::Any]
        #     For testing all well-known types.
        # @!attribute [rw] struct_value
        #   @return [Google::Protobuf::Struct]
        # @!attribute [rw] value_value
        #   @return [Google::Protobuf::Value]
        # @!attribute [rw] list_value_value
        #   @return [Google::Protobuf::ListValue]
        # @!attribute [rw] map_list_value_value
        #   @return [Hash{String => Google::Protobuf::ListValue}]
        # @!attribute [rw] time_value
        #   @return [Google::Protobuf::Timestamp]
        # @!attribute [rw] duration_value
        #   @return [Google::Protobuf::Duration]
        # @!attribute [rw] field_mask_value
        #   @return [Google::Protobuf::FieldMask]
        # @!attribute [rw] int32_value
        #   @return [Google::Protobuf::Int32Value]
        # @!attribute [rw] uint32_value
        #   @return [Google::Protobuf::UInt32Value]
        # @!attribute [rw] int64_value
        #   @return [Google::Protobuf::Int64Value]
        # @!attribute [rw] uint64_value
        #   @return [Google::Protobuf::UInt64Value]
        # @!attribute [rw] float_value
        #   @return [Google::Protobuf::FloatValue]
        # @!attribute [rw] double_value
        #   @return [Google::Protobuf::DoubleValue]
        # @!attribute [rw] string_value
        #   @return [Google::Protobuf::StringValue]
        # @!attribute [rw] bool_value
        #   @return [Google::Protobuf::BoolValue]
        # @!attribute [rw] bytes_value
        #   @return [Google::Protobuf::BytesValue]
        # @!attribute [rw] map_string_value
        #   @return [Hash{Integer => String}]
        #     Test doc generation of lists:
        #
        #     * Here is a sentence about the first element of the list that continues
        #       into a second line.
        #     * The second element of the list.
        #     * Another element of the list where the indentation isn't consistent
        #       after a blank space.
        #
        #       The second paragraph of the list
        #       that doesn't have a hanging indent.
        # @!attribute [rw] map_message_value
        #   @return [Hash{String => Google::Example::Library::V1::SomeMessage}]
        # @!attribute [rw] resource
        #   @return [Google::Test::Shared::Data::Used]
        #     Tests Python doc generation: should generate a dummy file for shared_type
        #     resource, but *not* its import, other_shared_type
        class Book
          module Rating
            # GOOD enum description
            GOOD = 0

            # Enum description with special characters: <>&"+'@.
            BAD = 1
          end
        end

        # A single book in the archives.
        # @!attribute [rw] name
        #   @return [String]
        #     The resource name of the book.
        #     Book names have the form +archives/{archive_id}/books/{book_id}+.
        # @!attribute [rw] author
        #   @return [String]
        #     The name of the book author.
        # @!attribute [rw] title
        #   @return [String]
        #     The title of the book.
        # @!attribute [rw] read
        #   @return [true, false]
        #     Value indicating whether the book has been read.
        class BookFromArchive; end

        # @!attribute [rw] field
        #   @return [Integer]
        # @!attribute [rw] field2
        #   @return [Google::Example::Library::V1::SomeMessage2]
        # @!attribute [rw] alignment
        #   @return [Google::Example::Library::V1::SomeMessage::Alignment]
        class SomeMessage
          # Tests service with two enums of the same simple name
          module Alignment
            GOOD = 0

            NEUTRAL = 1

            EVIL = 2
          end
        end

        # @!attribute [rw] field1
        #   @return [Integer]
        # @!attribute [rw] format
        #   @return [Google::Example::Library::V1::SomeMessage2::Alignment]
        class SomeMessage2
          class SomeMessage3
            # Tests Python nested enums
            module Alignment
              # 8-bit
              CHAR = 0

              # 32-bit
              INT = 1

              # 64-bit
              DOUBLE = 2
            end
          end

          # Another enum with duplicated simple name
          module Alignment
            FLUSH_LEFT = 0

            FLUSH_RIGHT = 1

            CENTERED = 2

            JUSTIFIED = 3
          end
        end

        # A Shelf contains a collection of books with a theme.
        # @!attribute [rw] name
        #   @return [String]
        #     The resource name of the shelf.
        #     Shelf names have the form +bookShelves/{shelf_id}+.
        # @!attribute [rw] theme
        #   @return [String]
        #     The theme of the shelf
        # @!attribute [rw] internal_theme
        #   @return [String]
        #     Internal theme that is visible to trusted testers only.
        class Shelf; end

        # Request message for LibraryService.CreateShelf.
        # @!attribute [rw] shelf
        #   @return [Google::Example::Library::V1::Shelf]
        #     The shelf to create.
        class CreateShelfRequest; end

        # Request message for LibraryService.GetShelf.
        # @!attribute [rw] name
        #   @return [String]
        #     The name of the shelf to retrieve.
        # @!attribute [rw] message
        #   @return [Google::Example::Library::V1::SomeMessage]
        #     Field to verify that message-type query parameter gets flattened.
        # @!attribute [rw] string_builder
        #   @return [Google::Example::Library::V1::StringBuilder]
        # @!attribute [rw] options
        #   @return [String]
        #     To test 'options' parameter name conflict.
        class GetShelfRequest; end

        # Creates a name conflict with java.lang type
        # @!attribute [rw] name
        #   @return [String]
        class StringBuilder; end

        # Request message for LibraryService.ListShelves.
        # @!attribute [rw] page_token
        #   @return [String]
        #     A token identifying a page of results the server should return.
        #     Typically, this is the value of
        #     {Google::Example::Library::V1::ListShelvesResponse#next_page_token ListShelvesResponse#next_page_token}
        #     returned from the previous call to +ListShelves+ method.
        class ListShelvesRequest; end

        # Response message for LibraryService.ListShelves.
        # @!attribute [rw] shelves
        #   @return [Array<Google::Example::Library::V1::Shelf>]
        #     The list of shelves.
        # @!attribute [rw] next_page_token
        #   @return [String]
        #     A token to retrieve next page of results.
        #     Pass this value in the
        #     {Google::Example::Library::V1::ListShelvesRequest#page_token ListShelvesRequest#page_token}
        #     field in the subsequent call to +ListShelves+ method to retrieve the next
        #     page of results.
        class ListShelvesResponse; end

        # Request message for LibraryService.StreamShelves.
        class StreamShelvesRequest; end

        # Response message for LibraryService.StreamShelves.
        # @!attribute [rw] shelves
        #   @return [Array<Google::Example::Library::V1::Shelf>]
        #     The list of shelves.
        class StreamShelvesResponse; end

        # Request message for LibraryService.DeleteShelf.
        # @!attribute [rw] name
        #   @return [String]
        #     The name of the shelf to delete.
        class DeleteShelfRequest; end

        # Describes the shelf being removed (other_shelf_name) and updated
        # (name) in this merge.
        # @!attribute [rw] name
        #   @return [String]
        #     The name of the shelf we're adding books to.
        # @!attribute [rw] other_shelf_name
        #   @return [String]
        #     The name of the shelf we're removing books from and deleting.
        class MergeShelvesRequest; end

        # Request message for LibraryService.CreateBook.
        # @!attribute [rw] name
        #   @return [String]
        #     The name of the shelf in which the book is created.
        # @!attribute [rw] book
        #   @return [Google::Example::Library::V1::Book]
        #     The book to create.
        class CreateBookRequest; end

        # Request message for LibraryService.PublishSeries.
        # @!attribute [rw] shelf
        #   @return [Google::Example::Library::V1::Shelf]
        #     The shelf in which the series is created.
        # @!attribute [rw] books
        #   @return [Array<Google::Example::Library::V1::Book>]
        #     The books to publish in the series.
        # @!attribute [rw] edition
        #   @return [Integer]
        #     The edition of the series
        # @!attribute [rw] review_copy
        #   @return [true, false]
        #     If the book is in a pre-publish state
        # @!attribute [rw] series_uuid
        #   @return [Google::Example::Library::V1::SeriesUuid]
        #     Uniquely identifies the series to the publishing house.
        class PublishSeriesRequest; end

        # @!attribute [rw] series_bytes
        #   @return [String]
        # @!attribute [rw] series_string
        #   @return [String]
        class SeriesUuid; end

        # Response message for LibraryService.PublishSeries.
        # @!attribute [rw] book_names
        #   @return [Array<String>]
        #     The names of the books in the series that were published
        class PublishSeriesResponse; end

        # Request message for LibraryService.GetBook.
        # @!attribute [rw] name
        #   @return [String]
        #     The name of the book to retrieve.
        class GetBookRequest; end

        # Request message for LibraryService.ListBooks.
        # @!attribute [rw] name
        #   @return [String]
        #     The name of the shelf whose books we'd like to list.
        # @!attribute [rw] page_size
        #   @return [Integer]
        #     Requested page size. Server may return fewer books than requested.
        #     If unspecified, server will pick an appropriate default.
        # @!attribute [rw] page_token
        #   @return [String]
        #     A token identifying a page of results the server should return.
        #     Typically, this is the value of
        #     {Google::Example::Library::V1::ListBooksResponse#next_page_token ListBooksResponse#next_page_token}.
        #     returned from the previous call to +ListBooks+ method.
        # @!attribute [rw] filter
        #   @return [String]
        #     To test python built-in wrapping.
        class ListBooksRequest; end

        # Response message for LibraryService.ListBooks.
        # @!attribute [rw] books
        #   @return [Array<Google::Example::Library::V1::Book>]
        #     The list of books.
        # @!attribute [rw] next_page_token
        #   @return [String]
        #     A token to retrieve next page of results.
        #     Pass this value in the
        #     {Google::Example::Library::V1::ListBooksRequest#page_token ListBooksRequest#page_token}
        #     field in the subsequent call to +ListBooks+ method to retrieve the next
        #     page of results.
        class ListBooksResponse; end

        # Request message for LibraryService.StreamBooks.
        # @!attribute [rw] name
        #   @return [String]
        #     The name of the shelf whose books we'd like to list.
        class StreamBooksRequest; end

        # Request message for LibraryService.UpdateBook.
        # @!attribute [rw] name
        #   @return [String]
        #     The name of the book to update.
        # @!attribute [rw] optional_foo
        #   @return [String]
        #     An optional foo.
        # @!attribute [rw] book
        #   @return [Google::Example::Library::V1::Book]
        #     The book to update with.
        # @!attribute [rw] update_mask
        #   @return [Google::Protobuf::FieldMask]
        #     A field mask to apply, rendered as an HTTP parameter.
        # @!attribute [rw] physical_mask
        #   @return [Google::Example::Library::V1::FieldMask]
        #     To test Python import clash resolution.
        class UpdateBookRequest; end

        # Request message for LibraryService.DeleteBook.
        # @!attribute [rw] name
        #   @return [String]
        #     The name of the book to delete.
        class DeleteBookRequest; end

        # Describes what book to move (name) and what shelf we're moving it
        # to (other_shelf_name).
        # @!attribute [rw] name
        #   @return [String]
        #     The name of the book to move.
        # @!attribute [rw] other_shelf_name
        #   @return [String]
        #     The name of the destination shelf.
        class MoveBookRequest; end

        # @!attribute [rw] name
        #   @return [String]
        # @!attribute [rw] page_size
        #   @return [Integer]
        # @!attribute [rw] page_token
        #   @return [String]
        class ListStringsRequest; end

        # @!attribute [rw] strings
        #   @return [Array<String>]
        # @!attribute [rw] next_page_token
        #   @return [String]
        class ListStringsResponse; end

        # @!attribute [rw] name
        #   @return [String]
        # @!attribute [rw] comments
        #   @return [Array<Google::Example::Library::V1::Comment>]
        class AddCommentsRequest; end

        # @!attribute [rw] user_name
        #   @return [String]
        #     won't be filled in by the sample generator
        # @!attribute [rw] comment
        #   @return [String]
        #     should be filled in by the sample generator
        # @!attribute [rw] stage
        #   @return [Google::Example::Library::V1::Comment::Stage]
        #     should be filled in by the sample generator
        # @!attribute [rw] alignment
        #   @return [Google::Example::Library::V1::SomeMessage2::SomeMessage3::Alignment]
        #     Tests Python nested enums
        class Comment
          module Stage
            UNSET = 0

            DRAFT = 1

            PUBLISHED = 2

            DELETED = 3
          end
        end

        # Request message for LibraryService.GetBookFromArchive.
        # @!attribute [rw] name
        #   @return [String]
        #     The name of the book to retrieve.
        class GetBookFromArchiveRequest; end

        # Request message for LibraryService.GetBookFromAnywhere.
        # @!attribute [rw] name
        #   @return [String]
        #     The name of the book to retrieve.
        # @!attribute [rw] alt_book_name
        #   @return [String]
        #     An alternate book name, used to test restricting flattened field to a
        #     single resource name type in a oneof.
        class GetBookFromAnywhereRequest; end

        # Request message for LibraryService.GetBookFromAbsolutelyAnywhere.
        # @!attribute [rw] name
        #   @return [String]
        #     The name of the book to retrieve.
        class GetBookFromAbsolutelyAnywhereRequest; end

        # Request message for LibraryService.UpdateBookIndex.
        # @!attribute [rw] name
        #   @return [String]
        #     The name of the book to update.
        # @!attribute [rw] index_name
        #   @return [String]
        #     The name of the index for the book
        # @!attribute [rw] index_map
        #   @return [Hash{String => String}]
        #     The index to update the book with
        class UpdateBookIndexRequest; end

        # @!attribute [rw] name
        #   @return [String]
        #     The name of the book to be discussed. If this is in the middle
        #     of the stream and this is not specified, the name in the previous
        #     message will be reused.
        # @!attribute [rw] comment
        #   @return [Google::Example::Library::V1::Comment]
        #     The new comment.
        class DiscussBookRequest; end

        # Test repeated field with resource name format in request
        # @!attribute [rw] names
        #   @return [Array<String>]
        # @!attribute [rw] shelves
        #   @return [Array<String>]
        # @!attribute [rw] page_size
        #   @return [Integer]
        # @!attribute [rw] page_token
        #   @return [String]
        class FindRelatedBooksRequest; end

        # Test repeated field with resource name format in page streaming response
        # @!attribute [rw] names
        #   @return [Array<String>]
        # @!attribute [rw] next_page_token
        #   @return [String]
        class FindRelatedBooksResponse; end

        # Metadata for a longrunning operation.
        # @!attribute [rw] progress_percent
        #   @return [Integer]
        #     Approximate percentage of the book processed thus far.
        class GetBigBookMetadata; end

        # @!attribute [rw] required_singular_int32
        #   @return [Integer]
        # @!attribute [rw] required_singular_int64
        #   @return [Integer]
        # @!attribute [rw] required_singular_float
        #   @return [Float]
        # @!attribute [rw] required_singular_double
        #   @return [Float]
        # @!attribute [rw] required_singular_bool
        #   @return [true, false]
        # @!attribute [rw] required_singular_enum
        #   @return [Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerEnum]
        # @!attribute [rw] required_singular_string
        #   @return [String]
        # @!attribute [rw] required_singular_bytes
        #   @return [String]
        # @!attribute [rw] required_singular_message
        #   @return [Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerMessage]
        # @!attribute [rw] required_singular_resource_name
        #   @return [String]
        # @!attribute [rw] required_singular_resource_name_oneof
        #   @return [String]
        # @!attribute [rw] required_singular_fixed32
        #   @return [Integer]
        # @!attribute [rw] required_singular_fixed64
        #   @return [Integer]
        # @!attribute [rw] required_repeated_int32
        #   @return [Array<Integer>]
        # @!attribute [rw] required_repeated_int64
        #   @return [Array<Integer>]
        # @!attribute [rw] required_repeated_float
        #   @return [Array<Float>]
        # @!attribute [rw] required_repeated_double
        #   @return [Array<Float>]
        # @!attribute [rw] required_repeated_bool
        #   @return [Array<true, false>]
        # @!attribute [rw] required_repeated_enum
        #   @return [Array<Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerEnum>]
        # @!attribute [rw] required_repeated_string
        #   @return [Array<String>]
        # @!attribute [rw] required_repeated_bytes
        #   @return [Array<String>]
        # @!attribute [rw] required_repeated_message
        #   @return [Array<Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerMessage>]
        # @!attribute [rw] required_repeated_resource_name
        #   @return [Array<String>]
        # @!attribute [rw] required_repeated_resource_name_oneof
        #   @return [Array<String>]
        # @!attribute [rw] required_repeated_fixed32
        #   @return [Array<Integer>]
        # @!attribute [rw] required_repeated_fixed64
        #   @return [Array<Integer>]
        # @!attribute [rw] required_map
        #   @return [Hash{Integer => String}]
        # @!attribute [rw] optional_singular_int32
        #   @return [Integer]
        # @!attribute [rw] optional_singular_int64
        #   @return [Integer]
        # @!attribute [rw] optional_singular_float
        #   @return [Float]
        # @!attribute [rw] optional_singular_double
        #   @return [Float]
        # @!attribute [rw] optional_singular_bool
        #   @return [true, false]
        # @!attribute [rw] optional_singular_enum
        #   @return [Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerEnum]
        # @!attribute [rw] optional_singular_string
        #   @return [String]
        # @!attribute [rw] optional_singular_bytes
        #   @return [String]
        # @!attribute [rw] optional_singular_message
        #   @return [Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerMessage]
        # @!attribute [rw] optional_singular_resource_name
        #   @return [String]
        # @!attribute [rw] optional_singular_resource_name_oneof
        #   @return [String]
        # @!attribute [rw] optional_singular_fixed32
        #   @return [Integer]
        # @!attribute [rw] optional_singular_fixed64
        #   @return [Integer]
        # @!attribute [rw] optional_repeated_int32
        #   @return [Array<Integer>]
        # @!attribute [rw] optional_repeated_int64
        #   @return [Array<Integer>]
        # @!attribute [rw] optional_repeated_float
        #   @return [Array<Float>]
        # @!attribute [rw] optional_repeated_double
        #   @return [Array<Float>]
        # @!attribute [rw] optional_repeated_bool
        #   @return [Array<true, false>]
        # @!attribute [rw] optional_repeated_enum
        #   @return [Array<Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerEnum>]
        # @!attribute [rw] optional_repeated_string
        #   @return [Array<String>]
        # @!attribute [rw] optional_repeated_bytes
        #   @return [Array<String>]
        # @!attribute [rw] optional_repeated_message
        #   @return [Array<Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerMessage>]
        # @!attribute [rw] optional_repeated_resource_name
        #   @return [Array<String>]
        # @!attribute [rw] optional_repeated_resource_name_oneof
        #   @return [Array<String>]
        # @!attribute [rw] optional_repeated_fixed32
        #   @return [Array<Integer>]
        # @!attribute [rw] optional_repeated_fixed64
        #   @return [Array<Integer>]
        # @!attribute [rw] optional_map
        #   @return [Hash{Integer => String}]
        class TestOptionalRequiredFlatteningParamsRequest
          class InnerMessage; end

          # For testing all types, plus resource-names, as required and optional.
          module InnerEnum
            ZERO = 0

            ONE = 1
          end
        end

        class TestOptionalRequiredFlatteningParamsResponse; end
      end
    end
  end
end
============== file: lib/library/v1/doc/overview.rb ==============
# Copyright 2017, Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# rubocop:disable LineLength

##
# # Ruby Client for Google Example Library API ([Alpha](https://github.com/GoogleCloudPlatform/google-cloud-ruby#versioning))
#
# [Google Example Library API][Product Documentation]:
# A simple Google Example Library API.
# - [Product Documentation][]
#
# ## Quick Start
# In order to use this library, you first need to go through the following
# steps:
#
# 1. [Select or create a Cloud Platform project.](https://console.cloud.google.com/project)
# 2. [Enable the Google Example Library API.](https://console.cloud.google.com/apis/api/library)
# 3. [Setup Authentication.](https://googlecloudplatform.github.io/google-cloud-ruby/#/docs/google-cloud/master/guides/authentication)
#
# ### Installation
# ```
# $ gem install library
# ```
#
# ### Preview
# #### LibraryServiceClient
# ```rb
# require "library"
#
# library_service_client = Library.new
# formatted_name = Library::V1::LibraryServiceClient.book_path("testShelf-" + Time.new.to_i.to_s, project_id)
# optional_foo = ''
# rating = :GOOD
# book = { rating: rating }
# update_mask = {}
# physical_mask = {}
# response = library_service_client.update_book(formatted_name, book, optional_foo: optional_foo, update_mask: update_mask, physical_mask: physical_mask)
# ```
#
# ### Next Steps
# - Read the [Google Example Library API Product documentation][Product Documentation]
#   to learn more about the product and see How-to Guides.
# - View this [repository's main README](https://github.com/GoogleCloudPlatform/google-cloud-ruby/blob/master/README.md)
#   to see the full list of Cloud APIs that we cover.
#
# [Product Documentation]: https://cloud.google.com/library
#
#
module Library
  module V1
  end
end
============== file: lib/library/v1/doc/shared_type.rb ==============
# Copyright 2017, Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

module Google
  module Test
    module Shared
      module Data
        # This message is used by the library service and does not reference
        # other_shared_type.proto.
        # @!attribute [rw] times_used
        #   @return [Integer]
        class Used; end

        # This message is not used by the library service but does reference
        # other_shared_type.proto.
        # @!attribute [rw] other
        #   @return [Google::Test::Shared::Data::OtherType]
        class Unused; end
      end
    end
  end
end
============== file: lib/library/v1/library_service_client.rb ==============
# Copyright 2017, Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# EDITING INSTRUCTIONS
# This file was generated from the file
# https://github.com/googleapis/googleapis/blob/master/library.proto,
# and updates to that file get reflected here through a refresh process.
# For the short term, the refresh process will only be runnable by Google
# engineers.
#
# The only allowed edits are to method and file documentation. A 3-way
# merge preserves those additions if the generated source changes.

require "json"
require "pathname"

require "google/gax"
require "google/gax/operation"
require "google/longrunning/operations_client"

require "library_pb"
require "tagger_pb"
require "library/credentials"

module Library
  module V1
    # This API represents a simple digital library.  It lets you manage Shelf
    # resources and Book resources in the library. It defines the following
    # resource model:
    #
    # * The API has a collection of {Google::Example::Library::V1::Shelf Shelf}
    #   resources, named +bookShelves/*+
    #
    # * Each Shelf has a collection of {Google::Example::Library::V1::Book Book}
    #   resources, named +bookShelves/*/books/*+
    #
    # Check out [cloud docs!](https://cloud.google.com/library/example/link).
    # This is [not a cloud link](http://www.google.com).
    #
    # Service comment may include special characters: <>&"+'@.
    #
    # @!attribute [r] library_service_stub
    #   @return [Google::Example::Library::V1::LibraryService::Stub]
    # @!attribute [r] labeler_stub
    #   @return [Google::Tagger::V1::Labeler::Stub]
    class LibraryServiceClient
      attr_reader :library_service_stub, :labeler_stub

      # The default address of the service.
      SERVICE_ADDRESS = "library-example.googleapis.com".freeze

      # The default port of the service.
      DEFAULT_SERVICE_PORT = 443

      DEFAULT_TIMEOUT = 30

      PAGE_DESCRIPTORS = {
        "list_shelves" => Google::Gax::PageDescriptor.new(
          "page_token",
          "next_page_token",
          "shelves"),
        "list_books" => Google::Gax::PageDescriptor.new(
          "page_token",
          "next_page_token",
          "books"),
        "list_strings" => Google::Gax::PageDescriptor.new(
          "page_token",
          "next_page_token",
          "strings"),
        "find_related_books" => Google::Gax::PageDescriptor.new(
          "page_token",
          "next_page_token",
          "names")
      }.freeze

      private_constant :PAGE_DESCRIPTORS

      BUNDLE_DESCRIPTORS = {
        "publish_series" => Google::Gax::BundleDescriptor.new(
          "books",
          [
            "edition",
            "shelf.name"
          ],
          subresponse_field: "book_names"),
        "add_comments" => Google::Gax::BundleDescriptor.new(
          "comments",
          [
            "name"
          ])
      }.freeze

      private_constant :BUNDLE_DESCRIPTORS

      # The scopes needed to make gRPC calls to all of the methods defined in
      # this service.
      ALL_SCOPES = [
        "https://www.googleapis.com/auth/cloud-platform",
        "https://www.googleapis.com/auth/library"
      ].freeze

      SHELF_PATH_TEMPLATE = Google::Gax::PathTemplate.new(
        "shelves/{shelf_id}"
      )

      private_constant :SHELF_PATH_TEMPLATE

      BOOK_PATH_TEMPLATE = Google::Gax::PathTemplate.new(
        "shelves/{shelf_id}/books/{book_id}"
      )

      private_constant :BOOK_PATH_TEMPLATE

      RETURN_PATH_TEMPLATE = Google::Gax::PathTemplate.new(
        "shelves/{shelf}/books/{book}/returns/{return}"
      )

      private_constant :RETURN_PATH_TEMPLATE

      # Returns a fully-qualified shelf resource name string.
      # @param shelf_id [String]
      # @return [String]
      def self.shelf_path shelf_id
        SHELF_PATH_TEMPLATE.render(
          :"shelf_id" => shelf_id
        )
      end

      # Returns a fully-qualified book resource name string.
      # @param shelf_id [String]
      # @param book_id [String]
      # @return [String]
      def self.book_path shelf_id, book_id
        BOOK_PATH_TEMPLATE.render(
          :"shelf_id" => shelf_id,
          :"book_id" => book_id
        )
      end

      # Returns a fully-qualified return resource name string.
      # @param shelf [String]
      # @param book [String]
      # @param return_ [String]
      # @return [String]
      def self.return_path shelf, book, return_
        RETURN_PATH_TEMPLATE.render(
          :"shelf" => shelf,
          :"book" => book,
          :"return" => return_
        )
      end

      # @param credentials [Google::Auth::Credentials, String, Hash, GRPC::Core::Channel, GRPC::Core::ChannelCredentials, Proc]
      #   Provides the means for authenticating requests made by the client. This parameter can
      #   be many types.
      #   A `Google::Auth::Credentials` uses a the properties of its represented keyfile for
      #   authenticating requests made by this client.
      #   A `String` will be treated as the path to the keyfile to be used for the construction of
      #   credentials for this client.
      #   A `Hash` will be treated as the contents of a keyfile to be used for the construction of
      #   credentials for this client.
      #   A `GRPC::Core::Channel` will be used to make calls through.
      #   A `GRPC::Core::ChannelCredentials` for the setting up the RPC client. The channel credentials
      #   should already be composed with a `GRPC::Core::CallCredentials` object.
      #   A `Proc` will be used as an updater_proc for the Grpc channel. The proc transforms the
      #   metadata for requests, generally, to give OAuth credentials.
      # @param scopes [Array<String>]
      #   The OAuth scopes for this service. This parameter is ignored if
      #   an updater_proc is supplied.
      # @param client_config [Hash]
      #   A Hash for call options for each method. See
      #   Google::Gax#construct_settings for the structure of
      #   this data. Falls back to the default config if not specified
      #   or the specified config is missing data points.
      # @param timeout [Numeric]
      #   The default timeout, in seconds, for calls made through this client.
      def initialize \
          service_path: SERVICE_ADDRESS,
          port: DEFAULT_SERVICE_PORT,
          channel: nil,
          chan_creds: nil,
          updater_proc: nil,
          credentials: nil,
          scopes: ALL_SCOPES,
          client_config: {},
          timeout: DEFAULT_TIMEOUT,
          lib_name: nil,
          lib_version: ""
        # These require statements are intentionally placed here to initialize
        # the gRPC module only when it's required.
        # See https://github.com/googleapis/toolkit/issues/446
        require "google/gax/grpc"
        require "library_services_pb"
        require "tagger_services_pb"

        if channel || chan_creds || updater_proc
          warn "The `channel`, `chan_creds`, and `updater_proc` parameters will be removed " \
            "on 2017/09/08"
          credentials ||= channel
          credentials ||= chan_creds
          credentials ||= updater_proc
        end
        if service_path != SERVICE_ADDRESS || port != DEFAULT_SERVICE_PORT
          warn "`service_path` and `port` parameters are deprecated and will be removed"
        end

        credentials ||= Library::Credentials.default

        @operations_client = Google::Longrunning::OperationsClient.new(
          service_path: service_path,
          credentials: credentials,
          scopes: scopes,
          client_config: client_config,
          timeout: timeout,
          lib_name: lib_name,
          lib_version: lib_version,
        )

        if credentials.is_a?(String) || credentials.is_a?(Hash)
          updater_proc = Library::Credentials.new(credentials).updater_proc
        end
        if credentials.is_a?(GRPC::Core::Channel)
          channel = credentials
        end
        if credentials.is_a?(GRPC::Core::ChannelCredentials)
          chan_creds = credentials
        end
        if credentials.is_a?(Proc)
          updater_proc = credentials
        end
        if credentials.is_a?(Google::Auth::Credentials)
          updater_proc = credentials.updater_proc
        end

        google_api_client = "gl-ruby/#{RUBY_VERSION}"
        google_api_client << " #{lib_name}/#{lib_version}" if lib_name
        google_api_client << " gapic/0.6.8 gax/#{Google::Gax::VERSION}"
        google_api_client << " grpc/#{GRPC::VERSION}"
        google_api_client.freeze

        headers = { :"x-goog-api-client" => google_api_client }
        client_config_file = Pathname.new(__dir__).join(
          "library_service_client_config.json"
        )
        defaults = client_config_file.open do |f|
          Google::Gax.construct_settings(
            "google.example.library.v1.LibraryService",
            JSON.parse(f.read),
            client_config,
            Google::Gax::Grpc::STATUS_CODE_NAMES,
            timeout,
            bundle_descriptors: BUNDLE_DESCRIPTORS,
            page_descriptors: PAGE_DESCRIPTORS,
            errors: Google::Gax::Grpc::API_ERRORS,
            kwargs: headers
          )
        end
        @library_service_stub = Google::Gax::Grpc.create_stub(
          service_path,
          port,
          chan_creds: chan_creds,
          channel: channel,
          updater_proc: updater_proc,
          scopes: scopes,
          &Google::Example::Library::V1::LibraryService::Stub.method(:new)
        )
        @labeler_stub = Google::Gax::Grpc.create_stub(
          service_path,
          port,
          chan_creds: chan_creds,
          channel: channel,
          updater_proc: updater_proc,
          scopes: scopes,
          &Google::Tagger::V1::Labeler::Stub.method(:new)
        )

        @create_shelf = Google::Gax.create_api_call(
          @library_service_stub.method(:create_shelf),
          defaults["create_shelf"]
        )
        @get_shelf = Google::Gax.create_api_call(
          @library_service_stub.method(:get_shelf),
          defaults["get_shelf"]
        )
        @list_shelves = Google::Gax.create_api_call(
          @library_service_stub.method(:list_shelves),
          defaults["list_shelves"]
        )
        @delete_shelf = Google::Gax.create_api_call(
          @library_service_stub.method(:delete_shelf),
          defaults["delete_shelf"]
        )
        @merge_shelves = Google::Gax.create_api_call(
          @library_service_stub.method(:merge_shelves),
          defaults["merge_shelves"]
        )
        @create_book = Google::Gax.create_api_call(
          @library_service_stub.method(:create_book),
          defaults["create_book"]
        )
        @publish_series = Google::Gax.create_api_call(
          @library_service_stub.method(:publish_series),
          defaults["publish_series"]
        )
        @get_book = Google::Gax.create_api_call(
          @library_service_stub.method(:get_book),
          defaults["get_book"]
        )
        @list_books = Google::Gax.create_api_call(
          @library_service_stub.method(:list_books),
          defaults["list_books"]
        )
        @delete_book = Google::Gax.create_api_call(
          @library_service_stub.method(:delete_book),
          defaults["delete_book"]
        )
        @update_book = Google::Gax.create_api_call(
          @library_service_stub.method(:update_book),
          defaults["update_book"]
        )
        @move_book = Google::Gax.create_api_call(
          @library_service_stub.method(:move_book),
          defaults["move_book"]
        )
        @list_strings = Google::Gax.create_api_call(
          @library_service_stub.method(:list_strings),
          defaults["list_strings"]
        )
        @add_comments = Google::Gax.create_api_call(
          @library_service_stub.method(:add_comments),
          defaults["add_comments"]
        )
        @get_book_from_archive = Google::Gax.create_api_call(
          @library_service_stub.method(:get_book_from_archive),
          defaults["get_book_from_archive"]
        )
        @get_book_from_anywhere = Google::Gax.create_api_call(
          @library_service_stub.method(:get_book_from_anywhere),
          defaults["get_book_from_anywhere"]
        )
        @get_book_from_absolutely_anywhere = Google::Gax.create_api_call(
          @library_service_stub.method(:get_book_from_absolutely_anywhere),
          defaults["get_book_from_absolutely_anywhere"]
        )
        @update_book_index = Google::Gax.create_api_call(
          @library_service_stub.method(:update_book_index),
          defaults["update_book_index"]
        )
        @stream_shelves = Google::Gax.create_api_call(
          @library_service_stub.method(:stream_shelves),
          defaults["stream_shelves"]
        )
        @stream_books = Google::Gax.create_api_call(
          @library_service_stub.method(:stream_books),
          defaults["stream_books"]
        )
        @discuss_book = Google::Gax.create_api_call(
          @library_service_stub.method(:discuss_book),
          defaults["discuss_book"]
        )
        @monolog_about_book = Google::Gax.create_api_call(
          @library_service_stub.method(:monolog_about_book),
          defaults["monolog_about_book"]
        )
        @find_related_books = Google::Gax.create_api_call(
          @library_service_stub.method(:find_related_books),
          defaults["find_related_books"]
        )
        @add_tag = Google::Gax.create_api_call(
          @library_service_stub.method(:add_tag),
          defaults["add_tag"]
        )
        @get_big_book = Google::Gax.create_api_call(
          @library_service_stub.method(:get_big_book),
          defaults["get_big_book"]
        )
        @get_big_nothing = Google::Gax.create_api_call(
          @library_service_stub.method(:get_big_nothing),
          defaults["get_big_nothing"]
        )
        @test_optional_required_flattening_params = Google::Gax.create_api_call(
          @library_service_stub.method(:test_optional_required_flattening_params),
          defaults["test_optional_required_flattening_params"]
        )
        @add_label = Google::Gax.create_api_call(
          @labeler_stub.method(:add_label),
          defaults["add_label"]
        )
      end

      # Service calls

      # Creates a shelf, and returns the new Shelf.
      # RPC method comment may include special characters: <>&"+'@.
      #
      # @param shelf [Google::Example::Library::V1::Shelf | Hash]
      #   The shelf to create.
      #   A hash of the same form as `Google::Example::Library::V1::Shelf`
      #   can also be provided.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Example::Library::V1::Shelf]
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   shelf = {}
      #   response = library_service_client.create_shelf(shelf)

      def create_shelf \
          shelf,
          options: nil
        req = {
          shelf: shelf
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::CreateShelfRequest)
        @create_shelf.call(req, options)
      end

      # Gets a shelf.
      #
      # @param name [String]
      #   The name of the shelf to retrieve.
      # @param options_ [String]
      #   To test 'options' parameter name conflict.
      # @param message [Google::Example::Library::V1::SomeMessage | Hash]
      #   Field to verify that message-type query parameter gets flattened.
      #   A hash of the same form as `Google::Example::Library::V1::SomeMessage`
      #   can also be provided.
      # @param string_builder [Google::Example::Library::V1::StringBuilder | Hash]
      #   A hash of the same form as `Google::Example::Library::V1::StringBuilder`
      #   can also be provided.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Example::Library::V1::Shelf]
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   formatted_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")
      #   options_ = ''
      #   response = library_service_client.get_shelf(formatted_name, options_)

      def get_shelf \
          name,
          options_,
          message: nil,
          string_builder: nil,
          options: nil
        req = {
          name: name,
          options: options_,
          message: message,
          string_builder: string_builder
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::GetShelfRequest)
        @get_shelf.call(req, options)
      end

      # Lists shelves.
      #
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Gax::PagedEnumerable<Google::Example::Library::V1::Shelf>]
      #   An enumerable of Google::Example::Library::V1::Shelf instances.
      #   See Google::Gax::PagedEnumerable documentation for other
      #   operations such as per-page iteration or access to the response
      #   object.
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #
      #   # Iterate over all results.
      #   library_service_client.list_shelves.each do |element|
      #     # Process element.
      #   end
      #
      #   # Or iterate over results one page at a time.
      #   library_service_client.list_shelves.each_page do |page|
      #     # Process each page at a time.
      #     page.each do |element|
      #       # Process element.
      #     end
      #   end

      def list_shelves options: nil
        req = Google::Example::Library::V1::ListShelvesRequest.new
        @list_shelves.call(req, options)
      end

      # Deletes a shelf.
      #
      # @param name [String]
      #   The name of the shelf to delete.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   formatted_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")
      #   library_service_client.delete_shelf(formatted_name)

      def delete_shelf \
          name,
          options: nil
        req = {
          name: name
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::DeleteShelfRequest)
        @delete_shelf.call(req, options)
        nil
      end

      # Merges two shelves by adding all books from the shelf named
      # +other_shelf_name+ to shelf +name+, and deletes
      # +other_shelf_name+. Returns the updated shelf.
      #
      # @param name [String]
      #   The name of the shelf we're adding books to.
      # @param other_shelf_name [String]
      #   The name of the shelf we're removing books from and deleting.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Example::Library::V1::Shelf]
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   formatted_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")
      #   formatted_other_shelf_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")
      #   response = library_service_client.merge_shelves(formatted_name, formatted_other_shelf_name)

      def merge_shelves \
          name,
          other_shelf_name,
          options: nil
        req = {
          name: name,
          other_shelf_name: other_shelf_name
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::MergeShelvesRequest)
        @merge_shelves.call(req, options)
      end

      # Creates a book.
      #
      # @param name [String]
      #   The name of the shelf in which the book is created.
      # @param book [Google::Example::Library::V1::Book | Hash]
      #   The book to create.
      #   A hash of the same form as `Google::Example::Library::V1::Book`
      #   can also be provided.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Example::Library::V1::Book]
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   formatted_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")
      #   book = {}
      #   response = library_service_client.create_book(formatted_name, book)

      def create_book \
          name,
          book,
          options: nil
        req = {
          name: name,
          book: book
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::CreateBookRequest)
        @create_book.call(req, options)
      end

      # Creates a series of books.
      #
      # @param shelf [Google::Example::Library::V1::Shelf | Hash]
      #   The shelf in which the series is created.
      #   A hash of the same form as `Google::Example::Library::V1::Shelf`
      #   can also be provided.
      # @param books [Array<Google::Example::Library::V1::Book | Hash>]
      #   The books to publish in the series.
      #   A hash of the same form as `Google::Example::Library::V1::Book`
      #   can also be provided.
      # @param series_uuid [Google::Example::Library::V1::SeriesUuid | Hash]
      #   Uniquely identifies the series to the publishing house.
      #   A hash of the same form as `Google::Example::Library::V1::SeriesUuid`
      #   can also be provided.
      # @param edition [Integer]
      #   The edition of the series
      # @param review_copy [true, false]
      #   If the book is in a pre-publish state
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Example::Library::V1::PublishSeriesResponse]
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   shelf = {}
      #   books = []
      #   series_string = "foobar"
      #   series_uuid = { series_string: series_string }
      #   response = library_service_client.publish_series(shelf, books, series_uuid)

      def publish_series \
          shelf,
          books,
          series_uuid,
          edition: nil,
          review_copy: nil,
          options: nil
        req = {
          shelf: shelf,
          books: books,
          series_uuid: series_uuid,
          edition: edition,
          review_copy: review_copy
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::PublishSeriesRequest)
        @publish_series.call(req, options)
      end

      # Gets a book.
      #
      # @param name [String]
      #   The name of the book to retrieve.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Example::Library::V1::Book]
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      #   response = library_service_client.get_book(formatted_name)

      def get_book \
          name,
          options: nil
        req = {
          name: name
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::GetBookRequest)
        @get_book.call(req, options)
      end

      # Lists books in a shelf.
      #
      # @param name [String]
      #   The name of the shelf whose books we'd like to list.
      # @param page_size [Integer]
      #   The maximum number of resources contained in the underlying API
      #   response. If page streaming is performed per-resource, this
      #   parameter does not affect the return value. If page streaming is
      #   performed per-page, this determines the maximum number of
      #   resources in a page.
      # @param filter [String]
      #   To test python built-in wrapping.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Gax::PagedEnumerable<Google::Example::Library::V1::Book>]
      #   An enumerable of Google::Example::Library::V1::Book instances.
      #   See Google::Gax::PagedEnumerable documentation for other
      #   operations such as per-page iteration or access to the response
      #   object.
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   formatted_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")
      #
      #   # Iterate over all results.
      #   library_service_client.list_books(formatted_name).each do |element|
      #     # Process element.
      #   end
      #
      #   # Or iterate over results one page at a time.
      #   library_service_client.list_books(formatted_name).each_page do |page|
      #     # Process each page at a time.
      #     page.each do |element|
      #       # Process element.
      #     end
      #   end

      def list_books \
          name,
          page_size: nil,
          filter: nil,
          options: nil
        req = {
          name: name,
          page_size: page_size,
          filter: filter
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::ListBooksRequest)
        @list_books.call(req, options)
      end

      # Deletes a book.
      #
      # @param name [String]
      #   The name of the book to delete.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      #   library_service_client.delete_book(formatted_name)

      def delete_book \
          name,
          options: nil
        req = {
          name: name
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::DeleteBookRequest)
        @delete_book.call(req, options)
        nil
      end

      # Updates a book.
      #
      # @param name [String]
      #   The name of the book to update.
      # @param book [Google::Example::Library::V1::Book | Hash]
      #   The book to update with.
      #   A hash of the same form as `Google::Example::Library::V1::Book`
      #   can also be provided.
      # @param optional_foo [String]
      #   An optional foo.
      # @param update_mask [Google::Protobuf::FieldMask | Hash]
      #   A field mask to apply, rendered as an HTTP parameter.
      #   A hash of the same form as `Google::Protobuf::FieldMask`
      #   can also be provided.
      # @param physical_mask [Google::Example::Library::V1::FieldMask | Hash]
      #   To test Python import clash resolution.
      #   A hash of the same form as `Google::Example::Library::V1::FieldMask`
      #   can also be provided.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Example::Library::V1::Book]
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      #   book = {}
      #   response = library_service_client.update_book(formatted_name, book)

      def update_book \
          name,
          book,
          optional_foo: nil,
          update_mask: nil,
          physical_mask: nil,
          options: nil
        req = {
          name: name,
          book: book,
          optional_foo: optional_foo,
          update_mask: update_mask,
          physical_mask: physical_mask
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::UpdateBookRequest)
        @update_book.call(req, options)
      end

      # Moves a book to another shelf, and returns the new book.
      #
      # @param name [String]
      #   The name of the book to move.
      # @param other_shelf_name [String]
      #   The name of the destination shelf.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Example::Library::V1::Book]
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      #   formatted_other_shelf_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")
      #   response = library_service_client.move_book(formatted_name, formatted_other_shelf_name)

      def move_book \
          name,
          other_shelf_name,
          options: nil
        req = {
          name: name,
          other_shelf_name: other_shelf_name
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::MoveBookRequest)
        @move_book.call(req, options)
      end

      # Lists a primitive resource. To test go page streaming.
      #
      # @param name [String]
      # @param page_size [Integer]
      #   The maximum number of resources contained in the underlying API
      #   response. If page streaming is performed per-resource, this
      #   parameter does not affect the return value. If page streaming is
      #   performed per-page, this determines the maximum number of
      #   resources in a page.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Gax::PagedEnumerable<String>]
      #   An enumerable of String instances.
      #   See Google::Gax::PagedEnumerable documentation for other
      #   operations such as per-page iteration or access to the response
      #   object.
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #
      #   # Iterate over all results.
      #   library_service_client.list_strings.each do |element|
      #     # Process element.
      #   end
      #
      #   # Or iterate over results one page at a time.
      #   library_service_client.list_strings.each_page do |page|
      #     # Process each page at a time.
      #     page.each do |element|
      #       # Process element.
      #     end
      #   end

      def list_strings \
          name: nil,
          page_size: nil,
          options: nil
        req = {
          name: name,
          page_size: page_size
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::ListStringsRequest)
        @list_strings.call(req, options)
      end

      # Adds comments to a book
      #
      # @param name [String]
      # @param comments [Array<Google::Example::Library::V1::Comment | Hash>]
      #   A hash of the same form as `Google::Example::Library::V1::Comment`
      #   can also be provided.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      #   comment = ''
      #   stage = :UNSET
      #   alignment = :CHAR
      #   comments_element = {
      #     comment: comment,
      #     stage: stage,
      #     alignment: alignment
      #   }
      #   comments = [comments_element]
      #   library_service_client.add_comments(formatted_name, comments)

      def add_comments \
          name,
          comments,
          options: nil
        req = {
          name: name,
          comments: comments
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::AddCommentsRequest)
        @add_comments.call(req, options)
        nil
      end

      # Gets a book from an archive.
      #
      # @param name [String]
      #   The name of the book to retrieve.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Example::Library::V1::BookFromArchive]
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   formatted_name = Library::V1::LibraryServiceClient.archived_book_path("[ARCHIVE_PATH]", "[BOOK_ID]")
      #   response = library_service_client.get_book_from_archive(formatted_name)

      def get_book_from_archive \
          name,
          options: nil
        req = {
          name: name
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::GetBookFromArchiveRequest)
        @get_book_from_archive.call(req, options)
      end

      # Gets a book from a shelf or archive.
      #
      # @param name [String]
      #   The name of the book to retrieve.
      # @param alt_book_name [String]
      #   An alternate book name, used to test restricting flattened field to a
      #   single resource name type in a oneof.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Example::Library::V1::BookFromAnywhere]
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      #   formatted_alt_book_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      #   response = library_service_client.get_book_from_anywhere(formatted_name, formatted_alt_book_name)

      def get_book_from_anywhere \
          name,
          alt_book_name,
          options: nil
        req = {
          name: name,
          alt_book_name: alt_book_name
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::GetBookFromAnywhereRequest)
        @get_book_from_anywhere.call(req, options)
      end

      # Test proper OneOf-Any resource name mapping
      #
      # @param name [String]
      #   The name of the book to retrieve.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Example::Library::V1::BookFromAnywhere]
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      #   response = library_service_client.get_book_from_absolutely_anywhere(formatted_name)

      def get_book_from_absolutely_anywhere \
          name,
          options: nil
        req = {
          name: name
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::GetBookFromAbsolutelyAnywhereRequest)
        @get_book_from_absolutely_anywhere.call(req, options)
      end

      # Updates the index of a book.
      #
      # @param name [String]
      #   The name of the book to update.
      # @param index_name [String]
      #   The name of the index for the book
      # @param index_map [Hash{String => String}]
      #   The index to update the book with
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      #   index_name = "default index"
      #   index_map_item = ''
      #   index_map = { "default_key" => index_map_item }
      #   library_service_client.update_book_index(formatted_name, index_name, index_map)

      def update_book_index \
          name,
          index_name,
          index_map,
          options: nil
        req = {
          name: name,
          index_name: index_name,
          index_map: index_map
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::UpdateBookIndexRequest)
        @update_book_index.call(req, options)
        nil
      end

      # Test server streaming
      # gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
      #
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Enumerable<Google::Example::Library::V1::StreamShelvesResponse>]
      #   An enumerable of Google::Example::Library::V1::StreamShelvesResponse instances.
      #
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   library_service_client.stream_shelves.each do |element|
      #     # Process element.
      #   end

      def stream_shelves options: nil
        req = Google::Example::Library::V1::StreamShelvesRequest.new
        @stream_shelves.call(req, options)
      end

      # Test server streaming, non-paged responses.
      # gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
      #
      # @param name [String]
      #   The name of the shelf whose books we'd like to list.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Enumerable<Google::Example::Library::V1::Book>]
      #   An enumerable of Google::Example::Library::V1::Book instances.
      #
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   name = ''
      #   library_service_client.stream_books(name).each do |element|
      #     # Process element.
      #   end

      def stream_books \
          name,
          options: nil
        req = {
          name: name
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::StreamBooksRequest)
        @stream_books.call(req, options)
      end

      # Test bidi-streaming.
      # gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
      #
      # @param reqs [Enumerable<Google::Example::Library::V1::DiscussBookRequest>]
      #   The input requests.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Enumerable<Google::Example::Library::V1::Comment>]
      #   An enumerable of Google::Example::Library::V1::Comment instances.
      #
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      #
      # @note
      #   EXPERIMENTAL:
      #     Streaming requests are still undergoing review.
      #     This method interface might change in the future.
      #
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   name = ''
      #   request = { name: name }
      #   requests = [request]
      #   library_service_client.discuss_book(requests).each do |element|
      #     # Process element.
      #   end

      def discuss_book reqs, options: nil
        request_protos = reqs.lazy.map do |req|
          Google::Gax::to_proto(req, Google::Example::Library::V1::DiscussBookRequest)
        end
        @discuss_book.call(request_protos, options)
      end

      # Test client streaming.
      # gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
      #
      # @param reqs [Enumerable<Google::Example::Library::V1::DiscussBookRequest>]
      #   The input requests.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Example::Library::V1::Comment]
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      #
      # @note
      #   EXPERIMENTAL:
      #     Streaming requests are still undergoing review.
      #     This method interface might change in the future.
      #
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   name = ''
      #   request = { name: name }
      #   requests = [request]
      #   response = library_service_client.monolog_about_book(requests)

      def monolog_about_book reqs, options: nil
        request_protos = reqs.lazy.map do |req|
          Google::Gax::to_proto(req, Google::Example::Library::V1::DiscussBookRequest)
        end
        @monolog_about_book.call(request_protos, options)
      end

      # @param names [Array<String>]
      # @param shelves [Array<String>]
      # @param page_size [Integer]
      #   The maximum number of resources contained in the underlying API
      #   response. If page streaming is performed per-resource, this
      #   parameter does not affect the return value. If page streaming is
      #   performed per-page, this determines the maximum number of
      #   resources in a page.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Gax::PagedEnumerable<String>]
      #   An enumerable of String instances.
      #   See Google::Gax::PagedEnumerable documentation for other
      #   operations such as per-page iteration or access to the response
      #   object.
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   names_element = ''
      #   names = [names_element]
      #   shelves = []
      #
      #   # Iterate over all results.
      #   library_service_client.find_related_books(names, shelves).each do |element|
      #     # Process element.
      #   end
      #
      #   # Or iterate over results one page at a time.
      #   library_service_client.find_related_books(names, shelves).each_page do |page|
      #     # Process each page at a time.
      #     page.each do |element|
      #       # Process element.
      #     end
      #   end

      def find_related_books \
          names,
          shelves,
          page_size: nil,
          options: nil
        req = {
          names: names,
          shelves: shelves,
          page_size: page_size
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::FindRelatedBooksRequest)
        @find_related_books.call(req, options)
      end

      # Adds a tag to the book. This RPC is a mixin.
      #
      # @param resource [String]
      #   REQUIRED: The resource which the tag is being added to.
      #   Resource is usually specified as a path, such as,
      #   projects/{project}/zones/{zone}/disks/{disk}.
      # @param tag [String]
      #   REQUIRED: The tag to add.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Tagger::V1::AddTagResponse]
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   formatted_resource = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      #   tag = ''
      #   response = library_service_client.add_tag(formatted_resource, tag)

      def add_tag \
          resource,
          tag,
          options: nil
        req = {
          resource: resource,
          tag: tag
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Tagger::V1::AddTagRequest)
        @add_tag.call(req, options)
      end

      # Adds a label to the entity.
      #
      # @param resource [String]
      #   REQUIRED: The resource which the label is being added to.
      #   Resource is usually specified as a path, such as,
      #   projects/{project}/zones/{zone}/disks/{disk}.
      # @param label [String]
      #   REQUIRED: The label to add.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Tagger::V1::AddLabelResponse]
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   formatted_resource = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      #   label = ''
      #   response = library_service_client.add_label(formatted_resource, label)

      def add_label \
          resource,
          label,
          options: nil
        req = {
          resource: resource,
          label: label
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Tagger::V1::AddLabelRequest)
        @add_label.call(req, options)
      end

      # Test long-running operations
      #
      # @param name [String]
      #   The name of the book to retrieve.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Gax::Operation]
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      #
      #   # Register a callback during the method call.
      #   operation = library_service_client.get_big_book(formatted_name) do |op|
      #     raise op.results.message if op.error?
      #     op_results = op.results
      #     # Process the results.
      #
      #     metadata = op.metadata
      #     # Process the metadata.
      #   end
      #
      #   # Or use the return value to register a callback.
      #   operation.on_done do |op|
      #     raise op.results.message if op.error?
      #     op_results = op.results
      #     # Process the results.
      #
      #     metadata = op.metadata
      #     # Process the metadata.
      #   end
      #
      #   # Manually reload the operation.
      #   operation.reload!
      #
      #   # Or block until the operation completes, triggering callbacks on
      #   # completion.
      #   operation.wait_until_done!

      def get_big_book \
          name,
          options: nil
        req = {
          name: name
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::GetBookRequest)
        operation = Google::Gax::Operation.new(
          @get_big_book.call(req, options),
          @operations_client,
          Google::Example::Library::V1::Book,
          Google::Example::Library::V1::GetBigBookMetadata,
          call_options: options
        )
        operation.on_done { |operation| yield(operation) } if block_given?
        operation
      end

      # Test long-running operations with empty return type.
      #
      # @param name [String]
      #   The name of the book to retrieve.
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Gax::Operation]
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      #
      #   # Register a callback during the method call.
      #   operation = library_service_client.get_big_nothing(formatted_name) do |op|
      #     raise op.results.message if op.error?
      #     op_results = op.results
      #     # Process the results.
      #
      #     metadata = op.metadata
      #     # Process the metadata.
      #   end
      #
      #   # Or use the return value to register a callback.
      #   operation.on_done do |op|
      #     raise op.results.message if op.error?
      #     op_results = op.results
      #     # Process the results.
      #
      #     metadata = op.metadata
      #     # Process the metadata.
      #   end
      #
      #   # Manually reload the operation.
      #   operation.reload!
      #
      #   # Or block until the operation completes, triggering callbacks on
      #   # completion.
      #   operation.wait_until_done!

      def get_big_nothing \
          name,
          options: nil
        req = {
          name: name
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::GetBookRequest)
        operation = Google::Gax::Operation.new(
          @get_big_nothing.call(req, options),
          @operations_client,
          Google::Protobuf::Empty,
          Google::Example::Library::V1::GetBigBookMetadata,
          call_options: options
        )
        operation.on_done { |operation| yield(operation) } if block_given?
        operation
      end

      # Test optional flattening parameters of all types
      #
      # @param required_singular_int32 [Integer]
      # @param required_singular_int64 [Integer]
      # @param required_singular_float [Float]
      # @param required_singular_double [Float]
      # @param required_singular_bool [true, false]
      # @param required_singular_enum [Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerEnum]
      # @param required_singular_string [String]
      # @param required_singular_bytes [String]
      # @param required_singular_message [Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerMessage | Hash]
      #   A hash of the same form as `Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerMessage`
      #   can also be provided.
      # @param required_singular_resource_name [String]
      # @param required_singular_resource_name_oneof [String]
      # @param required_singular_fixed32 [Integer]
      # @param required_singular_fixed64 [Integer]
      # @param required_repeated_int32 [Array<Integer>]
      # @param required_repeated_int64 [Array<Integer>]
      # @param required_repeated_float [Array<Float>]
      # @param required_repeated_double [Array<Float>]
      # @param required_repeated_bool [Array<true, false>]
      # @param required_repeated_enum [Array<Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerEnum>]
      # @param required_repeated_string [Array<String>]
      # @param required_repeated_bytes [Array<String>]
      # @param required_repeated_message [Array<Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerMessage | Hash>]
      #   A hash of the same form as `Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerMessage`
      #   can also be provided.
      # @param required_repeated_resource_name [Array<String>]
      # @param required_repeated_resource_name_oneof [Array<String>]
      # @param required_repeated_fixed32 [Array<Integer>]
      # @param required_repeated_fixed64 [Array<Integer>]
      # @param required_map [Hash{Integer => String}]
      # @param optional_singular_int32 [Integer]
      # @param optional_singular_int64 [Integer]
      # @param optional_singular_float [Float]
      # @param optional_singular_double [Float]
      # @param optional_singular_bool [true, false]
      # @param optional_singular_enum [Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerEnum]
      # @param optional_singular_string [String]
      # @param optional_singular_bytes [String]
      # @param optional_singular_message [Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerMessage | Hash]
      #   A hash of the same form as `Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerMessage`
      #   can also be provided.
      # @param optional_singular_resource_name [String]
      # @param optional_singular_resource_name_oneof [String]
      # @param optional_singular_fixed32 [Integer]
      # @param optional_singular_fixed64 [Integer]
      # @param optional_repeated_int32 [Array<Integer>]
      # @param optional_repeated_int64 [Array<Integer>]
      # @param optional_repeated_float [Array<Float>]
      # @param optional_repeated_double [Array<Float>]
      # @param optional_repeated_bool [Array<true, false>]
      # @param optional_repeated_enum [Array<Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerEnum>]
      # @param optional_repeated_string [Array<String>]
      # @param optional_repeated_bytes [Array<String>]
      # @param optional_repeated_message [Array<Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerMessage | Hash>]
      #   A hash of the same form as `Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerMessage`
      #   can also be provided.
      # @param optional_repeated_resource_name [Array<String>]
      # @param optional_repeated_resource_name_oneof [Array<String>]
      # @param optional_repeated_fixed32 [Array<Integer>]
      # @param optional_repeated_fixed64 [Array<Integer>]
      # @param optional_map [Hash{Integer => String}]
      # @param options [Google::Gax::CallOptions]
      #   Overrides the default settings for this call, e.g, timeout,
      #   retries, etc.
      # @return [Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsResponse]
      # @raise [Google::Gax::GaxError] if the RPC is aborted.
      # @example
      #   require "library/v1"
      #
      #   library_service_client = Library::V1.new
      #   required_singular_int32 = 0
      #   required_singular_int64 = 0
      #   required_singular_float = 0.0
      #   required_singular_double = 0.0
      #   required_singular_bool = false
      #   required_singular_enum = :ZERO
      #   required_singular_string = ''
      #   required_singular_bytes = ''
      #   required_singular_message = {}
      #   required_singular_resource_name = ''
      #   required_singular_resource_name_oneof = ''
      #   required_singular_fixed32 = 0
      #   required_singular_fixed64 = 0
      #   required_repeated_int32 = []
      #   required_repeated_int64 = []
      #   required_repeated_float = []
      #   required_repeated_double = []
      #   required_repeated_bool = []
      #   required_repeated_enum = []
      #   required_repeated_string = []
      #   required_repeated_bytes = []
      #   required_repeated_message = []
      #   formatted_required_repeated_resource_name = []
      #   formatted_required_repeated_resource_name_oneof = []
      #   required_repeated_fixed32 = []
      #   required_repeated_fixed64 = []
      #   required_map = {}
      #   response = library_service_client.test_optional_required_flattening_params(required_singular_int32, required_singular_int64, required_singular_float, required_singular_double, required_singular_bool, required_singular_enum, required_singular_string, required_singular_bytes, required_singular_message, required_singular_resource_name, required_singular_resource_name_oneof, required_singular_fixed32, required_singular_fixed64, required_repeated_int32, required_repeated_int64, required_repeated_float, required_repeated_double, required_repeated_bool, required_repeated_enum, required_repeated_string, required_repeated_bytes, required_repeated_message, formatted_required_repeated_resource_name, formatted_required_repeated_resource_name_oneof, required_repeated_fixed32, required_repeated_fixed64, required_map)

      def test_optional_required_flattening_params \
          required_singular_int32,
          required_singular_int64,
          required_singular_float,
          required_singular_double,
          required_singular_bool,
          required_singular_enum,
          required_singular_string,
          required_singular_bytes,
          required_singular_message,
          required_singular_resource_name,
          required_singular_resource_name_oneof,
          required_singular_fixed32,
          required_singular_fixed64,
          required_repeated_int32,
          required_repeated_int64,
          required_repeated_float,
          required_repeated_double,
          required_repeated_bool,
          required_repeated_enum,
          required_repeated_string,
          required_repeated_bytes,
          required_repeated_message,
          required_repeated_resource_name,
          required_repeated_resource_name_oneof,
          required_repeated_fixed32,
          required_repeated_fixed64,
          required_map,
          optional_singular_int32: nil,
          optional_singular_int64: nil,
          optional_singular_float: nil,
          optional_singular_double: nil,
          optional_singular_bool: nil,
          optional_singular_enum: nil,
          optional_singular_string: nil,
          optional_singular_bytes: nil,
          optional_singular_message: nil,
          optional_singular_resource_name: nil,
          optional_singular_resource_name_oneof: nil,
          optional_singular_fixed32: nil,
          optional_singular_fixed64: nil,
          optional_repeated_int32: nil,
          optional_repeated_int64: nil,
          optional_repeated_float: nil,
          optional_repeated_double: nil,
          optional_repeated_bool: nil,
          optional_repeated_enum: nil,
          optional_repeated_string: nil,
          optional_repeated_bytes: nil,
          optional_repeated_message: nil,
          optional_repeated_resource_name: nil,
          optional_repeated_resource_name_oneof: nil,
          optional_repeated_fixed32: nil,
          optional_repeated_fixed64: nil,
          optional_map: nil,
          options: nil
        req = {
          required_singular_int32: required_singular_int32,
          required_singular_int64: required_singular_int64,
          required_singular_float: required_singular_float,
          required_singular_double: required_singular_double,
          required_singular_bool: required_singular_bool,
          required_singular_enum: required_singular_enum,
          required_singular_string: required_singular_string,
          required_singular_bytes: required_singular_bytes,
          required_singular_message: required_singular_message,
          required_singular_resource_name: required_singular_resource_name,
          required_singular_resource_name_oneof: required_singular_resource_name_oneof,
          required_singular_fixed32: required_singular_fixed32,
          required_singular_fixed64: required_singular_fixed64,
          required_repeated_int32: required_repeated_int32,
          required_repeated_int64: required_repeated_int64,
          required_repeated_float: required_repeated_float,
          required_repeated_double: required_repeated_double,
          required_repeated_bool: required_repeated_bool,
          required_repeated_enum: required_repeated_enum,
          required_repeated_string: required_repeated_string,
          required_repeated_bytes: required_repeated_bytes,
          required_repeated_message: required_repeated_message,
          required_repeated_resource_name: required_repeated_resource_name,
          required_repeated_resource_name_oneof: required_repeated_resource_name_oneof,
          required_repeated_fixed32: required_repeated_fixed32,
          required_repeated_fixed64: required_repeated_fixed64,
          required_map: required_map,
          optional_singular_int32: optional_singular_int32,
          optional_singular_int64: optional_singular_int64,
          optional_singular_float: optional_singular_float,
          optional_singular_double: optional_singular_double,
          optional_singular_bool: optional_singular_bool,
          optional_singular_enum: optional_singular_enum,
          optional_singular_string: optional_singular_string,
          optional_singular_bytes: optional_singular_bytes,
          optional_singular_message: optional_singular_message,
          optional_singular_resource_name: optional_singular_resource_name,
          optional_singular_resource_name_oneof: optional_singular_resource_name_oneof,
          optional_singular_fixed32: optional_singular_fixed32,
          optional_singular_fixed64: optional_singular_fixed64,
          optional_repeated_int32: optional_repeated_int32,
          optional_repeated_int64: optional_repeated_int64,
          optional_repeated_float: optional_repeated_float,
          optional_repeated_double: optional_repeated_double,
          optional_repeated_bool: optional_repeated_bool,
          optional_repeated_enum: optional_repeated_enum,
          optional_repeated_string: optional_repeated_string,
          optional_repeated_bytes: optional_repeated_bytes,
          optional_repeated_message: optional_repeated_message,
          optional_repeated_resource_name: optional_repeated_resource_name,
          optional_repeated_resource_name_oneof: optional_repeated_resource_name_oneof,
          optional_repeated_fixed32: optional_repeated_fixed32,
          optional_repeated_fixed64: optional_repeated_fixed64,
          optional_map: optional_map
        }.delete_if { |_, v| v.nil? }
        req = Google::Gax::to_proto(req, Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest)
        @test_optional_required_flattening_params.call(req, options)
      end
    end
  end
end

============== file: lib/library/v1/library_service_client_config.json ==============
{
  "interfaces": {
    "google.example.library.v1.LibraryService": {
      "retry_codes": {
        "idempotent": [
          "DEADLINE_EXCEEDED",
          "UNAVAILABLE"
        ],
        "non_idempotent": []
      },
      "retry_params": {
        "default": {
          "initial_retry_delay_millis": 100,
          "retry_delay_multiplier": 1.2,
          "max_retry_delay_millis": 1000,
          "initial_rpc_timeout_millis": 300,
          "rpc_timeout_multiplier": 1.3,
          "max_rpc_timeout_millis": 3000,
          "total_timeout_millis": 30000
        }
      },
      "methods": {
        "CreateShelf": {
          "timeout_millis": 1000,
          "retry_codes_name": "non_idempotent",
          "retry_params_name": "default"
        },
        "GetShelf": {
          "timeout_millis": 2000,
          "retry_codes_name": "idempotent",
          "retry_params_name": "default"
        },
        "ListShelves": {
          "timeout_millis": 3000,
          "retry_codes_name": "idempotent",
          "retry_params_name": "default"
        },
        "DeleteShelf": {
          "timeout_millis": 4000,
          "retry_codes_name": "idempotent",
          "retry_params_name": "default"
        },
        "MergeShelves": {
          "timeout_millis": 5000,
          "retry_codes_name": "non_idempotent",
          "retry_params_name": "default"
        },
        "CreateBook": {
          "timeout_millis": 6000,
          "retry_codes_name": "non_idempotent",
          "retry_params_name": "default"
        },
        "PublishSeries": {
          "timeout_millis": 7000,
          "retry_codes_name": "non_idempotent",
          "retry_params_name": "default",
          "bundling": {
            "element_count_threshold": 6,
            "element_count_limit": 7,
            "request_byte_threshold": 100000,
            "request_byte_limit": 150000,
            "delay_threshold_millis": 500
          }
        },
        "GetBook": {
          "timeout_millis": 8000,
          "retry_codes_name": "idempotent",
          "retry_params_name": "default"
        },
        "ListBooks": {
          "timeout_millis": 10000,
          "retry_codes_name": "idempotent",
          "retry_params_name": "default"
        },
        "DeleteBook": {
          "timeout_millis": 10000,
          "retry_codes_name": "idempotent",
          "retry_params_name": "default"
        },
        "UpdateBook": {
          "timeout_millis": 10000,
          "retry_codes_name": "idempotent",
          "retry_params_name": "default"
        },
        "MoveBook": {
          "timeout_millis": 10000,
          "retry_codes_name": "non_idempotent",
          "retry_params_name": "default"
        },
        "ListStrings": {
          "timeout_millis": 10000,
          "retry_codes_name": "idempotent",
          "retry_params_name": "default"
        },
        "AddComments": {
          "timeout_millis": 10000,
          "retry_codes_name": "non_idempotent",
          "retry_params_name": "default",
          "bundling": {
            "element_count_threshold": 6,
            "request_byte_threshold": 100000,
            "delay_threshold_millis": 500
          }
        },
        "GetBookFromArchive": {
          "timeout_millis": 10000,
          "retry_codes_name": "idempotent",
          "retry_params_name": "default"
        },
        "GetBookFromAnywhere": {
          "timeout_millis": 10000,
          "retry_codes_name": "idempotent",
          "retry_params_name": "default"
        },
        "GetBookFromAbsolutelyAnywhere": {
          "timeout_millis": 10000,
          "retry_codes_name": "idempotent",
          "retry_params_name": "default"
        },
        "UpdateBookIndex": {
          "timeout_millis": 10000,
          "retry_codes_name": "idempotent",
          "retry_params_name": "default"
        },
        "StreamShelves": {
          "timeout_millis": 30000,
          "retry_codes_name": "idempotent",
          "retry_params_name": "default"
        },
        "StreamBooks": {
          "timeout_millis": 30000,
          "retry_codes_name": "idempotent",
          "retry_params_name": "default"
        },
        "DiscussBook": {
          "timeout_millis": 30000,
          "retry_codes_name": "non_idempotent",
          "retry_params_name": "default"
        },
        "MonologAboutBook": {
          "timeout_millis": 30000,
          "retry_codes_name": "non_idempotent",
          "retry_params_name": "default"
        },
        "FindRelatedBooks": {
          "timeout_millis": 3000,
          "retry_codes_name": "idempotent",
          "retry_params_name": "default"
        },
        "AddTag": {
          "timeout_millis": 60000,
          "retry_codes_name": "non_idempotent",
          "retry_params_name": "default"
        },
        "AddLabel": {
          "timeout_millis": 60000,
          "retry_codes_name": "non_idempotent",
          "retry_params_name": "default"
        },
        "GetBigBook": {
          "timeout_millis": 60000,
          "retry_codes_name": "non_idempotent",
          "retry_params_name": "default"
        },
        "GetBigNothing": {
          "timeout_millis": 60000,
          "retry_codes_name": "non_idempotent",
          "retry_params_name": "default"
        },
        "TestOptionalRequiredFlatteningParams": {
          "timeout_millis": 60000,
          "retry_codes_name": "non_idempotent",
          "retry_params_name": "default"
        }
      }
    }
  }
}

============== file: library.gemspec ==============
# -*- ruby -*-
# encoding: utf-8

Gem::Specification.new do |gem|
  gem.name          = "library"
  gem.version       = "0.6.8"

  gem.authors       = ["Google, Inc."]
  gem.email         = "googleapis-packages@google.com"
  gem.description   = "library is the official library for Google Example Library API."
  gem.summary       = "API Client library for Google Example Library API"
  gem.homepage      = "https://github.com/googleapis/googleapis"
  gem.license       = "Apache-2.0"

  gem.platform      = Gem::Platform::RUBY

  gem.files         = `git ls-files -- lib/*`.split("\n") +
                      ["README.md", "LICENSE", ".yardopts"]
  gem.require_paths = ["lib"]

  gem.required_ruby_version = ">= 2.0.0"

  gem.add_dependency "google-gax", "~> 0.8.0"
  gem.add_dependency "google-some-other-package-v1", "~> 0.2.1"
  gem.add_dependency "googleapis-common-protos", "~> 1.3.1"
  gem.add_dependency "googleauth", "~> 0.5.1"

  gem.add_development_dependency "minitest", "~> 5.10"
  gem.add_development_dependency "rubocop", "<= 0.35.1"
  gem.add_development_dependency "simplecov", "~> 0.9"
end

============== file: test/library/v1/library_service_client_test.rb ==============
# Copyright 2017, Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

require "minitest/autorun"
require "minitest/spec"

require "google/gax"

require "library"
require "library/v1/library_service_client"
require "library_services_pb"
require "tagger_services_pb"
require "google/longrunning/operations_pb"

class CustomTestError < StandardError; end

# Mock for the GRPC::ClientStub class.
class MockGrpcClientStub

  # @param expected_symbol [Symbol] the symbol of the grpc method to be mocked.
  # @param mock_method [Proc] The method that is being mocked.
  def initialize(expected_symbol, mock_method)
    @expected_symbol = expected_symbol
    @mock_method = mock_method
  end

  # This overrides the Object#method method to return the mocked method when the mocked method
  # is being requested. For methods that aren't being tested, this method returns a proc that
  # will raise an error when called. This is to assure that only the mocked grpc method is being
  # called.
  #
  # @param symbol [Symbol] The symbol of the method being requested.
  # @return [Proc] The proc of the requested method. If the requested method is not being mocked
  #   the proc returned will raise when called.
  def method(symbol)
    return @mock_method if symbol == @expected_symbol

    # The requested method is not being tested, raise if it called.
    proc do
      raise "The method #{symbol} was unexpectedly called during the " \
        "test for #{@expected_symbol}."
    end
  end
end

class MockLibraryServiceCredentials < Library::Credentials
  def initialize(method_name)
    @method_name = method_name
  end

  def updater_proc
    proc do
      raise "The method `#{@method_name}` was trying to make a grpc request. This should not " \
          "happen since the grpc layer is being mocked."
    end
  end
end

describe Library::V1::LibraryServiceClient do

  describe 'create_shelf' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#create_shelf."

    it 'invokes create_shelf without error' do
      # Create request parameters
      shelf = {}

      # Create expected grpc response
      name = "name3373707"
      theme = "theme110327241"
      internal_theme = "internalTheme792518087"
      expected_response = {
        name: name,
        theme: theme,
        internal_theme: internal_theme
      }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::Shelf)

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::CreateShelfRequest, request)
        assert_equal(Google::Gax::to_proto(shelf, Google::Example::Library::V1::Shelf), request.shelf)
        expected_response
      end
      mock_stub = MockGrpcClientStub.new(:create_shelf, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("create_shelf")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.create_shelf(shelf)

          # Verify the response
          assert_equal(expected_response, response)
        end
      end
    end

    it 'invokes create_shelf with error' do
      # Create request parameters
      shelf = {}

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::CreateShelfRequest, request)
        assert_equal(Google::Gax::to_proto(shelf, Google::Example::Library::V1::Shelf), request.shelf)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:create_shelf, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("create_shelf")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.create_shelf(shelf)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'get_shelf' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#get_shelf."

    it 'invokes get_shelf without error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")
      options_ = ''

      # Create expected grpc response
      name_2 = "name2-1052831874"
      theme = "theme110327241"
      internal_theme = "internalTheme792518087"
      expected_response = {
        name: name_2,
        theme: theme,
        internal_theme: internal_theme
      }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::Shelf)

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::GetShelfRequest, request)
        assert_equal(formatted_name, request.name)
        assert_equal(options_, request.options)
        expected_response
      end
      mock_stub = MockGrpcClientStub.new(:get_shelf, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("get_shelf")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.get_shelf(formatted_name, options_)

          # Verify the response
          assert_equal(expected_response, response)
        end
      end
    end

    it 'invokes get_shelf with error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")
      options_ = ''

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::GetShelfRequest, request)
        assert_equal(formatted_name, request.name)
        assert_equal(options_, request.options)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:get_shelf, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("get_shelf")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.get_shelf(formatted_name, options_)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'list_shelves' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#list_shelves."

    it 'invokes list_shelves without error' do
      # Create expected grpc response
      next_page_token = ""
      shelves_element = {}
      shelves = [shelves_element]
      expected_response = { next_page_token: next_page_token, shelves: shelves }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::ListShelvesResponse)

      # Mock Grpc layer
      mock_method = proc do
        expected_response
      end
      mock_stub = MockGrpcClientStub.new(:list_shelves, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("list_shelves")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.list_shelves

          # Verify the response
          assert(response.instance_of?(Google::Gax::PagedEnumerable))
          assert_equal(expected_response, response.page.response)
          assert_nil(response.next_page)
          assert_equal(expected_response.shelves.to_a, response.to_a)
        end
      end
    end

    it 'invokes list_shelves with error' do
      # Mock Grpc layer
      mock_method = proc do
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:list_shelves, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("list_shelves")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.list_shelves
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'delete_shelf' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#delete_shelf."

    it 'invokes delete_shelf without error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::DeleteShelfRequest, request)
        assert_equal(formatted_name, request.name)
        nil
      end
      mock_stub = MockGrpcClientStub.new(:delete_shelf, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("delete_shelf")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.delete_shelf(formatted_name)

          # Verify the response
          assert_nil(response)
        end
      end
    end

    it 'invokes delete_shelf with error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::DeleteShelfRequest, request)
        assert_equal(formatted_name, request.name)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:delete_shelf, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("delete_shelf")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.delete_shelf(formatted_name)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'merge_shelves' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#merge_shelves."

    it 'invokes merge_shelves without error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")
      formatted_other_shelf_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")

      # Create expected grpc response
      name_2 = "name2-1052831874"
      theme = "theme110327241"
      internal_theme = "internalTheme792518087"
      expected_response = {
        name: name_2,
        theme: theme,
        internal_theme: internal_theme
      }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::Shelf)

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::MergeShelvesRequest, request)
        assert_equal(formatted_name, request.name)
        assert_equal(formatted_other_shelf_name, request.other_shelf_name)
        expected_response
      end
      mock_stub = MockGrpcClientStub.new(:merge_shelves, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("merge_shelves")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.merge_shelves(formatted_name, formatted_other_shelf_name)

          # Verify the response
          assert_equal(expected_response, response)
        end
      end
    end

    it 'invokes merge_shelves with error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")
      formatted_other_shelf_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::MergeShelvesRequest, request)
        assert_equal(formatted_name, request.name)
        assert_equal(formatted_other_shelf_name, request.other_shelf_name)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:merge_shelves, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("merge_shelves")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.merge_shelves(formatted_name, formatted_other_shelf_name)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'create_book' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#create_book."

    it 'invokes create_book without error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")
      book = {}

      # Create expected grpc response
      name_2 = "name2-1052831874"
      author = "author-1406328437"
      title = "title110371416"
      read = true
      expected_response = {
        name: name_2,
        author: author,
        title: title,
        read: read
      }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::Book)

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::CreateBookRequest, request)
        assert_equal(formatted_name, request.name)
        assert_equal(Google::Gax::to_proto(book, Google::Example::Library::V1::Book), request.book)
        expected_response
      end
      mock_stub = MockGrpcClientStub.new(:create_book, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("create_book")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.create_book(formatted_name, book)

          # Verify the response
          assert_equal(expected_response, response)
        end
      end
    end

    it 'invokes create_book with error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")
      book = {}

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::CreateBookRequest, request)
        assert_equal(formatted_name, request.name)
        assert_equal(Google::Gax::to_proto(book, Google::Example::Library::V1::Book), request.book)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:create_book, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("create_book")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.create_book(formatted_name, book)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'publish_series' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#publish_series."

    it 'invokes publish_series without error' do
      # Create request parameters
      shelf = {}
      books = []
      series_string = "foobar"
      series_uuid = { series_string: series_string }

      # Create expected grpc response
      book_names_element = "bookNamesElement1491670575"
      book_names = [book_names_element]
      expected_response = { book_names: book_names }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::PublishSeriesResponse)

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::PublishSeriesRequest, request)
        assert_equal(Google::Gax::to_proto(shelf, Google::Example::Library::V1::Shelf), request.shelf)
        books = books.map do |req|
          Google::Gax::to_proto(req, Google::Example::Library::V1::Book)
        end
        assert_equal(books, request.books)
        assert_equal(Google::Gax::to_proto(series_uuid, Google::Example::Library::V1::SeriesUuid), request.series_uuid)
        expected_response
      end
      mock_stub = MockGrpcClientStub.new(:publish_series, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("publish_series")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.publish_series(
            shelf,
            books,
            series_uuid
          )

          # Verify the response
          assert_equal(expected_response, response)
        end
      end
    end

    it 'invokes publish_series with error' do
      # Create request parameters
      shelf = {}
      books = []
      series_string = "foobar"
      series_uuid = { series_string: series_string }

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::PublishSeriesRequest, request)
        assert_equal(Google::Gax::to_proto(shelf, Google::Example::Library::V1::Shelf), request.shelf)
        books = books.map do |req|
          Google::Gax::to_proto(req, Google::Example::Library::V1::Book)
        end
        assert_equal(books, request.books)
        assert_equal(Google::Gax::to_proto(series_uuid, Google::Example::Library::V1::SeriesUuid), request.series_uuid)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:publish_series, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("publish_series")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.publish_series(
              shelf,
              books,
              series_uuid
            )
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'get_book' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#get_book."

    it 'invokes get_book without error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")

      # Create expected grpc response
      name_2 = "name2-1052831874"
      author = "author-1406328437"
      title = "title110371416"
      read = true
      expected_response = {
        name: name_2,
        author: author,
        title: title,
        read: read
      }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::Book)

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::GetBookRequest, request)
        assert_equal(formatted_name, request.name)
        expected_response
      end
      mock_stub = MockGrpcClientStub.new(:get_book, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("get_book")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.get_book(formatted_name)

          # Verify the response
          assert_equal(expected_response, response)
        end
      end
    end

    it 'invokes get_book with error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::GetBookRequest, request)
        assert_equal(formatted_name, request.name)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:get_book, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("get_book")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.get_book(formatted_name)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'list_books' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#list_books."

    it 'invokes list_books without error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")

      # Create expected grpc response
      next_page_token = ""
      books_element = {}
      books = [books_element]
      expected_response = { next_page_token: next_page_token, books: books }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::ListBooksResponse)

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::ListBooksRequest, request)
        assert_equal(formatted_name, request.name)
        expected_response
      end
      mock_stub = MockGrpcClientStub.new(:list_books, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("list_books")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.list_books(formatted_name)

          # Verify the response
          assert(response.instance_of?(Google::Gax::PagedEnumerable))
          assert_equal(expected_response, response.page.response)
          assert_nil(response.next_page)
          assert_equal(expected_response.books.to_a, response.to_a)
        end
      end
    end

    it 'invokes list_books with error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::ListBooksRequest, request)
        assert_equal(formatted_name, request.name)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:list_books, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("list_books")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.list_books(formatted_name)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'delete_book' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#delete_book."

    it 'invokes delete_book without error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::DeleteBookRequest, request)
        assert_equal(formatted_name, request.name)
        nil
      end
      mock_stub = MockGrpcClientStub.new(:delete_book, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("delete_book")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.delete_book(formatted_name)

          # Verify the response
          assert_nil(response)
        end
      end
    end

    it 'invokes delete_book with error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::DeleteBookRequest, request)
        assert_equal(formatted_name, request.name)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:delete_book, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("delete_book")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.delete_book(formatted_name)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'update_book' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#update_book."

    it 'invokes update_book without error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      book = {}

      # Create expected grpc response
      name_2 = "name2-1052831874"
      author = "author-1406328437"
      title = "title110371416"
      read = true
      expected_response = {
        name: name_2,
        author: author,
        title: title,
        read: read
      }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::Book)

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::UpdateBookRequest, request)
        assert_equal(formatted_name, request.name)
        assert_equal(Google::Gax::to_proto(book, Google::Example::Library::V1::Book), request.book)
        expected_response
      end
      mock_stub = MockGrpcClientStub.new(:update_book, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("update_book")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.update_book(formatted_name, book)

          # Verify the response
          assert_equal(expected_response, response)
        end
      end
    end

    it 'invokes update_book with error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      book = {}

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::UpdateBookRequest, request)
        assert_equal(formatted_name, request.name)
        assert_equal(Google::Gax::to_proto(book, Google::Example::Library::V1::Book), request.book)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:update_book, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("update_book")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.update_book(formatted_name, book)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'move_book' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#move_book."

    it 'invokes move_book without error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      formatted_other_shelf_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")

      # Create expected grpc response
      name_2 = "name2-1052831874"
      author = "author-1406328437"
      title = "title110371416"
      read = true
      expected_response = {
        name: name_2,
        author: author,
        title: title,
        read: read
      }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::Book)

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::MoveBookRequest, request)
        assert_equal(formatted_name, request.name)
        assert_equal(formatted_other_shelf_name, request.other_shelf_name)
        expected_response
      end
      mock_stub = MockGrpcClientStub.new(:move_book, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("move_book")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.move_book(formatted_name, formatted_other_shelf_name)

          # Verify the response
          assert_equal(expected_response, response)
        end
      end
    end

    it 'invokes move_book with error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      formatted_other_shelf_name = Library::V1::LibraryServiceClient.shelf_path("[SHELF_ID]")

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::MoveBookRequest, request)
        assert_equal(formatted_name, request.name)
        assert_equal(formatted_other_shelf_name, request.other_shelf_name)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:move_book, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("move_book")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.move_book(formatted_name, formatted_other_shelf_name)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'list_strings' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#list_strings."

    it 'invokes list_strings without error' do
      # Create expected grpc response
      next_page_token = ""
      strings_element = "stringsElement474465855"
      strings = [strings_element]
      expected_response = { next_page_token: next_page_token, strings: strings }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::ListStringsResponse)

      # Mock Grpc layer
      mock_method = proc do
        expected_response
      end
      mock_stub = MockGrpcClientStub.new(:list_strings, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("list_strings")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.list_strings

          # Verify the response
          assert(response.instance_of?(Google::Gax::PagedEnumerable))
          assert_equal(expected_response, response.page.response)
          assert_nil(response.next_page)
          assert_equal(expected_response.strings.to_a, response.to_a)
        end
      end
    end

    it 'invokes list_strings with error' do
      # Mock Grpc layer
      mock_method = proc do
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:list_strings, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("list_strings")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.list_strings
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'add_comments' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#add_comments."

    it 'invokes add_comments without error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      comment = ''
      stage = :UNSET
      alignment = :CHAR
      comments_element = {
        comment: comment,
        stage: stage,
        alignment: alignment
      }
      comments = [comments_element]

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::AddCommentsRequest, request)
        assert_equal(formatted_name, request.name)
        comments = comments.map do |req|
          Google::Gax::to_proto(req, Google::Example::Library::V1::Comment)
        end
        assert_equal(comments, request.comments)
        nil
      end
      mock_stub = MockGrpcClientStub.new(:add_comments, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("add_comments")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.add_comments(formatted_name, comments)

          # Verify the response
          assert_nil(response)
        end
      end
    end

    it 'invokes add_comments with error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      comment = ''
      stage = :UNSET
      alignment = :CHAR
      comments_element = {
        comment: comment,
        stage: stage,
        alignment: alignment
      }
      comments = [comments_element]

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::AddCommentsRequest, request)
        assert_equal(formatted_name, request.name)
        comments = comments.map do |req|
          Google::Gax::to_proto(req, Google::Example::Library::V1::Comment)
        end
        assert_equal(comments, request.comments)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:add_comments, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("add_comments")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.add_comments(formatted_name, comments)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'get_book_from_archive' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#get_book_from_archive."

    it 'invokes get_book_from_archive without error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.archived_book_path("[ARCHIVE_PATH]", "[BOOK_ID]")

      # Create expected grpc response
      name_2 = "name2-1052831874"
      author = "author-1406328437"
      title = "title110371416"
      read = true
      expected_response = {
        name: name_2,
        author: author,
        title: title,
        read: read
      }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::BookFromArchive)

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::GetBookFromArchiveRequest, request)
        assert_equal(formatted_name, request.name)
        expected_response
      end
      mock_stub = MockGrpcClientStub.new(:get_book_from_archive, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("get_book_from_archive")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.get_book_from_archive(formatted_name)

          # Verify the response
          assert_equal(expected_response, response)
        end
      end
    end

    it 'invokes get_book_from_archive with error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.archived_book_path("[ARCHIVE_PATH]", "[BOOK_ID]")

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::GetBookFromArchiveRequest, request)
        assert_equal(formatted_name, request.name)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:get_book_from_archive, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("get_book_from_archive")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.get_book_from_archive(formatted_name)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'get_book_from_anywhere' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#get_book_from_anywhere."

    it 'invokes get_book_from_anywhere without error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      formatted_alt_book_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")

      # Create expected grpc response
      name_2 = "name2-1052831874"
      author = "author-1406328437"
      title = "title110371416"
      read = true
      expected_response = {
        name: name_2,
        author: author,
        title: title,
        read: read
      }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::BookFromAnywhere)

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::GetBookFromAnywhereRequest, request)
        assert_equal(formatted_name, request.name)
        assert_equal(formatted_alt_book_name, request.alt_book_name)
        expected_response
      end
      mock_stub = MockGrpcClientStub.new(:get_book_from_anywhere, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("get_book_from_anywhere")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.get_book_from_anywhere(formatted_name, formatted_alt_book_name)

          # Verify the response
          assert_equal(expected_response, response)
        end
      end
    end

    it 'invokes get_book_from_anywhere with error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      formatted_alt_book_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::GetBookFromAnywhereRequest, request)
        assert_equal(formatted_name, request.name)
        assert_equal(formatted_alt_book_name, request.alt_book_name)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:get_book_from_anywhere, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("get_book_from_anywhere")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.get_book_from_anywhere(formatted_name, formatted_alt_book_name)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'get_book_from_absolutely_anywhere' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#get_book_from_absolutely_anywhere."

    it 'invokes get_book_from_absolutely_anywhere without error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")

      # Create expected grpc response
      name_2 = "name2-1052831874"
      author = "author-1406328437"
      title = "title110371416"
      read = true
      expected_response = {
        name: name_2,
        author: author,
        title: title,
        read: read
      }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::BookFromAnywhere)

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::GetBookFromAbsolutelyAnywhereRequest, request)
        assert_equal(formatted_name, request.name)
        expected_response
      end
      mock_stub = MockGrpcClientStub.new(:get_book_from_absolutely_anywhere, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("get_book_from_absolutely_anywhere")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.get_book_from_absolutely_anywhere(formatted_name)

          # Verify the response
          assert_equal(expected_response, response)
        end
      end
    end

    it 'invokes get_book_from_absolutely_anywhere with error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::GetBookFromAbsolutelyAnywhereRequest, request)
        assert_equal(formatted_name, request.name)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:get_book_from_absolutely_anywhere, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("get_book_from_absolutely_anywhere")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.get_book_from_absolutely_anywhere(formatted_name)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'update_book_index' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#update_book_index."

    it 'invokes update_book_index without error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      index_name = "default index"
      index_map_item = ''
      index_map = { "default_key" => index_map_item }

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::UpdateBookIndexRequest, request)
        assert_equal(formatted_name, request.name)
        assert_equal(index_name, request.index_name)
        assert_equal(Google::Gax::to_proto(index_map, Google::Example::Library::V1::UpdateBookIndexRequest::IndexMapEntry), request.index_map)
        nil
      end
      mock_stub = MockGrpcClientStub.new(:update_book_index, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("update_book_index")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.update_book_index(
            formatted_name,
            index_name,
            index_map
          )

          # Verify the response
          assert_nil(response)
        end
      end
    end

    it 'invokes update_book_index with error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      index_name = "default index"
      index_map_item = ''
      index_map = { "default_key" => index_map_item }

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::UpdateBookIndexRequest, request)
        assert_equal(formatted_name, request.name)
        assert_equal(index_name, request.index_name)
        assert_equal(Google::Gax::to_proto(index_map, Google::Example::Library::V1::UpdateBookIndexRequest::IndexMapEntry), request.index_map)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:update_book_index, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("update_book_index")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.update_book_index(
              formatted_name,
              index_name,
              index_map
            )
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'stream_shelves' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#stream_shelves."

    it 'invokes stream_shelves without error' do
      # Create expected grpc response
      shelves_element = {}
      shelves = [shelves_element]
      expected_response = { shelves: shelves }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::StreamShelvesResponse)

      # Mock Grpc layer
      mock_method = proc do
        [expected_response]
      end
      mock_stub = MockGrpcClientStub.new(:stream_shelves, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("stream_shelves")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.stream_shelves

          # Verify the response
          assert_equal(1, response.count)
          assert_equal(expected_response, response.first)
        end
      end
    end

    it 'invokes stream_shelves with error' do
      # Mock Grpc layer
      mock_method = proc do
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:stream_shelves, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("stream_shelves")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.stream_shelves
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'stream_books' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#stream_books."

    it 'invokes stream_books without error' do
      # Create request parameters
      name = ''

      # Create expected grpc response
      name_2 = "name2-1052831874"
      author = "author-1406328437"
      title = "title110371416"
      read = true
      expected_response = {
        name: name_2,
        author: author,
        title: title,
        read: read
      }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::Book)

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::StreamBooksRequest, request)
        assert_equal(name, request.name)
        [expected_response]
      end
      mock_stub = MockGrpcClientStub.new(:stream_books, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("stream_books")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.stream_books(name)

          # Verify the response
          assert_equal(1, response.count)
          assert_equal(expected_response, response.first)
        end
      end
    end

    it 'invokes stream_books with error' do
      # Create request parameters
      name = ''

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::StreamBooksRequest, request)
        assert_equal(name, request.name)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:stream_books, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("stream_books")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.stream_books(name)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'discuss_book' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#discuss_book."

    it 'invokes discuss_book without error' do
      # Create request parameters
      name = ''
      request = { name: name }

      # Create expected grpc response
      user_name = "userName339340927"
      comment = "95"
      expected_response = { user_name: user_name, comment: comment }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::Comment)

      # Mock Grpc layer
      mock_method = proc do |requests|
        request = requests.first
        assert_instance_of(Google::Example::Library::V1::DiscussBookRequest, request)
        assert_equal(name, request.name)
        [expected_response]
      end
      mock_stub = MockGrpcClientStub.new(:discuss_book, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("discuss_book")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.discuss_book([request])

          # Verify the response
          assert_equal(1, response.count)
          assert_equal(expected_response, response.first)
        end
      end
    end

    it 'invokes discuss_book with error' do
      # Create request parameters
      name = ''
      request = { name: name }

      # Mock Grpc layer
      mock_method = proc do |requests|
        request = requests.first
        assert_instance_of(Google::Example::Library::V1::DiscussBookRequest, request)
        assert_equal(name, request.name)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:discuss_book, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("discuss_book")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.discuss_book([request])
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'monolog_about_book' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#monolog_about_book."

    it 'invokes monolog_about_book without error' do
      # Create request parameters
      name = ''
      request = { name: name }

      # Create expected grpc response
      user_name = "userName339340927"
      comment = "95"
      expected_response = { user_name: user_name, comment: comment }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::Comment)

      # Mock Grpc layer
      mock_method = proc do |requests|
        request = requests.first
        assert_instance_of(Google::Example::Library::V1::DiscussBookRequest, request)
        assert_equal(name, request.name)
        expected_response
      end
      mock_stub = MockGrpcClientStub.new(:monolog_about_book, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("monolog_about_book")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.monolog_about_book([request])

          # Verify the response
          assert_equal(expected_response, response)
        end
      end
    end

    it 'invokes monolog_about_book with error' do
      # Create request parameters
      name = ''
      request = { name: name }

      # Mock Grpc layer
      mock_method = proc do |requests|
        request = requests.first
        assert_instance_of(Google::Example::Library::V1::DiscussBookRequest, request)
        assert_equal(name, request.name)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:monolog_about_book, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("monolog_about_book")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.monolog_about_book([request])
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'find_related_books' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#find_related_books."

    it 'invokes find_related_books without error' do
      # Create request parameters
      names_element = ''
      names = [names_element]
      shelves = []

      # Create expected grpc response
      next_page_token = ""
      names_element_2 = "namesElement21120252792"
      names_2 = [names_element_2]
      expected_response = { next_page_token: next_page_token, names: names_2 }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::FindRelatedBooksResponse)

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::FindRelatedBooksRequest, request)
        assert_equal(names, request.names)
        assert_equal(shelves, request.shelves)
        expected_response
      end
      mock_stub = MockGrpcClientStub.new(:find_related_books, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("find_related_books")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.find_related_books(names, shelves)

          # Verify the response
          assert(response.instance_of?(Google::Gax::PagedEnumerable))
          assert_equal(expected_response, response.page.response)
          assert_nil(response.next_page)
          assert_equal(expected_response.names.to_a, response.to_a)
        end
      end
    end

    it 'invokes find_related_books with error' do
      # Create request parameters
      names_element = ''
      names = [names_element]
      shelves = []

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::FindRelatedBooksRequest, request)
        assert_equal(names, request.names)
        assert_equal(shelves, request.shelves)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:find_related_books, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("find_related_books")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.find_related_books(names, shelves)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'add_tag' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#add_tag."

    it 'invokes add_tag without error' do
      # Create request parameters
      formatted_resource = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      tag = ''

      # Create expected grpc response
      expected_response = {}
      expected_response = Google::Gax::to_proto(expected_response, Google::Tagger::V1::AddTagResponse)

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Tagger::V1::AddTagRequest, request)
        assert_equal(formatted_resource, request.resource)
        assert_equal(tag, request.tag)
        expected_response
      end
      mock_stub = MockGrpcClientStub.new(:add_tag, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("add_tag")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.add_tag(formatted_resource, tag)

          # Verify the response
          assert_equal(expected_response, response)
        end
      end
    end

    it 'invokes add_tag with error' do
      # Create request parameters
      formatted_resource = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      tag = ''

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Tagger::V1::AddTagRequest, request)
        assert_equal(formatted_resource, request.resource)
        assert_equal(tag, request.tag)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:add_tag, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("add_tag")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.add_tag(formatted_resource, tag)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'add_label' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#add_label."

    it 'invokes add_label without error' do
      # Create request parameters
      formatted_resource = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      label = ''

      # Create expected grpc response
      expected_response = {}
      expected_response = Google::Gax::to_proto(expected_response, Google::Tagger::V1::AddLabelResponse)

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Tagger::V1::AddLabelRequest, request)
        assert_equal(formatted_resource, request.resource)
        assert_equal(label, request.label)
        expected_response
      end
      mock_stub = MockGrpcClientStub.new(:add_label, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("add_label")

      Google::Tagger::V1::Labeler::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.add_label(formatted_resource, label)

          # Verify the response
          assert_equal(expected_response, response)
        end
      end
    end

    it 'invokes add_label with error' do
      # Create request parameters
      formatted_resource = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")
      label = ''

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Tagger::V1::AddLabelRequest, request)
        assert_equal(formatted_resource, request.resource)
        assert_equal(label, request.label)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:add_label, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("add_label")

      Google::Tagger::V1::Labeler::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.add_label(formatted_resource, label)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'get_big_book' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#get_big_book."

    it 'invokes get_big_book without error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")

      # Create expected grpc response
      name_2 = "name2-1052831874"
      author = "author-1406328437"
      title = "title110371416"
      read = true
      expected_response = {
        name: name_2,
        author: author,
        title: title,
        read: read
      }
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::Book)
      result = Google::Protobuf::Any.new
      result.pack(expected_response)
      operation = Google::Longrunning::Operation.new(
        name: 'operations/get_big_book_test',
        done: true,
        response: result
      )

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::GetBookRequest, request)
        assert_equal(formatted_name, request.name)
        operation
      end
      mock_stub = MockGrpcClientStub.new(:get_big_book, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("get_big_book")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.get_big_book(formatted_name)

          # Verify the response
          assert_equal(expected_response, response.response)
        end
      end
    end

    it 'invokes get_big_book and returns an operation error.' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")

      # Create expected grpc response
      operation_error = Google::Rpc::Status.new(
        message: 'Operation error for Library::V1::LibraryServiceClient#get_big_book.'
      )
      operation = Google::Longrunning::Operation.new(
        name: 'operations/get_big_book_test',
        done: true,
        error: operation_error
      )

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::GetBookRequest, request)
        assert_equal(formatted_name, request.name)
        operation
      end
      mock_stub = MockGrpcClientStub.new(:get_big_book, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("get_big_book")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.get_big_book(formatted_name)

          # Verify the response
          assert(response.error?)
          assert_equal(operation_error, response.error)
        end
      end
    end

    it 'invokes get_big_book with error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::GetBookRequest, request)
        assert_equal(formatted_name, request.name)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:get_big_book, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("get_big_book")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.get_big_book(formatted_name)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'get_big_nothing' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#get_big_nothing."

    it 'invokes get_big_nothing without error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")

      # Create expected grpc response
      expected_response = {}
      expected_response = Google::Gax::to_proto(expected_response, Google::Protobuf::Empty)
      result = Google::Protobuf::Any.new
      result.pack(expected_response)
      operation = Google::Longrunning::Operation.new(
        name: 'operations/get_big_nothing_test',
        done: true,
        response: result
      )

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::GetBookRequest, request)
        assert_equal(formatted_name, request.name)
        operation
      end
      mock_stub = MockGrpcClientStub.new(:get_big_nothing, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("get_big_nothing")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.get_big_nothing(formatted_name)

          # Verify the response
          assert_equal(expected_response, response.response)
        end
      end
    end

    it 'invokes get_big_nothing and returns an operation error.' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")

      # Create expected grpc response
      operation_error = Google::Rpc::Status.new(
        message: 'Operation error for Library::V1::LibraryServiceClient#get_big_nothing.'
      )
      operation = Google::Longrunning::Operation.new(
        name: 'operations/get_big_nothing_test',
        done: true,
        error: operation_error
      )

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::GetBookRequest, request)
        assert_equal(formatted_name, request.name)
        operation
      end
      mock_stub = MockGrpcClientStub.new(:get_big_nothing, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("get_big_nothing")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.get_big_nothing(formatted_name)

          # Verify the response
          assert(response.error?)
          assert_equal(operation_error, response.error)
        end
      end
    end

    it 'invokes get_big_nothing with error' do
      # Create request parameters
      formatted_name = Library::V1::LibraryServiceClient.book_path("[SHELF_ID]", "[BOOK_ID]")

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::GetBookRequest, request)
        assert_equal(formatted_name, request.name)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:get_big_nothing, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("get_big_nothing")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.get_big_nothing(formatted_name)
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end

  describe 'test_optional_required_flattening_params' do
    custom_error = CustomTestError.new "Custom test error for Library::V1::LibraryServiceClient#test_optional_required_flattening_params."

    it 'invokes test_optional_required_flattening_params without error' do
      # Create request parameters
      required_singular_int32 = 0
      required_singular_int64 = 0
      required_singular_float = 0.0
      required_singular_double = 0.0
      required_singular_bool = false
      required_singular_enum = :ZERO
      required_singular_string = ''
      required_singular_bytes = ''
      required_singular_message = {}
      required_singular_resource_name = ''
      required_singular_resource_name_oneof = ''
      required_singular_fixed32 = 0
      required_singular_fixed64 = 0
      required_repeated_int32 = []
      required_repeated_int64 = []
      required_repeated_float = []
      required_repeated_double = []
      required_repeated_bool = []
      required_repeated_enum = []
      required_repeated_string = []
      required_repeated_bytes = []
      required_repeated_message = []
      formatted_required_repeated_resource_name = []
      formatted_required_repeated_resource_name_oneof = []
      required_repeated_fixed32 = []
      required_repeated_fixed64 = []
      required_map = {}

      # Create expected grpc response
      expected_response = {}
      expected_response = Google::Gax::to_proto(expected_response, Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsResponse)

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest, request)
        assert_equal(required_singular_int32, request.required_singular_int32)
        assert_equal(required_singular_int64, request.required_singular_int64)
        assert_equal(required_singular_float, request.required_singular_float)
        assert_equal(required_singular_double, request.required_singular_double)
        assert_equal(required_singular_bool, request.required_singular_bool)
        assert_equal(required_singular_enum, request.required_singular_enum)
        assert_equal(required_singular_string, request.required_singular_string)
        assert_equal(required_singular_bytes, request.required_singular_bytes)
        assert_equal(Google::Gax::to_proto(required_singular_message, Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerMessage), request.required_singular_message)
        assert_equal(required_singular_resource_name, request.required_singular_resource_name)
        assert_equal(required_singular_resource_name_oneof, request.required_singular_resource_name_oneof)
        assert_equal(required_singular_fixed32, request.required_singular_fixed32)
        assert_equal(required_singular_fixed64, request.required_singular_fixed64)
        assert_equal(required_repeated_int32, request.required_repeated_int32)
        assert_equal(required_repeated_int64, request.required_repeated_int64)
        assert_equal(required_repeated_float, request.required_repeated_float)
        assert_equal(required_repeated_double, request.required_repeated_double)
        assert_equal(required_repeated_bool, request.required_repeated_bool)
        assert_equal(required_repeated_enum, request.required_repeated_enum)
        assert_equal(required_repeated_string, request.required_repeated_string)
        assert_equal(required_repeated_bytes, request.required_repeated_bytes)
        required_repeated_message = required_repeated_message.map do |req|
          Google::Gax::to_proto(req, Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerMessage)
        end
        assert_equal(required_repeated_message, request.required_repeated_message)
        assert_equal(formatted_required_repeated_resource_name, request.required_repeated_resource_name)
        assert_equal(formatted_required_repeated_resource_name_oneof, request.required_repeated_resource_name_oneof)
        assert_equal(required_repeated_fixed32, request.required_repeated_fixed32)
        assert_equal(required_repeated_fixed64, request.required_repeated_fixed64)
        assert_equal(Google::Gax::to_proto(required_map, Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::RequiredMapEntry), request.required_map)
        expected_response
      end
      mock_stub = MockGrpcClientStub.new(:test_optional_required_flattening_params, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("test_optional_required_flattening_params")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          response = client.test_optional_required_flattening_params(
            required_singular_int32,
            required_singular_int64,
            required_singular_float,
            required_singular_double,
            required_singular_bool,
            required_singular_enum,
            required_singular_string,
            required_singular_bytes,
            required_singular_message,
            required_singular_resource_name,
            required_singular_resource_name_oneof,
            required_singular_fixed32,
            required_singular_fixed64,
            required_repeated_int32,
            required_repeated_int64,
            required_repeated_float,
            required_repeated_double,
            required_repeated_bool,
            required_repeated_enum,
            required_repeated_string,
            required_repeated_bytes,
            required_repeated_message,
            formatted_required_repeated_resource_name,
            formatted_required_repeated_resource_name_oneof,
            required_repeated_fixed32,
            required_repeated_fixed64,
            required_map
          )

          # Verify the response
          assert_equal(expected_response, response)
        end
      end
    end

    it 'invokes test_optional_required_flattening_params with error' do
      # Create request parameters
      required_singular_int32 = 0
      required_singular_int64 = 0
      required_singular_float = 0.0
      required_singular_double = 0.0
      required_singular_bool = false
      required_singular_enum = :ZERO
      required_singular_string = ''
      required_singular_bytes = ''
      required_singular_message = {}
      required_singular_resource_name = ''
      required_singular_resource_name_oneof = ''
      required_singular_fixed32 = 0
      required_singular_fixed64 = 0
      required_repeated_int32 = []
      required_repeated_int64 = []
      required_repeated_float = []
      required_repeated_double = []
      required_repeated_bool = []
      required_repeated_enum = []
      required_repeated_string = []
      required_repeated_bytes = []
      required_repeated_message = []
      formatted_required_repeated_resource_name = []
      formatted_required_repeated_resource_name_oneof = []
      required_repeated_fixed32 = []
      required_repeated_fixed64 = []
      required_map = {}

      # Mock Grpc layer
      mock_method = proc do |request|
        assert_instance_of(Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest, request)
        assert_equal(required_singular_int32, request.required_singular_int32)
        assert_equal(required_singular_int64, request.required_singular_int64)
        assert_equal(required_singular_float, request.required_singular_float)
        assert_equal(required_singular_double, request.required_singular_double)
        assert_equal(required_singular_bool, request.required_singular_bool)
        assert_equal(required_singular_enum, request.required_singular_enum)
        assert_equal(required_singular_string, request.required_singular_string)
        assert_equal(required_singular_bytes, request.required_singular_bytes)
        assert_equal(Google::Gax::to_proto(required_singular_message, Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerMessage), request.required_singular_message)
        assert_equal(required_singular_resource_name, request.required_singular_resource_name)
        assert_equal(required_singular_resource_name_oneof, request.required_singular_resource_name_oneof)
        assert_equal(required_singular_fixed32, request.required_singular_fixed32)
        assert_equal(required_singular_fixed64, request.required_singular_fixed64)
        assert_equal(required_repeated_int32, request.required_repeated_int32)
        assert_equal(required_repeated_int64, request.required_repeated_int64)
        assert_equal(required_repeated_float, request.required_repeated_float)
        assert_equal(required_repeated_double, request.required_repeated_double)
        assert_equal(required_repeated_bool, request.required_repeated_bool)
        assert_equal(required_repeated_enum, request.required_repeated_enum)
        assert_equal(required_repeated_string, request.required_repeated_string)
        assert_equal(required_repeated_bytes, request.required_repeated_bytes)
        required_repeated_message = required_repeated_message.map do |req|
          Google::Gax::to_proto(req, Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::InnerMessage)
        end
        assert_equal(required_repeated_message, request.required_repeated_message)
        assert_equal(formatted_required_repeated_resource_name, request.required_repeated_resource_name)
        assert_equal(formatted_required_repeated_resource_name_oneof, request.required_repeated_resource_name_oneof)
        assert_equal(required_repeated_fixed32, request.required_repeated_fixed32)
        assert_equal(required_repeated_fixed64, request.required_repeated_fixed64)
        assert_equal(Google::Gax::to_proto(required_map, Google::Example::Library::V1::TestOptionalRequiredFlatteningParamsRequest::RequiredMapEntry), request.required_map)
        raise custom_error
      end
      mock_stub = MockGrpcClientStub.new(:test_optional_required_flattening_params, mock_method)

      # Mock auth layer
      mock_credentials = MockLibraryServiceCredentials.new("test_optional_required_flattening_params")

      Google::Example::Library::V1::LibraryService::Stub.stub(:new, mock_stub) do
        Library::Credentials.stub(:default, mock_credentials) do
          client = Library.new(version: :v1)

          # Call method
          err = assert_raises Google::Gax::GaxError do
            client.test_optional_required_flattening_params(
              required_singular_int32,
              required_singular_int64,
              required_singular_float,
              required_singular_double,
              required_singular_bool,
              required_singular_enum,
              required_singular_string,
              required_singular_bytes,
              required_singular_message,
              required_singular_resource_name,
              required_singular_resource_name_oneof,
              required_singular_fixed32,
              required_singular_fixed64,
              required_repeated_int32,
              required_repeated_int64,
              required_repeated_float,
              required_repeated_double,
              required_repeated_bool,
              required_repeated_enum,
              required_repeated_string,
              required_repeated_bytes,
              required_repeated_message,
              formatted_required_repeated_resource_name,
              formatted_required_repeated_resource_name_oneof,
              required_repeated_fixed32,
              required_repeated_fixed64,
              required_map
            )
          end

          # Verify the GaxError wrapped the custom error that was raised.
          assert_match(custom_error.message, err.message)
        end
      end
    end
  end
end
============== file: test/library/v1/library_service_smoke_test.rb ==============
# Copyright 2017, Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# AUTO GENERATED BY GAPIC

require "minitest/autorun"
require "minitest/spec"

require "library"

describe "LibraryServiceSmokeTest" do
  it "runs one smoke test with update_book" do
    unless ENV["SMOKE_TEST_PROJECT"]
      fail "Usage: SMOKE_TEST_PROJECT=<project_id> ruby #{$0}"
    end
    project_id = ENV["SMOKE_TEST_PROJECT"].freeze

    library_service_client = Library.new
    formatted_name = Library::V1::LibraryServiceClient.book_path("testShelf-" + Time.new.to_i.to_s, project_id)
    optional_foo = ''
    rating = :GOOD
    book = { rating: rating }
    update_mask = {}
    physical_mask = {}
    response = library_service_client.update_book(formatted_name, book, optional_foo: optional_foo, update_mask: update_mask, physical_mask: physical_mask)
  end
end
