============== file: src/main/java/com/google/cloud/fakebilling/v1/AttachedDisk.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.core.ApiMessage;
import com.google.common.collect.ImmutableList;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class AttachedDisk implements ApiMessage {
  private final Integer index;
  private final Interface interface2;
  private final List<String> licenses;
  private final String mode;
  private final String type;

  private AttachedDisk(
      Integer index,
      Interface interface2,
      List<String> licenses,
      String mode,
      String type
      ) {
    this.index = index;
    this.interface2 = interface2;
    this.licenses = licenses;
    this.mode = mode;
    this.type = type;
  }

  @Override
  public Map<String, List<String>> populateFieldsInMap(Set<String> fieldNames) {
    Map<String, List<String>> fieldMap = new HashMap<>();
    if (fieldNames.contains("index")) {
      fieldMap.put("index", Collections.singletonList(String.valueOf(index)));
    }
    if (fieldNames.contains("interface2")) {
      fieldMap.put("interface2", Collections.singletonList(String.valueOf(interface2)));
    }
    if (fieldNames.contains("licenses")) {
      fieldMap.put("licenses", Collections.singletonList(String.valueOf(licenses)));
    }
    if (fieldNames.contains("mode")) {
      fieldMap.put("mode", Collections.singletonList(String.valueOf(mode)));
    }
    if (fieldNames.contains("type")) {
      fieldMap.put("type", Collections.singletonList(String.valueOf(type)));
    }
    return fieldMap;
  }

  public Integer getIndex() {
    return index;
  }

  public Interface getInterface() {
    return interface2;
  }

  public List<String> getLicenses() {
    return licenses;
  }

  public String getMode() {
    return mode;
  }

  public String getType() {
    return type;
  }


  public static Builder newBuilder() {
    return new AttachedDisk.Builder();
  }

  public static class Builder {
    private Integer index;
    private Interface interface2;
    private List<String> licenses;
    private String mode;
    private String type;

    Builder() {}

    Builder(AttachedDisk source) {
      this.index = source.index;
      this.interface2 = source.interface2;
      this.licenses = source.licenses;
      this.mode = source.mode;
      this.type = source.type;
    }

    public Integer getIndex() {
      return index;
    }

    public Builder setIndex(Integer index) {
      this.index = index;
      return this;
    }

    public Interface getInterface() {
      return interface2;
    }

    public Builder setInterface(Interface interface2) {
      this.interface2 = interface2;
      return this;
    }

    public List<String> getLicenses() {
      return licenses;
    }

    public Builder setLicenses(List<String> licenses) {
      this.licenses = licenses;
      return this;
    }

    public String getMode() {
      return mode;
    }

    public Builder setMode(String mode) {
      this.mode = mode;
      return this;
    }

    public String getType() {
      return type;
    }

    public Builder setType(String type) {
      this.type = type;
      return this;
    }


    public AttachedDisk build() {




      return new AttachedDisk(
        index,
        interface2,
        licenses,
        mode,
        type
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setIndex(this.index);
      newBuilder.setInterface(this.interface2);
      newBuilder.setLicenses(this.licenses);
      newBuilder.setMode(this.mode);
      newBuilder.setType(this.type);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "AttachedDisk{"
        + "index=" + index + ", "
        + "interface2=" + interface2 + ", "
        + "licenses=" + licenses + ", "
        + "mode=" + mode + ", "
        + "type=" + type
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof AttachedDisk) {
      AttachedDisk that = (AttachedDisk) o;
      return
          Objects.equals(this.index, that.getIndex()) &&
          Objects.equals(this.interface2, that.getInterface()) &&
          Objects.equals(this.licenses, that.getLicenses()) &&
          Objects.equals(this.mode, that.getMode()) &&
          Objects.equals(this.type, that.getType())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      index,
      interface2,
      licenses,
      mode,
      type
    );
  }
}

============== file: src/main/java/com/google/cloud/fakebilling/v1/BillingAccount.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.core.ApiMessage;
import com.google.common.collect.ImmutableList;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class BillingAccount implements ApiMessage {
  private final String name;
  private final Boolean open;

  private BillingAccount(
      String name,
      Boolean open
      ) {
    this.name = name;
    this.open = open;
  }

  @Override
  public Map<String, List<String>> populateFieldsInMap(Set<String> fieldNames) {
    Map<String, List<String>> fieldMap = new HashMap<>();
    if (fieldNames.contains("name")) {
      fieldMap.put("name", Collections.singletonList(String.valueOf(name)));
    }
    if (fieldNames.contains("open")) {
      fieldMap.put("open", Collections.singletonList(String.valueOf(open)));
    }
    return fieldMap;
  }

  public String getName() {
    return name;
  }

  public Boolean getOpen() {
    return open;
  }


  public static Builder newBuilder() {
    return new BillingAccount.Builder();
  }

  public static class Builder {
    private String name;
    private Boolean open;

    Builder() {}

    Builder(BillingAccount source) {
      this.name = source.name;
      this.open = source.open;
    }

    public String getName() {
      return name;
    }

    public Builder setName(String name) {
      this.name = name;
      return this;
    }

    public Boolean getOpen() {
      return open;
    }

    public Builder setOpen(Boolean open) {
      this.open = open;
      return this;
    }


    public BillingAccount build() {

      return new BillingAccount(
        name,
        open
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setName(this.name);
      newBuilder.setOpen(this.open);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "BillingAccount{"
        + "name=" + name + ", "
        + "open=" + open
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof BillingAccount) {
      BillingAccount that = (BillingAccount) o;
      return
          Objects.equals(this.name, that.getName()) &&
          Objects.equals(this.open, that.getOpen())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      name,
      open
    );
  }
}

============== file: src/main/java/com/google/cloud/fakebilling/v1/Data.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.core.ApiMessage;
import com.google.common.collect.ImmutableList;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class Data implements ApiMessage {
  private final String key;
  private final String value;

  private Data(
      String key,
      String value
      ) {
    this.key = key;
    this.value = value;
  }

  @Override
  public Map<String, List<String>> populateFieldsInMap(Set<String> fieldNames) {
    Map<String, List<String>> fieldMap = new HashMap<>();
    if (fieldNames.contains("key")) {
      fieldMap.put("key", Collections.singletonList(String.valueOf(key)));
    }
    if (fieldNames.contains("value")) {
      fieldMap.put("value", Collections.singletonList(String.valueOf(value)));
    }
    return fieldMap;
  }

  public String getKey() {
    return key;
  }

  public String getValue() {
    return value;
  }


  public static Builder newBuilder() {
    return new Data.Builder();
  }

  public static class Builder {
    private String key;
    private String value;

    Builder() {}

    Builder(Data source) {
      this.key = source.key;
      this.value = source.value;
    }

    public String getKey() {
      return key;
    }

    public Builder setKey(String key) {
      this.key = key;
      return this;
    }

    public String getValue() {
      return value;
    }

    public Builder setValue(String value) {
      this.value = value;
      return this;
    }


    public Data build() {

      return new Data(
        key,
        value
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setKey(this.key);
      newBuilder.setValue(this.value);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "Data{"
        + "key=" + key + ", "
        + "value=" + value
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof Data) {
      Data that = (Data) o;
      return
          Objects.equals(this.key, that.getKey()) &&
          Objects.equals(this.value, that.getValue())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      key,
      value
    );
  }
}

============== file: src/main/java/com/google/cloud/fakebilling/v1/Error.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.core.ApiMessage;
import com.google.common.collect.ImmutableList;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class Error implements ApiMessage {
  private final List<Errors> errors;

  private Error(
      List<Errors> errors
      ) {
    this.errors = errors;
  }

  @Override
  public Map<String, List<String>> populateFieldsInMap(Set<String> fieldNames) {
    Map<String, List<String>> fieldMap = new HashMap<>();
    if (fieldNames.contains("errors")) {
      fieldMap.put("errors", Collections.singletonList(String.valueOf(errors)));
    }
    return fieldMap;
  }

  public List<Errors> getErrors() {
    return errors;
  }


  public static Builder newBuilder() {
    return new Error.Builder();
  }

  public static class Builder {
    private List<Errors> errors;

    Builder() {}

    Builder(Error source) {
      this.errors = source.errors;
    }

    public List<Errors> getErrors() {
      return errors;
    }

    public Builder setErrors(List<Errors> errors) {
      this.errors = errors;
      return this;
    }


    public Error build() {
      return new Error(
        errors
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setErrors(this.errors);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "Error{"
        + "errors=" + errors
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof Error) {
      Error that = (Error) o;
      return
          Objects.equals(this.errors, that.getErrors())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      errors
    );
  }
}

============== file: src/main/java/com/google/cloud/fakebilling/v1/Errors.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.core.ApiMessage;
import com.google.common.collect.ImmutableList;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class Errors implements ApiMessage {
  private final String code;
  private final String location;
  private final String message;

  private Errors(
      String code,
      String location,
      String message
      ) {
    this.code = code;
    this.location = location;
    this.message = message;
  }

  @Override
  public Map<String, List<String>> populateFieldsInMap(Set<String> fieldNames) {
    Map<String, List<String>> fieldMap = new HashMap<>();
    if (fieldNames.contains("code")) {
      fieldMap.put("code", Collections.singletonList(String.valueOf(code)));
    }
    if (fieldNames.contains("location")) {
      fieldMap.put("location", Collections.singletonList(String.valueOf(location)));
    }
    if (fieldNames.contains("message")) {
      fieldMap.put("message", Collections.singletonList(String.valueOf(message)));
    }
    return fieldMap;
  }

  public String getCode() {
    return code;
  }

  public String getLocation() {
    return location;
  }

  public String getMessage() {
    return message;
  }


  public static Builder newBuilder() {
    return new Errors.Builder();
  }

  public static class Builder {
    private String code;
    private String location;
    private String message;

    Builder() {}

    Builder(Errors source) {
      this.code = source.code;
      this.location = source.location;
      this.message = source.message;
    }

    public String getCode() {
      return code;
    }

    public Builder setCode(String code) {
      this.code = code;
      return this;
    }

    public String getLocation() {
      return location;
    }

    public Builder setLocation(String location) {
      this.location = location;
      return this;
    }

    public String getMessage() {
      return message;
    }

    public Builder setMessage(String message) {
      this.message = message;
      return this;
    }


    public Errors build() {


      return new Errors(
        code,
        location,
        message
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setCode(this.code);
      newBuilder.setLocation(this.location);
      newBuilder.setMessage(this.message);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "Errors{"
        + "code=" + code + ", "
        + "location=" + location + ", "
        + "message=" + message
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof Errors) {
      Errors that = (Errors) o;
      return
          Objects.equals(this.code, that.getCode()) &&
          Objects.equals(this.location, that.getLocation()) &&
          Objects.equals(this.message, that.getMessage())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      code,
      location,
      message
    );
  }
}

============== file: src/main/java/com/google/cloud/fakebilling/v1/Interface.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.core.ApiMessage;
import com.google.common.collect.ImmutableList;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class Interface implements ApiMessage {
  private final String face;
  private final Boolean inter;
  private final String interface2;

  private Interface(
      String face,
      Boolean inter,
      String interface2
      ) {
    this.face = face;
    this.inter = inter;
    this.interface2 = interface2;
  }

  @Override
  public Map<String, List<String>> populateFieldsInMap(Set<String> fieldNames) {
    Map<String, List<String>> fieldMap = new HashMap<>();
    if (fieldNames.contains("face")) {
      fieldMap.put("face", Collections.singletonList(String.valueOf(face)));
    }
    if (fieldNames.contains("inter")) {
      fieldMap.put("inter", Collections.singletonList(String.valueOf(inter)));
    }
    if (fieldNames.contains("interface2")) {
      fieldMap.put("interface2", Collections.singletonList(String.valueOf(interface2)));
    }
    return fieldMap;
  }

  public String getFace() {
    return face;
  }

  public Boolean getInter() {
    return inter;
  }

  public String getInterface() {
    return interface2;
  }


  public static Builder newBuilder() {
    return new Interface.Builder();
  }

  public static class Builder {
    private String face;
    private Boolean inter;
    private String interface2;

    Builder() {}

    Builder(Interface source) {
      this.face = source.face;
      this.inter = source.inter;
      this.interface2 = source.interface2;
    }

    public String getFace() {
      return face;
    }

    public Builder setFace(String face) {
      this.face = face;
      return this;
    }

    public Boolean getInter() {
      return inter;
    }

    public Builder setInter(Boolean inter) {
      this.inter = inter;
      return this;
    }

    public String getInterface() {
      return interface2;
    }

    public Builder setInterface(String interface2) {
      this.interface2 = interface2;
      return this;
    }


    public Interface build() {


      return new Interface(
        face,
        inter,
        interface2
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setFace(this.face);
      newBuilder.setInter(this.inter);
      newBuilder.setInterface(this.interface2);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "Interface{"
        + "face=" + face + ", "
        + "inter=" + inter + ", "
        + "interface2=" + interface2
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof Interface) {
      Interface that = (Interface) o;
      return
          Objects.equals(this.face, that.getFace()) &&
          Objects.equals(this.inter, that.getInter()) &&
          Objects.equals(this.interface2, that.getInterface())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      face,
      inter,
      interface2
    );
  }
}

============== file: src/main/java/com/google/cloud/fakebilling/v1/ListBillingAccountsResponse.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.core.ApiMessage;
import com.google.common.collect.ImmutableList;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class ListBillingAccountsResponse implements ApiMessage {
  private final List<BillingAccount> billingAccounts;
  private final String nextPageToken;

  private ListBillingAccountsResponse(
      List<BillingAccount> billingAccounts,
      String nextPageToken
      ) {
    this.billingAccounts = billingAccounts;
    this.nextPageToken = nextPageToken;
  }

  @Override
  public Map<String, List<String>> populateFieldsInMap(Set<String> fieldNames) {
    Map<String, List<String>> fieldMap = new HashMap<>();
    if (fieldNames.contains("billingAccounts")) {
      fieldMap.put("billingAccounts", Collections.singletonList(String.valueOf(billingAccounts)));
    }
    if (fieldNames.contains("nextPageToken")) {
      fieldMap.put("nextPageToken", Collections.singletonList(String.valueOf(nextPageToken)));
    }
    return fieldMap;
  }

  public List<BillingAccount> getBillingAccounts() {
    return billingAccounts;
  }

  public String getNextPageToken() {
    return nextPageToken;
  }


  public static Builder newBuilder() {
    return new ListBillingAccountsResponse.Builder();
  }

  public static class Builder {
    private List<BillingAccount> billingAccounts;
    private String nextPageToken;

    Builder() {}

    Builder(ListBillingAccountsResponse source) {
      this.billingAccounts = source.billingAccounts;
      this.nextPageToken = source.nextPageToken;
    }

    public List<BillingAccount> getBillingAccounts() {
      return billingAccounts;
    }

    public Builder setBillingAccounts(List<BillingAccount> billingAccounts) {
      this.billingAccounts = billingAccounts;
      return this;
    }

    public String getNextPageToken() {
      return nextPageToken;
    }

    public Builder setNextPageToken(String nextPageToken) {
      this.nextPageToken = nextPageToken;
      return this;
    }


    public ListBillingAccountsResponse build() {

      return new ListBillingAccountsResponse(
        billingAccounts,
        nextPageToken
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setBillingAccounts(this.billingAccounts);
      newBuilder.setNextPageToken(this.nextPageToken);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "ListBillingAccountsResponse{"
        + "billingAccounts=" + billingAccounts + ", "
        + "nextPageToken=" + nextPageToken
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof ListBillingAccountsResponse) {
      ListBillingAccountsResponse that = (ListBillingAccountsResponse) o;
      return
          Objects.equals(this.billingAccounts, that.getBillingAccounts()) &&
          Objects.equals(this.nextPageToken, that.getNextPageToken())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      billingAccounts,
      nextPageToken
    );
  }
}

============== file: src/main/java/com/google/cloud/fakebilling/v1/ListProjectBillingInfoResponse.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.core.ApiMessage;
import com.google.common.collect.ImmutableList;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class ListProjectBillingInfoResponse implements ApiMessage {
  private final String nextPageToken;
  private final List<ProjectBillingInfo> projectBillingInfo;

  private ListProjectBillingInfoResponse(
      String nextPageToken,
      List<ProjectBillingInfo> projectBillingInfo
      ) {
    this.nextPageToken = nextPageToken;
    this.projectBillingInfo = projectBillingInfo;
  }

  @Override
  public Map<String, List<String>> populateFieldsInMap(Set<String> fieldNames) {
    Map<String, List<String>> fieldMap = new HashMap<>();
    if (fieldNames.contains("nextPageToken")) {
      fieldMap.put("nextPageToken", Collections.singletonList(String.valueOf(nextPageToken)));
    }
    if (fieldNames.contains("projectBillingInfo")) {
      fieldMap.put("projectBillingInfo", Collections.singletonList(String.valueOf(projectBillingInfo)));
    }
    return fieldMap;
  }

  public String getNextPageToken() {
    return nextPageToken;
  }

  public List<ProjectBillingInfo> getProjectBillingInfo() {
    return projectBillingInfo;
  }


  public static Builder newBuilder() {
    return new ListProjectBillingInfoResponse.Builder();
  }

  public static class Builder {
    private String nextPageToken;
    private List<ProjectBillingInfo> projectBillingInfo;

    Builder() {}

    Builder(ListProjectBillingInfoResponse source) {
      this.nextPageToken = source.nextPageToken;
      this.projectBillingInfo = source.projectBillingInfo;
    }

    public String getNextPageToken() {
      return nextPageToken;
    }

    public Builder setNextPageToken(String nextPageToken) {
      this.nextPageToken = nextPageToken;
      return this;
    }

    public List<ProjectBillingInfo> getProjectBillingInfo() {
      return projectBillingInfo;
    }

    public Builder setProjectBillingInfo(List<ProjectBillingInfo> projectBillingInfo) {
      this.projectBillingInfo = projectBillingInfo;
      return this;
    }


    public ListProjectBillingInfoResponse build() {

      return new ListProjectBillingInfoResponse(
        nextPageToken,
        projectBillingInfo
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setNextPageToken(this.nextPageToken);
      newBuilder.setProjectBillingInfo(this.projectBillingInfo);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "ListProjectBillingInfoResponse{"
        + "nextPageToken=" + nextPageToken + ", "
        + "projectBillingInfo=" + projectBillingInfo
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof ListProjectBillingInfoResponse) {
      ListProjectBillingInfoResponse that = (ListProjectBillingInfoResponse) o;
      return
          Objects.equals(this.nextPageToken, that.getNextPageToken()) &&
          Objects.equals(this.projectBillingInfo, that.getProjectBillingInfo())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      nextPageToken,
      projectBillingInfo
    );
  }
}

============== file: src/main/java/com/google/cloud/fakebilling/v1/Operation.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.core.ApiMessage;
import com.google.common.collect.ImmutableList;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class Operation implements ApiMessage {
  private final String creationTimestamp;
  private final String description;
  private final Error error;
  private final Integer httpErrorStatusCode;
  private final String id;
  private final String name;
  private final String status;
  private final List<Warnings> warnings;

  private Operation(
      String creationTimestamp,
      String description,
      Error error,
      Integer httpErrorStatusCode,
      String id,
      String name,
      String status,
      List<Warnings> warnings
      ) {
    this.creationTimestamp = creationTimestamp;
    this.description = description;
    this.error = error;
    this.httpErrorStatusCode = httpErrorStatusCode;
    this.id = id;
    this.name = name;
    this.status = status;
    this.warnings = warnings;
  }

  @Override
  public Map<String, List<String>> populateFieldsInMap(Set<String> fieldNames) {
    Map<String, List<String>> fieldMap = new HashMap<>();
    if (fieldNames.contains("creationTimestamp")) {
      fieldMap.put("creationTimestamp", Collections.singletonList(String.valueOf(creationTimestamp)));
    }
    if (fieldNames.contains("description")) {
      fieldMap.put("description", Collections.singletonList(String.valueOf(description)));
    }
    if (fieldNames.contains("error")) {
      fieldMap.put("error", Collections.singletonList(String.valueOf(error)));
    }
    if (fieldNames.contains("httpErrorStatusCode")) {
      fieldMap.put("httpErrorStatusCode", Collections.singletonList(String.valueOf(httpErrorStatusCode)));
    }
    if (fieldNames.contains("id")) {
      fieldMap.put("id", Collections.singletonList(String.valueOf(id)));
    }
    if (fieldNames.contains("name")) {
      fieldMap.put("name", Collections.singletonList(String.valueOf(name)));
    }
    if (fieldNames.contains("status")) {
      fieldMap.put("status", Collections.singletonList(String.valueOf(status)));
    }
    if (fieldNames.contains("warnings")) {
      fieldMap.put("warnings", Collections.singletonList(String.valueOf(warnings)));
    }
    return fieldMap;
  }

  public String getCreationTimestamp() {
    return creationTimestamp;
  }

  public String getDescription() {
    return description;
  }

  public Error getError() {
    return error;
  }

  public Integer getHttpErrorStatusCode() {
    return httpErrorStatusCode;
  }

  public String getId() {
    return id;
  }

  public String getName() {
    return name;
  }

  public String getStatus() {
    return status;
  }

  public List<Warnings> getWarnings() {
    return warnings;
  }


  public static Builder newBuilder() {
    return new Operation.Builder();
  }

  public static class Builder {
    private String creationTimestamp;
    private String description;
    private Error error;
    private Integer httpErrorStatusCode;
    private String id;
    private String name;
    private String status;
    private List<Warnings> warnings;

    Builder() {}

    Builder(Operation source) {
      this.creationTimestamp = source.creationTimestamp;
      this.description = source.description;
      this.error = source.error;
      this.httpErrorStatusCode = source.httpErrorStatusCode;
      this.id = source.id;
      this.name = source.name;
      this.status = source.status;
      this.warnings = source.warnings;
    }

    public String getCreationTimestamp() {
      return creationTimestamp;
    }

    public Builder setCreationTimestamp(String creationTimestamp) {
      this.creationTimestamp = creationTimestamp;
      return this;
    }

    public String getDescription() {
      return description;
    }

    public Builder setDescription(String description) {
      this.description = description;
      return this;
    }

    public Error getError() {
      return error;
    }

    public Builder setError(Error error) {
      this.error = error;
      return this;
    }

    public Integer getHttpErrorStatusCode() {
      return httpErrorStatusCode;
    }

    public Builder setHttpErrorStatusCode(Integer httpErrorStatusCode) {
      this.httpErrorStatusCode = httpErrorStatusCode;
      return this;
    }

    public String getId() {
      return id;
    }

    public Builder setId(String id) {
      this.id = id;
      return this;
    }

    public String getName() {
      return name;
    }

    public Builder setName(String name) {
      this.name = name;
      return this;
    }

    public String getStatus() {
      return status;
    }

    public Builder setStatus(String status) {
      this.status = status;
      return this;
    }

    public List<Warnings> getWarnings() {
      return warnings;
    }

    public Builder setWarnings(List<Warnings> warnings) {
      this.warnings = warnings;
      return this;
    }


    public Operation build() {







      return new Operation(
        creationTimestamp,
        description,
        error,
        httpErrorStatusCode,
        id,
        name,
        status,
        warnings
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setCreationTimestamp(this.creationTimestamp);
      newBuilder.setDescription(this.description);
      newBuilder.setError(this.error);
      newBuilder.setHttpErrorStatusCode(this.httpErrorStatusCode);
      newBuilder.setId(this.id);
      newBuilder.setName(this.name);
      newBuilder.setStatus(this.status);
      newBuilder.setWarnings(this.warnings);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "Operation{"
        + "creationTimestamp=" + creationTimestamp + ", "
        + "description=" + description + ", "
        + "error=" + error + ", "
        + "httpErrorStatusCode=" + httpErrorStatusCode + ", "
        + "id=" + id + ", "
        + "name=" + name + ", "
        + "status=" + status + ", "
        + "warnings=" + warnings
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof Operation) {
      Operation that = (Operation) o;
      return
          Objects.equals(this.creationTimestamp, that.getCreationTimestamp()) &&
          Objects.equals(this.description, that.getDescription()) &&
          Objects.equals(this.error, that.getError()) &&
          Objects.equals(this.httpErrorStatusCode, that.getHttpErrorStatusCode()) &&
          Objects.equals(this.id, that.getId()) &&
          Objects.equals(this.name, that.getName()) &&
          Objects.equals(this.status, that.getStatus()) &&
          Objects.equals(this.warnings, that.getWarnings())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      creationTimestamp,
      description,
      error,
      httpErrorStatusCode,
      id,
      name,
      status,
      warnings
    );
  }
}

============== file: src/main/java/com/google/cloud/fakebilling/v1/ProjectBillingInfo.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.core.ApiMessage;
import com.google.common.collect.ImmutableList;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class ProjectBillingInfo implements ApiMessage {
  private final Boolean billingEnabled;
  private final String projectId;

  private ProjectBillingInfo(
      Boolean billingEnabled,
      String projectId
      ) {
    this.billingEnabled = billingEnabled;
    this.projectId = projectId;
  }

  @Override
  public Map<String, List<String>> populateFieldsInMap(Set<String> fieldNames) {
    Map<String, List<String>> fieldMap = new HashMap<>();
    if (fieldNames.contains("billingEnabled")) {
      fieldMap.put("billingEnabled", Collections.singletonList(String.valueOf(billingEnabled)));
    }
    if (fieldNames.contains("projectId")) {
      fieldMap.put("projectId", Collections.singletonList(String.valueOf(projectId)));
    }
    return fieldMap;
  }

  public Boolean getBillingEnabled() {
    return billingEnabled;
  }

  public String getProjectId() {
    return projectId;
  }


  public static Builder newBuilder() {
    return new ProjectBillingInfo.Builder();
  }

  public static class Builder {
    private Boolean billingEnabled;
    private String projectId;

    Builder() {}

    Builder(ProjectBillingInfo source) {
      this.billingEnabled = source.billingEnabled;
      this.projectId = source.projectId;
    }

    public Boolean getBillingEnabled() {
      return billingEnabled;
    }

    public Builder setBillingEnabled(Boolean billingEnabled) {
      this.billingEnabled = billingEnabled;
      return this;
    }

    public String getProjectId() {
      return projectId;
    }

    public Builder setProjectId(String projectId) {
      this.projectId = projectId;
      return this;
    }


    public ProjectBillingInfo build() {

      return new ProjectBillingInfo(
        billingEnabled,
        projectId
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setBillingEnabled(this.billingEnabled);
      newBuilder.setProjectId(this.projectId);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "ProjectBillingInfo{"
        + "billingEnabled=" + billingEnabled + ", "
        + "projectId=" + projectId
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof ProjectBillingInfo) {
      ProjectBillingInfo that = (ProjectBillingInfo) o;
      return
          Objects.equals(this.billingEnabled, that.getBillingEnabled()) &&
          Objects.equals(this.projectId, that.getProjectId())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      billingEnabled,
      projectId
    );
  }
}

============== file: src/main/java/com/google/cloud/fakebilling/v1/Warnings.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.core.ApiMessage;
import com.google.common.collect.ImmutableList;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class Warnings implements ApiMessage {
  private final String code;
  private final List<Data> data;
  private final String message;
  private final ProjectBillingInfo projectBillingInfo;

  private Warnings(
      String code,
      List<Data> data,
      String message,
      ProjectBillingInfo projectBillingInfo
      ) {
    this.code = code;
    this.data = data;
    this.message = message;
    this.projectBillingInfo = projectBillingInfo;
  }

  @Override
  public Map<String, List<String>> populateFieldsInMap(Set<String> fieldNames) {
    Map<String, List<String>> fieldMap = new HashMap<>();
    if (fieldNames.contains("code")) {
      fieldMap.put("code", Collections.singletonList(String.valueOf(code)));
    }
    if (fieldNames.contains("data")) {
      fieldMap.put("data", Collections.singletonList(String.valueOf(data)));
    }
    if (fieldNames.contains("message")) {
      fieldMap.put("message", Collections.singletonList(String.valueOf(message)));
    }
    if (fieldNames.contains("projectBillingInfo")) {
      fieldMap.put("projectBillingInfo", Collections.singletonList(String.valueOf(projectBillingInfo)));
    }
    return fieldMap;
  }

  public String getCode() {
    return code;
  }

  public List<Data> getData() {
    return data;
  }

  public String getMessage() {
    return message;
  }

  public ProjectBillingInfo getProjectBillingInfo() {
    return projectBillingInfo;
  }


  public static Builder newBuilder() {
    return new Warnings.Builder();
  }

  public static class Builder {
    private String code;
    private List<Data> data;
    private String message;
    private ProjectBillingInfo projectBillingInfo;

    Builder() {}

    Builder(Warnings source) {
      this.code = source.code;
      this.data = source.data;
      this.message = source.message;
      this.projectBillingInfo = source.projectBillingInfo;
    }

    public String getCode() {
      return code;
    }

    public Builder setCode(String code) {
      this.code = code;
      return this;
    }

    public List<Data> getData() {
      return data;
    }

    public Builder setData(List<Data> data) {
      this.data = data;
      return this;
    }

    public String getMessage() {
      return message;
    }

    public Builder setMessage(String message) {
      this.message = message;
      return this;
    }

    public ProjectBillingInfo getProjectBillingInfo() {
      return projectBillingInfo;
    }

    public Builder setProjectBillingInfo(ProjectBillingInfo projectBillingInfo) {
      this.projectBillingInfo = projectBillingInfo;
      return this;
    }


    public Warnings build() {



      return new Warnings(
        code,
        data,
        message,
        projectBillingInfo
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setCode(this.code);
      newBuilder.setData(this.data);
      newBuilder.setMessage(this.message);
      newBuilder.setProjectBillingInfo(this.projectBillingInfo);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "Warnings{"
        + "code=" + code + ", "
        + "data=" + data + ", "
        + "message=" + message + ", "
        + "projectBillingInfo=" + projectBillingInfo
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof Warnings) {
      Warnings that = (Warnings) o;
      return
          Objects.equals(this.code, that.getCode()) &&
          Objects.equals(this.data, that.getData()) &&
          Objects.equals(this.message, that.getMessage()) &&
          Objects.equals(this.projectBillingInfo, that.getProjectBillingInfo())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      code,
      data,
      message,
      projectBillingInfo
    );
  }
}

============== file: src/main/java/com/google/cloud/fakebilling/v1/BillingAccountsGetHttpRequest.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.core.ApiMessage;
import com.google.common.collect.ImmutableList;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class BillingAccountsGetHttpRequest implements ApiMessage {
  private final String access_token;
  private final String callback;
  private final String fields;
  private final List<String> fooRepeated;
  private final String key;
  private final String name;
  private final String prettyPrint;
  private final String quotaUser;
  private final String userIp;

  private BillingAccountsGetHttpRequest(
      String access_token,
      String callback,
      String fields,
      List<String> fooRepeated,
      String key,
      String name,
      String prettyPrint,
      String quotaUser,
      String userIp
      ) {
    this.access_token = access_token;
    this.callback = callback;
    this.fields = fields;
    this.fooRepeated = fooRepeated;
    this.key = key;
    this.name = name;
    this.prettyPrint = prettyPrint;
    this.quotaUser = quotaUser;
    this.userIp = userIp;
  }

  @Override
  public Map<String, List<String>> populateFieldsInMap(Set<String> fieldNames) {
    Map<String, List<String>> fieldMap = new HashMap<>();
    if (fieldNames.contains("access_token")) {
      fieldMap.put("access_token", Collections.singletonList(String.valueOf(access_token)));
    }
    if (fieldNames.contains("callback")) {
      fieldMap.put("callback", Collections.singletonList(String.valueOf(callback)));
    }
    if (fieldNames.contains("fields")) {
      fieldMap.put("fields", Collections.singletonList(String.valueOf(fields)));
    }
    if (fieldNames.contains("fooRepeated")) {
      fieldMap.put("fooRepeated", fooRepeated);
    }
    if (fieldNames.contains("key")) {
      fieldMap.put("key", Collections.singletonList(String.valueOf(key)));
    }
    if (fieldNames.contains("name")) {
      fieldMap.put("name", Collections.singletonList(String.valueOf(name)));
    }
    if (fieldNames.contains("prettyPrint")) {
      fieldMap.put("prettyPrint", Collections.singletonList(String.valueOf(prettyPrint)));
    }
    if (fieldNames.contains("quotaUser")) {
      fieldMap.put("quotaUser", Collections.singletonList(String.valueOf(quotaUser)));
    }
    if (fieldNames.contains("userIp")) {
      fieldMap.put("userIp", Collections.singletonList(String.valueOf(userIp)));
    }
    return fieldMap;
  }

  public String getAccessToken() {
    return access_token;
  }

  public String getCallback() {
    return callback;
  }

  public String getFields() {
    return fields;
  }

  public List<String> getFooRepeated() {
    return fooRepeated;
  }

  public String getKey() {
    return key;
  }

  public String getName() {
    return name;
  }

  public String getPrettyPrint() {
    return prettyPrint;
  }

  public String getQuotaUser() {
    return quotaUser;
  }

  public String getUserIp() {
    return userIp;
  }


  public static Builder newBuilder() {
    return new BillingAccountsGetHttpRequest.Builder();
  }

  public static class Builder {
    private String access_token;
    private String callback;
    private String fields;
    private List<String> fooRepeated;
    private String key;
    private String name;
    private String prettyPrint;
    private String quotaUser;
    private String userIp;

    Builder() {}

    Builder(BillingAccountsGetHttpRequest source) {
      this.access_token = source.access_token;
      this.callback = source.callback;
      this.fields = source.fields;
      this.fooRepeated = source.fooRepeated;
      this.key = source.key;
      this.name = source.name;
      this.prettyPrint = source.prettyPrint;
      this.quotaUser = source.quotaUser;
      this.userIp = source.userIp;
    }

    public String getAccessToken() {
      return access_token;
    }

    public Builder setAccessToken(String access_token) {
      this.access_token = access_token;
      return this;
    }

    public String getCallback() {
      return callback;
    }

    public Builder setCallback(String callback) {
      this.callback = callback;
      return this;
    }

    public String getFields() {
      return fields;
    }

    public Builder setFields(String fields) {
      this.fields = fields;
      return this;
    }

    public List<String> getFooRepeated() {
      return fooRepeated;
    }

    public Builder setFooRepeated(List<String> fooRepeated) {
      this.fooRepeated = fooRepeated;
      return this;
    }

    public String getKey() {
      return key;
    }

    public Builder setKey(String key) {
      this.key = key;
      return this;
    }

    public String getName() {
      return name;
    }

    public Builder setName(String name) {
      this.name = name;
      return this;
    }

    public String getPrettyPrint() {
      return prettyPrint;
    }

    public Builder setPrettyPrint(String prettyPrint) {
      this.prettyPrint = prettyPrint;
      return this;
    }

    public String getQuotaUser() {
      return quotaUser;
    }

    public Builder setQuotaUser(String quotaUser) {
      this.quotaUser = quotaUser;
      return this;
    }

    public String getUserIp() {
      return userIp;
    }

    public Builder setUserIp(String userIp) {
      this.userIp = userIp;
      return this;
    }


    public BillingAccountsGetHttpRequest build() {
      String missing = "";





      if (name == null) {
        missing += " name";
      }



      if (!missing.isEmpty()) {
        throw new IllegalStateException("Missing required properties:" + missing);
      }
      return new BillingAccountsGetHttpRequest(
        access_token,
        callback,
        fields,
        fooRepeated,
        key,
        name,
        prettyPrint,
        quotaUser,
        userIp
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setAccessToken(this.access_token);
      newBuilder.setCallback(this.callback);
      newBuilder.setFields(this.fields);
      newBuilder.setFooRepeated(this.fooRepeated);
      newBuilder.setKey(this.key);
      newBuilder.setName(this.name);
      newBuilder.setPrettyPrint(this.prettyPrint);
      newBuilder.setQuotaUser(this.quotaUser);
      newBuilder.setUserIp(this.userIp);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "BillingAccountsGetHttpRequest{"
        + "access_token=" + access_token + ", "
        + "callback=" + callback + ", "
        + "fields=" + fields + ", "
        + "fooRepeated=" + fooRepeated + ", "
        + "key=" + key + ", "
        + "name=" + name + ", "
        + "prettyPrint=" + prettyPrint + ", "
        + "quotaUser=" + quotaUser + ", "
        + "userIp=" + userIp
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof BillingAccountsGetHttpRequest) {
      BillingAccountsGetHttpRequest that = (BillingAccountsGetHttpRequest) o;
      return
          Objects.equals(this.access_token, that.getAccessToken()) &&
          Objects.equals(this.callback, that.getCallback()) &&
          Objects.equals(this.fields, that.getFields()) &&
          Objects.equals(this.fooRepeated, that.getFooRepeated()) &&
          Objects.equals(this.key, that.getKey()) &&
          Objects.equals(this.name, that.getName()) &&
          Objects.equals(this.prettyPrint, that.getPrettyPrint()) &&
          Objects.equals(this.quotaUser, that.getQuotaUser()) &&
          Objects.equals(this.userIp, that.getUserIp())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      access_token,
      callback,
      fields,
      fooRepeated,
      key,
      name,
      prettyPrint,
      quotaUser,
      userIp
    );
  }
}

============== file: src/main/java/com/google/cloud/fakebilling/v1/BillingAccountsListHttpRequest.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.core.ApiMessage;
import com.google.common.collect.ImmutableList;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class BillingAccountsListHttpRequest implements ApiMessage {
  private final String access_token;
  private final String callback;
  private final String fields;
  private final String key;
  private final Long maxResults;
  private final Integer pageSize;
  private final String pageToken;
  private final String prettyPrint;
  private final String quotaUser;
  private final String userIp;

  private BillingAccountsListHttpRequest(
      String access_token,
      String callback,
      String fields,
      String key,
      Long maxResults,
      Integer pageSize,
      String pageToken,
      String prettyPrint,
      String quotaUser,
      String userIp
      ) {
    this.access_token = access_token;
    this.callback = callback;
    this.fields = fields;
    this.key = key;
    this.maxResults = maxResults;
    this.pageSize = pageSize;
    this.pageToken = pageToken;
    this.prettyPrint = prettyPrint;
    this.quotaUser = quotaUser;
    this.userIp = userIp;
  }

  @Override
  public Map<String, List<String>> populateFieldsInMap(Set<String> fieldNames) {
    Map<String, List<String>> fieldMap = new HashMap<>();
    if (fieldNames.contains("access_token")) {
      fieldMap.put("access_token", Collections.singletonList(String.valueOf(access_token)));
    }
    if (fieldNames.contains("callback")) {
      fieldMap.put("callback", Collections.singletonList(String.valueOf(callback)));
    }
    if (fieldNames.contains("fields")) {
      fieldMap.put("fields", Collections.singletonList(String.valueOf(fields)));
    }
    if (fieldNames.contains("key")) {
      fieldMap.put("key", Collections.singletonList(String.valueOf(key)));
    }
    if (fieldNames.contains("maxResults")) {
      fieldMap.put("maxResults", Collections.singletonList(String.valueOf(maxResults)));
    }
    if (fieldNames.contains("pageSize")) {
      fieldMap.put("pageSize", Collections.singletonList(String.valueOf(pageSize)));
    }
    if (fieldNames.contains("pageToken")) {
      fieldMap.put("pageToken", Collections.singletonList(String.valueOf(pageToken)));
    }
    if (fieldNames.contains("prettyPrint")) {
      fieldMap.put("prettyPrint", Collections.singletonList(String.valueOf(prettyPrint)));
    }
    if (fieldNames.contains("quotaUser")) {
      fieldMap.put("quotaUser", Collections.singletonList(String.valueOf(quotaUser)));
    }
    if (fieldNames.contains("userIp")) {
      fieldMap.put("userIp", Collections.singletonList(String.valueOf(userIp)));
    }
    return fieldMap;
  }

  public String getAccessToken() {
    return access_token;
  }

  public String getCallback() {
    return callback;
  }

  public String getFields() {
    return fields;
  }

  public String getKey() {
    return key;
  }

  public Long getMaxResults() {
    return maxResults;
  }

  public Integer getPageSize() {
    return pageSize;
  }

  public String getPageToken() {
    return pageToken;
  }

  public String getPrettyPrint() {
    return prettyPrint;
  }

  public String getQuotaUser() {
    return quotaUser;
  }

  public String getUserIp() {
    return userIp;
  }


  public static Builder newBuilder() {
    return new BillingAccountsListHttpRequest.Builder();
  }

  public static class Builder {
    private String access_token;
    private String callback;
    private String fields;
    private String key;
    private Long maxResults;
    private Integer pageSize;
    private String pageToken;
    private String prettyPrint;
    private String quotaUser;
    private String userIp;

    Builder() {}

    Builder(BillingAccountsListHttpRequest source) {
      this.access_token = source.access_token;
      this.callback = source.callback;
      this.fields = source.fields;
      this.key = source.key;
      this.maxResults = source.maxResults;
      this.pageSize = source.pageSize;
      this.pageToken = source.pageToken;
      this.prettyPrint = source.prettyPrint;
      this.quotaUser = source.quotaUser;
      this.userIp = source.userIp;
    }

    public String getAccessToken() {
      return access_token;
    }

    public Builder setAccessToken(String access_token) {
      this.access_token = access_token;
      return this;
    }

    public String getCallback() {
      return callback;
    }

    public Builder setCallback(String callback) {
      this.callback = callback;
      return this;
    }

    public String getFields() {
      return fields;
    }

    public Builder setFields(String fields) {
      this.fields = fields;
      return this;
    }

    public String getKey() {
      return key;
    }

    public Builder setKey(String key) {
      this.key = key;
      return this;
    }

    public Long getMaxResults() {
      return maxResults;
    }

    public Builder setMaxResults(Long maxResults) {
      this.maxResults = maxResults;
      return this;
    }

    public Integer getPageSize() {
      return pageSize;
    }

    public Builder setPageSize(Integer pageSize) {
      this.pageSize = pageSize;
      return this;
    }

    public String getPageToken() {
      return pageToken;
    }

    public Builder setPageToken(String pageToken) {
      this.pageToken = pageToken;
      return this;
    }

    public String getPrettyPrint() {
      return prettyPrint;
    }

    public Builder setPrettyPrint(String prettyPrint) {
      this.prettyPrint = prettyPrint;
      return this;
    }

    public String getQuotaUser() {
      return quotaUser;
    }

    public Builder setQuotaUser(String quotaUser) {
      this.quotaUser = quotaUser;
      return this;
    }

    public String getUserIp() {
      return userIp;
    }

    public Builder setUserIp(String userIp) {
      this.userIp = userIp;
      return this;
    }


    public BillingAccountsListHttpRequest build() {









      return new BillingAccountsListHttpRequest(
        access_token,
        callback,
        fields,
        key,
        maxResults,
        pageSize,
        pageToken,
        prettyPrint,
        quotaUser,
        userIp
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setAccessToken(this.access_token);
      newBuilder.setCallback(this.callback);
      newBuilder.setFields(this.fields);
      newBuilder.setKey(this.key);
      newBuilder.setMaxResults(this.maxResults);
      newBuilder.setPageSize(this.pageSize);
      newBuilder.setPageToken(this.pageToken);
      newBuilder.setPrettyPrint(this.prettyPrint);
      newBuilder.setQuotaUser(this.quotaUser);
      newBuilder.setUserIp(this.userIp);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "BillingAccountsListHttpRequest{"
        + "access_token=" + access_token + ", "
        + "callback=" + callback + ", "
        + "fields=" + fields + ", "
        + "key=" + key + ", "
        + "maxResults=" + maxResults + ", "
        + "pageSize=" + pageSize + ", "
        + "pageToken=" + pageToken + ", "
        + "prettyPrint=" + prettyPrint + ", "
        + "quotaUser=" + quotaUser + ", "
        + "userIp=" + userIp
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof BillingAccountsListHttpRequest) {
      BillingAccountsListHttpRequest that = (BillingAccountsListHttpRequest) o;
      return
          Objects.equals(this.access_token, that.getAccessToken()) &&
          Objects.equals(this.callback, that.getCallback()) &&
          Objects.equals(this.fields, that.getFields()) &&
          Objects.equals(this.key, that.getKey()) &&
          Objects.equals(this.maxResults, that.getMaxResults()) &&
          Objects.equals(this.pageSize, that.getPageSize()) &&
          Objects.equals(this.pageToken, that.getPageToken()) &&
          Objects.equals(this.prettyPrint, that.getPrettyPrint()) &&
          Objects.equals(this.quotaUser, that.getQuotaUser()) &&
          Objects.equals(this.userIp, that.getUserIp())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      access_token,
      callback,
      fields,
      key,
      maxResults,
      pageSize,
      pageToken,
      prettyPrint,
      quotaUser,
      userIp
    );
  }
}

============== file: src/main/java/com/google/cloud/fakebilling/v1/ProjectsGetBillingInfoHttpRequest.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.core.ApiMessage;
import com.google.common.collect.ImmutableList;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class ProjectsGetBillingInfoHttpRequest implements ApiMessage {
  private final String access_token;
  private final String callback;
  private final String fields;
  private final String key;
  private final String name;
  private final String prettyPrint;
  private final String quotaUser;
  private final String userIp;

  private ProjectsGetBillingInfoHttpRequest(
      String access_token,
      String callback,
      String fields,
      String key,
      String name,
      String prettyPrint,
      String quotaUser,
      String userIp
      ) {
    this.access_token = access_token;
    this.callback = callback;
    this.fields = fields;
    this.key = key;
    this.name = name;
    this.prettyPrint = prettyPrint;
    this.quotaUser = quotaUser;
    this.userIp = userIp;
  }

  @Override
  public Map<String, List<String>> populateFieldsInMap(Set<String> fieldNames) {
    Map<String, List<String>> fieldMap = new HashMap<>();
    if (fieldNames.contains("access_token")) {
      fieldMap.put("access_token", Collections.singletonList(String.valueOf(access_token)));
    }
    if (fieldNames.contains("callback")) {
      fieldMap.put("callback", Collections.singletonList(String.valueOf(callback)));
    }
    if (fieldNames.contains("fields")) {
      fieldMap.put("fields", Collections.singletonList(String.valueOf(fields)));
    }
    if (fieldNames.contains("key")) {
      fieldMap.put("key", Collections.singletonList(String.valueOf(key)));
    }
    if (fieldNames.contains("name")) {
      fieldMap.put("name", Collections.singletonList(String.valueOf(name)));
    }
    if (fieldNames.contains("prettyPrint")) {
      fieldMap.put("prettyPrint", Collections.singletonList(String.valueOf(prettyPrint)));
    }
    if (fieldNames.contains("quotaUser")) {
      fieldMap.put("quotaUser", Collections.singletonList(String.valueOf(quotaUser)));
    }
    if (fieldNames.contains("userIp")) {
      fieldMap.put("userIp", Collections.singletonList(String.valueOf(userIp)));
    }
    return fieldMap;
  }

  public String getAccessToken() {
    return access_token;
  }

  public String getCallback() {
    return callback;
  }

  public String getFields() {
    return fields;
  }

  public String getKey() {
    return key;
  }

  public String getName() {
    return name;
  }

  public String getPrettyPrint() {
    return prettyPrint;
  }

  public String getQuotaUser() {
    return quotaUser;
  }

  public String getUserIp() {
    return userIp;
  }


  public static Builder newBuilder() {
    return new ProjectsGetBillingInfoHttpRequest.Builder();
  }

  public static class Builder {
    private String access_token;
    private String callback;
    private String fields;
    private String key;
    private String name;
    private String prettyPrint;
    private String quotaUser;
    private String userIp;

    Builder() {}

    Builder(ProjectsGetBillingInfoHttpRequest source) {
      this.access_token = source.access_token;
      this.callback = source.callback;
      this.fields = source.fields;
      this.key = source.key;
      this.name = source.name;
      this.prettyPrint = source.prettyPrint;
      this.quotaUser = source.quotaUser;
      this.userIp = source.userIp;
    }

    public String getAccessToken() {
      return access_token;
    }

    public Builder setAccessToken(String access_token) {
      this.access_token = access_token;
      return this;
    }

    public String getCallback() {
      return callback;
    }

    public Builder setCallback(String callback) {
      this.callback = callback;
      return this;
    }

    public String getFields() {
      return fields;
    }

    public Builder setFields(String fields) {
      this.fields = fields;
      return this;
    }

    public String getKey() {
      return key;
    }

    public Builder setKey(String key) {
      this.key = key;
      return this;
    }

    public String getName() {
      return name;
    }

    public Builder setName(String name) {
      this.name = name;
      return this;
    }

    public String getPrettyPrint() {
      return prettyPrint;
    }

    public Builder setPrettyPrint(String prettyPrint) {
      this.prettyPrint = prettyPrint;
      return this;
    }

    public String getQuotaUser() {
      return quotaUser;
    }

    public Builder setQuotaUser(String quotaUser) {
      this.quotaUser = quotaUser;
      return this;
    }

    public String getUserIp() {
      return userIp;
    }

    public Builder setUserIp(String userIp) {
      this.userIp = userIp;
      return this;
    }


    public ProjectsGetBillingInfoHttpRequest build() {
      String missing = "";




      if (name == null) {
        missing += " name";
      }



      if (!missing.isEmpty()) {
        throw new IllegalStateException("Missing required properties:" + missing);
      }
      return new ProjectsGetBillingInfoHttpRequest(
        access_token,
        callback,
        fields,
        key,
        name,
        prettyPrint,
        quotaUser,
        userIp
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setAccessToken(this.access_token);
      newBuilder.setCallback(this.callback);
      newBuilder.setFields(this.fields);
      newBuilder.setKey(this.key);
      newBuilder.setName(this.name);
      newBuilder.setPrettyPrint(this.prettyPrint);
      newBuilder.setQuotaUser(this.quotaUser);
      newBuilder.setUserIp(this.userIp);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "ProjectsGetBillingInfoHttpRequest{"
        + "access_token=" + access_token + ", "
        + "callback=" + callback + ", "
        + "fields=" + fields + ", "
        + "key=" + key + ", "
        + "name=" + name + ", "
        + "prettyPrint=" + prettyPrint + ", "
        + "quotaUser=" + quotaUser + ", "
        + "userIp=" + userIp
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof ProjectsGetBillingInfoHttpRequest) {
      ProjectsGetBillingInfoHttpRequest that = (ProjectsGetBillingInfoHttpRequest) o;
      return
          Objects.equals(this.access_token, that.getAccessToken()) &&
          Objects.equals(this.callback, that.getCallback()) &&
          Objects.equals(this.fields, that.getFields()) &&
          Objects.equals(this.key, that.getKey()) &&
          Objects.equals(this.name, that.getName()) &&
          Objects.equals(this.prettyPrint, that.getPrettyPrint()) &&
          Objects.equals(this.quotaUser, that.getQuotaUser()) &&
          Objects.equals(this.userIp, that.getUserIp())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      access_token,
      callback,
      fields,
      key,
      name,
      prettyPrint,
      quotaUser,
      userIp
    );
  }
}

============== file: src/main/java/com/google/cloud/fakebilling/v1/ProjectsListHttpRequest.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.core.ApiMessage;
import com.google.common.collect.ImmutableList;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class ProjectsListHttpRequest implements ApiMessage {
  private final String access_token;
  private final String callback;
  private final String fields;
  private final String key;
  private final String name;
  private final Integer pageSize;
  private final String pageToken;
  private final String prettyPrint;
  private final String quotaUser;
  private final String userIp;

  private ProjectsListHttpRequest(
      String access_token,
      String callback,
      String fields,
      String key,
      String name,
      Integer pageSize,
      String pageToken,
      String prettyPrint,
      String quotaUser,
      String userIp
      ) {
    this.access_token = access_token;
    this.callback = callback;
    this.fields = fields;
    this.key = key;
    this.name = name;
    this.pageSize = pageSize;
    this.pageToken = pageToken;
    this.prettyPrint = prettyPrint;
    this.quotaUser = quotaUser;
    this.userIp = userIp;
  }

  @Override
  public Map<String, List<String>> populateFieldsInMap(Set<String> fieldNames) {
    Map<String, List<String>> fieldMap = new HashMap<>();
    if (fieldNames.contains("access_token")) {
      fieldMap.put("access_token", Collections.singletonList(String.valueOf(access_token)));
    }
    if (fieldNames.contains("callback")) {
      fieldMap.put("callback", Collections.singletonList(String.valueOf(callback)));
    }
    if (fieldNames.contains("fields")) {
      fieldMap.put("fields", Collections.singletonList(String.valueOf(fields)));
    }
    if (fieldNames.contains("key")) {
      fieldMap.put("key", Collections.singletonList(String.valueOf(key)));
    }
    if (fieldNames.contains("name")) {
      fieldMap.put("name", Collections.singletonList(String.valueOf(name)));
    }
    if (fieldNames.contains("pageSize")) {
      fieldMap.put("pageSize", Collections.singletonList(String.valueOf(pageSize)));
    }
    if (fieldNames.contains("pageToken")) {
      fieldMap.put("pageToken", Collections.singletonList(String.valueOf(pageToken)));
    }
    if (fieldNames.contains("prettyPrint")) {
      fieldMap.put("prettyPrint", Collections.singletonList(String.valueOf(prettyPrint)));
    }
    if (fieldNames.contains("quotaUser")) {
      fieldMap.put("quotaUser", Collections.singletonList(String.valueOf(quotaUser)));
    }
    if (fieldNames.contains("userIp")) {
      fieldMap.put("userIp", Collections.singletonList(String.valueOf(userIp)));
    }
    return fieldMap;
  }

  public String getAccessToken() {
    return access_token;
  }

  public String getCallback() {
    return callback;
  }

  public String getFields() {
    return fields;
  }

  public String getKey() {
    return key;
  }

  public String getName() {
    return name;
  }

  public Integer getPageSize() {
    return pageSize;
  }

  public String getPageToken() {
    return pageToken;
  }

  public String getPrettyPrint() {
    return prettyPrint;
  }

  public String getQuotaUser() {
    return quotaUser;
  }

  public String getUserIp() {
    return userIp;
  }


  public static Builder newBuilder() {
    return new ProjectsListHttpRequest.Builder();
  }

  public static class Builder {
    private String access_token;
    private String callback;
    private String fields;
    private String key;
    private String name;
    private Integer pageSize;
    private String pageToken;
    private String prettyPrint;
    private String quotaUser;
    private String userIp;

    Builder() {}

    Builder(ProjectsListHttpRequest source) {
      this.access_token = source.access_token;
      this.callback = source.callback;
      this.fields = source.fields;
      this.key = source.key;
      this.name = source.name;
      this.pageSize = source.pageSize;
      this.pageToken = source.pageToken;
      this.prettyPrint = source.prettyPrint;
      this.quotaUser = source.quotaUser;
      this.userIp = source.userIp;
    }

    public String getAccessToken() {
      return access_token;
    }

    public Builder setAccessToken(String access_token) {
      this.access_token = access_token;
      return this;
    }

    public String getCallback() {
      return callback;
    }

    public Builder setCallback(String callback) {
      this.callback = callback;
      return this;
    }

    public String getFields() {
      return fields;
    }

    public Builder setFields(String fields) {
      this.fields = fields;
      return this;
    }

    public String getKey() {
      return key;
    }

    public Builder setKey(String key) {
      this.key = key;
      return this;
    }

    public String getName() {
      return name;
    }

    public Builder setName(String name) {
      this.name = name;
      return this;
    }

    public Integer getPageSize() {
      return pageSize;
    }

    public Builder setPageSize(Integer pageSize) {
      this.pageSize = pageSize;
      return this;
    }

    public String getPageToken() {
      return pageToken;
    }

    public Builder setPageToken(String pageToken) {
      this.pageToken = pageToken;
      return this;
    }

    public String getPrettyPrint() {
      return prettyPrint;
    }

    public Builder setPrettyPrint(String prettyPrint) {
      this.prettyPrint = prettyPrint;
      return this;
    }

    public String getQuotaUser() {
      return quotaUser;
    }

    public Builder setQuotaUser(String quotaUser) {
      this.quotaUser = quotaUser;
      return this;
    }

    public String getUserIp() {
      return userIp;
    }

    public Builder setUserIp(String userIp) {
      this.userIp = userIp;
      return this;
    }


    public ProjectsListHttpRequest build() {
      String missing = "";




      if (name == null) {
        missing += " name";
      }





      if (!missing.isEmpty()) {
        throw new IllegalStateException("Missing required properties:" + missing);
      }
      return new ProjectsListHttpRequest(
        access_token,
        callback,
        fields,
        key,
        name,
        pageSize,
        pageToken,
        prettyPrint,
        quotaUser,
        userIp
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setAccessToken(this.access_token);
      newBuilder.setCallback(this.callback);
      newBuilder.setFields(this.fields);
      newBuilder.setKey(this.key);
      newBuilder.setName(this.name);
      newBuilder.setPageSize(this.pageSize);
      newBuilder.setPageToken(this.pageToken);
      newBuilder.setPrettyPrint(this.prettyPrint);
      newBuilder.setQuotaUser(this.quotaUser);
      newBuilder.setUserIp(this.userIp);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "ProjectsListHttpRequest{"
        + "access_token=" + access_token + ", "
        + "callback=" + callback + ", "
        + "fields=" + fields + ", "
        + "key=" + key + ", "
        + "name=" + name + ", "
        + "pageSize=" + pageSize + ", "
        + "pageToken=" + pageToken + ", "
        + "prettyPrint=" + prettyPrint + ", "
        + "quotaUser=" + quotaUser + ", "
        + "userIp=" + userIp
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof ProjectsListHttpRequest) {
      ProjectsListHttpRequest that = (ProjectsListHttpRequest) o;
      return
          Objects.equals(this.access_token, that.getAccessToken()) &&
          Objects.equals(this.callback, that.getCallback()) &&
          Objects.equals(this.fields, that.getFields()) &&
          Objects.equals(this.key, that.getKey()) &&
          Objects.equals(this.name, that.getName()) &&
          Objects.equals(this.pageSize, that.getPageSize()) &&
          Objects.equals(this.pageToken, that.getPageToken()) &&
          Objects.equals(this.prettyPrint, that.getPrettyPrint()) &&
          Objects.equals(this.quotaUser, that.getQuotaUser()) &&
          Objects.equals(this.userIp, that.getUserIp())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      access_token,
      callback,
      fields,
      key,
      name,
      pageSize,
      pageToken,
      prettyPrint,
      quotaUser,
      userIp
    );
  }
}

============== file: src/main/java/com/google/cloud/fakebilling/v1/ProjectsUpdateBillingInfoHttpRequest.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.core.ApiMessage;
import com.google.common.collect.ImmutableList;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class ProjectsUpdateBillingInfoHttpRequest implements ApiMessage {
  private final String access_token;
  private final String callback;
  private final String fields;
  private final String key;
  private final String name;
  private final String prettyPrint;
  private final String quotaUser;
  private final ProjectBillingInfo request;
  private final String userIp;

  private ProjectsUpdateBillingInfoHttpRequest(
      String access_token,
      String callback,
      String fields,
      String key,
      String name,
      String prettyPrint,
      String quotaUser,
      ProjectBillingInfo request,
      String userIp
      ) {
    this.access_token = access_token;
    this.callback = callback;
    this.fields = fields;
    this.key = key;
    this.name = name;
    this.prettyPrint = prettyPrint;
    this.quotaUser = quotaUser;
    this.request = request;
    this.userIp = userIp;
  }

  @Override
  public Map<String, List<String>> populateFieldsInMap(Set<String> fieldNames) {
    Map<String, List<String>> fieldMap = new HashMap<>();
    if (fieldNames.contains("access_token")) {
      fieldMap.put("access_token", Collections.singletonList(String.valueOf(access_token)));
    }
    if (fieldNames.contains("callback")) {
      fieldMap.put("callback", Collections.singletonList(String.valueOf(callback)));
    }
    if (fieldNames.contains("fields")) {
      fieldMap.put("fields", Collections.singletonList(String.valueOf(fields)));
    }
    if (fieldNames.contains("key")) {
      fieldMap.put("key", Collections.singletonList(String.valueOf(key)));
    }
    if (fieldNames.contains("name")) {
      fieldMap.put("name", Collections.singletonList(String.valueOf(name)));
    }
    if (fieldNames.contains("prettyPrint")) {
      fieldMap.put("prettyPrint", Collections.singletonList(String.valueOf(prettyPrint)));
    }
    if (fieldNames.contains("quotaUser")) {
      fieldMap.put("quotaUser", Collections.singletonList(String.valueOf(quotaUser)));
    }
    if (fieldNames.contains("request")) {
      fieldMap.put("request", Collections.singletonList(String.valueOf(request)));
    }
    if (fieldNames.contains("userIp")) {
      fieldMap.put("userIp", Collections.singletonList(String.valueOf(userIp)));
    }
    return fieldMap;
  }

  public String getAccessToken() {
    return access_token;
  }

  public String getCallback() {
    return callback;
  }

  public String getFields() {
    return fields;
  }

  public String getKey() {
    return key;
  }

  public String getName() {
    return name;
  }

  public String getPrettyPrint() {
    return prettyPrint;
  }

  public String getQuotaUser() {
    return quotaUser;
  }

  public ProjectBillingInfo getRequest() {
    return request;
  }

  public String getUserIp() {
    return userIp;
  }


  public static Builder newBuilder() {
    return new ProjectsUpdateBillingInfoHttpRequest.Builder();
  }

  public static class Builder {
    private String access_token;
    private String callback;
    private String fields;
    private String key;
    private String name;
    private String prettyPrint;
    private String quotaUser;
    private ProjectBillingInfo request;
    private String userIp;

    Builder() {}

    Builder(ProjectsUpdateBillingInfoHttpRequest source) {
      this.access_token = source.access_token;
      this.callback = source.callback;
      this.fields = source.fields;
      this.key = source.key;
      this.name = source.name;
      this.prettyPrint = source.prettyPrint;
      this.quotaUser = source.quotaUser;
      this.request = source.request;
      this.userIp = source.userIp;
    }

    public String getAccessToken() {
      return access_token;
    }

    public Builder setAccessToken(String access_token) {
      this.access_token = access_token;
      return this;
    }

    public String getCallback() {
      return callback;
    }

    public Builder setCallback(String callback) {
      this.callback = callback;
      return this;
    }

    public String getFields() {
      return fields;
    }

    public Builder setFields(String fields) {
      this.fields = fields;
      return this;
    }

    public String getKey() {
      return key;
    }

    public Builder setKey(String key) {
      this.key = key;
      return this;
    }

    public String getName() {
      return name;
    }

    public Builder setName(String name) {
      this.name = name;
      return this;
    }

    public String getPrettyPrint() {
      return prettyPrint;
    }

    public Builder setPrettyPrint(String prettyPrint) {
      this.prettyPrint = prettyPrint;
      return this;
    }

    public String getQuotaUser() {
      return quotaUser;
    }

    public Builder setQuotaUser(String quotaUser) {
      this.quotaUser = quotaUser;
      return this;
    }

    public ProjectBillingInfo getRequest() {
      return request;
    }

    public Builder setRequest(ProjectBillingInfo request) {
      this.request = request;
      return this;
    }

    public String getUserIp() {
      return userIp;
    }

    public Builder setUserIp(String userIp) {
      this.userIp = userIp;
      return this;
    }


    public ProjectsUpdateBillingInfoHttpRequest build() {
      String missing = "";




      if (name == null) {
        missing += " name";
      }




      if (!missing.isEmpty()) {
        throw new IllegalStateException("Missing required properties:" + missing);
      }
      return new ProjectsUpdateBillingInfoHttpRequest(
        access_token,
        callback,
        fields,
        key,
        name,
        prettyPrint,
        quotaUser,
        request,
        userIp
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setAccessToken(this.access_token);
      newBuilder.setCallback(this.callback);
      newBuilder.setFields(this.fields);
      newBuilder.setKey(this.key);
      newBuilder.setName(this.name);
      newBuilder.setPrettyPrint(this.prettyPrint);
      newBuilder.setQuotaUser(this.quotaUser);
      newBuilder.setRequest(this.request);
      newBuilder.setUserIp(this.userIp);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "ProjectsUpdateBillingInfoHttpRequest{"
        + "access_token=" + access_token + ", "
        + "callback=" + callback + ", "
        + "fields=" + fields + ", "
        + "key=" + key + ", "
        + "name=" + name + ", "
        + "prettyPrint=" + prettyPrint + ", "
        + "quotaUser=" + quotaUser + ", "
        + "request=" + request + ", "
        + "userIp=" + userIp
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof ProjectsUpdateBillingInfoHttpRequest) {
      ProjectsUpdateBillingInfoHttpRequest that = (ProjectsUpdateBillingInfoHttpRequest) o;
      return
          Objects.equals(this.access_token, that.getAccessToken()) &&
          Objects.equals(this.callback, that.getCallback()) &&
          Objects.equals(this.fields, that.getFields()) &&
          Objects.equals(this.key, that.getKey()) &&
          Objects.equals(this.name, that.getName()) &&
          Objects.equals(this.prettyPrint, that.getPrettyPrint()) &&
          Objects.equals(this.quotaUser, that.getQuotaUser()) &&
          Objects.equals(this.request, that.getRequest()) &&
          Objects.equals(this.userIp, that.getUserIp())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      access_token,
      callback,
      fields,
      key,
      name,
      prettyPrint,
      quotaUser,
      request,
      userIp
    );
  }
}

============== file: src/main/java/com/google/cloud/fakebilling/v1/BillingAccountAdminClient.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.BetaApi;
import com.google.auth.Credentials;
import static com.google.cloud.fakebilling.v1.PagedResponseWrappers.BillingAccountsListPagedResponse;
import java.io.Closeable;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import javax.annotation.Generated;

// AUTO-GENERATED DOCUMENTATION AND SERVICE
/**
 * Service Description:
 *
 * <p>This class provides the ability to make remote calls to the backing service through method
 * calls that map to API methods. Sample code to get started:
 *
 * <pre>
 * <code>
 * try (BillingAccountAdminClient billingAccountAdminClient = BillingAccountAdminClient.create()) {
 *
 *   BillingAccount response = billingAccountAdminClient.billingAccountsGet();
 * }
 * </code>
 * </pre>
 *
 * <p>Note: close() needs to be called on the billingAccountAdminClient object to clean up resources such
 * as threads. In the example above, try-with-resources is used, which automatically calls
 * close().
 *
 * <p>The surface of this class includes several types of Java methods for each of the API's methods:
 *
 * <ol>
 * <li> A "flattened" method. With this type of method, the fields of the request type have been
 * converted into function parameters. It may be the case that not all fields are available
 * as parameters, and not every API method will have a flattened method entry point.
 * <li> A "request object" method. This type of method only takes one parameter, a request
 * object, which must be constructed before the call. Not every API method will have a request
 * object method.
 * <li> A "callable" method. This type of method takes no parameters and returns an immutable
 * API callable object, which can be used to initiate calls to the service.
 * </ol>
 *
 * <p>See the individual methods for example code.
 *
 * <p>Many parameters require resource names to be formatted in a particular way. To assist
 * with these names, this class includes a format method for each type of name, and additionally
 * a parse method to extract the individual identifiers contained within names that are
 * returned.
 *
 * <p>This class can be customized by passing in a custom instance of BillingAccountAdminSettings to
 * create(). For example:
 *
 * <pre>
 * <code>
 * BillingAccountAdminSettings billingAccountAdminSettings =
 *     BillingAccountAdminSettings.defaultBuilder()
 *         .setCredentialsProvider(FixedCredentialsProvider.create(myCredentials))
 *         .build();
 * BillingAccountAdminClient billingAccountAdminClient =
 *     BillingAccountAdminClient.create(billingAccountAdminSettings);
 * </code>
 * </pre>
 */
@Generated("by GAPIC")
public class BillingAccountAdminClient implements AutoCloseable {
  private final BillingAccountAdminSettings settings;
  private final ScheduledExecutorService executor;
  private final ManagedChannel channel;
  private final List<AutoCloseable> closeables = new ArrayList<>();

  private final UnaryCallable<BillingAccountsListHttpRequest, BillingAccountsListHttpResponse> billingAccountsListCallable;
  private final UnaryCallable<BillingAccountsListHttpRequest, BillingAccountsListPagedResponse> billingAccountsListPagedCallable;
  private final UnaryCallable<BillingAccountsGetHttpRequest, BillingAccountsGetHttpResponse> billingAccountsGetCallable;

  private static final PathTemplate BILLING_ACCOUNT_PATH_TEMPLATE =
      PathTemplate.createWithoutUrlEncoding("billingAccounts/{billing_account}");

  /**
   * Formats a string containing the fully-qualified path to represent
   * a billing_account resource.
   */
  public static final String formatBillingAccountName(String billingAccount) {
    return BILLING_ACCOUNT_PATH_TEMPLATE.instantiate(
        "billing_account", billingAccount);
  }

  /**
   * Parses the billing_account from the given fully-qualified path which
   * represents a billing_account resource.
   */
  public static final String parseBillingAccountFromBillingAccountName(String billingAccountName) {
    return BILLING_ACCOUNT_PATH_TEMPLATE.parse(billingAccountName).get("billing_account");
  }

  /**
   * Constructs an instance of BillingAccountAdminClient with default settings.
   */
  public static final BillingAccountAdminClient create() throws IOException {
    return create(BillingAccountAdminSettings.defaultBuilder().build());
  }

  /**
   * Constructs an instance of BillingAccountAdminClient, using the given settings.
   * The channels are created based on the settings passed in, or defaults for any
   * settings that are not set.
   */
  public static final BillingAccountAdminClient create(BillingAccountAdminSettings settings) throws IOException {
    return new BillingAccountAdminClient(settings);
  }

  /**
   * Constructs an instance of BillingAccountAdminClient, using the given settings.
   * This is protected so that it easy to make a subclass, but otherwise, the static
   * factory methods should be preferred.
   */
  protected BillingAccountAdminClient(BillingAccountAdminSettings settings) throws IOException {
    this.settings = settings;
    ChannelAndExecutor channelAndExecutor = settings.getChannelAndExecutor();
    this.executor = channelAndExecutor.getExecutor();
    this.channel = channelAndExecutor.getChannel();
    Credentials credentials = settings.getCredentialsProvider().getCredentials();

    ClientContext clientContext =
        ClientContext.newBuilder()
            .setExecutor(this.executor)
            .setChannel(this.channel)
            .setCredentials(credentials)
            .build();


    this.billingAccountsListCallable = UnaryCallable.create(settings.billingAccountsListSettings(), clientContext);
    this.billingAccountsListPagedCallable =
        UnaryCallable.createPagedVariant(settings.billingAccountsListSettings(), clientContext);
    this.billingAccountsGetCallable = UnaryCallable.create(settings.billingAccountsGetSettings(), clientContext);

    if (settings.getChannelProvider().shouldAutoClose()) {
      closeables.add(
        new Closeable() {
          @Override
          public void close() throws IOException {
            channel.shutdown();
          }
        });
    }
    if (settings.getExecutorProvider().shouldAutoClose()) {
      closeables.add(
        new Closeable() {
          @Override
          public void close() throws IOException {
            executor.shutdown();
          }
        });
    }
  }

  public final BillingAccountAdminSettings getSettings() {
    return settings;
  }


  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Lists the billing accounts that the current authenticated user
   * [owns](https://support.google.com/cloud/answer/4430947).
   *
   * Sample code:
   * <pre><code>
   * try (BillingAccountAdminClient billingAccountAdminClient = BillingAccountAdminClient.create()) {
   *
   *   for (ListBillingAccountsResponse element : billingAccountAdminClient.billingAccountsList().iterateAll()) {
   *     // doThingsWith(element);
   *   }
   * }
   * </code></pre>
   *
   * @param request The request object containing all of the parameters for the API call.
   * @throws com.google.api.gax.grpc.ApiException if the remote call fails
   */
  @BetaApi
  public final BillingAccountsListPagedResponse billingAccountsList(BillingAccountsListHttpRequest request) {
    return billingAccountsListPagedCallable()
        .call(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Lists the billing accounts that the current authenticated user
   * [owns](https://support.google.com/cloud/answer/4430947).
   *
   * Sample code:
   * <pre><code>
   * try (BillingAccountAdminClient billingAccountAdminClient = BillingAccountAdminClient.create()) {
   *
   *   ApiFuture&lt;BillingAccountsListPagedResponse&gt; future = billingAccountAdminClient.billingAccountsListPagedCallable().futureCall();
   *   // Do something
   *   for (ListBillingAccountsResponse element : future.get().iterateAll()) {
   *     // doThingsWith(element);
   *   }
   * }
   * </code></pre>
   */
  @BetaApi
  public final UnaryCallable<BillingAccountsListHttpRequest, BillingAccountsListPagedResponse> billingAccountsListPagedCallable() {
    return billingAccountsListPagedCallable;
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Lists the billing accounts that the current authenticated user
   * [owns](https://support.google.com/cloud/answer/4430947).
   *
   * Sample code:
   * <pre><code>
   * try (BillingAccountAdminClient billingAccountAdminClient = BillingAccountAdminClient.create()) {
   *
   *   while (true) {
   *     BillingAccountsListHttpResponse response = billingAccountAdminClient.billingAccountsListCallable().call();
   *     for (ListBillingAccountsResponse element : response.getResponse()) {
   *       // doThingsWith(element);
   *     }
   *     String nextPageToken = response.getNextPageToken();
   *     if (!Strings.isNullOrEmpty(nextPageToken)) {
   *       request = request.toBuilder().setPageToken(nextPageToken).build();
   *     } else {
   *       break;
   *     }
   *   }
   * }
   * </code></pre>
   */
  @BetaApi
  public final UnaryCallable<BillingAccountsListHttpRequest, BillingAccountsListHttpResponse> billingAccountsListCallable() {
    return billingAccountsListCallable;
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Gets information about a billing account. The current authenticated user
   * must be an [owner of the billing
   * account](https://support.google.com/cloud/answer/4430947).
   *
   * Sample code:
   * <pre><code>
   * try (BillingAccountAdminClient billingAccountAdminClient = BillingAccountAdminClient.create()) {
   *
   *   BillingAccount response = billingAccountAdminClient.billingAccountsGet();
   * }
   * </code></pre>
   *
   * @param name DiscoveryField.getScopedDocumentation() not yet implemented.
   * @throws com.google.api.gax.grpc.ApiException if the remote call fails
   */
  @BetaApi
  public final BillingAccount billingAccountsGet(String name) {

    BillingAccountsGetHttpRequest request =
        BillingAccountsGetHttpRequest.newBuilder()
        .setName(name)
        .build();
    return billingAccountsGet(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Gets information about a billing account. The current authenticated user
   * must be an [owner of the billing
   * account](https://support.google.com/cloud/answer/4430947).
   *
   * Sample code:
   * <pre><code>
   * try (BillingAccountAdminClient billingAccountAdminClient = BillingAccountAdminClient.create()) {
   *
   *   BillingAccount response = billingAccountAdminClient.billingAccountsGet();
   * }
   * </code></pre>
   *
   * @param request The request object containing all of the parameters for the API call.
   * @throws com.google.api.gax.grpc.ApiException if the remote call fails
   */
  @BetaApi
  private final BillingAccount billingAccountsGet(BillingAccountsGetHttpRequest request) {
    return billingAccountsGetCallable().call(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Gets information about a billing account. The current authenticated user
   * must be an [owner of the billing
   * account](https://support.google.com/cloud/answer/4430947).
   *
   * Sample code:
   * <pre><code>
   * try (BillingAccountAdminClient billingAccountAdminClient = BillingAccountAdminClient.create()) {
   *
   *   ApiFuture&lt;BillingAccount&gt; future = billingAccountAdminClient.billingAccountsGetCallable().futureCall();
   *   // Do something
   *   BillingAccountsGetHttpResponse response = future.get();
   * }
   * </code></pre>
   */
  @BetaApi
  public final UnaryCallable<BillingAccountsGetHttpRequest, BillingAccountsGetHttpResponse> billingAccountsGetCallable() {
    return billingAccountsGetCallable;
  }

  /**
   * Initiates an orderly shutdown in which preexisting calls continue but new calls are immediately
   * cancelled.
   */
  @Override
  public final void close() throws Exception {
    for (AutoCloseable closeable : closeables) {
      closeable.close();
    }
  }

}
============== file: src/main/java/com/google/cloud/fakebilling/v1/BillingAccountAdminSettings.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.ApiFuture;
import com.google.api.core.BetaApi;
import com.google.api.gax.core.CredentialsProvider;
import com.google.api.gax.core.GoogleCredentialsProvider;
import com.google.api.gax.core.PropertiesProvider;
import com.google.api.gax.grpc.ApiExceptions;
import com.google.api.gax.grpc.CallContext;
import com.google.api.gax.grpc.ChannelProvider;
import com.google.api.gax.grpc.ClientSettings;
import com.google.api.gax.grpc.ExecutorProvider;
import com.google.api.gax.grpc.InstantiatingChannelProvider;
import com.google.api.gax.grpc.InstantiatingExecutorProvider;
import com.google.api.gax.grpc.PageContext;
import com.google.api.gax.grpc.PagedCallSettings;
import com.google.api.gax.grpc.PagedListDescriptor;
import com.google.api.gax.grpc.PagedListResponseFactory;
import com.google.api.gax.grpc.SimpleCallSettings;
import com.google.api.gax.grpc.UnaryCallSettings;
import com.google.api.gax.grpc.UnaryCallable;
import com.google.api.gax.retrying.RetrySettings;
import com.google.auth.Credentials;
import static com.google.cloud.fakebilling.v1.PagedResponseWrappers.BillingAccountsListPagedResponse;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import io.grpc.ManagedChannel;
import io.grpc.Status;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import javax.annotation.Generated;
import org.threeten.bp.Duration;

// AUTO-GENERATED DOCUMENTATION AND CLASS
/**
 * Settings class to configure an instance of {@link BillingAccountAdminClient}.
 *
 * <p>The default instance has everything set to sensible defaults:
 *
 * <ul>
 * <li>The default service address (Service address.) and default port (443)
 * are used.
 * <li>Credentials are acquired automatically through Application Default Credentials.
 * <li>Retries are configured for idempotent methods but not for non-idempotent methods.
 * </ul>
 *
 * <p>The builder of this class is recursive, so contained classes are themselves builders.
 * When build() is called, the tree of builders is called to create the complete settings
 * object. For example, to set the total timeout of billingAccountsGet to 30 seconds:
 *
 * <pre>
 * <code>
 * BillingAccountAdminSettings.Builder billingAccountAdminSettingsBuilder =
 *     BillingAccountAdminSettings.defaultBuilder();
 * billingAccountAdminSettingsBuilder.billingAccountsGetSettings().getRetrySettingsBuilder()
 *     .setTotalTimeout(Duration.ofSeconds(30));
 * BillingAccountAdminSettings billingAccountAdminSettings = billingAccountAdminSettingsBuilder.build();
 * </code>
 * </pre>
 */
@Generated("by GAPIC v0.0.5")
public class BillingAccountAdminSettings extends ClientSettings {
  /**
   * The default scopes of the service.
   */
  private static final ImmutableList<String> DEFAULT_SERVICE_SCOPES = ImmutableList.<String>builder()
      .add("https://www.googleapis.com/auth/cloud-platform")
      .build();

  private static final String DEFAULT_GAPIC_NAME = "gapic";
  private static final String DEFAULT_GAPIC_VERSION = "";

  private static final String PROPERTIES_FILE = "/com/google/cloud/fakebilling/v1/project.properties";
  private static final String META_VERSION_KEY = "artifact.version";

  private static String gapicVersion;

  private static final io.grpc.MethodDescriptor<BillingAccountsListHttpRequest, BillingAccountsListHttpResponse> getGrpcMethodConstant() not implemented for Discovery-based APIs. =
        io.grpc.MethodDescriptor.create(
            io.grpc.MethodDescriptor.MethodType.UNARY,
            "Full service name./fakebilling.billingAccounts.list",
            io.grpc.protobuf.ProtoUtils.marshaller(BillingAccountsListHttpRequest.getDefaultInstance()),
            io.grpc.protobuf.ProtoUtils.marshaller(BillingAccountsListHttpResponse.getDefaultInstance()));
  private static final io.grpc.MethodDescriptor<BillingAccountsGetHttpRequest, BillingAccount> Grpc not used in Discovery-based method. =
        io.grpc.MethodDescriptor.create(
            io.grpc.MethodDescriptor.MethodType.UNARY,
            "Full service name./fakebilling.billingAccounts.get",
            io.grpc.protobuf.ProtoUtils.marshaller(BillingAccountsGetHttpRequest.getDefaultInstance()),
            io.grpc.protobuf.ProtoUtils.marshaller(BillingAccountsGetHttpResponse.getDefaultInstance()));

  private final PagedCallSettings<BillingAccountsListHttpRequest, BillingAccountsListHttpResponse, FakebillingBillingAccountsListPagedResponse> fakebillingBillingAccountsListSettings;
  private final SimpleCallSettings<BillingAccountsGetHttpRequest, BillingAccountsGetHttpResponse> fakebillingBillingAccountsGetSettings;

  /**
   * Returns the object with the settings used for calls to billingAccountsList.
   */
  public PagedCallSettings<BillingAccountsListHttpRequest, BillingAccountsListHttpResponse, BillingAccountsListPagedResponse> billingAccountsListSettings() {
    return billingAccountsListSettings;
  }

  /**
   * Returns the object with the settings used for calls to billingAccountsGet.
   */
  public SimpleCallSettings<BillingAccountsGetHttpRequest, BillingAccountsGetHttpResponse> billingAccountsGetSettings() {
    return billingAccountsGetSettings;
  }


  /**
   * Returns a builder for the default ExecutorProvider for this service.
   */
  public static InstantiatingExecutorProvider.Builder defaultExecutorProviderBuilder() {
    return InstantiatingExecutorProvider.newBuilder();
  }

  /**
   * Returns the default service endpoint.
   */
  public static String getDefaultEndpoint() {
    return "Service address.:443";
  }


  /**
   * Returns the default service scopes.
   */
  public static List<String> getDefaultServiceScopes() {
    return DEFAULT_SERVICE_SCOPES;
  }


  /**
   * Returns a builder for the default credentials for this service.
   */
  public static GoogleCredentialsProvider.Builder defaultCredentialsProviderBuilder() {
    return GoogleCredentialsProvider.newBuilder()
        .setScopesToApply(DEFAULT_SERVICE_SCOPES)
        ;
  }

  /** Returns a builder for the default ChannelProvider for this service. */
  public static InstantiatingChannelProvider.Builder defaultChannelProviderBuilder() {
    return InstantiatingChannelProvider.newBuilder()
        .setEndpoint(getDefaultEndpoint())
        .setGeneratorHeader(DEFAULT_GAPIC_NAME, getGapicVersion());
  }

  private static String getGapicVersion() {
    if (gapicVersion == null) {
      gapicVersion = PropertiesProvider.loadProperty(
          BillingAccountAdminSettings.class, PROPERTIES_FILE, META_VERSION_KEY);
      gapicVersion = gapicVersion == null ? DEFAULT_GAPIC_VERSION : gapicVersion;
    }
    return gapicVersion;
  }

  /**
   * Returns a builder for this class with recommended defaults.
   */
  public static Builder defaultBuilder() {
    return Builder.createDefault();
  }

  /**
   * Returns a new builder for this class.
   */
  public static Builder newBuilder() {
    return new Builder();
  }

  /**
   * Returns a builder containing all the values of this settings class.
   */
  public Builder toBuilder() {
    return new Builder(this);
  }

  private BillingAccountAdminSettings(Builder settingsBuilder) throws IOException {
    super(settingsBuilder.getExecutorProvider(),
          settingsBuilder.getChannelProvider(),
          settingsBuilder.getCredentialsProvider());

    billingAccountsListSettings = settingsBuilder.billingAccountsListSettings().build();
    billingAccountsGetSettings = settingsBuilder.billingAccountsGetSettings().build();
  }

  private static final PagedListDescriptor<BillingAccountsListHttpRequest, BillingAccountsListHttpResponse, ListBillingAccountsResponse> BILLING_ACCOUNTS_LIST_PAGE_STR_DESC =
      new PagedListDescriptor<BillingAccountsListHttpRequest, BillingAccountsListHttpResponse, ListBillingAccountsResponse>() {
        @Override
        public String emptyToken() {
          return ListBillingAccountsResponse.newBuilder().build();
        }
        @Override
        public BillingAccountsListHttpRequest injectToken(BillingAccountsListHttpRequest payload, String token) {
          return BillingAccountsListHttpRequest
            .newBuilder(payload)
            .setPageToken(token)
            .build();
        }
        @Override
        public BillingAccountsListHttpRequest injectPageSize(BillingAccountsListHttpRequest payload, int pageSize) {
          return BillingAccountsListHttpRequest
            .newBuilder(payload)
            .setMaxResults(pageSize)
            .build();
        }
        @Override
        public Integer extractPageSize(BillingAccountsListHttpRequest payload) {
          return payload.getMaxResults();
        }
        @Override
        public String extractNextToken(BillingAccountsListHttpResponse payload) {
          return payload.getListBillingAccountsResponse();
        }
        @Override
        public Iterable<ListBillingAccountsResponse> extractResources(BillingAccountsListHttpResponse payload) {
          return payload.getResponse();
        }
      };

  private static final PagedListResponseFactory<BillingAccountsListHttpRequest, BillingAccountsListHttpResponse, FakebillingBillingAccountsListPagedResponse> FAKEBILLING_BILLING_ACCOUNTS_LIST_PAGE_STR_FACT =
      new PagedListResponseFactory<BillingAccountsListHttpRequest, BillingAccountsListHttpResponse, FakebillingBillingAccountsListPagedResponse>() {
        @Override
        public ApiFuture<BillingAccountsListPagedResponse> getFuturePagedResponse(
            UnaryCallable<BillingAccountsListHttpRequest, BillingAccountsListHttpResponse> callable,
            BillingAccountsListHttpRequest request,
            CallContext context,
            ApiFuture<BillingAccountsListHttpResponse> futureResponse) {
          PageContext<BillingAccountsListHttpRequest, BillingAccountsListHttpResponse, ListBillingAccountsResponse> pageContext =
              PageContext.create(callable, BILLING_ACCOUNTS_LIST_PAGE_STR_DESC, request, context);
          return BillingAccountsListPagedResponse.createAsync(pageContext, futureResponse);
        }
      };


  /**
   * Builder for BillingAccountAdminSettings.
   */
  public static class Builder extends ClientSettings.Builder {
    private final ImmutableList<UnaryCallSettings.Builder> unaryMethodSettingsBuilders;

    private final PagedCallSettings.Builder<BillingAccountsListHttpRequest, BillingAccountsListHttpResponse, BillingAccountsListPagedResponse> billingAccountsListSettings;
    private final SimpleCallSettings.Builder<BillingAccountsGetHttpRequest, BillingAccountsGetHttpResponse> billingAccountsGetSettings;

    private static final ImmutableMap<String, ImmutableSet<Status.Code>> RETRYABLE_CODE_DEFINITIONS;

    static {
      ImmutableMap.Builder<String, ImmutableSet<Status.Code>> definitions = ImmutableMap.builder();
      definitions.put(
          "idempotent",
          Sets.immutableEnumSet(Lists.<Status.Code>newArrayList(Status.Code.DEADLINE_EXCEEDED, Status.Code.UNAVAILABLE)));
      RETRYABLE_CODE_DEFINITIONS = definitions.build();
    }

    private static final ImmutableMap<String, RetrySettings.Builder> RETRY_PARAM_DEFINITIONS;

    static {
      ImmutableMap.Builder<String, RetrySettings.Builder> definitions = ImmutableMap.builder();
      RetrySettings.Builder settingsBuilder = null;
      settingsBuilder = RetrySettings.newBuilder()
          .setInitialRetryDelay(Duration.ofMillis(100L))
          .setRetryDelayMultiplier(1.3)
          .setMaxRetryDelay(Duration.ofMillis(60000L))
          .setInitialRpcTimeout(Duration.ofMillis(60000L))
          .setRpcTimeoutMultiplier(1.0)
          .setMaxRpcTimeout(Duration.ofMillis(60000L))
          .setTotalTimeout(Duration.ofMillis(600000L));
      definitions.put("default", settingsBuilder);
      RETRY_PARAM_DEFINITIONS = definitions.build();
    }

    private Builder() {
      super(defaultChannelProviderBuilder().build());
      setCredentialsProvider(defaultCredentialsProviderBuilder().build());

      billingAccountsListSettings = PagedCallSettings.newBuilder(
          Grpc not used in Discovery-based method.,
          BILLING_ACCOUNTS_LIST_PAGE_STR_FACT);

      fakebillingBillingAccountsGetSettings = SimpleCallSettings.newBuilder(Grpc not used in Discovery-based method.);

      unaryMethodSettingsBuilders = ImmutableList.<UnaryCallSettings.Builder>of(
          billingAccountsListSettings,
          billingAccountsGetSettings
      );
    }

    private static Builder createDefault() {
      Builder builder = new Builder();

      builder.billingAccountsListSettings()
          .setRetryableCodes(RETRYABLE_CODE_DEFINITIONS.get("idempotent"))
          .setRetrySettingsBuilder(RETRY_PARAM_DEFINITIONS.get("default"));

      builder.billingAccountsGetSettings()
          .setRetryableCodes(RETRYABLE_CODE_DEFINITIONS.get("idempotent"))
          .setRetrySettingsBuilder(RETRY_PARAM_DEFINITIONS.get("default"));

      return builder;
    }

    private Builder(BillingAccountAdminSettings settings) {
      super(settings);

      billingAccountsListSettings = settings.billingAccountsListSettings.toBuilder();
      billingAccountsGetSettings = settings.billingAccountsGetSettings.toBuilder();

      unaryMethodSettingsBuilders = ImmutableList.<UnaryCallSettings.Builder>of(
          billingAccountsListSettings,
          billingAccountsGetSettings
      );
    }

    @Override
    public Builder setExecutorProvider(ExecutorProvider executorProvider) {
      super.setExecutorProvider(executorProvider);
      return this;
    }

    @Override
    public Builder setChannelProvider(ChannelProvider channelProvider) {
      super.setChannelProvider(channelProvider);
      return this;
    }

    @Override
    public Builder setCredentialsProvider(CredentialsProvider credentialsProvider) {
      super.setCredentialsProvider(credentialsProvider);
      return this;
    }

    /**
     * Applies the given settings to all of the unary API methods in this service. Only
     * values that are non-null will be applied, so this method is not capable
     * of un-setting any values.
     *
     * Note: This method does not support applying settings to streaming methods.
     */
    public Builder applyToAllUnaryMethods(UnaryCallSettings.Builder unaryCallSettings) throws Exception {
      super.applyToAllUnaryMethods(unaryMethodSettingsBuilders, unaryCallSettings);
      return this;
    }

    /**
     * Returns the builder for the settings used for calls to billingAccountsList.
     */
    public PagedCallSettings.Builder<BillingAccountsListHttpRequest, BillingAccountsListHttpResponse, BillingAccountsListPagedResponse> billingAccountsListSettings() {
      return billingAccountsListSettings;
    }

    /**
     * Returns the builder for the settings used for calls to billingAccountsGet.
     */
    public SimpleCallSettings.Builder<BillingAccountsGetHttpRequest, BillingAccountsGetHttpResponse> billingAccountsGetSettings() {
      return billingAccountsGetSettings;
    }

    @Override
    public BillingAccountAdminSettings build() throws IOException {
      return new BillingAccountAdminSettings(this);
    }
  }
}
============== file: src/main/java/com/google/cloud/fakebilling/v1/ProjectAdminClient.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.BetaApi;
import com.google.auth.Credentials;
import java.io.Closeable;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import javax.annotation.Generated;

// AUTO-GENERATED DOCUMENTATION AND SERVICE
/**
 * Service Description:
 * Configure billing projects.
 *
 * <p>This class provides the ability to make remote calls to the backing service through method
 * calls that map to API methods. Sample code to get started:
 *
 * <pre>
 * <code>
 * try (ProjectAdminClient projectAdminClient = ProjectAdminClient.create()) {
 *
 *   ProjectBillingInfo response = projectAdminClient.projectsUpdateBillingInfo();
 * }
 * </code>
 * </pre>
 *
 * <p>Note: close() needs to be called on the projectAdminClient object to clean up resources such
 * as threads. In the example above, try-with-resources is used, which automatically calls
 * close().
 *
 * <p>The surface of this class includes several types of Java methods for each of the API's methods:
 *
 * <ol>
 * <li> A "flattened" method. With this type of method, the fields of the request type have been
 * converted into function parameters. It may be the case that not all fields are available
 * as parameters, and not every API method will have a flattened method entry point.
 * <li> A "request object" method. This type of method only takes one parameter, a request
 * object, which must be constructed before the call. Not every API method will have a request
 * object method.
 * <li> A "callable" method. This type of method takes no parameters and returns an immutable
 * API callable object, which can be used to initiate calls to the service.
 * </ol>
 *
 * <p>See the individual methods for example code.
 *
 * <p>Many parameters require resource names to be formatted in a particular way. To assist
 * with these names, this class includes a format method for each type of name, and additionally
 * a parse method to extract the individual identifiers contained within names that are
 * returned.
 *
 * <p>This class can be customized by passing in a custom instance of ProjectAdminSettings to
 * create(). For example:
 *
 * <pre>
 * <code>
 * ProjectAdminSettings projectAdminSettings =
 *     ProjectAdminSettings.defaultBuilder()
 *         .setCredentialsProvider(FixedCredentialsProvider.create(myCredentials))
 *         .build();
 * ProjectAdminClient projectAdminClient =
 *     ProjectAdminClient.create(projectAdminSettings);
 * </code>
 * </pre>
 */
@Generated("by GAPIC")
public class ProjectAdminClient implements AutoCloseable {
  private final ProjectAdminSettings settings;
  private final ScheduledExecutorService executor;
  private final ManagedChannel channel;
  private final List<AutoCloseable> closeables = new ArrayList<>();

  private final UnaryCallable<ProjectsUpdateBillingInfoHttpRequest, ProjectsUpdateBillingInfoHttpResponse> projectsUpdateBillingInfoCallable;
  private final UnaryCallable<ProjectsGetBillingInfoHttpRequest, ProjectsGetBillingInfoHttpResponse> projectsGetBillingInfoCallable;

  private static final PathTemplate PROJECT_PATH_TEMPLATE =
      PathTemplate.createWithoutUrlEncoding("projects/{project}");

  /**
   * Formats a string containing the fully-qualified path to represent
   * a project resource.
   */
  public static final String formatProjectName(String project) {
    return PROJECT_PATH_TEMPLATE.instantiate(
        "project", project);
  }

  /**
   * Parses the project from the given fully-qualified path which
   * represents a project resource.
   */
  public static final String parseProjectFromProjectName(String projectName) {
    return PROJECT_PATH_TEMPLATE.parse(projectName).get("project");
  }

  /**
   * Constructs an instance of ProjectAdminClient with default settings.
   */
  public static final ProjectAdminClient create() throws IOException {
    return create(ProjectAdminSettings.defaultBuilder().build());
  }

  /**
   * Constructs an instance of ProjectAdminClient, using the given settings.
   * The channels are created based on the settings passed in, or defaults for any
   * settings that are not set.
   */
  public static final ProjectAdminClient create(ProjectAdminSettings settings) throws IOException {
    return new ProjectAdminClient(settings);
  }

  /**
   * Constructs an instance of ProjectAdminClient, using the given settings.
   * This is protected so that it easy to make a subclass, but otherwise, the static
   * factory methods should be preferred.
   */
  protected ProjectAdminClient(ProjectAdminSettings settings) throws IOException {
    this.settings = settings;
    ChannelAndExecutor channelAndExecutor = settings.getChannelAndExecutor();
    this.executor = channelAndExecutor.getExecutor();
    this.channel = channelAndExecutor.getChannel();
    Credentials credentials = settings.getCredentialsProvider().getCredentials();

    ClientContext clientContext =
        ClientContext.newBuilder()
            .setExecutor(this.executor)
            .setChannel(this.channel)
            .setCredentials(credentials)
            .build();


    this.projectsUpdateBillingInfoCallable = UnaryCallable.create(settings.projectsUpdateBillingInfoSettings(), clientContext);
    this.projectsGetBillingInfoCallable = UnaryCallable.create(settings.projectsGetBillingInfoSettings(), clientContext);

    if (settings.getChannelProvider().shouldAutoClose()) {
      closeables.add(
        new Closeable() {
          @Override
          public void close() throws IOException {
            channel.shutdown();
          }
        });
    }
    if (settings.getExecutorProvider().shouldAutoClose()) {
      closeables.add(
        new Closeable() {
          @Override
          public void close() throws IOException {
            executor.shutdown();
          }
        });
    }
  }

  public final ProjectAdminSettings getSettings() {
    return settings;
  }


  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Sets or updates the billing account associated with a project. You specify
   * the new billing account by setting the `billing_account_name` in the
   * `ProjectBillingInfo` resource to the resource name of a billing account.
   * Associating a project with an open billing account enables billing on the
   * project and allows charges for resource usage. If the project already had a
   * billing account, this method changes the billing account used for resource
   * usage charges.
   *
   * &#42;Note:&#42; Incurred charges that have not yet been reported in the transaction
   * history of the Google Cloud Console may be billed to the new billing
   * account, even if the charge occurred before the new billing account was
   * assigned to the project.
   *
   * The current authenticated user must have ownership privileges for both the
   * [project](https://cloud.google.com/docs/permissions-overview#h.bgs0oxofvnoo
   * ) and the [billing
   * account](https://support.google.com/cloud/answer/4430947).
   *
   * You can disable billing on the project by setting the
   * `billing_account_name` field to empty. This action disassociates the
   * current billing account from the project. Any billable activity of your
   * in-use services will stop, and your application could stop functioning as
   * expected. Any unbilled charges to date will be billed to the previously
   * associated account. The current authenticated user must be either an owner
   * of the project or an owner of the billing account for the project.
   *
   * Note that associating a project with a &#42;closed&#42; billing account will have
   * much the same effect as disabling billing on the project: any paid
   * resources used by the project will be shut down. Thus, unless you wish to
   * disable billing, you should always call this method with the name of an
   * &#42;open&#42; billing account.
   *
   * Sample code:
   * <pre><code>
   * try (ProjectAdminClient projectAdminClient = ProjectAdminClient.create()) {
   *
   *   ProjectBillingInfo response = projectAdminClient.projectsUpdateBillingInfo();
   * }
   * </code></pre>
   *
   * @param request The request object containing all of the parameters for the API call.
   * @throws com.google.api.gax.grpc.ApiException if the remote call fails
   */
  @BetaApi
  public final ProjectBillingInfo projectsUpdateBillingInfo(ProjectsUpdateBillingInfoHttpRequest request) {
    return projectsUpdateBillingInfoCallable().call(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Sets or updates the billing account associated with a project. You specify
   * the new billing account by setting the `billing_account_name` in the
   * `ProjectBillingInfo` resource to the resource name of a billing account.
   * Associating a project with an open billing account enables billing on the
   * project and allows charges for resource usage. If the project already had a
   * billing account, this method changes the billing account used for resource
   * usage charges.
   *
   * &#42;Note:&#42; Incurred charges that have not yet been reported in the transaction
   * history of the Google Cloud Console may be billed to the new billing
   * account, even if the charge occurred before the new billing account was
   * assigned to the project.
   *
   * The current authenticated user must have ownership privileges for both the
   * [project](https://cloud.google.com/docs/permissions-overview#h.bgs0oxofvnoo
   * ) and the [billing
   * account](https://support.google.com/cloud/answer/4430947).
   *
   * You can disable billing on the project by setting the
   * `billing_account_name` field to empty. This action disassociates the
   * current billing account from the project. Any billable activity of your
   * in-use services will stop, and your application could stop functioning as
   * expected. Any unbilled charges to date will be billed to the previously
   * associated account. The current authenticated user must be either an owner
   * of the project or an owner of the billing account for the project.
   *
   * Note that associating a project with a &#42;closed&#42; billing account will have
   * much the same effect as disabling billing on the project: any paid
   * resources used by the project will be shut down. Thus, unless you wish to
   * disable billing, you should always call this method with the name of an
   * &#42;open&#42; billing account.
   *
   * Sample code:
   * <pre><code>
   * try (ProjectAdminClient projectAdminClient = ProjectAdminClient.create()) {
   *
   *   ApiFuture&lt;ProjectBillingInfo&gt; future = projectAdminClient.projectsUpdateBillingInfoCallable().futureCall();
   *   // Do something
   *   ProjectsUpdateBillingInfoHttpResponse response = future.get();
   * }
   * </code></pre>
   */
  @BetaApi
  public final UnaryCallable<ProjectsUpdateBillingInfoHttpRequest, ProjectsUpdateBillingInfoHttpResponse> projectsUpdateBillingInfoCallable() {
    return projectsUpdateBillingInfoCallable;
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Gets the billing information for a project. The current authenticated user
   * must have [permission to view the
   * project](https://cloud.google.com/docs/permissions-overview#h.bgs0oxofvnoo
   * ).
   *
   * Sample code:
   * <pre><code>
   * try (ProjectAdminClient projectAdminClient = ProjectAdminClient.create()) {
   *
   *   ProjectBillingInfo response = projectAdminClient.projectsGetBillingInfo();
   * }
   * </code></pre>
   *
   * @param request The request object containing all of the parameters for the API call.
   * @throws com.google.api.gax.grpc.ApiException if the remote call fails
   */
  @BetaApi
  public final ProjectBillingInfo projectsGetBillingInfo(ProjectsGetBillingInfoHttpRequest request) {
    return projectsGetBillingInfoCallable().call(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Gets the billing information for a project. The current authenticated user
   * must have [permission to view the
   * project](https://cloud.google.com/docs/permissions-overview#h.bgs0oxofvnoo
   * ).
   *
   * Sample code:
   * <pre><code>
   * try (ProjectAdminClient projectAdminClient = ProjectAdminClient.create()) {
   *
   *   ApiFuture&lt;ProjectBillingInfo&gt; future = projectAdminClient.projectsGetBillingInfoCallable().futureCall();
   *   // Do something
   *   ProjectsGetBillingInfoHttpResponse response = future.get();
   * }
   * </code></pre>
   */
  @BetaApi
  public final UnaryCallable<ProjectsGetBillingInfoHttpRequest, ProjectsGetBillingInfoHttpResponse> projectsGetBillingInfoCallable() {
    return projectsGetBillingInfoCallable;
  }

  /**
   * Initiates an orderly shutdown in which preexisting calls continue but new calls are immediately
   * cancelled.
   */
  @Override
  public final void close() throws Exception {
    for (AutoCloseable closeable : closeables) {
      closeable.close();
    }
  }

}
============== file: src/main/java/com/google/cloud/fakebilling/v1/ProjectAdminSettings.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.core.CredentialsProvider;
import com.google.api.gax.core.GoogleCredentialsProvider;
import com.google.api.gax.core.PropertiesProvider;
import com.google.api.gax.grpc.ApiExceptions;
import com.google.api.gax.grpc.ChannelProvider;
import com.google.api.gax.grpc.ClientSettings;
import com.google.api.gax.grpc.ExecutorProvider;
import com.google.api.gax.grpc.InstantiatingChannelProvider;
import com.google.api.gax.grpc.InstantiatingExecutorProvider;
import com.google.api.gax.grpc.SimpleCallSettings;
import com.google.api.gax.grpc.UnaryCallSettings;
import com.google.api.gax.retrying.RetrySettings;
import com.google.auth.Credentials;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import io.grpc.ManagedChannel;
import io.grpc.Status;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import javax.annotation.Generated;
import org.threeten.bp.Duration;

// AUTO-GENERATED DOCUMENTATION AND CLASS
/**
 * Settings class to configure an instance of {@link ProjectAdminClient}.
 *
 * <p>The default instance has everything set to sensible defaults:
 *
 * <ul>
 * <li>The default service address (Service address.) and default port (443)
 * are used.
 * <li>Credentials are acquired automatically through Application Default Credentials.
 * <li>Retries are configured for idempotent methods but not for non-idempotent methods.
 * </ul>
 *
 * <p>The builder of this class is recursive, so contained classes are themselves builders.
 * When build() is called, the tree of builders is called to create the complete settings
 * object. For example, to set the total timeout of projectsUpdateBillingInfo to 30 seconds:
 *
 * <pre>
 * <code>
 * ProjectAdminSettings.Builder projectAdminSettingsBuilder =
 *     ProjectAdminSettings.defaultBuilder();
 * projectAdminSettingsBuilder.projectsUpdateBillingInfoSettings().getRetrySettingsBuilder()
 *     .setTotalTimeout(Duration.ofSeconds(30));
 * ProjectAdminSettings projectAdminSettings = projectAdminSettingsBuilder.build();
 * </code>
 * </pre>
 */
@Generated("by GAPIC v0.0.5")
public class ProjectAdminSettings extends ClientSettings {
  /**
   * The default scopes of the service.
   */
  private static final ImmutableList<String> DEFAULT_SERVICE_SCOPES = ImmutableList.<String>builder()
      .add("https://www.googleapis.com/auth/cloud-platform")
      .build();

  private static final String DEFAULT_GAPIC_NAME = "gapic";
  private static final String DEFAULT_GAPIC_VERSION = "";

  private static final String PROPERTIES_FILE = "/com/google/cloud/fakebilling/v1/project.properties";
  private static final String META_VERSION_KEY = "artifact.version";

  private static String gapicVersion;

  private static final io.grpc.MethodDescriptor<ProjectsUpdateBillingInfoHttpRequest, ProjectsUpdateBillingInfoHttpResponse> getGrpcMethodConstant() not implemented for Discovery-based APIs. =
        io.grpc.MethodDescriptor.create(
            io.grpc.MethodDescriptor.MethodType.UNARY,
            "Full service name./fakebilling.projects.updateBillingInfo",
            io.grpc.protobuf.ProtoUtils.marshaller(projectsUpdateBillingInfoHttpRequest.getDefaultInstance()),
            io.grpc.protobuf.ProtoUtils.marshaller(ProjectBillingInfo.getDefaultInstance()));
  private static final io.grpc.MethodDescriptor<projectsGetBillingInfoHttpRequest, ProjectBillingInfo> Grpc not used in Discovery-based method. =
        io.grpc.MethodDescriptor.create(
            io.grpc.MethodDescriptor.MethodType.UNARY,
            "Full service name./fakebilling.projects.getBillingInfo",
            io.grpc.protobuf.ProtoUtils.marshaller(projectsGetBillingInfoHttpRequest.getDefaultInstance()),
            io.grpc.protobuf.ProtoUtils.marshaller(ProjectBillingInfo.getDefaultInstance()));

  private final SimpleCallSettings<ProjectsUpdateBillingInfoHttpRequest, ProjectsUpdateBillingInfoHttpResponse> fakebillingProjectsUpdateBillingInfoSettings;
  private final SimpleCallSettings<ProjectsGetBillingInfoHttpRequest, ProjectsGetBillingInfoHttpResponse> fakebillingProjectsGetBillingInfoSettings;

  /**
   * Returns the object with the settings used for calls to projectsUpdateBillingInfo.
   */
  public SimpleCallSettings<ProjectsUpdateBillingInfoHttpRequest, ProjectsUpdateBillingInfoHttpResponse> projectsUpdateBillingInfoSettings() {
    return projectsUpdateBillingInfoSettings;
  }

  /**
   * Returns the object with the settings used for calls to projectsGetBillingInfo.
   */
  public SimpleCallSettings<ProjectsGetBillingInfoHttpRequest, ProjectsGetBillingInfoHttpResponse> projectsGetBillingInfoSettings() {
    return projectsGetBillingInfoSettings;
  }


  /**
   * Returns a builder for the default ExecutorProvider for this service.
   */
  public static InstantiatingExecutorProvider.Builder defaultExecutorProviderBuilder() {
    return InstantiatingExecutorProvider.newBuilder();
  }

  /**
   * Returns the default service endpoint.
   */
  public static String getDefaultEndpoint() {
    return "Service address.:443";
  }


  /**
   * Returns the default service scopes.
   */
  public static List<String> getDefaultServiceScopes() {
    return DEFAULT_SERVICE_SCOPES;
  }


  /**
   * Returns a builder for the default credentials for this service.
   */
  public static GoogleCredentialsProvider.Builder defaultCredentialsProviderBuilder() {
    return GoogleCredentialsProvider.newBuilder()
        .setScopesToApply(DEFAULT_SERVICE_SCOPES)
        ;
  }

  /** Returns a builder for the default ChannelProvider for this service. */
  public static InstantiatingChannelProvider.Builder defaultChannelProviderBuilder() {
    return InstantiatingChannelProvider.newBuilder()
        .setEndpoint(getDefaultEndpoint())
        .setGeneratorHeader(DEFAULT_GAPIC_NAME, getGapicVersion());
  }

  private static String getGapicVersion() {
    if (gapicVersion == null) {
      gapicVersion = PropertiesProvider.loadProperty(
          ProjectAdminSettings.class, PROPERTIES_FILE, META_VERSION_KEY);
      gapicVersion = gapicVersion == null ? DEFAULT_GAPIC_VERSION : gapicVersion;
    }
    return gapicVersion;
  }

  /**
   * Returns a builder for this class with recommended defaults.
   */
  public static Builder defaultBuilder() {
    return Builder.createDefault();
  }

  /**
   * Returns a new builder for this class.
   */
  public static Builder newBuilder() {
    return new Builder();
  }

  /**
   * Returns a builder containing all the values of this settings class.
   */
  public Builder toBuilder() {
    return new Builder(this);
  }

  private ProjectAdminSettings(Builder settingsBuilder) throws IOException {
    super(settingsBuilder.getExecutorProvider(),
          settingsBuilder.getChannelProvider(),
          settingsBuilder.getCredentialsProvider());

    projectsUpdateBillingInfoSettings = settingsBuilder.projectsUpdateBillingInfoSettings().build();
    projectsGetBillingInfoSettings = settingsBuilder.projectsGetBillingInfoSettings().build();
  }




  /**
   * Builder for ProjectAdminSettings.
   */
  public static class Builder extends ClientSettings.Builder {
    private final ImmutableList<UnaryCallSettings.Builder> unaryMethodSettingsBuilders;

    private final SimpleCallSettings.Builder<ProjectsUpdateBillingInfoHttpRequest, ProjectsUpdateBillingInfoHttpResponse> projectsUpdateBillingInfoSettings;
    private final SimpleCallSettings.Builder<ProjectsGetBillingInfoHttpRequest, ProjectsGetBillingInfoHttpResponse> projectsGetBillingInfoSettings;

    private static final ImmutableMap<String, ImmutableSet<Status.Code>> RETRYABLE_CODE_DEFINITIONS;

    static {
      ImmutableMap.Builder<String, ImmutableSet<Status.Code>> definitions = ImmutableMap.builder();
      definitions.put(
          "idempotent",
          Sets.immutableEnumSet(Lists.<Status.Code>newArrayList(Status.Code.DEADLINE_EXCEEDED, Status.Code.UNAVAILABLE)));
      RETRYABLE_CODE_DEFINITIONS = definitions.build();
    }

    private static final ImmutableMap<String, RetrySettings.Builder> RETRY_PARAM_DEFINITIONS;

    static {
      ImmutableMap.Builder<String, RetrySettings.Builder> definitions = ImmutableMap.builder();
      RetrySettings.Builder settingsBuilder = null;
      settingsBuilder = RetrySettings.newBuilder()
          .setInitialRetryDelay(Duration.ofMillis(100L))
          .setRetryDelayMultiplier(1.3)
          .setMaxRetryDelay(Duration.ofMillis(60000L))
          .setInitialRpcTimeout(Duration.ofMillis(60000L))
          .setRpcTimeoutMultiplier(1.0)
          .setMaxRpcTimeout(Duration.ofMillis(60000L))
          .setTotalTimeout(Duration.ofMillis(600000L));
      definitions.put("default", settingsBuilder);
      RETRY_PARAM_DEFINITIONS = definitions.build();
    }

    private Builder() {
      super(defaultChannelProviderBuilder().build());
      setCredentialsProvider(defaultCredentialsProviderBuilder().build());

      fakebillingProjectsUpdateBillingInfoSettings = SimpleCallSettings.newBuilder(Grpc not used in Discovery-based method.);

      fakebillingProjectsGetBillingInfoSettings = SimpleCallSettings.newBuilder(Grpc not used in Discovery-based method.);

      unaryMethodSettingsBuilders = ImmutableList.<UnaryCallSettings.Builder>of(
          projectsUpdateBillingInfoSettings,
          projectsGetBillingInfoSettings
      );
    }

    private static Builder createDefault() {
      Builder builder = new Builder();

      builder.projectsUpdateBillingInfoSettings()
          .setRetryableCodes(RETRYABLE_CODE_DEFINITIONS.get("idempotent"))
          .setRetrySettingsBuilder(RETRY_PARAM_DEFINITIONS.get("default"));

      builder.projectsGetBillingInfoSettings()
          .setRetryableCodes(RETRYABLE_CODE_DEFINITIONS.get("idempotent"))
          .setRetrySettingsBuilder(RETRY_PARAM_DEFINITIONS.get("default"));

      return builder;
    }

    private Builder(ProjectAdminSettings settings) {
      super(settings);

      projectsUpdateBillingInfoSettings = settings.projectsUpdateBillingInfoSettings.toBuilder();
      projectsGetBillingInfoSettings = settings.projectsGetBillingInfoSettings.toBuilder();

      unaryMethodSettingsBuilders = ImmutableList.<UnaryCallSettings.Builder>of(
          projectsUpdateBillingInfoSettings,
          projectsGetBillingInfoSettings
      );
    }

    @Override
    public Builder setExecutorProvider(ExecutorProvider executorProvider) {
      super.setExecutorProvider(executorProvider);
      return this;
    }

    @Override
    public Builder setChannelProvider(ChannelProvider channelProvider) {
      super.setChannelProvider(channelProvider);
      return this;
    }

    @Override
    public Builder setCredentialsProvider(CredentialsProvider credentialsProvider) {
      super.setCredentialsProvider(credentialsProvider);
      return this;
    }

    /**
     * Applies the given settings to all of the unary API methods in this service. Only
     * values that are non-null will be applied, so this method is not capable
     * of un-setting any values.
     *
     * Note: This method does not support applying settings to streaming methods.
     */
    public Builder applyToAllUnaryMethods(UnaryCallSettings.Builder unaryCallSettings) throws Exception {
      super.applyToAllUnaryMethods(unaryMethodSettingsBuilders, unaryCallSettings);
      return this;
    }

    /**
     * Returns the builder for the settings used for calls to projectsUpdateBillingInfo.
     */
    public SimpleCallSettings.Builder<ProjectsUpdateBillingInfoHttpRequest, ProjectsUpdateBillingInfoHttpResponse> projectsUpdateBillingInfoSettings() {
      return projectsUpdateBillingInfoSettings;
    }

    /**
     * Returns the builder for the settings used for calls to projectsGetBillingInfo.
     */
    public SimpleCallSettings.Builder<ProjectsGetBillingInfoHttpRequest, ProjectsGetBillingInfoHttpResponse> projectsGetBillingInfoSettings() {
      return projectsGetBillingInfoSettings;
    }

    @Override
    public ProjectAdminSettings build() throws IOException {
      return new ProjectAdminSettings(this);
    }
  }
}
============== file: src/main/java/com/google/cloud/fakebilling/v1/PagedResponseWrappers.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.fakebilling.v1;

import com.google.api.core.ApiFunction;
import com.google.api.core.ApiFuture;
import com.google.api.core.ApiFutures;
import com.google.api.core.BetaApi;
import com.google.api.gax.core.FixedSizeCollection;
import com.google.api.gax.core.Page;
import com.google.api.gax.core.PagedListResponse;
import com.google.api.gax.grpc.AbstractFixedSizeCollection;
import com.google.api.gax.grpc.AbstractPage;
import com.google.api.gax.grpc.AbstractPagedListResponse;
import com.google.api.gax.grpc.ApiExceptions;
import com.google.api.gax.grpc.PageContext;
import com.google.common.base.Function;
import com.google.common.collect.Iterables;
import java.util.Iterator;
import java.util.List;
import javax.annotation.Generated;

// AUTO-GENERATED DOCUMENTATION AND CLASS
/**
 * Wrapper class to contain paged response types for page streaming methods.
 * Each static class inside this wrapper class is used as the return type of
 * one of an API method that implements the page streaming pattern.
 */
@Generated("by GAPIC")
public class PagedResponseWrappers {

  public static class BillingAccountsListPagedResponse extends AbstractPagedListResponse<
      BillingAccountsListHttpRequest,
      BillingAccountsListHttpResponse,
      ListBillingAccountsResponse,
      BillingAccountsListPage,
      BillingAccountsListFixedSizeCollection> {

    public static ApiFuture<BillingAccountsListPagedResponse> createAsync(
        PageContext<BillingAccountsListHttpRequest, BillingAccountsListHttpResponse, ListBillingAccountsResponse> context,
        ApiFuture<BillingAccountsListHttpResponse> futureResponse) {
      ApiFuture<BillingAccountsListPage> futurePage =
          BillingAccountsListPage.createEmptyPage().createPageAsync(context, futureResponse);
      return ApiFutures.transform(
          futurePage,
          new ApiFunction<BillingAccountsListPage, BillingAccountsListPagedResponse>() {
            @Override
            public BillingAccountsListPagedResponse apply(BillingAccountsListPage input) {
              return new BillingAccountsListPagedResponse(input);
            }
          });
    }

    private BillingAccountsListPagedResponse(BillingAccountsListPage page) {
      super(page, BillingAccountsListFixedSizeCollection.createEmptyCollection());
    }


  }

  public static class BillingAccountsListPage extends AbstractPage<
      BillingAccountsListHttpRequest,
      BillingAccountsListHttpResponse,
      ListBillingAccountsResponse,
      BillingAccountsListPage> {

    private BillingAccountsListPage(
        PageContext<BillingAccountsListHttpRequest, BillingAccountsListHttpResponse, ListBillingAccountsResponse> context,
        BillingAccountsListHttpResponse response) {
      super(context, response);
    }

    private static BillingAccountsListPage createEmptyPage() {
      return new BillingAccountsListPage(null, null);
    }

    @Override
    protected BillingAccountsListPage createPage(
        PageContext<BillingAccountsListHttpRequest, BillingAccountsListHttpResponse, ListBillingAccountsResponse> context,
        BillingAccountsListHttpResponse response) {
      return new BillingAccountsListPage(context, response);
    }

    @Override
    protected ApiFuture<BillingAccountsListPage> createPageAsync(
        PageContext<BillingAccountsListHttpRequest, BillingAccountsListHttpResponse, ListBillingAccountsResponse> context,
        ApiFuture<BillingAccountsListHttpResponse> futureResponse) {
      return super.createPageAsync(context, futureResponse);
    }




  }

  public static class BillingAccountsListFixedSizeCollection extends AbstractFixedSizeCollection<
      BillingAccountsListHttpRequest,
      BillingAccountsListHttpResponse,
      ListBillingAccountsResponse,
      BillingAccountsListPage,
      BillingAccountsListFixedSizeCollection> {

    private BillingAccountsListFixedSizeCollection(List<BillingAccountsListPage> pages, int collectionSize) {
      super(pages, collectionSize);
    }

    private static BillingAccountsListFixedSizeCollection createEmptyCollection() {
      return new BillingAccountsListFixedSizeCollection(null, 0);
    }

    @Override
    protected BillingAccountsListFixedSizeCollection createCollection(
        List<BillingAccountsListPage> pages, int collectionSize) {
      return new BillingAccountsListFixedSizeCollection(pages, collectionSize);
    }


  }

}
============== file: src/main/java/com/google/cloud/fakebilling/v1/package-info.java ==============
/*
 * Copyright 2017, Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A client to Service title..
 *
 * The interfaces provided are listed below, along with usage samples.
 *
 * =========================
 * BillingAccountAdminClient
 * =========================
 *
 * Service Description:
 *
 * Sample for BillingAccountAdminClient:
 * <pre>
 * <code>
 * try (BillingAccountAdminClient billingAccountAdminClient = BillingAccountAdminClient.create()) {
 *
 *   BillingAccount response = billingAccountAdminClient.billingAccountsGet();
 * }
 * </code>
 * </pre>
 *
 * ==================
 * ProjectAdminClient
 * ==================
 *
 * Service Description:
 * Configure billing projects.
 *
 * Sample for ProjectAdminClient:
 * <pre>
 * <code>
 * try (ProjectAdminClient projectAdminClient = ProjectAdminClient.create()) {
 *
 *   ProjectBillingInfo response = projectAdminClient.projectsUpdateBillingInfo();
 * }
 * </code>
 * </pre>
 *
 */

package com.google.cloud.fakebilling.v1;
