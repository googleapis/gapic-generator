============== file: src/main/java/com/google/cloud/simplecompute/v1/ProjectGlobalAddressName.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.pathtemplate.PathTemplate;
import com.google.api.resourcenames.ResourceName;
import com.google.api.resourcenames.ResourceNameFactory;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableMap;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class ProjectGlobalAddressName implements ResourceName {
  private final String address;
  private final String project;
  private static final PathTemplate PATH_TEMPLATE =
        PathTemplate.createWithoutUrlEncoding("{project}/global/addresses/{address}");

  public static final String SERVICE_ADDRESS = "https://www.googleapis.com/compute/v1/projects/";

  private volatile Map<String, String> fieldValuesMap;

  public static Builder newBuilder() {
    return new Builder();
  }

  public Builder toBuilder() {
    return new Builder(this);
  }

  private ProjectGlobalAddressName(Builder builder) {
    address = Preconditions.checkNotNull(builder.getAddress());
    project = Preconditions.checkNotNull(builder.getProject());
  }

  public static ProjectGlobalAddressName of(
      String address,
      String project
      ) {
    return newBuilder()
    .setAddress(address)
    .setProject(project)
      .build();
  }

  public static String format(
      String address,
      String project
      ) {
    return of(
        address,
        project
        )
        .toString();
  }

  public String getAddress() {
    return address;
  }

  public String getProject() {
    return project;
  }


  @Override
  public Map<String, String> getFieldValuesMap() {
    if (fieldValuesMap == null) {
      synchronized (this) {
        if (fieldValuesMap == null) {
          ImmutableMap.Builder<String, String> fieldMapBuilder = ImmutableMap.builder();
          fieldMapBuilder.put("address", address);
          fieldMapBuilder.put("project", project);
          fieldValuesMap = fieldMapBuilder.build();
        }
      }
    }
    return fieldValuesMap;
  }

  public String getFieldValue(String fieldName) {
    return getFieldValuesMap().get(fieldName);
  }


  public static ResourceNameFactory<ProjectGlobalAddressName> newFactory() {
    return new ResourceNameFactory<ProjectGlobalAddressName>() {
      public ProjectGlobalAddressName parse(String formattedString) {return ProjectGlobalAddressName.parse(formattedString);}
    };
  }

  public static ProjectGlobalAddressName parse(String formattedString) {
    String resourcePath = formattedString;
    if (formattedString.startsWith(SERVICE_ADDRESS)) {
      resourcePath = formattedString.substring(SERVICE_ADDRESS.length());
    }
    Map<String, String> matchMap =
        PATH_TEMPLATE.validatedMatch(resourcePath, "ProjectGlobalAddressName.parse: formattedString not in valid format");
    return of(
      matchMap.get("address"),
      matchMap.get("project")
    );
  }

  public static boolean isParsableFrom(String formattedString) {
    String resourcePath = formattedString;
    if (formattedString.startsWith(SERVICE_ADDRESS)) {
      resourcePath = formattedString.substring(SERVICE_ADDRESS.length());
    }
    return PATH_TEMPLATE.matches(resourcePath);
  }

  public static class Builder {
    private String address;
    private String project;

    public String getAddress() {
      return address;
    }
    public String getProject() {
      return project;
    }

    public Builder setAddress(String address) {
      this.address = address;
      return this;
    }
    public Builder setProject(String project) {
      this.project = project;
      return this;
    }

    private Builder() {}

    public Builder (ProjectGlobalAddressName projectGlobalAddressName) {
      address = projectGlobalAddressName.address;
      project = projectGlobalAddressName.project;
    }

    public ProjectGlobalAddressName build() {
      return new ProjectGlobalAddressName(this);
    }
  }

  @Override
  public String toString() {
    return  SERVICE_ADDRESS + PATH_TEMPLATE.instantiate(
        "address", address,
        "project", project
        );
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof ProjectGlobalAddressName) {
      ProjectGlobalAddressName that = (ProjectGlobalAddressName) o;
      return
          Objects.equals(this.address, that.getAddress()) &&
          Objects.equals(this.project, that.getProject())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      address,
      project
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/ProjectName.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.pathtemplate.PathTemplate;
import com.google.api.resourcenames.ResourceName;
import com.google.api.resourcenames.ResourceNameFactory;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableMap;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class ProjectName implements ResourceName {
  private final String project;
  private static final PathTemplate PATH_TEMPLATE =
        PathTemplate.createWithoutUrlEncoding("{project}");

  public static final String SERVICE_ADDRESS = "https://www.googleapis.com/compute/v1/projects/";

  private volatile Map<String, String> fieldValuesMap;

  public static Builder newBuilder() {
    return new Builder();
  }

  public Builder toBuilder() {
    return new Builder(this);
  }

  private ProjectName(Builder builder) {
    project = Preconditions.checkNotNull(builder.getProject());
  }

  public static ProjectName of(
      String project
      ) {
    return newBuilder()
    .setProject(project)
      .build();
  }

  public static String format(
      String project
      ) {
    return of(
        project
        )
        .toString();
  }

  public String getProject() {
    return project;
  }


  @Override
  public Map<String, String> getFieldValuesMap() {
    if (fieldValuesMap == null) {
      synchronized (this) {
        if (fieldValuesMap == null) {
          ImmutableMap.Builder<String, String> fieldMapBuilder = ImmutableMap.builder();
          fieldMapBuilder.put("project", project);
          fieldValuesMap = fieldMapBuilder.build();
        }
      }
    }
    return fieldValuesMap;
  }

  public String getFieldValue(String fieldName) {
    return getFieldValuesMap().get(fieldName);
  }


  public static ResourceNameFactory<ProjectName> newFactory() {
    return new ResourceNameFactory<ProjectName>() {
      public ProjectName parse(String formattedString) {return ProjectName.parse(formattedString);}
    };
  }

  public static ProjectName parse(String formattedString) {
    String resourcePath = formattedString;
    if (formattedString.startsWith(SERVICE_ADDRESS)) {
      resourcePath = formattedString.substring(SERVICE_ADDRESS.length());
    }
    Map<String, String> matchMap =
        PATH_TEMPLATE.validatedMatch(resourcePath, "ProjectName.parse: formattedString not in valid format");
    return of(
      matchMap.get("project")
    );
  }

  public static boolean isParsableFrom(String formattedString) {
    String resourcePath = formattedString;
    if (formattedString.startsWith(SERVICE_ADDRESS)) {
      resourcePath = formattedString.substring(SERVICE_ADDRESS.length());
    }
    return PATH_TEMPLATE.matches(resourcePath);
  }

  public static class Builder {
    private String project;

    public String getProject() {
      return project;
    }

    public Builder setProject(String project) {
      this.project = project;
      return this;
    }

    private Builder() {}

    public Builder (ProjectName projectName) {
      project = projectName.project;
    }

    public ProjectName build() {
      return new ProjectName(this);
    }
  }

  @Override
  public String toString() {
    return  SERVICE_ADDRESS + PATH_TEMPLATE.instantiate(
        "project", project
        );
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof ProjectName) {
      ProjectName that = (ProjectName) o;
      return
          Objects.equals(this.project, that.getProject())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      project
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/ProjectRegionAddressName.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.pathtemplate.PathTemplate;
import com.google.api.resourcenames.ResourceName;
import com.google.api.resourcenames.ResourceNameFactory;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableMap;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class ProjectRegionAddressName implements ResourceName {
  private final String address;
  private final String project;
  private final String region;
  private static final PathTemplate PATH_TEMPLATE =
        PathTemplate.createWithoutUrlEncoding("{project}/regions/{region}/addresses/{address}");

  public static final String SERVICE_ADDRESS = "https://www.googleapis.com/compute/v1/projects/";

  private volatile Map<String, String> fieldValuesMap;

  public static Builder newBuilder() {
    return new Builder();
  }

  public Builder toBuilder() {
    return new Builder(this);
  }

  private ProjectRegionAddressName(Builder builder) {
    address = Preconditions.checkNotNull(builder.getAddress());
    project = Preconditions.checkNotNull(builder.getProject());
    region = Preconditions.checkNotNull(builder.getRegion());
  }

  public static ProjectRegionAddressName of(
      String address,
      String project,
      String region
      ) {
    return newBuilder()
    .setAddress(address)
    .setProject(project)
    .setRegion(region)
      .build();
  }

  public static String format(
      String address,
      String project,
      String region
      ) {
    return of(
        address,
        project,
        region
        )
        .toString();
  }

  public String getAddress() {
    return address;
  }

  public String getProject() {
    return project;
  }

  public String getRegion() {
    return region;
  }


  @Override
  public Map<String, String> getFieldValuesMap() {
    if (fieldValuesMap == null) {
      synchronized (this) {
        if (fieldValuesMap == null) {
          ImmutableMap.Builder<String, String> fieldMapBuilder = ImmutableMap.builder();
          fieldMapBuilder.put("address", address);
          fieldMapBuilder.put("project", project);
          fieldMapBuilder.put("region", region);
          fieldValuesMap = fieldMapBuilder.build();
        }
      }
    }
    return fieldValuesMap;
  }

  public String getFieldValue(String fieldName) {
    return getFieldValuesMap().get(fieldName);
  }


  public static ResourceNameFactory<ProjectRegionAddressName> newFactory() {
    return new ResourceNameFactory<ProjectRegionAddressName>() {
      public ProjectRegionAddressName parse(String formattedString) {return ProjectRegionAddressName.parse(formattedString);}
    };
  }

  public static ProjectRegionAddressName parse(String formattedString) {
    String resourcePath = formattedString;
    if (formattedString.startsWith(SERVICE_ADDRESS)) {
      resourcePath = formattedString.substring(SERVICE_ADDRESS.length());
    }
    Map<String, String> matchMap =
        PATH_TEMPLATE.validatedMatch(resourcePath, "ProjectRegionAddressName.parse: formattedString not in valid format");
    return of(
      matchMap.get("address"),
      matchMap.get("project"),
      matchMap.get("region")
    );
  }

  public static boolean isParsableFrom(String formattedString) {
    String resourcePath = formattedString;
    if (formattedString.startsWith(SERVICE_ADDRESS)) {
      resourcePath = formattedString.substring(SERVICE_ADDRESS.length());
    }
    return PATH_TEMPLATE.matches(resourcePath);
  }

  public static class Builder {
    private String address;
    private String project;
    private String region;

    public String getAddress() {
      return address;
    }
    public String getProject() {
      return project;
    }
    public String getRegion() {
      return region;
    }

    public Builder setAddress(String address) {
      this.address = address;
      return this;
    }
    public Builder setProject(String project) {
      this.project = project;
      return this;
    }
    public Builder setRegion(String region) {
      this.region = region;
      return this;
    }

    private Builder() {}

    public Builder (ProjectRegionAddressName projectRegionAddressName) {
      address = projectRegionAddressName.address;
      project = projectRegionAddressName.project;
      region = projectRegionAddressName.region;
    }

    public ProjectRegionAddressName build() {
      return new ProjectRegionAddressName(this);
    }
  }

  @Override
  public String toString() {
    return  SERVICE_ADDRESS + PATH_TEMPLATE.instantiate(
        "address", address,
        "project", project,
        "region", region
        );
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof ProjectRegionAddressName) {
      ProjectRegionAddressName that = (ProjectRegionAddressName) o;
      return
          Objects.equals(this.address, that.getAddress()) &&
          Objects.equals(this.project, that.getProject()) &&
          Objects.equals(this.region, that.getRegion())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      address,
      project,
      region
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/ProjectRegionName.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.pathtemplate.PathTemplate;
import com.google.api.resourcenames.ResourceName;
import com.google.api.resourcenames.ResourceNameFactory;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableMap;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;

@Generated("by GAPIC")
@BetaApi
public final class ProjectRegionName implements ResourceName {
  private final String project;
  private final String region;
  private static final PathTemplate PATH_TEMPLATE =
        PathTemplate.createWithoutUrlEncoding("{project}/regions/{region}");

  public static final String SERVICE_ADDRESS = "https://www.googleapis.com/compute/v1/projects/";

  private volatile Map<String, String> fieldValuesMap;

  public static Builder newBuilder() {
    return new Builder();
  }

  public Builder toBuilder() {
    return new Builder(this);
  }

  private ProjectRegionName(Builder builder) {
    project = Preconditions.checkNotNull(builder.getProject());
    region = Preconditions.checkNotNull(builder.getRegion());
  }

  public static ProjectRegionName of(
      String project,
      String region
      ) {
    return newBuilder()
    .setProject(project)
    .setRegion(region)
      .build();
  }

  public static String format(
      String project,
      String region
      ) {
    return of(
        project,
        region
        )
        .toString();
  }

  public String getProject() {
    return project;
  }

  public String getRegion() {
    return region;
  }


  @Override
  public Map<String, String> getFieldValuesMap() {
    if (fieldValuesMap == null) {
      synchronized (this) {
        if (fieldValuesMap == null) {
          ImmutableMap.Builder<String, String> fieldMapBuilder = ImmutableMap.builder();
          fieldMapBuilder.put("project", project);
          fieldMapBuilder.put("region", region);
          fieldValuesMap = fieldMapBuilder.build();
        }
      }
    }
    return fieldValuesMap;
  }

  public String getFieldValue(String fieldName) {
    return getFieldValuesMap().get(fieldName);
  }


  public static ResourceNameFactory<ProjectRegionName> newFactory() {
    return new ResourceNameFactory<ProjectRegionName>() {
      public ProjectRegionName parse(String formattedString) {return ProjectRegionName.parse(formattedString);}
    };
  }

  public static ProjectRegionName parse(String formattedString) {
    String resourcePath = formattedString;
    if (formattedString.startsWith(SERVICE_ADDRESS)) {
      resourcePath = formattedString.substring(SERVICE_ADDRESS.length());
    }
    Map<String, String> matchMap =
        PATH_TEMPLATE.validatedMatch(resourcePath, "ProjectRegionName.parse: formattedString not in valid format");
    return of(
      matchMap.get("project"),
      matchMap.get("region")
    );
  }

  public static boolean isParsableFrom(String formattedString) {
    String resourcePath = formattedString;
    if (formattedString.startsWith(SERVICE_ADDRESS)) {
      resourcePath = formattedString.substring(SERVICE_ADDRESS.length());
    }
    return PATH_TEMPLATE.matches(resourcePath);
  }

  public static class Builder {
    private String project;
    private String region;

    public String getProject() {
      return project;
    }
    public String getRegion() {
      return region;
    }

    public Builder setProject(String project) {
      this.project = project;
      return this;
    }
    public Builder setRegion(String region) {
      this.region = region;
      return this;
    }

    private Builder() {}

    public Builder (ProjectRegionName projectRegionName) {
      project = projectRegionName.project;
      region = projectRegionName.region;
    }

    public ProjectRegionName build() {
      return new ProjectRegionName(this);
    }
  }

  @Override
  public String toString() {
    return  SERVICE_ADDRESS + PATH_TEMPLATE.instantiate(
        "project", project,
        "region", region
        );
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof ProjectRegionName) {
      ProjectRegionName that = (ProjectRegionName) o;
      return
          Objects.equals(this.project, that.getProject()) &&
          Objects.equals(this.region, that.getRegion())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      project,
      region
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/Address.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.httpjson.ApiMessage;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.annotations.SerializedName;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;
import javax.annotation.Nullable;

@Generated("by GAPIC")
@BetaApi
/**
 * A reserved address resource.
*/
public final class Address implements ApiMessage {
  private final String address;
  private final String description;
  private final String id;
  private final String kind;
  private final String name;
  private final String region;
  private final String selfLink;
  private final String status;

  private Address() {
    this.address = null;
    this.description = null;
    this.id = null;
    this.kind = null;
    this.name = null;
    this.region = null;
    this.selfLink = null;
    this.status = null;
  }


  private Address(
      String address,
      String description,
      String id,
      String kind,
      String name,
      String region,
      String selfLink,
      String status
      ) {
    this.address = address;
    this.description = description;
    this.id = id;
    this.kind = kind;
    this.name = name;
    this.region = region;
    this.selfLink = selfLink;
    this.status = status;
  }

  @Override
  public Object getFieldValue(String fieldName) {
    if ("address".equals(fieldName)) {
      return address;
    }
    if ("description".equals(fieldName)) {
      return description;
    }
    if ("id".equals(fieldName)) {
      return id;
    }
    if ("kind".equals(fieldName)) {
      return kind;
    }
    if ("name".equals(fieldName)) {
      return name;
    }
    if ("region".equals(fieldName)) {
      return region;
    }
    if ("selfLink".equals(fieldName)) {
      return selfLink;
    }
    if ("status".equals(fieldName)) {
      return status;
    }
    return null;
  }

  @Nullable
  @Override
  public ApiMessage getApiMessageRequestBody() {
    return null;
  }

  @Nullable
  @Override
  /**
   * The fields that should be serialized (even if they have empty values).
   * If the containing message object has a non-null fieldmask,
   * then all the fields in the field mask (and only those fields in the field mask)
   * will be serialized. If the containing object does not have a fieldmask, then
   * only non-empty fields will be serialized.
  */
  public List<String> getFieldMask() {
    return null;
  }

  /**
   * The static external IP address represented by this resource. Only IPv4 is supported.
  */
  public String getAddress() {
    return address;
  }

  /**
   * An optional description of this resource. Provide this property when you create the resource.
  */
  public String getDescription() {
    return description;
  }

  /**
   * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
  */
  public String getId() {
    return id;
  }

  /**
   * [Output Only] Type of the resource. Always compute#address for addresses.
  */
  public String getKind() {
    return kind;
  }

  /**
   * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression [a-z]([-a-z0-9]&#42;[a-z0-9])? which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
  */
  public String getName() {
    return name;
  }

  /**
   * [Output Only] URL of the region where the regional address resides. This field is not applicable to global addresses.
  */
  public String getRegion() {
    return region;
  }

  /**
   * [Output Only] Server-defined URL for the resource.
  */
  public String getSelfLink() {
    return selfLink;
  }

  /**
   * [Output Only] The status of the address, which can be either IN_USE or RESERVED. An address that is RESERVED is currently reserved and available to use. An IN_USE address is currently being used by another resource and is not available.
  */
  public String getStatus() {
    return status;
  }


  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(Address prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  public static Address getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }
  private static final Address DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new Address();
  }

  public static class Builder {
    private String address;
    private String description;
    private String id;
    private String kind;
    private String name;
    private String region;
    private String selfLink;
    private String status;

    Builder() {}

    public Builder mergeFrom(Address other) {
      if (other == Address.getDefaultInstance()) return this;
      if (other.getAddress() != null) {
        this.address = other.address;
      }
      if (other.getDescription() != null) {
        this.description = other.description;
      }
      if (other.getId() != null) {
        this.id = other.id;
      }
      if (other.getKind() != null) {
        this.kind = other.kind;
      }
      if (other.getName() != null) {
        this.name = other.name;
      }
      if (other.getRegion() != null) {
        this.region = other.region;
      }
      if (other.getSelfLink() != null) {
        this.selfLink = other.selfLink;
      }
      if (other.getStatus() != null) {
        this.status = other.status;
      }
      return this;
    }

    Builder(Address source) {
      this.address = source.address;
      this.description = source.description;
      this.id = source.id;
      this.kind = source.kind;
      this.name = source.name;
      this.region = source.region;
      this.selfLink = source.selfLink;
      this.status = source.status;
    }

    /**
     * The static external IP address represented by this resource. Only IPv4 is supported.
    */
    public String getAddress() {
      return address;
    }

    /**
     * The static external IP address represented by this resource. Only IPv4 is supported.
    */
    public Builder setAddress(String address) {
      this.address = address;
      return this;
    }

    /**
     * An optional description of this resource. Provide this property when you create the resource.
    */
    public String getDescription() {
      return description;
    }

    /**
     * An optional description of this resource. Provide this property when you create the resource.
    */
    public Builder setDescription(String description) {
      this.description = description;
      return this;
    }

    /**
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
    */
    public String getId() {
      return id;
    }

    /**
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
    */
    public Builder setId(String id) {
      this.id = id;
      return this;
    }

    /**
     * [Output Only] Type of the resource. Always compute#address for addresses.
    */
    public String getKind() {
      return kind;
    }

    /**
     * [Output Only] Type of the resource. Always compute#address for addresses.
    */
    public Builder setKind(String kind) {
      this.kind = kind;
      return this;
    }

    /**
     * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression [a-z]([-a-z0-9]&#42;[a-z0-9])? which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
    */
    public String getName() {
      return name;
    }

    /**
     * Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression [a-z]([-a-z0-9]&#42;[a-z0-9])? which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
    */
    public Builder setName(String name) {
      this.name = name;
      return this;
    }

    /**
     * [Output Only] URL of the region where the regional address resides. This field is not applicable to global addresses.
    */
    public String getRegion() {
      return region;
    }

    /**
     * [Output Only] URL of the region where the regional address resides. This field is not applicable to global addresses.
    */
    public Builder setRegion(String region) {
      this.region = region;
      return this;
    }

    /**
     * [Output Only] Server-defined URL for the resource.
    */
    public String getSelfLink() {
      return selfLink;
    }

    /**
     * [Output Only] Server-defined URL for the resource.
    */
    public Builder setSelfLink(String selfLink) {
      this.selfLink = selfLink;
      return this;
    }

    /**
     * [Output Only] The status of the address, which can be either IN_USE or RESERVED. An address that is RESERVED is currently reserved and available to use. An IN_USE address is currently being used by another resource and is not available.
    */
    public String getStatus() {
      return status;
    }

    /**
     * [Output Only] The status of the address, which can be either IN_USE or RESERVED. An address that is RESERVED is currently reserved and available to use. An IN_USE address is currently being used by another resource and is not available.
    */
    public Builder setStatus(String status) {
      this.status = status;
      return this;
    }


    public Address build() {







      return new Address(
        address,
        description,
        id,
        kind,
        name,
        region,
        selfLink,
        status
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setAddress(this.address);
      newBuilder.setDescription(this.description);
      newBuilder.setId(this.id);
      newBuilder.setKind(this.kind);
      newBuilder.setName(this.name);
      newBuilder.setRegion(this.region);
      newBuilder.setSelfLink(this.selfLink);
      newBuilder.setStatus(this.status);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "Address{"
        + "address=" + address + ", "
        + "description=" + description + ", "
        + "id=" + id + ", "
        + "kind=" + kind + ", "
        + "name=" + name + ", "
        + "region=" + region + ", "
        + "selfLink=" + selfLink + ", "
        + "status=" + status
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof Address) {
      Address that = (Address) o;
      return
          Objects.equals(this.address, that.getAddress()) &&
          Objects.equals(this.description, that.getDescription()) &&
          Objects.equals(this.id, that.getId()) &&
          Objects.equals(this.kind, that.getKind()) &&
          Objects.equals(this.name, that.getName()) &&
          Objects.equals(this.region, that.getRegion()) &&
          Objects.equals(this.selfLink, that.getSelfLink()) &&
          Objects.equals(this.status, that.getStatus())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      address,
      description,
      id,
      kind,
      name,
      region,
      selfLink,
      status
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/AddressAggregatedList.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.httpjson.ApiMessage;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.annotations.SerializedName;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;
import javax.annotation.Nullable;

@Generated("by GAPIC")
@BetaApi
public final class AddressAggregatedList implements ApiMessage {
  private final String id;
  private final Map<String, AddressesScopedList> items;
  private final String kind;
  private final String nextPageToken;
  private final String selfLink;

  private AddressAggregatedList() {
    this.id = null;
    this.items = null;
    this.kind = null;
    this.nextPageToken = null;
    this.selfLink = null;
  }


  private AddressAggregatedList(
      String id,
      Map<String, AddressesScopedList> items,
      String kind,
      String nextPageToken,
      String selfLink
      ) {
    this.id = id;
    this.items = items;
    this.kind = kind;
    this.nextPageToken = nextPageToken;
    this.selfLink = selfLink;
  }

  @Override
  public Object getFieldValue(String fieldName) {
    if ("id".equals(fieldName)) {
      return id;
    }
    if ("items".equals(fieldName)) {
      return items;
    }
    if ("kind".equals(fieldName)) {
      return kind;
    }
    if ("nextPageToken".equals(fieldName)) {
      return nextPageToken;
    }
    if ("selfLink".equals(fieldName)) {
      return selfLink;
    }
    return null;
  }

  @Nullable
  @Override
  public ApiMessage getApiMessageRequestBody() {
    return null;
  }

  @Nullable
  @Override
  /**
   * The fields that should be serialized (even if they have empty values).
   * If the containing message object has a non-null fieldmask,
   * then all the fields in the field mask (and only those fields in the field mask)
   * will be serialized. If the containing object does not have a fieldmask, then
   * only non-empty fields will be serialized.
  */
  public List<String> getFieldMask() {
    return null;
  }

  /**
   * [Output Only] Unique identifier for the resource; defined by the server.
  */
  public String getId() {
    return id;
  }

  /**
   * A list of AddressesScopedList resources.
   * The key for the map is: [Output Only] Name of the scope containing this set of addresses.
  */
  public Map<String, AddressesScopedList> getItemsMap() {
    return items;
  }

  /**
   * [Output Only] Type of resource. Always compute#addressAggregatedList for aggregated lists of addresses.
  */
  public String getKind() {
    return kind;
  }

  /**
   * [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
  */
  public String getNextPageToken() {
    return nextPageToken;
  }

  /**
   * [Output Only] Server-defined URL for this resource.
  */
  public String getSelfLink() {
    return selfLink;
  }


  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(AddressAggregatedList prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  public static AddressAggregatedList getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }
  private static final AddressAggregatedList DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new AddressAggregatedList();
  }

  public static class Builder {
    private String id;
    private Map<String, AddressesScopedList> items;
    private String kind;
    private String nextPageToken;
    private String selfLink;

    Builder() {}

    public Builder mergeFrom(AddressAggregatedList other) {
      if (other == AddressAggregatedList.getDefaultInstance()) return this;
      if (other.getId() != null) {
        this.id = other.id;
      }
      if (other.getItemsMap() != null) {
        this.items = other.items;
      }
      if (other.getKind() != null) {
        this.kind = other.kind;
      }
      if (other.getNextPageToken() != null) {
        this.nextPageToken = other.nextPageToken;
      }
      if (other.getSelfLink() != null) {
        this.selfLink = other.selfLink;
      }
      return this;
    }

    Builder(AddressAggregatedList source) {
      this.id = source.id;
      this.items = source.items;
      this.kind = source.kind;
      this.nextPageToken = source.nextPageToken;
      this.selfLink = source.selfLink;
    }

    /**
     * [Output Only] Unique identifier for the resource; defined by the server.
    */
    public String getId() {
      return id;
    }

    /**
     * [Output Only] Unique identifier for the resource; defined by the server.
    */
    public Builder setId(String id) {
      this.id = id;
      return this;
    }

    /**
     * A list of AddressesScopedList resources.
     * The key for the map is: [Output Only] Name of the scope containing this set of addresses.
    */
    public Map<String, AddressesScopedList> getItemsMap() {
      return items;
    }

    /**
     * A list of AddressesScopedList resources.
     * The key for the map is: [Output Only] Name of the scope containing this set of addresses.
    */
    public Builder putAllItems(Map<String, AddressesScopedList> items) {
      this.items = items;
      return this;
    }

    /**
     * [Output Only] Type of resource. Always compute#addressAggregatedList for aggregated lists of addresses.
    */
    public String getKind() {
      return kind;
    }

    /**
     * [Output Only] Type of resource. Always compute#addressAggregatedList for aggregated lists of addresses.
    */
    public Builder setKind(String kind) {
      this.kind = kind;
      return this;
    }

    /**
     * [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
    */
    public String getNextPageToken() {
      return nextPageToken;
    }

    /**
     * [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
    */
    public Builder setNextPageToken(String nextPageToken) {
      this.nextPageToken = nextPageToken;
      return this;
    }

    /**
     * [Output Only] Server-defined URL for this resource.
    */
    public String getSelfLink() {
      return selfLink;
    }

    /**
     * [Output Only] Server-defined URL for this resource.
    */
    public Builder setSelfLink(String selfLink) {
      this.selfLink = selfLink;
      return this;
    }


    public AddressAggregatedList build() {




      return new AddressAggregatedList(
        id,
        items,
        kind,
        nextPageToken,
        selfLink
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setId(this.id);
      newBuilder.putAllItems(this.items);
      newBuilder.setKind(this.kind);
      newBuilder.setNextPageToken(this.nextPageToken);
      newBuilder.setSelfLink(this.selfLink);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "AddressAggregatedList{"
        + "id=" + id + ", "
        + "items=" + items + ", "
        + "kind=" + kind + ", "
        + "nextPageToken=" + nextPageToken + ", "
        + "selfLink=" + selfLink
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof AddressAggregatedList) {
      AddressAggregatedList that = (AddressAggregatedList) o;
      return
          Objects.equals(this.id, that.getId()) &&
          Objects.equals(this.items, that.getItemsMap()) &&
          Objects.equals(this.kind, that.getKind()) &&
          Objects.equals(this.nextPageToken, that.getNextPageToken()) &&
          Objects.equals(this.selfLink, that.getSelfLink())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      id,
      items,
      kind,
      nextPageToken,
      selfLink
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/AddressesScopedList.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.httpjson.ApiMessage;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.annotations.SerializedName;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;
import javax.annotation.Nullable;

@Generated("by GAPIC")
@BetaApi
public final class AddressesScopedList implements ApiMessage {
  private final List<Address> addresses;

  private AddressesScopedList() {
    this.addresses = null;
  }


  private AddressesScopedList(
      List<Address> addresses
      ) {
    this.addresses = addresses;
  }

  @Override
  public Object getFieldValue(String fieldName) {
    if ("addresses".equals(fieldName)) {
      return addresses;
    }
    return null;
  }

  @Nullable
  @Override
  public ApiMessage getApiMessageRequestBody() {
    return null;
  }

  @Nullable
  @Override
  /**
   * The fields that should be serialized (even if they have empty values).
   * If the containing message object has a non-null fieldmask,
   * then all the fields in the field mask (and only those fields in the field mask)
   * will be serialized. If the containing object does not have a fieldmask, then
   * only non-empty fields will be serialized.
  */
  public List<String> getFieldMask() {
    return null;
  }

  /**
   * [Output Only] List of addresses contained in this scope.
  */
  public List<Address> getAddressesList() {
    return addresses;
  }


  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(AddressesScopedList prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  public static AddressesScopedList getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }
  private static final AddressesScopedList DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new AddressesScopedList();
  }

  public static class Builder {
    private List<Address> addresses;

    Builder() {}

    public Builder mergeFrom(AddressesScopedList other) {
      if (other == AddressesScopedList.getDefaultInstance()) return this;
      if (other.getAddressesList() != null) {
        this.addresses = other.addresses;
      }
      return this;
    }

    Builder(AddressesScopedList source) {
      this.addresses = source.addresses;
    }

    /**
     * [Output Only] List of addresses contained in this scope.
    */
    public List<Address> getAddressesList() {
      return addresses;
    }

    /**
     * [Output Only] List of addresses contained in this scope.
    */
    public Builder addAllAddresses(List<Address> addresses) {
      if (this.addresses == null) {
        this.addresses = new LinkedList<>();
      }
      this.addresses.addAll(addresses);
      return this;
    }

    /**
     * [Output Only] List of addresses contained in this scope.
    */
    public Builder addAddresses(Address addresses) {
      if (this.addresses == null) {
        this.addresses = new LinkedList<>();
      }
      this.addresses.add(addresses);
      return this;
    }


    public AddressesScopedList build() {
      return new AddressesScopedList(
        addresses
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.addAllAddresses(this.addresses);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "AddressesScopedList{"
        + "addresses=" + addresses
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof AddressesScopedList) {
      AddressesScopedList that = (AddressesScopedList) o;
      return
          Objects.equals(this.addresses, that.getAddressesList())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      addresses
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/AddressList.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.httpjson.ApiMessage;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.annotations.SerializedName;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;
import javax.annotation.Nullable;

@Generated("by GAPIC")
@BetaApi
/**
 * Contains a list of addresses.
*/
public final class AddressList implements ApiMessage {
  private final String id;
  private final List<Address> items;
  private final String kind;
  private final String nextPageToken;
  private final String selfLink;

  private AddressList() {
    this.id = null;
    this.items = null;
    this.kind = null;
    this.nextPageToken = null;
    this.selfLink = null;
  }


  private AddressList(
      String id,
      List<Address> items,
      String kind,
      String nextPageToken,
      String selfLink
      ) {
    this.id = id;
    this.items = items;
    this.kind = kind;
    this.nextPageToken = nextPageToken;
    this.selfLink = selfLink;
  }

  @Override
  public Object getFieldValue(String fieldName) {
    if ("id".equals(fieldName)) {
      return id;
    }
    if ("items".equals(fieldName)) {
      return items;
    }
    if ("kind".equals(fieldName)) {
      return kind;
    }
    if ("nextPageToken".equals(fieldName)) {
      return nextPageToken;
    }
    if ("selfLink".equals(fieldName)) {
      return selfLink;
    }
    return null;
  }

  @Nullable
  @Override
  public ApiMessage getApiMessageRequestBody() {
    return null;
  }

  @Nullable
  @Override
  /**
   * The fields that should be serialized (even if they have empty values).
   * If the containing message object has a non-null fieldmask,
   * then all the fields in the field mask (and only those fields in the field mask)
   * will be serialized. If the containing object does not have a fieldmask, then
   * only non-empty fields will be serialized.
  */
  public List<String> getFieldMask() {
    return null;
  }

  /**
   * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
  */
  public String getId() {
    return id;
  }

  /**
   * [Output Only] A list of addresses.
  */
  public List<Address> getItemsList() {
    return items;
  }

  /**
   * [Output Only] Type of resource. Always compute#addressList for lists of addresses.
  */
  public String getKind() {
    return kind;
  }

  /**
   * [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
  */
  public String getNextPageToken() {
    return nextPageToken;
  }

  /**
   * [Output Only] Server-defined URL for the resource.
  */
  public String getSelfLink() {
    return selfLink;
  }


  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(AddressList prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  public static AddressList getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }
  private static final AddressList DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new AddressList();
  }

  public static class Builder {
    private String id;
    private List<Address> items;
    private String kind;
    private String nextPageToken;
    private String selfLink;

    Builder() {}

    public Builder mergeFrom(AddressList other) {
      if (other == AddressList.getDefaultInstance()) return this;
      if (other.getId() != null) {
        this.id = other.id;
      }
      if (other.getItemsList() != null) {
        this.items = other.items;
      }
      if (other.getKind() != null) {
        this.kind = other.kind;
      }
      if (other.getNextPageToken() != null) {
        this.nextPageToken = other.nextPageToken;
      }
      if (other.getSelfLink() != null) {
        this.selfLink = other.selfLink;
      }
      return this;
    }

    Builder(AddressList source) {
      this.id = source.id;
      this.items = source.items;
      this.kind = source.kind;
      this.nextPageToken = source.nextPageToken;
      this.selfLink = source.selfLink;
    }

    /**
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
    */
    public String getId() {
      return id;
    }

    /**
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
    */
    public Builder setId(String id) {
      this.id = id;
      return this;
    }

    /**
     * [Output Only] A list of addresses.
    */
    public List<Address> getItemsList() {
      return items;
    }

    /**
     * [Output Only] A list of addresses.
    */
    public Builder addAllItems(List<Address> items) {
      if (this.items == null) {
        this.items = new LinkedList<>();
      }
      this.items.addAll(items);
      return this;
    }

    /**
     * [Output Only] A list of addresses.
    */
    public Builder addItems(Address items) {
      if (this.items == null) {
        this.items = new LinkedList<>();
      }
      this.items.add(items);
      return this;
    }

    /**
     * [Output Only] Type of resource. Always compute#addressList for lists of addresses.
    */
    public String getKind() {
      return kind;
    }

    /**
     * [Output Only] Type of resource. Always compute#addressList for lists of addresses.
    */
    public Builder setKind(String kind) {
      this.kind = kind;
      return this;
    }

    /**
     * [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
    */
    public String getNextPageToken() {
      return nextPageToken;
    }

    /**
     * [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
    */
    public Builder setNextPageToken(String nextPageToken) {
      this.nextPageToken = nextPageToken;
      return this;
    }

    /**
     * [Output Only] Server-defined URL for the resource.
    */
    public String getSelfLink() {
      return selfLink;
    }

    /**
     * [Output Only] Server-defined URL for the resource.
    */
    public Builder setSelfLink(String selfLink) {
      this.selfLink = selfLink;
      return this;
    }


    public AddressList build() {




      return new AddressList(
        id,
        items,
        kind,
        nextPageToken,
        selfLink
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setId(this.id);
      newBuilder.addAllItems(this.items);
      newBuilder.setKind(this.kind);
      newBuilder.setNextPageToken(this.nextPageToken);
      newBuilder.setSelfLink(this.selfLink);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "AddressList{"
        + "id=" + id + ", "
        + "items=" + items + ", "
        + "kind=" + kind + ", "
        + "nextPageToken=" + nextPageToken + ", "
        + "selfLink=" + selfLink
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof AddressList) {
      AddressList that = (AddressList) o;
      return
          Objects.equals(this.id, that.getId()) &&
          Objects.equals(this.items, that.getItemsList()) &&
          Objects.equals(this.kind, that.getKind()) &&
          Objects.equals(this.nextPageToken, that.getNextPageToken()) &&
          Objects.equals(this.selfLink, that.getSelfLink())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      id,
      items,
      kind,
      nextPageToken,
      selfLink
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/Data.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.httpjson.ApiMessage;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.annotations.SerializedName;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;
import javax.annotation.Nullable;

@Generated("by GAPIC")
@BetaApi
/**
 * [Output Only] Metadata about this warning in key: value format. For example:
 * "data": [ { "key": "scope", "value": "zones/us-east1-d" }
*/
public final class Data implements ApiMessage {
  private final String key;
  private final String value;

  private Data() {
    this.key = null;
    this.value = null;
  }


  private Data(
      String key,
      String value
      ) {
    this.key = key;
    this.value = value;
  }

  @Override
  public Object getFieldValue(String fieldName) {
    if ("key".equals(fieldName)) {
      return key;
    }
    if ("value".equals(fieldName)) {
      return value;
    }
    return null;
  }

  @Nullable
  @Override
  public ApiMessage getApiMessageRequestBody() {
    return null;
  }

  @Nullable
  @Override
  /**
   * The fields that should be serialized (even if they have empty values).
   * If the containing message object has a non-null fieldmask,
   * then all the fields in the field mask (and only those fields in the field mask)
   * will be serialized. If the containing object does not have a fieldmask, then
   * only non-empty fields will be serialized.
  */
  public List<String> getFieldMask() {
    return null;
  }

  /**
   * [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
  */
  public String getKey() {
    return key;
  }

  /**
   * [Output Only] A warning data value corresponding to the key.
  */
  public String getValue() {
    return value;
  }


  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(Data prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  public static Data getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }
  private static final Data DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new Data();
  }

  public static class Builder {
    private String key;
    private String value;

    Builder() {}

    public Builder mergeFrom(Data other) {
      if (other == Data.getDefaultInstance()) return this;
      if (other.getKey() != null) {
        this.key = other.key;
      }
      if (other.getValue() != null) {
        this.value = other.value;
      }
      return this;
    }

    Builder(Data source) {
      this.key = source.key;
      this.value = source.value;
    }

    /**
     * [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
    */
    public String getKey() {
      return key;
    }

    /**
     * [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
    */
    public Builder setKey(String key) {
      this.key = key;
      return this;
    }

    /**
     * [Output Only] A warning data value corresponding to the key.
    */
    public String getValue() {
      return value;
    }

    /**
     * [Output Only] A warning data value corresponding to the key.
    */
    public Builder setValue(String value) {
      this.value = value;
      return this;
    }


    public Data build() {

      return new Data(
        key,
        value
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setKey(this.key);
      newBuilder.setValue(this.value);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "Data{"
        + "key=" + key + ", "
        + "value=" + value
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof Data) {
      Data that = (Data) o;
      return
          Objects.equals(this.key, that.getKey()) &&
          Objects.equals(this.value, that.getValue())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      key,
      value
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/DUMMYObject.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.httpjson.ApiMessage;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.annotations.SerializedName;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;
import javax.annotation.Nullable;

@Generated("by GAPIC")
@BetaApi
/**
 * A fake object to test discogapic generation of case insensitive message types.
*/
public final class DUMMYObject implements ApiMessage {
  private final String name;

  private DUMMYObject() {
    this.name = null;
  }


  private DUMMYObject(
      String name
      ) {
    this.name = name;
  }

  @Override
  public Object getFieldValue(String fieldName) {
    if ("name".equals(fieldName)) {
      return name;
    }
    return null;
  }

  @Nullable
  @Override
  public ApiMessage getApiMessageRequestBody() {
    return null;
  }

  @Nullable
  @Override
  /**
   * The fields that should be serialized (even if they have empty values).
   * If the containing message object has a non-null fieldmask,
   * then all the fields in the field mask (and only those fields in the field mask)
   * will be serialized. If the containing object does not have a fieldmask, then
   * only non-empty fields will be serialized.
  */
  public List<String> getFieldMask() {
    return null;
  }

  /**
   * Name of this object.
  */
  public String getName() {
    return name;
  }


  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(DUMMYObject prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  public static DUMMYObject getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }
  private static final DUMMYObject DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new DUMMYObject();
  }

  public static class Builder {
    private String name;

    Builder() {}

    public Builder mergeFrom(DUMMYObject other) {
      if (other == DUMMYObject.getDefaultInstance()) return this;
      if (other.getName() != null) {
        this.name = other.name;
      }
      return this;
    }

    Builder(DUMMYObject source) {
      this.name = source.name;
    }

    /**
     * Name of this object.
    */
    public String getName() {
      return name;
    }

    /**
     * Name of this object.
    */
    public Builder setName(String name) {
      this.name = name;
      return this;
    }


    public DUMMYObject build() {
      return new DUMMYObject(
        name
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setName(this.name);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "DUMMYObject{"
        + "name=" + name
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof DUMMYObject) {
      DUMMYObject that = (DUMMYObject) o;
      return
          Objects.equals(this.name, that.getName())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      name
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/DummyObject2.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.httpjson.ApiMessage;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.annotations.SerializedName;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;
import javax.annotation.Nullable;

@Generated("by GAPIC")
@BetaApi
/**
 * A fake object to test discogapic generation.
*/
public final class DummyObject2 implements ApiMessage {
  private final Float floatie;
  @SerializedName("IPProtocol")
  private final String iPProtocol;
  private final String name;
  private final Double precisionFloatie;
  private final Address primaryAddress;
  private final Address secondaryAddress;

  private DummyObject2() {
    this.floatie = null;
    this.iPProtocol = null;
    this.name = null;
    this.precisionFloatie = null;
    this.primaryAddress = null;
    this.secondaryAddress = null;
  }


  private DummyObject2(
      Float floatie,
      String iPProtocol,
      String name,
      Double precisionFloatie,
      Address primaryAddress,
      Address secondaryAddress
      ) {
    this.floatie = floatie;
    this.iPProtocol = iPProtocol;
    this.name = name;
    this.precisionFloatie = precisionFloatie;
    this.primaryAddress = primaryAddress;
    this.secondaryAddress = secondaryAddress;
  }

  @Override
  public Object getFieldValue(String fieldName) {
    if ("floatie".equals(fieldName)) {
      return floatie;
    }
    if ("iPProtocol".equals(fieldName)) {
      return iPProtocol;
    }
    if ("name".equals(fieldName)) {
      return name;
    }
    if ("precisionFloatie".equals(fieldName)) {
      return precisionFloatie;
    }
    if ("primaryAddress".equals(fieldName)) {
      return primaryAddress;
    }
    if ("secondaryAddress".equals(fieldName)) {
      return secondaryAddress;
    }
    return null;
  }

  @Nullable
  @Override
  public ApiMessage getApiMessageRequestBody() {
    return null;
  }

  @Nullable
  @Override
  /**
   * The fields that should be serialized (even if they have empty values).
   * If the containing message object has a non-null fieldmask,
   * then all the fields in the field mask (and only those fields in the field mask)
   * will be serialized. If the containing object does not have a fieldmask, then
   * only non-empty fields will be serialized.
  */
  public List<String> getFieldMask() {
    return null;
  }

  /**
   * A float type number.
  */
  public Float getFloatie() {
    return floatie;
  }

  /**
   * The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule. This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp), or the IP protocol number.
  */
  public String getIPProtocol() {
    return iPProtocol;
  }

  /**
   * Name of this object.
  */
  public String getName() {
    return name;
  }

  /**
   * A double type number.
  */
  public Double getPrecisionFloatie() {
    return precisionFloatie;
  }

  /**
   * One address.
  */
  public Address getPrimaryAddress() {
    return primaryAddress;
  }

  /**
   * Address two.
  */
  public Address getSecondaryAddress() {
    return secondaryAddress;
  }


  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(DummyObject2 prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  public static DummyObject2 getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }
  private static final DummyObject2 DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new DummyObject2();
  }

  public static class Builder {
    private Float floatie;
    private String iPProtocol;
    private String name;
    private Double precisionFloatie;
    private Address primaryAddress;
    private Address secondaryAddress;

    Builder() {}

    public Builder mergeFrom(DummyObject2 other) {
      if (other == DummyObject2.getDefaultInstance()) return this;
      if (other.getFloatie() != null) {
        this.floatie = other.floatie;
      }
      if (other.getIPProtocol() != null) {
        this.iPProtocol = other.iPProtocol;
      }
      if (other.getName() != null) {
        this.name = other.name;
      }
      if (other.getPrecisionFloatie() != null) {
        this.precisionFloatie = other.precisionFloatie;
      }
      if (other.getPrimaryAddress() != null) {
        this.primaryAddress = other.primaryAddress;
      }
      if (other.getSecondaryAddress() != null) {
        this.secondaryAddress = other.secondaryAddress;
      }
      return this;
    }

    Builder(DummyObject2 source) {
      this.floatie = source.floatie;
      this.iPProtocol = source.iPProtocol;
      this.name = source.name;
      this.precisionFloatie = source.precisionFloatie;
      this.primaryAddress = source.primaryAddress;
      this.secondaryAddress = source.secondaryAddress;
    }

    /**
     * A float type number.
    */
    public Float getFloatie() {
      return floatie;
    }

    /**
     * A float type number.
    */
    public Builder setFloatie(Float floatie) {
      this.floatie = floatie;
      return this;
    }

    /**
     * The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule. This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp), or the IP protocol number.
    */
    public String getIPProtocol() {
      return iPProtocol;
    }

    /**
     * The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule. This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp), or the IP protocol number.
    */
    public Builder setIPProtocol(String iPProtocol) {
      this.iPProtocol = iPProtocol;
      return this;
    }

    /**
     * Name of this object.
    */
    public String getName() {
      return name;
    }

    /**
     * Name of this object.
    */
    public Builder setName(String name) {
      this.name = name;
      return this;
    }

    /**
     * A double type number.
    */
    public Double getPrecisionFloatie() {
      return precisionFloatie;
    }

    /**
     * A double type number.
    */
    public Builder setPrecisionFloatie(Double precisionFloatie) {
      this.precisionFloatie = precisionFloatie;
      return this;
    }

    /**
     * One address.
    */
    public Address getPrimaryAddress() {
      return primaryAddress;
    }

    /**
     * One address.
    */
    public Builder setPrimaryAddress(Address primaryAddress) {
      this.primaryAddress = primaryAddress;
      return this;
    }

    /**
     * Address two.
    */
    public Address getSecondaryAddress() {
      return secondaryAddress;
    }

    /**
     * Address two.
    */
    public Builder setSecondaryAddress(Address secondaryAddress) {
      this.secondaryAddress = secondaryAddress;
      return this;
    }


    public DummyObject2 build() {





      return new DummyObject2(
        floatie,
        iPProtocol,
        name,
        precisionFloatie,
        primaryAddress,
        secondaryAddress
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setFloatie(this.floatie);
      newBuilder.setIPProtocol(this.iPProtocol);
      newBuilder.setName(this.name);
      newBuilder.setPrecisionFloatie(this.precisionFloatie);
      newBuilder.setPrimaryAddress(this.primaryAddress);
      newBuilder.setSecondaryAddress(this.secondaryAddress);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "DummyObject2{"
        + "floatie=" + floatie + ", "
        + "iPProtocol=" + iPProtocol + ", "
        + "name=" + name + ", "
        + "precisionFloatie=" + precisionFloatie + ", "
        + "primaryAddress=" + primaryAddress + ", "
        + "secondaryAddress=" + secondaryAddress
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof DummyObject2) {
      DummyObject2 that = (DummyObject2) o;
      return
          Objects.equals(this.floatie, that.getFloatie()) &&
          Objects.equals(this.iPProtocol, that.getIPProtocol()) &&
          Objects.equals(this.name, that.getName()) &&
          Objects.equals(this.precisionFloatie, that.getPrecisionFloatie()) &&
          Objects.equals(this.primaryAddress, that.getPrimaryAddress()) &&
          Objects.equals(this.secondaryAddress, that.getSecondaryAddress())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      floatie,
      iPProtocol,
      name,
      precisionFloatie,
      primaryAddress,
      secondaryAddress
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/Error.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.httpjson.ApiMessage;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.annotations.SerializedName;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;
import javax.annotation.Nullable;

@Generated("by GAPIC")
@BetaApi
/**
 * [Output Only] If errors are generated during processing of the operation, this field will be populated.
*/
public final class Error implements ApiMessage {
  private final List<Errors> errors;

  private Error() {
    this.errors = null;
  }


  private Error(
      List<Errors> errors
      ) {
    this.errors = errors;
  }

  @Override
  public Object getFieldValue(String fieldName) {
    if ("errors".equals(fieldName)) {
      return errors;
    }
    return null;
  }

  @Nullable
  @Override
  public ApiMessage getApiMessageRequestBody() {
    return null;
  }

  @Nullable
  @Override
  /**
   * The fields that should be serialized (even if they have empty values).
   * If the containing message object has a non-null fieldmask,
   * then all the fields in the field mask (and only those fields in the field mask)
   * will be serialized. If the containing object does not have a fieldmask, then
   * only non-empty fields will be serialized.
  */
  public List<String> getFieldMask() {
    return null;
  }

  /**
   * [Output Only] The array of errors encountered while processing this operation.
  */
  public List<Errors> getErrorsList() {
    return errors;
  }


  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(Error prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  public static Error getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }
  private static final Error DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new Error();
  }

  public static class Builder {
    private List<Errors> errors;

    Builder() {}

    public Builder mergeFrom(Error other) {
      if (other == Error.getDefaultInstance()) return this;
      if (other.getErrorsList() != null) {
        this.errors = other.errors;
      }
      return this;
    }

    Builder(Error source) {
      this.errors = source.errors;
    }

    /**
     * [Output Only] The array of errors encountered while processing this operation.
    */
    public List<Errors> getErrorsList() {
      return errors;
    }

    /**
     * [Output Only] The array of errors encountered while processing this operation.
    */
    public Builder addAllErrors(List<Errors> errors) {
      if (this.errors == null) {
        this.errors = new LinkedList<>();
      }
      this.errors.addAll(errors);
      return this;
    }

    /**
     * [Output Only] The array of errors encountered while processing this operation.
    */
    public Builder addErrors(Errors errors) {
      if (this.errors == null) {
        this.errors = new LinkedList<>();
      }
      this.errors.add(errors);
      return this;
    }


    public Error build() {
      return new Error(
        errors
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.addAllErrors(this.errors);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "Error{"
        + "errors=" + errors
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof Error) {
      Error that = (Error) o;
      return
          Objects.equals(this.errors, that.getErrorsList())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      errors
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/Errors.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.httpjson.ApiMessage;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.annotations.SerializedName;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;
import javax.annotation.Nullable;

@Generated("by GAPIC")
@BetaApi
/**
 * [Output Only] The array of errors encountered while processing this operation.
*/
public final class Errors implements ApiMessage {
  private final String code;
  private final String location;
  private final String message;

  private Errors() {
    this.code = null;
    this.location = null;
    this.message = null;
  }


  private Errors(
      String code,
      String location,
      String message
      ) {
    this.code = code;
    this.location = location;
    this.message = message;
  }

  @Override
  public Object getFieldValue(String fieldName) {
    if ("code".equals(fieldName)) {
      return code;
    }
    if ("location".equals(fieldName)) {
      return location;
    }
    if ("message".equals(fieldName)) {
      return message;
    }
    return null;
  }

  @Nullable
  @Override
  public ApiMessage getApiMessageRequestBody() {
    return null;
  }

  @Nullable
  @Override
  /**
   * The fields that should be serialized (even if they have empty values).
   * If the containing message object has a non-null fieldmask,
   * then all the fields in the field mask (and only those fields in the field mask)
   * will be serialized. If the containing object does not have a fieldmask, then
   * only non-empty fields will be serialized.
  */
  public List<String> getFieldMask() {
    return null;
  }

  /**
   * [Output Only] The error type identifier for this error.
  */
  public String getCode() {
    return code;
  }

  /**
   * [Output Only] Indicates the field in the request that caused the error. This property is optional.
  */
  public String getLocation() {
    return location;
  }

  /**
   * [Output Only] An optional, human-readable error message.
  */
  public String getMessage() {
    return message;
  }


  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(Errors prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  public static Errors getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }
  private static final Errors DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new Errors();
  }

  public static class Builder {
    private String code;
    private String location;
    private String message;

    Builder() {}

    public Builder mergeFrom(Errors other) {
      if (other == Errors.getDefaultInstance()) return this;
      if (other.getCode() != null) {
        this.code = other.code;
      }
      if (other.getLocation() != null) {
        this.location = other.location;
      }
      if (other.getMessage() != null) {
        this.message = other.message;
      }
      return this;
    }

    Builder(Errors source) {
      this.code = source.code;
      this.location = source.location;
      this.message = source.message;
    }

    /**
     * [Output Only] The error type identifier for this error.
    */
    public String getCode() {
      return code;
    }

    /**
     * [Output Only] The error type identifier for this error.
    */
    public Builder setCode(String code) {
      this.code = code;
      return this;
    }

    /**
     * [Output Only] Indicates the field in the request that caused the error. This property is optional.
    */
    public String getLocation() {
      return location;
    }

    /**
     * [Output Only] Indicates the field in the request that caused the error. This property is optional.
    */
    public Builder setLocation(String location) {
      this.location = location;
      return this;
    }

    /**
     * [Output Only] An optional, human-readable error message.
    */
    public String getMessage() {
      return message;
    }

    /**
     * [Output Only] An optional, human-readable error message.
    */
    public Builder setMessage(String message) {
      this.message = message;
      return this;
    }


    public Errors build() {


      return new Errors(
        code,
        location,
        message
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setCode(this.code);
      newBuilder.setLocation(this.location);
      newBuilder.setMessage(this.message);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "Errors{"
        + "code=" + code + ", "
        + "location=" + location + ", "
        + "message=" + message
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof Errors) {
      Errors that = (Errors) o;
      return
          Objects.equals(this.code, that.getCode()) &&
          Objects.equals(this.location, that.getLocation()) &&
          Objects.equals(this.message, that.getMessage())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      code,
      location,
      message
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/Operation.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.httpjson.ApiMessage;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.annotations.SerializedName;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;
import javax.annotation.Nullable;

@Generated("by GAPIC")
@BetaApi
/**
 * An Operation resource, used to manage asynchronous API requests.
*/
public final class Operation implements ApiMessage {
  private final String clientOperationId;
  private final String description;
  private final Error error;
  private final String httpErrorMessage;
  private final Integer httpErrorStatusCode;
  private final String id;
  private final String kind;
  private final String name;
  private final String operationType;
  private final Integer progress;
  private final String region;
  private final String selfLink;
  private final String startTime;
  private final String status;
  private final String statusMessage;
  private final String targetId;
  private final String targetLink;
  private final List<Warnings> warnings;
  private final String zone;

  private Operation() {
    this.clientOperationId = null;
    this.description = null;
    this.error = null;
    this.httpErrorMessage = null;
    this.httpErrorStatusCode = null;
    this.id = null;
    this.kind = null;
    this.name = null;
    this.operationType = null;
    this.progress = null;
    this.region = null;
    this.selfLink = null;
    this.startTime = null;
    this.status = null;
    this.statusMessage = null;
    this.targetId = null;
    this.targetLink = null;
    this.warnings = null;
    this.zone = null;
  }


  private Operation(
      String clientOperationId,
      String description,
      Error error,
      String httpErrorMessage,
      Integer httpErrorStatusCode,
      String id,
      String kind,
      String name,
      String operationType,
      Integer progress,
      String region,
      String selfLink,
      String startTime,
      String status,
      String statusMessage,
      String targetId,
      String targetLink,
      List<Warnings> warnings,
      String zone
      ) {
    this.clientOperationId = clientOperationId;
    this.description = description;
    this.error = error;
    this.httpErrorMessage = httpErrorMessage;
    this.httpErrorStatusCode = httpErrorStatusCode;
    this.id = id;
    this.kind = kind;
    this.name = name;
    this.operationType = operationType;
    this.progress = progress;
    this.region = region;
    this.selfLink = selfLink;
    this.startTime = startTime;
    this.status = status;
    this.statusMessage = statusMessage;
    this.targetId = targetId;
    this.targetLink = targetLink;
    this.warnings = warnings;
    this.zone = zone;
  }

  @Override
  public Object getFieldValue(String fieldName) {
    if ("clientOperationId".equals(fieldName)) {
      return clientOperationId;
    }
    if ("description".equals(fieldName)) {
      return description;
    }
    if ("error".equals(fieldName)) {
      return error;
    }
    if ("httpErrorMessage".equals(fieldName)) {
      return httpErrorMessage;
    }
    if ("httpErrorStatusCode".equals(fieldName)) {
      return httpErrorStatusCode;
    }
    if ("id".equals(fieldName)) {
      return id;
    }
    if ("kind".equals(fieldName)) {
      return kind;
    }
    if ("name".equals(fieldName)) {
      return name;
    }
    if ("operationType".equals(fieldName)) {
      return operationType;
    }
    if ("progress".equals(fieldName)) {
      return progress;
    }
    if ("region".equals(fieldName)) {
      return region;
    }
    if ("selfLink".equals(fieldName)) {
      return selfLink;
    }
    if ("startTime".equals(fieldName)) {
      return startTime;
    }
    if ("status".equals(fieldName)) {
      return status;
    }
    if ("statusMessage".equals(fieldName)) {
      return statusMessage;
    }
    if ("targetId".equals(fieldName)) {
      return targetId;
    }
    if ("targetLink".equals(fieldName)) {
      return targetLink;
    }
    if ("warnings".equals(fieldName)) {
      return warnings;
    }
    if ("zone".equals(fieldName)) {
      return zone;
    }
    return null;
  }

  @Nullable
  @Override
  public ApiMessage getApiMessageRequestBody() {
    return null;
  }

  @Nullable
  @Override
  /**
   * The fields that should be serialized (even if they have empty values).
   * If the containing message object has a non-null fieldmask,
   * then all the fields in the field mask (and only those fields in the field mask)
   * will be serialized. If the containing object does not have a fieldmask, then
   * only non-empty fields will be serialized.
  */
  public List<String> getFieldMask() {
    return null;
  }

  /**
   * [Output Only] Reserved for future use.
  */
  public String getClientOperationId() {
    return clientOperationId;
  }

  /**
   * [Output Only] A textual description of the operation, which is set when the operation is created.
  */
  public String getDescription() {
    return description;
  }

  /**
   * [Output Only] If errors are generated during processing of the operation, this field will be populated.
  */
  public Error getError() {
    return error;
  }

  /**
   * [Output Only] If the operation fails, this field contains the HTTP error message that was returned, such as NOT FOUND.
  */
  public String getHttpErrorMessage() {
    return httpErrorMessage;
  }

  /**
   * [Output Only] If the operation fails, this field contains the HTTP error status code that was returned. For example, a 404 means the resource was not found.
  */
  public Integer getHttpErrorStatusCode() {
    return httpErrorStatusCode;
  }

  /**
   * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
  */
  public String getId() {
    return id;
  }

  /**
   * [Output Only] Type of the resource. Always compute#operation for Operation resources.
  */
  public String getKind() {
    return kind;
  }

  /**
   * [Output Only] Name of the resource.
  */
  public String getName() {
    return name;
  }

  /**
   * [Output Only] The type of operation, such as insert, update, or delete, and so on.
  */
  public String getOperationType() {
    return operationType;
  }

  /**
   * [Output Only] An optional progress indicator that ranges from 0 to 100. There is no requirement that this be linear or support any granularity of operations. This should not be used to guess when the operation will be complete. This number should monotonically increase as the operation progresses.
  */
  public Integer getProgress() {
    return progress;
  }

  /**
   * [Output Only] The URL of the region where the operation resides. Only available when performing regional operations.
  */
  public String getRegion() {
    return region;
  }

  /**
   * [Output Only] Server-defined URL for the resource.
  */
  public String getSelfLink() {
    return selfLink;
  }

  /**
   * [Output Only] The time that this operation was started by the server. This value is in RFC3339 text format.
  */
  public String getStartTime() {
    return startTime;
  }

  /**
   * [Output Only] The status of the operation, which can be one of the following: PENDING, RUNNING, or DONE.
  */
  public String getStatus() {
    return status;
  }

  /**
   * [Output Only] An optional textual description of the current status of the operation.
  */
  public String getStatusMessage() {
    return statusMessage;
  }

  /**
   * [Output Only] The unique target ID, which identifies a specific incarnation of the target resource.
  */
  public String getTargetId() {
    return targetId;
  }

  /**
   * [Output Only] The URL of the resource that the operation modifies. For operations related to creating a snapshot, this points to the persistent disk that the snapshot was created from.
  */
  public String getTargetLink() {
    return targetLink;
  }

  /**
   * [Output Only] If warning messages are generated during processing of the operation, this field will be populated.
  */
  public List<Warnings> getWarningsList() {
    return warnings;
  }

  /**
   * [Output Only] The URL of the zone where the operation resides. Only available when performing per-zone operations.
  */
  public String getZone() {
    return zone;
  }


  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(Operation prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  public static Operation getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }
  private static final Operation DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new Operation();
  }

  public static class Builder {
    private String clientOperationId;
    private String description;
    private Error error;
    private String httpErrorMessage;
    private Integer httpErrorStatusCode;
    private String id;
    private String kind;
    private String name;
    private String operationType;
    private Integer progress;
    private String region;
    private String selfLink;
    private String startTime;
    private String status;
    private String statusMessage;
    private String targetId;
    private String targetLink;
    private List<Warnings> warnings;
    private String zone;

    Builder() {}

    public Builder mergeFrom(Operation other) {
      if (other == Operation.getDefaultInstance()) return this;
      if (other.getClientOperationId() != null) {
        this.clientOperationId = other.clientOperationId;
      }
      if (other.getDescription() != null) {
        this.description = other.description;
      }
      if (other.getError() != null) {
        this.error = other.error;
      }
      if (other.getHttpErrorMessage() != null) {
        this.httpErrorMessage = other.httpErrorMessage;
      }
      if (other.getHttpErrorStatusCode() != null) {
        this.httpErrorStatusCode = other.httpErrorStatusCode;
      }
      if (other.getId() != null) {
        this.id = other.id;
      }
      if (other.getKind() != null) {
        this.kind = other.kind;
      }
      if (other.getName() != null) {
        this.name = other.name;
      }
      if (other.getOperationType() != null) {
        this.operationType = other.operationType;
      }
      if (other.getProgress() != null) {
        this.progress = other.progress;
      }
      if (other.getRegion() != null) {
        this.region = other.region;
      }
      if (other.getSelfLink() != null) {
        this.selfLink = other.selfLink;
      }
      if (other.getStartTime() != null) {
        this.startTime = other.startTime;
      }
      if (other.getStatus() != null) {
        this.status = other.status;
      }
      if (other.getStatusMessage() != null) {
        this.statusMessage = other.statusMessage;
      }
      if (other.getTargetId() != null) {
        this.targetId = other.targetId;
      }
      if (other.getTargetLink() != null) {
        this.targetLink = other.targetLink;
      }
      if (other.getWarningsList() != null) {
        this.warnings = other.warnings;
      }
      if (other.getZone() != null) {
        this.zone = other.zone;
      }
      return this;
    }

    Builder(Operation source) {
      this.clientOperationId = source.clientOperationId;
      this.description = source.description;
      this.error = source.error;
      this.httpErrorMessage = source.httpErrorMessage;
      this.httpErrorStatusCode = source.httpErrorStatusCode;
      this.id = source.id;
      this.kind = source.kind;
      this.name = source.name;
      this.operationType = source.operationType;
      this.progress = source.progress;
      this.region = source.region;
      this.selfLink = source.selfLink;
      this.startTime = source.startTime;
      this.status = source.status;
      this.statusMessage = source.statusMessage;
      this.targetId = source.targetId;
      this.targetLink = source.targetLink;
      this.warnings = source.warnings;
      this.zone = source.zone;
    }

    /**
     * [Output Only] Reserved for future use.
    */
    public String getClientOperationId() {
      return clientOperationId;
    }

    /**
     * [Output Only] Reserved for future use.
    */
    public Builder setClientOperationId(String clientOperationId) {
      this.clientOperationId = clientOperationId;
      return this;
    }

    /**
     * [Output Only] A textual description of the operation, which is set when the operation is created.
    */
    public String getDescription() {
      return description;
    }

    /**
     * [Output Only] A textual description of the operation, which is set when the operation is created.
    */
    public Builder setDescription(String description) {
      this.description = description;
      return this;
    }

    /**
     * [Output Only] If errors are generated during processing of the operation, this field will be populated.
    */
    public Error getError() {
      return error;
    }

    /**
     * [Output Only] If errors are generated during processing of the operation, this field will be populated.
    */
    public Builder setError(Error error) {
      this.error = error;
      return this;
    }

    /**
     * [Output Only] If the operation fails, this field contains the HTTP error message that was returned, such as NOT FOUND.
    */
    public String getHttpErrorMessage() {
      return httpErrorMessage;
    }

    /**
     * [Output Only] If the operation fails, this field contains the HTTP error message that was returned, such as NOT FOUND.
    */
    public Builder setHttpErrorMessage(String httpErrorMessage) {
      this.httpErrorMessage = httpErrorMessage;
      return this;
    }

    /**
     * [Output Only] If the operation fails, this field contains the HTTP error status code that was returned. For example, a 404 means the resource was not found.
    */
    public Integer getHttpErrorStatusCode() {
      return httpErrorStatusCode;
    }

    /**
     * [Output Only] If the operation fails, this field contains the HTTP error status code that was returned. For example, a 404 means the resource was not found.
    */
    public Builder setHttpErrorStatusCode(Integer httpErrorStatusCode) {
      this.httpErrorStatusCode = httpErrorStatusCode;
      return this;
    }

    /**
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
    */
    public String getId() {
      return id;
    }

    /**
     * [Output Only] The unique identifier for the resource. This identifier is defined by the server.
    */
    public Builder setId(String id) {
      this.id = id;
      return this;
    }

    /**
     * [Output Only] Type of the resource. Always compute#operation for Operation resources.
    */
    public String getKind() {
      return kind;
    }

    /**
     * [Output Only] Type of the resource. Always compute#operation for Operation resources.
    */
    public Builder setKind(String kind) {
      this.kind = kind;
      return this;
    }

    /**
     * [Output Only] Name of the resource.
    */
    public String getName() {
      return name;
    }

    /**
     * [Output Only] Name of the resource.
    */
    public Builder setName(String name) {
      this.name = name;
      return this;
    }

    /**
     * [Output Only] The type of operation, such as insert, update, or delete, and so on.
    */
    public String getOperationType() {
      return operationType;
    }

    /**
     * [Output Only] The type of operation, such as insert, update, or delete, and so on.
    */
    public Builder setOperationType(String operationType) {
      this.operationType = operationType;
      return this;
    }

    /**
     * [Output Only] An optional progress indicator that ranges from 0 to 100. There is no requirement that this be linear or support any granularity of operations. This should not be used to guess when the operation will be complete. This number should monotonically increase as the operation progresses.
    */
    public Integer getProgress() {
      return progress;
    }

    /**
     * [Output Only] An optional progress indicator that ranges from 0 to 100. There is no requirement that this be linear or support any granularity of operations. This should not be used to guess when the operation will be complete. This number should monotonically increase as the operation progresses.
    */
    public Builder setProgress(Integer progress) {
      this.progress = progress;
      return this;
    }

    /**
     * [Output Only] The URL of the region where the operation resides. Only available when performing regional operations.
    */
    public String getRegion() {
      return region;
    }

    /**
     * [Output Only] The URL of the region where the operation resides. Only available when performing regional operations.
    */
    public Builder setRegion(String region) {
      this.region = region;
      return this;
    }

    /**
     * [Output Only] Server-defined URL for the resource.
    */
    public String getSelfLink() {
      return selfLink;
    }

    /**
     * [Output Only] Server-defined URL for the resource.
    */
    public Builder setSelfLink(String selfLink) {
      this.selfLink = selfLink;
      return this;
    }

    /**
     * [Output Only] The time that this operation was started by the server. This value is in RFC3339 text format.
    */
    public String getStartTime() {
      return startTime;
    }

    /**
     * [Output Only] The time that this operation was started by the server. This value is in RFC3339 text format.
    */
    public Builder setStartTime(String startTime) {
      this.startTime = startTime;
      return this;
    }

    /**
     * [Output Only] The status of the operation, which can be one of the following: PENDING, RUNNING, or DONE.
    */
    public String getStatus() {
      return status;
    }

    /**
     * [Output Only] The status of the operation, which can be one of the following: PENDING, RUNNING, or DONE.
    */
    public Builder setStatus(String status) {
      this.status = status;
      return this;
    }

    /**
     * [Output Only] An optional textual description of the current status of the operation.
    */
    public String getStatusMessage() {
      return statusMessage;
    }

    /**
     * [Output Only] An optional textual description of the current status of the operation.
    */
    public Builder setStatusMessage(String statusMessage) {
      this.statusMessage = statusMessage;
      return this;
    }

    /**
     * [Output Only] The unique target ID, which identifies a specific incarnation of the target resource.
    */
    public String getTargetId() {
      return targetId;
    }

    /**
     * [Output Only] The unique target ID, which identifies a specific incarnation of the target resource.
    */
    public Builder setTargetId(String targetId) {
      this.targetId = targetId;
      return this;
    }

    /**
     * [Output Only] The URL of the resource that the operation modifies. For operations related to creating a snapshot, this points to the persistent disk that the snapshot was created from.
    */
    public String getTargetLink() {
      return targetLink;
    }

    /**
     * [Output Only] The URL of the resource that the operation modifies. For operations related to creating a snapshot, this points to the persistent disk that the snapshot was created from.
    */
    public Builder setTargetLink(String targetLink) {
      this.targetLink = targetLink;
      return this;
    }

    /**
     * [Output Only] If warning messages are generated during processing of the operation, this field will be populated.
    */
    public List<Warnings> getWarningsList() {
      return warnings;
    }

    /**
     * [Output Only] If warning messages are generated during processing of the operation, this field will be populated.
    */
    public Builder addAllWarnings(List<Warnings> warnings) {
      if (this.warnings == null) {
        this.warnings = new LinkedList<>();
      }
      this.warnings.addAll(warnings);
      return this;
    }

    /**
     * [Output Only] If warning messages are generated during processing of the operation, this field will be populated.
    */
    public Builder addWarnings(Warnings warnings) {
      if (this.warnings == null) {
        this.warnings = new LinkedList<>();
      }
      this.warnings.add(warnings);
      return this;
    }

    /**
     * [Output Only] The URL of the zone where the operation resides. Only available when performing per-zone operations.
    */
    public String getZone() {
      return zone;
    }

    /**
     * [Output Only] The URL of the zone where the operation resides. Only available when performing per-zone operations.
    */
    public Builder setZone(String zone) {
      this.zone = zone;
      return this;
    }


    public Operation build() {


















      return new Operation(
        clientOperationId,
        description,
        error,
        httpErrorMessage,
        httpErrorStatusCode,
        id,
        kind,
        name,
        operationType,
        progress,
        region,
        selfLink,
        startTime,
        status,
        statusMessage,
        targetId,
        targetLink,
        warnings,
        zone
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setClientOperationId(this.clientOperationId);
      newBuilder.setDescription(this.description);
      newBuilder.setError(this.error);
      newBuilder.setHttpErrorMessage(this.httpErrorMessage);
      newBuilder.setHttpErrorStatusCode(this.httpErrorStatusCode);
      newBuilder.setId(this.id);
      newBuilder.setKind(this.kind);
      newBuilder.setName(this.name);
      newBuilder.setOperationType(this.operationType);
      newBuilder.setProgress(this.progress);
      newBuilder.setRegion(this.region);
      newBuilder.setSelfLink(this.selfLink);
      newBuilder.setStartTime(this.startTime);
      newBuilder.setStatus(this.status);
      newBuilder.setStatusMessage(this.statusMessage);
      newBuilder.setTargetId(this.targetId);
      newBuilder.setTargetLink(this.targetLink);
      newBuilder.addAllWarnings(this.warnings);
      newBuilder.setZone(this.zone);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "Operation{"
        + "clientOperationId=" + clientOperationId + ", "
        + "description=" + description + ", "
        + "error=" + error + ", "
        + "httpErrorMessage=" + httpErrorMessage + ", "
        + "httpErrorStatusCode=" + httpErrorStatusCode + ", "
        + "id=" + id + ", "
        + "kind=" + kind + ", "
        + "name=" + name + ", "
        + "operationType=" + operationType + ", "
        + "progress=" + progress + ", "
        + "region=" + region + ", "
        + "selfLink=" + selfLink + ", "
        + "startTime=" + startTime + ", "
        + "status=" + status + ", "
        + "statusMessage=" + statusMessage + ", "
        + "targetId=" + targetId + ", "
        + "targetLink=" + targetLink + ", "
        + "warnings=" + warnings + ", "
        + "zone=" + zone
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof Operation) {
      Operation that = (Operation) o;
      return
          Objects.equals(this.clientOperationId, that.getClientOperationId()) &&
          Objects.equals(this.description, that.getDescription()) &&
          Objects.equals(this.error, that.getError()) &&
          Objects.equals(this.httpErrorMessage, that.getHttpErrorMessage()) &&
          Objects.equals(this.httpErrorStatusCode, that.getHttpErrorStatusCode()) &&
          Objects.equals(this.id, that.getId()) &&
          Objects.equals(this.kind, that.getKind()) &&
          Objects.equals(this.name, that.getName()) &&
          Objects.equals(this.operationType, that.getOperationType()) &&
          Objects.equals(this.progress, that.getProgress()) &&
          Objects.equals(this.region, that.getRegion()) &&
          Objects.equals(this.selfLink, that.getSelfLink()) &&
          Objects.equals(this.startTime, that.getStartTime()) &&
          Objects.equals(this.status, that.getStatus()) &&
          Objects.equals(this.statusMessage, that.getStatusMessage()) &&
          Objects.equals(this.targetId, that.getTargetId()) &&
          Objects.equals(this.targetLink, that.getTargetLink()) &&
          Objects.equals(this.warnings, that.getWarningsList()) &&
          Objects.equals(this.zone, that.getZone())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      clientOperationId,
      description,
      error,
      httpErrorMessage,
      httpErrorStatusCode,
      id,
      kind,
      name,
      operationType,
      progress,
      region,
      selfLink,
      startTime,
      status,
      statusMessage,
      targetId,
      targetLink,
      warnings,
      zone
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/Warnings.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.httpjson.ApiMessage;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.annotations.SerializedName;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;
import javax.annotation.Nullable;

@Generated("by GAPIC")
@BetaApi
/**
 * [Output Only] If warning messages are generated during processing of the operation, this field will be populated.
*/
public final class Warnings implements ApiMessage {
  private final String code;
  private final List<Data> data;
  private final String message;

  private Warnings() {
    this.code = null;
    this.data = null;
    this.message = null;
  }


  private Warnings(
      String code,
      List<Data> data,
      String message
      ) {
    this.code = code;
    this.data = data;
    this.message = message;
  }

  @Override
  public Object getFieldValue(String fieldName) {
    if ("code".equals(fieldName)) {
      return code;
    }
    if ("data".equals(fieldName)) {
      return data;
    }
    if ("message".equals(fieldName)) {
      return message;
    }
    return null;
  }

  @Nullable
  @Override
  public ApiMessage getApiMessageRequestBody() {
    return null;
  }

  @Nullable
  @Override
  /**
   * The fields that should be serialized (even if they have empty values).
   * If the containing message object has a non-null fieldmask,
   * then all the fields in the field mask (and only those fields in the field mask)
   * will be serialized. If the containing object does not have a fieldmask, then
   * only non-empty fields will be serialized.
  */
  public List<String> getFieldMask() {
    return null;
  }

  /**
   * [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
  */
  public String getCode() {
    return code;
  }

  /**
   * [Output Only] Metadata about this warning in key: value format. For example:
   * "data": [ { "key": "scope", "value": "zones/us-east1-d" }
  */
  public List<Data> getDataList() {
    return data;
  }

  /**
   * [Output Only] A human-readable description of the warning code.
  */
  public String getMessage() {
    return message;
  }


  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(Warnings prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  public static Warnings getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }
  private static final Warnings DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new Warnings();
  }

  public static class Builder {
    private String code;
    private List<Data> data;
    private String message;

    Builder() {}

    public Builder mergeFrom(Warnings other) {
      if (other == Warnings.getDefaultInstance()) return this;
      if (other.getCode() != null) {
        this.code = other.code;
      }
      if (other.getDataList() != null) {
        this.data = other.data;
      }
      if (other.getMessage() != null) {
        this.message = other.message;
      }
      return this;
    }

    Builder(Warnings source) {
      this.code = source.code;
      this.data = source.data;
      this.message = source.message;
    }

    /**
     * [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
    */
    public String getCode() {
      return code;
    }

    /**
     * [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
    */
    public Builder setCode(String code) {
      this.code = code;
      return this;
    }

    /**
     * [Output Only] Metadata about this warning in key: value format. For example:
     * "data": [ { "key": "scope", "value": "zones/us-east1-d" }
    */
    public List<Data> getDataList() {
      return data;
    }

    /**
     * [Output Only] Metadata about this warning in key: value format. For example:
     * "data": [ { "key": "scope", "value": "zones/us-east1-d" }
    */
    public Builder addAllData(List<Data> data) {
      if (this.data == null) {
        this.data = new LinkedList<>();
      }
      this.data.addAll(data);
      return this;
    }

    /**
     * [Output Only] Metadata about this warning in key: value format. For example:
     * "data": [ { "key": "scope", "value": "zones/us-east1-d" }
    */
    public Builder addData(Data data) {
      if (this.data == null) {
        this.data = new LinkedList<>();
      }
      this.data.add(data);
      return this;
    }

    /**
     * [Output Only] A human-readable description of the warning code.
    */
    public String getMessage() {
      return message;
    }

    /**
     * [Output Only] A human-readable description of the warning code.
    */
    public Builder setMessage(String message) {
      this.message = message;
      return this;
    }


    public Warnings build() {


      return new Warnings(
        code,
        data,
        message
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setCode(this.code);
      newBuilder.addAllData(this.data);
      newBuilder.setMessage(this.message);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "Warnings{"
        + "code=" + code + ", "
        + "data=" + data + ", "
        + "message=" + message
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof Warnings) {
      Warnings that = (Warnings) o;
      return
          Objects.equals(this.code, that.getCode()) &&
          Objects.equals(this.data, that.getDataList()) &&
          Objects.equals(this.message, that.getMessage())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      code,
      data,
      message
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/AggregatedListAddressesHttpRequest.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.httpjson.ApiMessage;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.annotations.SerializedName;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;
import javax.annotation.Nullable;

@Generated("by GAPIC")
@BetaApi
/**
 * Request object for method compute.addresses.aggregatedList. Retrieves an aggregated list of addresses.
*/
public final class AggregatedListAddressesHttpRequest implements ApiMessage {
  private final String access_token;
  private final String callback;
  private final String fields;
  private final String filter;
  private final String key;
  private final Integer maxResults;
  private final String orderBy;
  private final String pageToken;
  private final String prettyPrint;
  private final String project;
  private final String quotaUser;
  private final String userIp;

  private AggregatedListAddressesHttpRequest() {
    this.access_token = null;
    this.callback = null;
    this.fields = null;
    this.filter = null;
    this.key = null;
    this.maxResults = null;
    this.orderBy = null;
    this.pageToken = null;
    this.prettyPrint = null;
    this.project = null;
    this.quotaUser = null;
    this.userIp = null;
  }


  private AggregatedListAddressesHttpRequest(
      String access_token,
      String callback,
      String fields,
      String filter,
      String key,
      Integer maxResults,
      String orderBy,
      String pageToken,
      String prettyPrint,
      String project,
      String quotaUser,
      String userIp
      ) {
    this.access_token = access_token;
    this.callback = callback;
    this.fields = fields;
    this.filter = filter;
    this.key = key;
    this.maxResults = maxResults;
    this.orderBy = orderBy;
    this.pageToken = pageToken;
    this.prettyPrint = prettyPrint;
    this.project = project;
    this.quotaUser = quotaUser;
    this.userIp = userIp;
  }

  @Override
  public Object getFieldValue(String fieldName) {
    if ("access_token".equals(fieldName)) {
      return access_token;
    }
    if ("callback".equals(fieldName)) {
      return callback;
    }
    if ("fields".equals(fieldName)) {
      return fields;
    }
    if ("filter".equals(fieldName)) {
      return filter;
    }
    if ("key".equals(fieldName)) {
      return key;
    }
    if ("maxResults".equals(fieldName)) {
      return maxResults;
    }
    if ("orderBy".equals(fieldName)) {
      return orderBy;
    }
    if ("pageToken".equals(fieldName)) {
      return pageToken;
    }
    if ("prettyPrint".equals(fieldName)) {
      return prettyPrint;
    }
    if ("project".equals(fieldName)) {
      return project;
    }
    if ("quotaUser".equals(fieldName)) {
      return quotaUser;
    }
    if ("userIp".equals(fieldName)) {
      return userIp;
    }
    return null;
  }

  @Nullable
  @Override
  public ApiMessage getApiMessageRequestBody() {
    return null;
  }

  @Nullable
  @Override
  /**
   * The fields that should be serialized (even if they have empty values).
   * If the containing message object has a non-null fieldmask,
   * then all the fields in the field mask (and only those fields in the field mask)
   * will be serialized. If the containing object does not have a fieldmask, then
   * only non-empty fields will be serialized.
  */
  public List<String> getFieldMask() {
    return null;
  }

  /**
   * OAuth 2.0 token for the current user.
  */
  public String getAccessToken() {
    return access_token;
  }

  /**
   * Name of the JavaScript callback function that handles the response.
  */
  public String getCallback() {
    return callback;
  }

  /**
   * Selector specifying a subset of fields to include in the response.
  */
  public String getFields() {
    return fields;
  }

  /**
   * A filter expression that filters resources listed in the response. The expression must specify the field name, a comparison operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The comparison operator must be either =, !=, &gt;, or &lt;.
   *
   * For example, if you are filtering Compute Engine instances, you can exclude instances named example-instance by specifying name != example-instance.
   *
   * You can also filter nested fields. For example, you could specify scheduling.automaticRestart = false to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels.
   *
   * To filter on multiple expressions, provide each separate expression within parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake"). By default, each expression is an AND expression. However, you can include AND and OR expressions explicitly. For example, (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true).
  */
  public String getFilter() {
    return filter;
  }

  /**
   * API key. Required unless you provide an OAuth 2.0 token.
  */
  public String getKey() {
    return key;
  }

  /**
   * The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, Compute Engine returns a nextPageToken that can be used to get the next page of results in subsequent list requests. Acceptable values are 0 to 500, inclusive. (Default: 500)
  */
  public Integer getMaxResults() {
    return maxResults;
  }

  /**
   * Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name.
   *
   * You can also sort results in descending order based on the creation timestamp using orderBy="creationTimestamp desc". This sorts results based on the creationTimestamp field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first.
   *
   * Currently, only sorting by name or creationTimestamp desc is supported.
  */
  public String getOrderBy() {
    return orderBy;
  }

  /**
   * Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results.
  */
  public String getPageToken() {
    return pageToken;
  }

  /**
   * Returns response with indentations and line breaks.
  */
  public String getPrettyPrint() {
    return prettyPrint;
  }

  /**
   * Project ID for this request.
   * It must have the format `{project}/aggregated/addresses`. \`{project}\` must start with a letter,
   * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
   *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
   *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
   *      &#42; must not start with \`"goog"\`.
  */
  public String getProject() {
    return project;
  }

  /**
   * Alternative to userIp.
  */
  public String getQuotaUser() {
    return quotaUser;
  }

  /**
   * IP address of the end user for whom the API call is being made.
  */
  public String getUserIp() {
    return userIp;
  }


  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(AggregatedListAddressesHttpRequest prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  public static AggregatedListAddressesHttpRequest getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }
  private static final AggregatedListAddressesHttpRequest DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new AggregatedListAddressesHttpRequest();
  }

  public static class Builder {
    private String access_token;
    private String callback;
    private String fields;
    private String filter;
    private String key;
    private Integer maxResults;
    private String orderBy;
    private String pageToken;
    private String prettyPrint;
    private String project;
    private String quotaUser;
    private String userIp;

    Builder() {}

    public Builder mergeFrom(AggregatedListAddressesHttpRequest other) {
      if (other == AggregatedListAddressesHttpRequest.getDefaultInstance()) return this;
      if (other.getAccessToken() != null) {
        this.access_token = other.access_token;
      }
      if (other.getCallback() != null) {
        this.callback = other.callback;
      }
      if (other.getFields() != null) {
        this.fields = other.fields;
      }
      if (other.getFilter() != null) {
        this.filter = other.filter;
      }
      if (other.getKey() != null) {
        this.key = other.key;
      }
      if (other.getMaxResults() != null) {
        this.maxResults = other.maxResults;
      }
      if (other.getOrderBy() != null) {
        this.orderBy = other.orderBy;
      }
      if (other.getPageToken() != null) {
        this.pageToken = other.pageToken;
      }
      if (other.getPrettyPrint() != null) {
        this.prettyPrint = other.prettyPrint;
      }
      if (other.getProject() != null) {
        this.project = other.project;
      }
      if (other.getQuotaUser() != null) {
        this.quotaUser = other.quotaUser;
      }
      if (other.getUserIp() != null) {
        this.userIp = other.userIp;
      }
      return this;
    }

    Builder(AggregatedListAddressesHttpRequest source) {
      this.access_token = source.access_token;
      this.callback = source.callback;
      this.fields = source.fields;
      this.filter = source.filter;
      this.key = source.key;
      this.maxResults = source.maxResults;
      this.orderBy = source.orderBy;
      this.pageToken = source.pageToken;
      this.prettyPrint = source.prettyPrint;
      this.project = source.project;
      this.quotaUser = source.quotaUser;
      this.userIp = source.userIp;
    }

    /**
     * OAuth 2.0 token for the current user.
    */
    public String getAccessToken() {
      return access_token;
    }

    /**
     * OAuth 2.0 token for the current user.
    */
    public Builder setAccessToken(String access_token) {
      this.access_token = access_token;
      return this;
    }

    /**
     * Name of the JavaScript callback function that handles the response.
    */
    public String getCallback() {
      return callback;
    }

    /**
     * Name of the JavaScript callback function that handles the response.
    */
    public Builder setCallback(String callback) {
      this.callback = callback;
      return this;
    }

    /**
     * Selector specifying a subset of fields to include in the response.
    */
    public String getFields() {
      return fields;
    }

    /**
     * Selector specifying a subset of fields to include in the response.
    */
    public Builder setFields(String fields) {
      this.fields = fields;
      return this;
    }

    /**
     * A filter expression that filters resources listed in the response. The expression must specify the field name, a comparison operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The comparison operator must be either =, !=, &gt;, or &lt;.
     *
     * For example, if you are filtering Compute Engine instances, you can exclude instances named example-instance by specifying name != example-instance.
     *
     * You can also filter nested fields. For example, you could specify scheduling.automaticRestart = false to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels.
     *
     * To filter on multiple expressions, provide each separate expression within parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake"). By default, each expression is an AND expression. However, you can include AND and OR expressions explicitly. For example, (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true).
    */
    public String getFilter() {
      return filter;
    }

    /**
     * A filter expression that filters resources listed in the response. The expression must specify the field name, a comparison operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The comparison operator must be either =, !=, &gt;, or &lt;.
     *
     * For example, if you are filtering Compute Engine instances, you can exclude instances named example-instance by specifying name != example-instance.
     *
     * You can also filter nested fields. For example, you could specify scheduling.automaticRestart = false to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels.
     *
     * To filter on multiple expressions, provide each separate expression within parentheses. For example, (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake"). By default, each expression is an AND expression. However, you can include AND and OR expressions explicitly. For example, (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true).
    */
    public Builder setFilter(String filter) {
      this.filter = filter;
      return this;
    }

    /**
     * API key. Required unless you provide an OAuth 2.0 token.
    */
    public String getKey() {
      return key;
    }

    /**
     * API key. Required unless you provide an OAuth 2.0 token.
    */
    public Builder setKey(String key) {
      this.key = key;
      return this;
    }

    /**
     * The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, Compute Engine returns a nextPageToken that can be used to get the next page of results in subsequent list requests. Acceptable values are 0 to 500, inclusive. (Default: 500)
    */
    public Integer getMaxResults() {
      return maxResults;
    }

    /**
     * The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, Compute Engine returns a nextPageToken that can be used to get the next page of results in subsequent list requests. Acceptable values are 0 to 500, inclusive. (Default: 500)
    */
    public Builder setMaxResults(Integer maxResults) {
      this.maxResults = maxResults;
      return this;
    }

    /**
     * Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name.
     *
     * You can also sort results in descending order based on the creation timestamp using orderBy="creationTimestamp desc". This sorts results based on the creationTimestamp field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first.
     *
     * Currently, only sorting by name or creationTimestamp desc is supported.
    */
    public String getOrderBy() {
      return orderBy;
    }

    /**
     * Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name.
     *
     * You can also sort results in descending order based on the creation timestamp using orderBy="creationTimestamp desc". This sorts results based on the creationTimestamp field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first.
     *
     * Currently, only sorting by name or creationTimestamp desc is supported.
    */
    public Builder setOrderBy(String orderBy) {
      this.orderBy = orderBy;
      return this;
    }

    /**
     * Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results.
    */
    public String getPageToken() {
      return pageToken;
    }

    /**
     * Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results.
    */
    public Builder setPageToken(String pageToken) {
      this.pageToken = pageToken;
      return this;
    }

    /**
     * Returns response with indentations and line breaks.
    */
    public String getPrettyPrint() {
      return prettyPrint;
    }

    /**
     * Returns response with indentations and line breaks.
    */
    public Builder setPrettyPrint(String prettyPrint) {
      this.prettyPrint = prettyPrint;
      return this;
    }

    /**
     * Project ID for this request.
     * It must have the format `{project}/aggregated/addresses`. \`{project}\` must start with a letter,
     * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
     *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
     *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
     *      &#42; must not start with \`"goog"\`.
    */
    public String getProject() {
      return project;
    }

    /**
     * Project ID for this request.
     * It must have the format `{project}/aggregated/addresses`. \`{project}\` must start with a letter,
     * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
     *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
     *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
     *      &#42; must not start with \`"goog"\`.
    */
    public Builder setProject(String project) {
      this.project = project;
      return this;
    }

    /**
     * Alternative to userIp.
    */
    public String getQuotaUser() {
      return quotaUser;
    }

    /**
     * Alternative to userIp.
    */
    public Builder setQuotaUser(String quotaUser) {
      this.quotaUser = quotaUser;
      return this;
    }

    /**
     * IP address of the end user for whom the API call is being made.
    */
    public String getUserIp() {
      return userIp;
    }

    /**
     * IP address of the end user for whom the API call is being made.
    */
    public Builder setUserIp(String userIp) {
      this.userIp = userIp;
      return this;
    }


    public AggregatedListAddressesHttpRequest build() {
      String missing = "";









      if (project == null) {
        missing += " project";
      }


      if (!missing.isEmpty()) {
        throw new IllegalStateException("Missing required properties:" + missing);
      }
      return new AggregatedListAddressesHttpRequest(
        access_token,
        callback,
        fields,
        filter,
        key,
        maxResults,
        orderBy,
        pageToken,
        prettyPrint,
        project,
        quotaUser,
        userIp
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setAccessToken(this.access_token);
      newBuilder.setCallback(this.callback);
      newBuilder.setFields(this.fields);
      newBuilder.setFilter(this.filter);
      newBuilder.setKey(this.key);
      newBuilder.setMaxResults(this.maxResults);
      newBuilder.setOrderBy(this.orderBy);
      newBuilder.setPageToken(this.pageToken);
      newBuilder.setPrettyPrint(this.prettyPrint);
      newBuilder.setProject(this.project);
      newBuilder.setQuotaUser(this.quotaUser);
      newBuilder.setUserIp(this.userIp);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "AggregatedListAddressesHttpRequest{"
        + "access_token=" + access_token + ", "
        + "callback=" + callback + ", "
        + "fields=" + fields + ", "
        + "filter=" + filter + ", "
        + "key=" + key + ", "
        + "maxResults=" + maxResults + ", "
        + "orderBy=" + orderBy + ", "
        + "pageToken=" + pageToken + ", "
        + "prettyPrint=" + prettyPrint + ", "
        + "project=" + project + ", "
        + "quotaUser=" + quotaUser + ", "
        + "userIp=" + userIp
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof AggregatedListAddressesHttpRequest) {
      AggregatedListAddressesHttpRequest that = (AggregatedListAddressesHttpRequest) o;
      return
          Objects.equals(this.access_token, that.getAccessToken()) &&
          Objects.equals(this.callback, that.getCallback()) &&
          Objects.equals(this.fields, that.getFields()) &&
          Objects.equals(this.filter, that.getFilter()) &&
          Objects.equals(this.key, that.getKey()) &&
          Objects.equals(this.maxResults, that.getMaxResults()) &&
          Objects.equals(this.orderBy, that.getOrderBy()) &&
          Objects.equals(this.pageToken, that.getPageToken()) &&
          Objects.equals(this.prettyPrint, that.getPrettyPrint()) &&
          Objects.equals(this.project, that.getProject()) &&
          Objects.equals(this.quotaUser, that.getQuotaUser()) &&
          Objects.equals(this.userIp, that.getUserIp())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      access_token,
      callback,
      fields,
      filter,
      key,
      maxResults,
      orderBy,
      pageToken,
      prettyPrint,
      project,
      quotaUser,
      userIp
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/DeleteAddressHttpRequest.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.httpjson.ApiMessage;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.annotations.SerializedName;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;
import javax.annotation.Nullable;

@Generated("by GAPIC")
@BetaApi
/**
 * Request object for method compute.addresses.delete. Deletes the specified address resource.
*/
public final class DeleteAddressHttpRequest implements ApiMessage {
  private final String access_token;
  private final String address;
  private final String callback;
  private final String fields;
  private final String key;
  private final String prettyPrint;
  private final String quotaUser;
  private final String userIp;

  private DeleteAddressHttpRequest() {
    this.access_token = null;
    this.address = null;
    this.callback = null;
    this.fields = null;
    this.key = null;
    this.prettyPrint = null;
    this.quotaUser = null;
    this.userIp = null;
  }


  private DeleteAddressHttpRequest(
      String access_token,
      String address,
      String callback,
      String fields,
      String key,
      String prettyPrint,
      String quotaUser,
      String userIp
      ) {
    this.access_token = access_token;
    this.address = address;
    this.callback = callback;
    this.fields = fields;
    this.key = key;
    this.prettyPrint = prettyPrint;
    this.quotaUser = quotaUser;
    this.userIp = userIp;
  }

  @Override
  public Object getFieldValue(String fieldName) {
    if ("access_token".equals(fieldName)) {
      return access_token;
    }
    if ("address".equals(fieldName)) {
      return address;
    }
    if ("callback".equals(fieldName)) {
      return callback;
    }
    if ("fields".equals(fieldName)) {
      return fields;
    }
    if ("key".equals(fieldName)) {
      return key;
    }
    if ("prettyPrint".equals(fieldName)) {
      return prettyPrint;
    }
    if ("quotaUser".equals(fieldName)) {
      return quotaUser;
    }
    if ("userIp".equals(fieldName)) {
      return userIp;
    }
    return null;
  }

  @Nullable
  @Override
  public ApiMessage getApiMessageRequestBody() {
    return null;
  }

  @Nullable
  @Override
  /**
   * The fields that should be serialized (even if they have empty values).
   * If the containing message object has a non-null fieldmask,
   * then all the fields in the field mask (and only those fields in the field mask)
   * will be serialized. If the containing object does not have a fieldmask, then
   * only non-empty fields will be serialized.
  */
  public List<String> getFieldMask() {
    return null;
  }

  /**
   * OAuth 2.0 token for the current user.
  */
  public String getAccessToken() {
    return access_token;
  }

  /**
   * Name of the address resource to delete.
   * It must have the format `{project}/regions/{region}/addresses/{address}`. \`{address}\` must start with a letter,
   * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
   *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
   *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
   *      &#42; must not start with \`"goog"\`.
  */
  public String getAddress() {
    return address;
  }

  /**
   * Name of the JavaScript callback function that handles the response.
  */
  public String getCallback() {
    return callback;
  }

  /**
   * Selector specifying a subset of fields to include in the response.
  */
  public String getFields() {
    return fields;
  }

  /**
   * API key. Required unless you provide an OAuth 2.0 token.
  */
  public String getKey() {
    return key;
  }

  /**
   * Returns response with indentations and line breaks.
  */
  public String getPrettyPrint() {
    return prettyPrint;
  }

  /**
   * Alternative to userIp.
  */
  public String getQuotaUser() {
    return quotaUser;
  }

  /**
   * IP address of the end user for whom the API call is being made.
  */
  public String getUserIp() {
    return userIp;
  }


  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(DeleteAddressHttpRequest prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  public static DeleteAddressHttpRequest getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }
  private static final DeleteAddressHttpRequest DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new DeleteAddressHttpRequest();
  }

  public static class Builder {
    private String access_token;
    private String address;
    private String callback;
    private String fields;
    private String key;
    private String prettyPrint;
    private String quotaUser;
    private String userIp;

    Builder() {}

    public Builder mergeFrom(DeleteAddressHttpRequest other) {
      if (other == DeleteAddressHttpRequest.getDefaultInstance()) return this;
      if (other.getAccessToken() != null) {
        this.access_token = other.access_token;
      }
      if (other.getAddress() != null) {
        this.address = other.address;
      }
      if (other.getCallback() != null) {
        this.callback = other.callback;
      }
      if (other.getFields() != null) {
        this.fields = other.fields;
      }
      if (other.getKey() != null) {
        this.key = other.key;
      }
      if (other.getPrettyPrint() != null) {
        this.prettyPrint = other.prettyPrint;
      }
      if (other.getQuotaUser() != null) {
        this.quotaUser = other.quotaUser;
      }
      if (other.getUserIp() != null) {
        this.userIp = other.userIp;
      }
      return this;
    }

    Builder(DeleteAddressHttpRequest source) {
      this.access_token = source.access_token;
      this.address = source.address;
      this.callback = source.callback;
      this.fields = source.fields;
      this.key = source.key;
      this.prettyPrint = source.prettyPrint;
      this.quotaUser = source.quotaUser;
      this.userIp = source.userIp;
    }

    /**
     * OAuth 2.0 token for the current user.
    */
    public String getAccessToken() {
      return access_token;
    }

    /**
     * OAuth 2.0 token for the current user.
    */
    public Builder setAccessToken(String access_token) {
      this.access_token = access_token;
      return this;
    }

    /**
     * Name of the address resource to delete.
     * It must have the format `{project}/regions/{region}/addresses/{address}`. \`{address}\` must start with a letter,
     * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
     *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
     *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
     *      &#42; must not start with \`"goog"\`.
    */
    public String getAddress() {
      return address;
    }

    /**
     * Name of the address resource to delete.
     * It must have the format `{project}/regions/{region}/addresses/{address}`. \`{address}\` must start with a letter,
     * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
     *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
     *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
     *      &#42; must not start with \`"goog"\`.
    */
    public Builder setAddress(String address) {
      this.address = address;
      return this;
    }

    /**
     * Name of the JavaScript callback function that handles the response.
    */
    public String getCallback() {
      return callback;
    }

    /**
     * Name of the JavaScript callback function that handles the response.
    */
    public Builder setCallback(String callback) {
      this.callback = callback;
      return this;
    }

    /**
     * Selector specifying a subset of fields to include in the response.
    */
    public String getFields() {
      return fields;
    }

    /**
     * Selector specifying a subset of fields to include in the response.
    */
    public Builder setFields(String fields) {
      this.fields = fields;
      return this;
    }

    /**
     * API key. Required unless you provide an OAuth 2.0 token.
    */
    public String getKey() {
      return key;
    }

    /**
     * API key. Required unless you provide an OAuth 2.0 token.
    */
    public Builder setKey(String key) {
      this.key = key;
      return this;
    }

    /**
     * Returns response with indentations and line breaks.
    */
    public String getPrettyPrint() {
      return prettyPrint;
    }

    /**
     * Returns response with indentations and line breaks.
    */
    public Builder setPrettyPrint(String prettyPrint) {
      this.prettyPrint = prettyPrint;
      return this;
    }

    /**
     * Alternative to userIp.
    */
    public String getQuotaUser() {
      return quotaUser;
    }

    /**
     * Alternative to userIp.
    */
    public Builder setQuotaUser(String quotaUser) {
      this.quotaUser = quotaUser;
      return this;
    }

    /**
     * IP address of the end user for whom the API call is being made.
    */
    public String getUserIp() {
      return userIp;
    }

    /**
     * IP address of the end user for whom the API call is being made.
    */
    public Builder setUserIp(String userIp) {
      this.userIp = userIp;
      return this;
    }


    public DeleteAddressHttpRequest build() {
      String missing = "";

      if (address == null) {
        missing += " address";
      }






      if (!missing.isEmpty()) {
        throw new IllegalStateException("Missing required properties:" + missing);
      }
      return new DeleteAddressHttpRequest(
        access_token,
        address,
        callback,
        fields,
        key,
        prettyPrint,
        quotaUser,
        userIp
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setAccessToken(this.access_token);
      newBuilder.setAddress(this.address);
      newBuilder.setCallback(this.callback);
      newBuilder.setFields(this.fields);
      newBuilder.setKey(this.key);
      newBuilder.setPrettyPrint(this.prettyPrint);
      newBuilder.setQuotaUser(this.quotaUser);
      newBuilder.setUserIp(this.userIp);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "DeleteAddressHttpRequest{"
        + "access_token=" + access_token + ", "
        + "address=" + address + ", "
        + "callback=" + callback + ", "
        + "fields=" + fields + ", "
        + "key=" + key + ", "
        + "prettyPrint=" + prettyPrint + ", "
        + "quotaUser=" + quotaUser + ", "
        + "userIp=" + userIp
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof DeleteAddressHttpRequest) {
      DeleteAddressHttpRequest that = (DeleteAddressHttpRequest) o;
      return
          Objects.equals(this.access_token, that.getAccessToken()) &&
          Objects.equals(this.address, that.getAddress()) &&
          Objects.equals(this.callback, that.getCallback()) &&
          Objects.equals(this.fields, that.getFields()) &&
          Objects.equals(this.key, that.getKey()) &&
          Objects.equals(this.prettyPrint, that.getPrettyPrint()) &&
          Objects.equals(this.quotaUser, that.getQuotaUser()) &&
          Objects.equals(this.userIp, that.getUserIp())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      access_token,
      address,
      callback,
      fields,
      key,
      prettyPrint,
      quotaUser,
      userIp
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/GetAddressHttpRequest.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.httpjson.ApiMessage;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.annotations.SerializedName;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;
import javax.annotation.Nullable;

@Generated("by GAPIC")
@BetaApi
/**
 * Request object for method compute.addresses.get. Returns the specified address resource.
*/
public final class GetAddressHttpRequest implements ApiMessage {
  private final String access_token;
  private final String address;
  private final String callback;
  private final String fields;
  private final String key;
  private final String prettyPrint;
  private final String quotaUser;
  private final String userIp;

  private GetAddressHttpRequest() {
    this.access_token = null;
    this.address = null;
    this.callback = null;
    this.fields = null;
    this.key = null;
    this.prettyPrint = null;
    this.quotaUser = null;
    this.userIp = null;
  }


  private GetAddressHttpRequest(
      String access_token,
      String address,
      String callback,
      String fields,
      String key,
      String prettyPrint,
      String quotaUser,
      String userIp
      ) {
    this.access_token = access_token;
    this.address = address;
    this.callback = callback;
    this.fields = fields;
    this.key = key;
    this.prettyPrint = prettyPrint;
    this.quotaUser = quotaUser;
    this.userIp = userIp;
  }

  @Override
  public Object getFieldValue(String fieldName) {
    if ("access_token".equals(fieldName)) {
      return access_token;
    }
    if ("address".equals(fieldName)) {
      return address;
    }
    if ("callback".equals(fieldName)) {
      return callback;
    }
    if ("fields".equals(fieldName)) {
      return fields;
    }
    if ("key".equals(fieldName)) {
      return key;
    }
    if ("prettyPrint".equals(fieldName)) {
      return prettyPrint;
    }
    if ("quotaUser".equals(fieldName)) {
      return quotaUser;
    }
    if ("userIp".equals(fieldName)) {
      return userIp;
    }
    return null;
  }

  @Nullable
  @Override
  public ApiMessage getApiMessageRequestBody() {
    return null;
  }

  @Nullable
  @Override
  /**
   * The fields that should be serialized (even if they have empty values).
   * If the containing message object has a non-null fieldmask,
   * then all the fields in the field mask (and only those fields in the field mask)
   * will be serialized. If the containing object does not have a fieldmask, then
   * only non-empty fields will be serialized.
  */
  public List<String> getFieldMask() {
    return null;
  }

  /**
   * OAuth 2.0 token for the current user.
  */
  public String getAccessToken() {
    return access_token;
  }

  /**
   * Name of the address resource to return.
   * It must have the format `{project}/regions/{region}/addresses/{address}`. \`{address}\` must start with a letter,
   * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
   *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
   *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
   *      &#42; must not start with \`"goog"\`.
  */
  public String getAddress() {
    return address;
  }

  /**
   * Name of the JavaScript callback function that handles the response.
  */
  public String getCallback() {
    return callback;
  }

  /**
   * Selector specifying a subset of fields to include in the response.
  */
  public String getFields() {
    return fields;
  }

  /**
   * API key. Required unless you provide an OAuth 2.0 token.
  */
  public String getKey() {
    return key;
  }

  /**
   * Returns response with indentations and line breaks.
  */
  public String getPrettyPrint() {
    return prettyPrint;
  }

  /**
   * Alternative to userIp.
  */
  public String getQuotaUser() {
    return quotaUser;
  }

  /**
   * IP address of the end user for whom the API call is being made.
  */
  public String getUserIp() {
    return userIp;
  }


  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(GetAddressHttpRequest prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  public static GetAddressHttpRequest getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }
  private static final GetAddressHttpRequest DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new GetAddressHttpRequest();
  }

  public static class Builder {
    private String access_token;
    private String address;
    private String callback;
    private String fields;
    private String key;
    private String prettyPrint;
    private String quotaUser;
    private String userIp;

    Builder() {}

    public Builder mergeFrom(GetAddressHttpRequest other) {
      if (other == GetAddressHttpRequest.getDefaultInstance()) return this;
      if (other.getAccessToken() != null) {
        this.access_token = other.access_token;
      }
      if (other.getAddress() != null) {
        this.address = other.address;
      }
      if (other.getCallback() != null) {
        this.callback = other.callback;
      }
      if (other.getFields() != null) {
        this.fields = other.fields;
      }
      if (other.getKey() != null) {
        this.key = other.key;
      }
      if (other.getPrettyPrint() != null) {
        this.prettyPrint = other.prettyPrint;
      }
      if (other.getQuotaUser() != null) {
        this.quotaUser = other.quotaUser;
      }
      if (other.getUserIp() != null) {
        this.userIp = other.userIp;
      }
      return this;
    }

    Builder(GetAddressHttpRequest source) {
      this.access_token = source.access_token;
      this.address = source.address;
      this.callback = source.callback;
      this.fields = source.fields;
      this.key = source.key;
      this.prettyPrint = source.prettyPrint;
      this.quotaUser = source.quotaUser;
      this.userIp = source.userIp;
    }

    /**
     * OAuth 2.0 token for the current user.
    */
    public String getAccessToken() {
      return access_token;
    }

    /**
     * OAuth 2.0 token for the current user.
    */
    public Builder setAccessToken(String access_token) {
      this.access_token = access_token;
      return this;
    }

    /**
     * Name of the address resource to return.
     * It must have the format `{project}/regions/{region}/addresses/{address}`. \`{address}\` must start with a letter,
     * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
     *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
     *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
     *      &#42; must not start with \`"goog"\`.
    */
    public String getAddress() {
      return address;
    }

    /**
     * Name of the address resource to return.
     * It must have the format `{project}/regions/{region}/addresses/{address}`. \`{address}\` must start with a letter,
     * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
     *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
     *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
     *      &#42; must not start with \`"goog"\`.
    */
    public Builder setAddress(String address) {
      this.address = address;
      return this;
    }

    /**
     * Name of the JavaScript callback function that handles the response.
    */
    public String getCallback() {
      return callback;
    }

    /**
     * Name of the JavaScript callback function that handles the response.
    */
    public Builder setCallback(String callback) {
      this.callback = callback;
      return this;
    }

    /**
     * Selector specifying a subset of fields to include in the response.
    */
    public String getFields() {
      return fields;
    }

    /**
     * Selector specifying a subset of fields to include in the response.
    */
    public Builder setFields(String fields) {
      this.fields = fields;
      return this;
    }

    /**
     * API key. Required unless you provide an OAuth 2.0 token.
    */
    public String getKey() {
      return key;
    }

    /**
     * API key. Required unless you provide an OAuth 2.0 token.
    */
    public Builder setKey(String key) {
      this.key = key;
      return this;
    }

    /**
     * Returns response with indentations and line breaks.
    */
    public String getPrettyPrint() {
      return prettyPrint;
    }

    /**
     * Returns response with indentations and line breaks.
    */
    public Builder setPrettyPrint(String prettyPrint) {
      this.prettyPrint = prettyPrint;
      return this;
    }

    /**
     * Alternative to userIp.
    */
    public String getQuotaUser() {
      return quotaUser;
    }

    /**
     * Alternative to userIp.
    */
    public Builder setQuotaUser(String quotaUser) {
      this.quotaUser = quotaUser;
      return this;
    }

    /**
     * IP address of the end user for whom the API call is being made.
    */
    public String getUserIp() {
      return userIp;
    }

    /**
     * IP address of the end user for whom the API call is being made.
    */
    public Builder setUserIp(String userIp) {
      this.userIp = userIp;
      return this;
    }


    public GetAddressHttpRequest build() {
      String missing = "";

      if (address == null) {
        missing += " address";
      }






      if (!missing.isEmpty()) {
        throw new IllegalStateException("Missing required properties:" + missing);
      }
      return new GetAddressHttpRequest(
        access_token,
        address,
        callback,
        fields,
        key,
        prettyPrint,
        quotaUser,
        userIp
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setAccessToken(this.access_token);
      newBuilder.setAddress(this.address);
      newBuilder.setCallback(this.callback);
      newBuilder.setFields(this.fields);
      newBuilder.setKey(this.key);
      newBuilder.setPrettyPrint(this.prettyPrint);
      newBuilder.setQuotaUser(this.quotaUser);
      newBuilder.setUserIp(this.userIp);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "GetAddressHttpRequest{"
        + "access_token=" + access_token + ", "
        + "address=" + address + ", "
        + "callback=" + callback + ", "
        + "fields=" + fields + ", "
        + "key=" + key + ", "
        + "prettyPrint=" + prettyPrint + ", "
        + "quotaUser=" + quotaUser + ", "
        + "userIp=" + userIp
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof GetAddressHttpRequest) {
      GetAddressHttpRequest that = (GetAddressHttpRequest) o;
      return
          Objects.equals(this.access_token, that.getAccessToken()) &&
          Objects.equals(this.address, that.getAddress()) &&
          Objects.equals(this.callback, that.getCallback()) &&
          Objects.equals(this.fields, that.getFields()) &&
          Objects.equals(this.key, that.getKey()) &&
          Objects.equals(this.prettyPrint, that.getPrettyPrint()) &&
          Objects.equals(this.quotaUser, that.getQuotaUser()) &&
          Objects.equals(this.userIp, that.getUserIp())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      access_token,
      address,
      callback,
      fields,
      key,
      prettyPrint,
      quotaUser,
      userIp
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/InsertAddressHttpRequest.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.httpjson.ApiMessage;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.annotations.SerializedName;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;
import javax.annotation.Nullable;

@Generated("by GAPIC")
@BetaApi
/**
 * Request object for method compute.addresses.insert. Creates an address resource in the specified project using the data included in the request.
*/
public final class InsertAddressHttpRequest implements ApiMessage {
  private final String access_token;
  private final Address addressResource;
  private final String callback;
  private final String fields;
  private final String key;
  private final String prettyPrint;
  private final String quotaUser;
  private final String region;
  private final String userIp;

  private InsertAddressHttpRequest() {
    this.access_token = null;
    this.addressResource = null;
    this.callback = null;
    this.fields = null;
    this.key = null;
    this.prettyPrint = null;
    this.quotaUser = null;
    this.region = null;
    this.userIp = null;
  }


  private InsertAddressHttpRequest(
      String access_token,
      Address addressResource,
      String callback,
      String fields,
      String key,
      String prettyPrint,
      String quotaUser,
      String region,
      String userIp
      ) {
    this.access_token = access_token;
    this.addressResource = addressResource;
    this.callback = callback;
    this.fields = fields;
    this.key = key;
    this.prettyPrint = prettyPrint;
    this.quotaUser = quotaUser;
    this.region = region;
    this.userIp = userIp;
  }

  @Override
  public Object getFieldValue(String fieldName) {
    if ("access_token".equals(fieldName)) {
      return access_token;
    }
    if ("addressResource".equals(fieldName)) {
      return addressResource;
    }
    if ("callback".equals(fieldName)) {
      return callback;
    }
    if ("fields".equals(fieldName)) {
      return fields;
    }
    if ("key".equals(fieldName)) {
      return key;
    }
    if ("prettyPrint".equals(fieldName)) {
      return prettyPrint;
    }
    if ("quotaUser".equals(fieldName)) {
      return quotaUser;
    }
    if ("region".equals(fieldName)) {
      return region;
    }
    if ("userIp".equals(fieldName)) {
      return userIp;
    }
    return null;
  }

  @Nullable
  @Override
  public Address getApiMessageRequestBody() {
    return addressResource;
  }

  @Nullable
  @Override
  /**
   * The fields that should be serialized (even if they have empty values).
   * If the containing message object has a non-null fieldmask,
   * then all the fields in the field mask (and only those fields in the field mask)
   * will be serialized. If the containing object does not have a fieldmask, then
   * only non-empty fields will be serialized.
  */
  public List<String> getFieldMask() {
    return null;
  }

  /**
   * OAuth 2.0 token for the current user.
  */
  public String getAccessToken() {
    return access_token;
  }

  /**
   * A reserved address resource.
  */
  public Address getAddressResource() {
    return addressResource;
  }

  /**
   * Name of the JavaScript callback function that handles the response.
  */
  public String getCallback() {
    return callback;
  }

  /**
   * Selector specifying a subset of fields to include in the response.
  */
  public String getFields() {
    return fields;
  }

  /**
   * API key. Required unless you provide an OAuth 2.0 token.
  */
  public String getKey() {
    return key;
  }

  /**
   * Returns response with indentations and line breaks.
  */
  public String getPrettyPrint() {
    return prettyPrint;
  }

  /**
   * Alternative to userIp.
  */
  public String getQuotaUser() {
    return quotaUser;
  }

  /**
   * Name of the region for this request.
   * It must have the format `{project}/regions/{region}/addresses`. \`{region}\` must start with a letter,
   * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
   *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
   *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
   *      &#42; must not start with \`"goog"\`.
  */
  public String getRegion() {
    return region;
  }

  /**
   * IP address of the end user for whom the API call is being made.
  */
  public String getUserIp() {
    return userIp;
  }


  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(InsertAddressHttpRequest prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  public static InsertAddressHttpRequest getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }
  private static final InsertAddressHttpRequest DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new InsertAddressHttpRequest();
  }

  public static class Builder {
    private String access_token;
    private Address addressResource;
    private String callback;
    private String fields;
    private String key;
    private String prettyPrint;
    private String quotaUser;
    private String region;
    private String userIp;

    Builder() {}

    public Builder mergeFrom(InsertAddressHttpRequest other) {
      if (other == InsertAddressHttpRequest.getDefaultInstance()) return this;
      if (other.getAccessToken() != null) {
        this.access_token = other.access_token;
      }
      if (other.getAddressResource() != null) {
        this.addressResource = other.addressResource;
      }
      if (other.getCallback() != null) {
        this.callback = other.callback;
      }
      if (other.getFields() != null) {
        this.fields = other.fields;
      }
      if (other.getKey() != null) {
        this.key = other.key;
      }
      if (other.getPrettyPrint() != null) {
        this.prettyPrint = other.prettyPrint;
      }
      if (other.getQuotaUser() != null) {
        this.quotaUser = other.quotaUser;
      }
      if (other.getRegion() != null) {
        this.region = other.region;
      }
      if (other.getUserIp() != null) {
        this.userIp = other.userIp;
      }
      return this;
    }

    Builder(InsertAddressHttpRequest source) {
      this.access_token = source.access_token;
      this.addressResource = source.addressResource;
      this.callback = source.callback;
      this.fields = source.fields;
      this.key = source.key;
      this.prettyPrint = source.prettyPrint;
      this.quotaUser = source.quotaUser;
      this.region = source.region;
      this.userIp = source.userIp;
    }

    /**
     * OAuth 2.0 token for the current user.
    */
    public String getAccessToken() {
      return access_token;
    }

    /**
     * OAuth 2.0 token for the current user.
    */
    public Builder setAccessToken(String access_token) {
      this.access_token = access_token;
      return this;
    }

    /**
     * A reserved address resource.
    */
    public Address getAddressResource() {
      return addressResource;
    }

    /**
     * A reserved address resource.
    */
    public Builder setAddressResource(Address addressResource) {
      this.addressResource = addressResource;
      return this;
    }

    /**
     * Name of the JavaScript callback function that handles the response.
    */
    public String getCallback() {
      return callback;
    }

    /**
     * Name of the JavaScript callback function that handles the response.
    */
    public Builder setCallback(String callback) {
      this.callback = callback;
      return this;
    }

    /**
     * Selector specifying a subset of fields to include in the response.
    */
    public String getFields() {
      return fields;
    }

    /**
     * Selector specifying a subset of fields to include in the response.
    */
    public Builder setFields(String fields) {
      this.fields = fields;
      return this;
    }

    /**
     * API key. Required unless you provide an OAuth 2.0 token.
    */
    public String getKey() {
      return key;
    }

    /**
     * API key. Required unless you provide an OAuth 2.0 token.
    */
    public Builder setKey(String key) {
      this.key = key;
      return this;
    }

    /**
     * Returns response with indentations and line breaks.
    */
    public String getPrettyPrint() {
      return prettyPrint;
    }

    /**
     * Returns response with indentations and line breaks.
    */
    public Builder setPrettyPrint(String prettyPrint) {
      this.prettyPrint = prettyPrint;
      return this;
    }

    /**
     * Alternative to userIp.
    */
    public String getQuotaUser() {
      return quotaUser;
    }

    /**
     * Alternative to userIp.
    */
    public Builder setQuotaUser(String quotaUser) {
      this.quotaUser = quotaUser;
      return this;
    }

    /**
     * Name of the region for this request.
     * It must have the format `{project}/regions/{region}/addresses`. \`{region}\` must start with a letter,
     * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
     *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
     *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
     *      &#42; must not start with \`"goog"\`.
    */
    public String getRegion() {
      return region;
    }

    /**
     * Name of the region for this request.
     * It must have the format `{project}/regions/{region}/addresses`. \`{region}\` must start with a letter,
     * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
     *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
     *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
     *      &#42; must not start with \`"goog"\`.
    */
    public Builder setRegion(String region) {
      this.region = region;
      return this;
    }

    /**
     * IP address of the end user for whom the API call is being made.
    */
    public String getUserIp() {
      return userIp;
    }

    /**
     * IP address of the end user for whom the API call is being made.
    */
    public Builder setUserIp(String userIp) {
      this.userIp = userIp;
      return this;
    }


    public InsertAddressHttpRequest build() {
      String missing = "";







      if (region == null) {
        missing += " region";
      }

      if (!missing.isEmpty()) {
        throw new IllegalStateException("Missing required properties:" + missing);
      }
      return new InsertAddressHttpRequest(
        access_token,
        addressResource,
        callback,
        fields,
        key,
        prettyPrint,
        quotaUser,
        region,
        userIp
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setAccessToken(this.access_token);
      newBuilder.setAddressResource(this.addressResource);
      newBuilder.setCallback(this.callback);
      newBuilder.setFields(this.fields);
      newBuilder.setKey(this.key);
      newBuilder.setPrettyPrint(this.prettyPrint);
      newBuilder.setQuotaUser(this.quotaUser);
      newBuilder.setRegion(this.region);
      newBuilder.setUserIp(this.userIp);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "InsertAddressHttpRequest{"
        + "access_token=" + access_token + ", "
        + "addressResource=" + addressResource + ", "
        + "callback=" + callback + ", "
        + "fields=" + fields + ", "
        + "key=" + key + ", "
        + "prettyPrint=" + prettyPrint + ", "
        + "quotaUser=" + quotaUser + ", "
        + "region=" + region + ", "
        + "userIp=" + userIp
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof InsertAddressHttpRequest) {
      InsertAddressHttpRequest that = (InsertAddressHttpRequest) o;
      return
          Objects.equals(this.access_token, that.getAccessToken()) &&
          Objects.equals(this.addressResource, that.getAddressResource()) &&
          Objects.equals(this.callback, that.getCallback()) &&
          Objects.equals(this.fields, that.getFields()) &&
          Objects.equals(this.key, that.getKey()) &&
          Objects.equals(this.prettyPrint, that.getPrettyPrint()) &&
          Objects.equals(this.quotaUser, that.getQuotaUser()) &&
          Objects.equals(this.region, that.getRegion()) &&
          Objects.equals(this.userIp, that.getUserIp())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      access_token,
      addressResource,
      callback,
      fields,
      key,
      prettyPrint,
      quotaUser,
      region,
      userIp
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/ListAddressesHttpRequest.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.httpjson.ApiMessage;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.annotations.SerializedName;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;
import javax.annotation.Nullable;

@Generated("by GAPIC")
@BetaApi
/**
 * Request object for method compute.addresses.list. Retrieves a list of addresses contained within the specified region.
*/
public final class ListAddressesHttpRequest implements ApiMessage {
  private final String access_token;
  private final String callback;
  private final String fields;
  private final String filter;
  private final String key;
  private final Integer maxResults;
  private final String orderBy;
  private final String pageToken;
  private final String prettyPrint;
  private final String quotaUser;
  private final String region;
  private final String userIp;

  private ListAddressesHttpRequest() {
    this.access_token = null;
    this.callback = null;
    this.fields = null;
    this.filter = null;
    this.key = null;
    this.maxResults = null;
    this.orderBy = null;
    this.pageToken = null;
    this.prettyPrint = null;
    this.quotaUser = null;
    this.region = null;
    this.userIp = null;
  }


  private ListAddressesHttpRequest(
      String access_token,
      String callback,
      String fields,
      String filter,
      String key,
      Integer maxResults,
      String orderBy,
      String pageToken,
      String prettyPrint,
      String quotaUser,
      String region,
      String userIp
      ) {
    this.access_token = access_token;
    this.callback = callback;
    this.fields = fields;
    this.filter = filter;
    this.key = key;
    this.maxResults = maxResults;
    this.orderBy = orderBy;
    this.pageToken = pageToken;
    this.prettyPrint = prettyPrint;
    this.quotaUser = quotaUser;
    this.region = region;
    this.userIp = userIp;
  }

  @Override
  public Object getFieldValue(String fieldName) {
    if ("access_token".equals(fieldName)) {
      return access_token;
    }
    if ("callback".equals(fieldName)) {
      return callback;
    }
    if ("fields".equals(fieldName)) {
      return fields;
    }
    if ("filter".equals(fieldName)) {
      return filter;
    }
    if ("key".equals(fieldName)) {
      return key;
    }
    if ("maxResults".equals(fieldName)) {
      return maxResults;
    }
    if ("orderBy".equals(fieldName)) {
      return orderBy;
    }
    if ("pageToken".equals(fieldName)) {
      return pageToken;
    }
    if ("prettyPrint".equals(fieldName)) {
      return prettyPrint;
    }
    if ("quotaUser".equals(fieldName)) {
      return quotaUser;
    }
    if ("region".equals(fieldName)) {
      return region;
    }
    if ("userIp".equals(fieldName)) {
      return userIp;
    }
    return null;
  }

  @Nullable
  @Override
  public ApiMessage getApiMessageRequestBody() {
    return null;
  }

  @Nullable
  @Override
  /**
   * The fields that should be serialized (even if they have empty values).
   * If the containing message object has a non-null fieldmask,
   * then all the fields in the field mask (and only those fields in the field mask)
   * will be serialized. If the containing object does not have a fieldmask, then
   * only non-empty fields will be serialized.
  */
  public List<String> getFieldMask() {
    return null;
  }

  /**
   * OAuth 2.0 token for the current user.
  */
  public String getAccessToken() {
    return access_token;
  }

  /**
   * Name of the JavaScript callback function that handles the response.
  */
  public String getCallback() {
    return callback;
  }

  /**
   * Selector specifying a subset of fields to include in the response.
  */
  public String getFields() {
    return fields;
  }

  /**
   * Sets a filter expression for filtering listed resources, in the form filter={expression}. Your {expression} must be in the format: field_name comparison_string literal_string.
   *
   * The field_name is the name of the field you want to compare. Only atomic field types are supported (string, number, boolean). The comparison_string must be either eq (equals) or ne (not equals). The literal_string is the string value to filter to. The literal value must be valid for the type of field you are filtering by (string, number, boolean). For string fields, the literal value is interpreted as a regular expression using RE2 syntax. The literal value must match the entire field.
   *
   * For example, to filter for instances that do not have a name of example-instance, you would use filter=name ne example-instance.
   *
   * You can filter on nested fields. For example, you could filter on instances that have set the scheduling.automaticRestart field to true. Use filtering on nested fields to take advantage of labels to organize and search for results based on label values.
   *
   * To filter on multiple expressions, provide each separate expression within parentheses. For example, (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple expressions are treated as AND expressions, meaning that resources must match all expressions to pass the filters.
  */
  public String getFilter() {
    return filter;
  }

  /**
   * API key. Required unless you provide an OAuth 2.0 token.
  */
  public String getKey() {
    return key;
  }

  /**
   * The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, Compute Engine returns a nextPageToken that can be used to get the next page of results in subsequent list requests.
  */
  public Integer getMaxResults() {
    return maxResults;
  }

  /**
   * Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name.
   *
   * You can also sort results in descending order based on the creation timestamp using orderBy="creationTimestamp desc". This sorts results based on the creationTimestamp field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first.
   *
   * Currently, only sorting by name or creationTimestamp desc is supported.
  */
  public String getOrderBy() {
    return orderBy;
  }

  /**
   * Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results.
  */
  public String getPageToken() {
    return pageToken;
  }

  /**
   * Returns response with indentations and line breaks.
  */
  public String getPrettyPrint() {
    return prettyPrint;
  }

  /**
   * Alternative to userIp.
  */
  public String getQuotaUser() {
    return quotaUser;
  }

  /**
   * Name of the region for this request.
   * It must have the format `{project}/regions/{region}/addresses`. \`{region}\` must start with a letter,
   * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
   *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
   *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
   *      &#42; must not start with \`"goog"\`.
  */
  public String getRegion() {
    return region;
  }

  /**
   * IP address of the end user for whom the API call is being made.
  */
  public String getUserIp() {
    return userIp;
  }


  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(ListAddressesHttpRequest prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  public static ListAddressesHttpRequest getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }
  private static final ListAddressesHttpRequest DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new ListAddressesHttpRequest();
  }

  public static class Builder {
    private String access_token;
    private String callback;
    private String fields;
    private String filter;
    private String key;
    private Integer maxResults;
    private String orderBy;
    private String pageToken;
    private String prettyPrint;
    private String quotaUser;
    private String region;
    private String userIp;

    Builder() {}

    public Builder mergeFrom(ListAddressesHttpRequest other) {
      if (other == ListAddressesHttpRequest.getDefaultInstance()) return this;
      if (other.getAccessToken() != null) {
        this.access_token = other.access_token;
      }
      if (other.getCallback() != null) {
        this.callback = other.callback;
      }
      if (other.getFields() != null) {
        this.fields = other.fields;
      }
      if (other.getFilter() != null) {
        this.filter = other.filter;
      }
      if (other.getKey() != null) {
        this.key = other.key;
      }
      if (other.getMaxResults() != null) {
        this.maxResults = other.maxResults;
      }
      if (other.getOrderBy() != null) {
        this.orderBy = other.orderBy;
      }
      if (other.getPageToken() != null) {
        this.pageToken = other.pageToken;
      }
      if (other.getPrettyPrint() != null) {
        this.prettyPrint = other.prettyPrint;
      }
      if (other.getQuotaUser() != null) {
        this.quotaUser = other.quotaUser;
      }
      if (other.getRegion() != null) {
        this.region = other.region;
      }
      if (other.getUserIp() != null) {
        this.userIp = other.userIp;
      }
      return this;
    }

    Builder(ListAddressesHttpRequest source) {
      this.access_token = source.access_token;
      this.callback = source.callback;
      this.fields = source.fields;
      this.filter = source.filter;
      this.key = source.key;
      this.maxResults = source.maxResults;
      this.orderBy = source.orderBy;
      this.pageToken = source.pageToken;
      this.prettyPrint = source.prettyPrint;
      this.quotaUser = source.quotaUser;
      this.region = source.region;
      this.userIp = source.userIp;
    }

    /**
     * OAuth 2.0 token for the current user.
    */
    public String getAccessToken() {
      return access_token;
    }

    /**
     * OAuth 2.0 token for the current user.
    */
    public Builder setAccessToken(String access_token) {
      this.access_token = access_token;
      return this;
    }

    /**
     * Name of the JavaScript callback function that handles the response.
    */
    public String getCallback() {
      return callback;
    }

    /**
     * Name of the JavaScript callback function that handles the response.
    */
    public Builder setCallback(String callback) {
      this.callback = callback;
      return this;
    }

    /**
     * Selector specifying a subset of fields to include in the response.
    */
    public String getFields() {
      return fields;
    }

    /**
     * Selector specifying a subset of fields to include in the response.
    */
    public Builder setFields(String fields) {
      this.fields = fields;
      return this;
    }

    /**
     * Sets a filter expression for filtering listed resources, in the form filter={expression}. Your {expression} must be in the format: field_name comparison_string literal_string.
     *
     * The field_name is the name of the field you want to compare. Only atomic field types are supported (string, number, boolean). The comparison_string must be either eq (equals) or ne (not equals). The literal_string is the string value to filter to. The literal value must be valid for the type of field you are filtering by (string, number, boolean). For string fields, the literal value is interpreted as a regular expression using RE2 syntax. The literal value must match the entire field.
     *
     * For example, to filter for instances that do not have a name of example-instance, you would use filter=name ne example-instance.
     *
     * You can filter on nested fields. For example, you could filter on instances that have set the scheduling.automaticRestart field to true. Use filtering on nested fields to take advantage of labels to organize and search for results based on label values.
     *
     * To filter on multiple expressions, provide each separate expression within parentheses. For example, (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple expressions are treated as AND expressions, meaning that resources must match all expressions to pass the filters.
    */
    public String getFilter() {
      return filter;
    }

    /**
     * Sets a filter expression for filtering listed resources, in the form filter={expression}. Your {expression} must be in the format: field_name comparison_string literal_string.
     *
     * The field_name is the name of the field you want to compare. Only atomic field types are supported (string, number, boolean). The comparison_string must be either eq (equals) or ne (not equals). The literal_string is the string value to filter to. The literal value must be valid for the type of field you are filtering by (string, number, boolean). For string fields, the literal value is interpreted as a regular expression using RE2 syntax. The literal value must match the entire field.
     *
     * For example, to filter for instances that do not have a name of example-instance, you would use filter=name ne example-instance.
     *
     * You can filter on nested fields. For example, you could filter on instances that have set the scheduling.automaticRestart field to true. Use filtering on nested fields to take advantage of labels to organize and search for results based on label values.
     *
     * To filter on multiple expressions, provide each separate expression within parentheses. For example, (scheduling.automaticRestart eq true) (zone eq us-central1-f). Multiple expressions are treated as AND expressions, meaning that resources must match all expressions to pass the filters.
    */
    public Builder setFilter(String filter) {
      this.filter = filter;
      return this;
    }

    /**
     * API key. Required unless you provide an OAuth 2.0 token.
    */
    public String getKey() {
      return key;
    }

    /**
     * API key. Required unless you provide an OAuth 2.0 token.
    */
    public Builder setKey(String key) {
      this.key = key;
      return this;
    }

    /**
     * The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, Compute Engine returns a nextPageToken that can be used to get the next page of results in subsequent list requests.
    */
    public Integer getMaxResults() {
      return maxResults;
    }

    /**
     * The maximum number of results per page that should be returned. If the number of available results is larger than maxResults, Compute Engine returns a nextPageToken that can be used to get the next page of results in subsequent list requests.
    */
    public Builder setMaxResults(Integer maxResults) {
      this.maxResults = maxResults;
      return this;
    }

    /**
     * Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name.
     *
     * You can also sort results in descending order based on the creation timestamp using orderBy="creationTimestamp desc". This sorts results based on the creationTimestamp field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first.
     *
     * Currently, only sorting by name or creationTimestamp desc is supported.
    */
    public String getOrderBy() {
      return orderBy;
    }

    /**
     * Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name.
     *
     * You can also sort results in descending order based on the creation timestamp using orderBy="creationTimestamp desc". This sorts results based on the creationTimestamp field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first.
     *
     * Currently, only sorting by name or creationTimestamp desc is supported.
    */
    public Builder setOrderBy(String orderBy) {
      this.orderBy = orderBy;
      return this;
    }

    /**
     * Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results.
    */
    public String getPageToken() {
      return pageToken;
    }

    /**
     * Specifies a page token to use. Set pageToken to the nextPageToken returned by a previous list request to get the next page of results.
    */
    public Builder setPageToken(String pageToken) {
      this.pageToken = pageToken;
      return this;
    }

    /**
     * Returns response with indentations and line breaks.
    */
    public String getPrettyPrint() {
      return prettyPrint;
    }

    /**
     * Returns response with indentations and line breaks.
    */
    public Builder setPrettyPrint(String prettyPrint) {
      this.prettyPrint = prettyPrint;
      return this;
    }

    /**
     * Alternative to userIp.
    */
    public String getQuotaUser() {
      return quotaUser;
    }

    /**
     * Alternative to userIp.
    */
    public Builder setQuotaUser(String quotaUser) {
      this.quotaUser = quotaUser;
      return this;
    }

    /**
     * Name of the region for this request.
     * It must have the format `{project}/regions/{region}/addresses`. \`{region}\` must start with a letter,
     * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
     *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
     *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
     *      &#42; must not start with \`"goog"\`.
    */
    public String getRegion() {
      return region;
    }

    /**
     * Name of the region for this request.
     * It must have the format `{project}/regions/{region}/addresses`. \`{region}\` must start with a letter,
     * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
     *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
     *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
     *      &#42; must not start with \`"goog"\`.
    */
    public Builder setRegion(String region) {
      this.region = region;
      return this;
    }

    /**
     * IP address of the end user for whom the API call is being made.
    */
    public String getUserIp() {
      return userIp;
    }

    /**
     * IP address of the end user for whom the API call is being made.
    */
    public Builder setUserIp(String userIp) {
      this.userIp = userIp;
      return this;
    }


    public ListAddressesHttpRequest build() {
      String missing = "";










      if (region == null) {
        missing += " region";
      }

      if (!missing.isEmpty()) {
        throw new IllegalStateException("Missing required properties:" + missing);
      }
      return new ListAddressesHttpRequest(
        access_token,
        callback,
        fields,
        filter,
        key,
        maxResults,
        orderBy,
        pageToken,
        prettyPrint,
        quotaUser,
        region,
        userIp
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setAccessToken(this.access_token);
      newBuilder.setCallback(this.callback);
      newBuilder.setFields(this.fields);
      newBuilder.setFilter(this.filter);
      newBuilder.setKey(this.key);
      newBuilder.setMaxResults(this.maxResults);
      newBuilder.setOrderBy(this.orderBy);
      newBuilder.setPageToken(this.pageToken);
      newBuilder.setPrettyPrint(this.prettyPrint);
      newBuilder.setQuotaUser(this.quotaUser);
      newBuilder.setRegion(this.region);
      newBuilder.setUserIp(this.userIp);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "ListAddressesHttpRequest{"
        + "access_token=" + access_token + ", "
        + "callback=" + callback + ", "
        + "fields=" + fields + ", "
        + "filter=" + filter + ", "
        + "key=" + key + ", "
        + "maxResults=" + maxResults + ", "
        + "orderBy=" + orderBy + ", "
        + "pageToken=" + pageToken + ", "
        + "prettyPrint=" + prettyPrint + ", "
        + "quotaUser=" + quotaUser + ", "
        + "region=" + region + ", "
        + "userIp=" + userIp
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof ListAddressesHttpRequest) {
      ListAddressesHttpRequest that = (ListAddressesHttpRequest) o;
      return
          Objects.equals(this.access_token, that.getAccessToken()) &&
          Objects.equals(this.callback, that.getCallback()) &&
          Objects.equals(this.fields, that.getFields()) &&
          Objects.equals(this.filter, that.getFilter()) &&
          Objects.equals(this.key, that.getKey()) &&
          Objects.equals(this.maxResults, that.getMaxResults()) &&
          Objects.equals(this.orderBy, that.getOrderBy()) &&
          Objects.equals(this.pageToken, that.getPageToken()) &&
          Objects.equals(this.prettyPrint, that.getPrettyPrint()) &&
          Objects.equals(this.quotaUser, that.getQuotaUser()) &&
          Objects.equals(this.region, that.getRegion()) &&
          Objects.equals(this.userIp, that.getUserIp())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      access_token,
      callback,
      fields,
      filter,
      key,
      maxResults,
      orderBy,
      pageToken,
      prettyPrint,
      quotaUser,
      region,
      userIp
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/PatchAddressHttpRequest.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.httpjson.ApiMessage;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.annotations.SerializedName;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;
import javax.annotation.Nullable;

@Generated("by GAPIC")
@BetaApi
/**
 * Request object for method compute.addresses.patch. Updates an address in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
*/
public final class PatchAddressHttpRequest implements ApiMessage {
  private final String access_token;
  private final String address;
  private final Address addressResource;
  private final String callback;
  private final List<String> fieldMask;
  private final String fields;
  private final String key;
  private final String prettyPrint;
  private final String quotaUser;
  private final String region;
  private final String requestId;
  private final String userIp;

  private PatchAddressHttpRequest() {
    this.access_token = null;
    this.address = null;
    this.addressResource = null;
    this.callback = null;
    this.fieldMask = null;
    this.fields = null;
    this.key = null;
    this.prettyPrint = null;
    this.quotaUser = null;
    this.region = null;
    this.requestId = null;
    this.userIp = null;
  }


  private PatchAddressHttpRequest(
      String access_token,
      String address,
      Address addressResource,
      String callback,
      List<String> fieldMask,
      String fields,
      String key,
      String prettyPrint,
      String quotaUser,
      String region,
      String requestId,
      String userIp
      ) {
    this.access_token = access_token;
    this.address = address;
    this.addressResource = addressResource;
    this.callback = callback;
    this.fieldMask = fieldMask;
    this.fields = fields;
    this.key = key;
    this.prettyPrint = prettyPrint;
    this.quotaUser = quotaUser;
    this.region = region;
    this.requestId = requestId;
    this.userIp = userIp;
  }

  @Override
  public Object getFieldValue(String fieldName) {
    if ("access_token".equals(fieldName)) {
      return access_token;
    }
    if ("address".equals(fieldName)) {
      return address;
    }
    if ("addressResource".equals(fieldName)) {
      return addressResource;
    }
    if ("callback".equals(fieldName)) {
      return callback;
    }
    if ("fieldMask".equals(fieldName)) {
      return fieldMask;
    }
    if ("fields".equals(fieldName)) {
      return fields;
    }
    if ("key".equals(fieldName)) {
      return key;
    }
    if ("prettyPrint".equals(fieldName)) {
      return prettyPrint;
    }
    if ("quotaUser".equals(fieldName)) {
      return quotaUser;
    }
    if ("region".equals(fieldName)) {
      return region;
    }
    if ("requestId".equals(fieldName)) {
      return requestId;
    }
    if ("userIp".equals(fieldName)) {
      return userIp;
    }
    return null;
  }

  @Nullable
  @Override
  public Address getApiMessageRequestBody() {
    return addressResource;
  }


  /**
   * OAuth 2.0 token for the current user.
  */
  public String getAccessToken() {
    return access_token;
  }

  /**
   * Name of the address to patch.
  */
  public String getAddress() {
    return address;
  }

  /**
   * A reserved address resource.
  */
  public Address getAddressResource() {
    return addressResource;
  }

  /**
   * Name of the JavaScript callback function that handles the response.
  */
  public String getCallback() {
    return callback;
  }

  /**
   * The fields that should be serialized (even if they have empty values). If the containing message object has a non-null fieldmask, then all the fields in the field mask (and only those fields in the field mask) will be serialized. If the containing object does not have a fieldmask, then only non-empty fields will be serialized.
  */
  public List<String> getFieldMask() {
    return fieldMask;
  }

  /**
   * Selector specifying a subset of fields to include in the response.
  */
  public String getFields() {
    return fields;
  }

  /**
   * API key. Required unless you provide an OAuth 2.0 token.
  */
  public String getKey() {
    return key;
  }

  /**
   * Returns response with indentations and line breaks.
  */
  public String getPrettyPrint() {
    return prettyPrint;
  }

  /**
   * Alternative to userIp.
  */
  public String getQuotaUser() {
    return quotaUser;
  }

  /**
   * Name of the region for this request.
   * It must have the format `{project}/regions/{region}/addresses`. \`{region}\` must start with a letter,
   * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
   *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
   *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
   *      &#42; must not start with \`"goog"\`.
  */
  public String getRegion() {
    return region;
  }

  /**
   * An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.
   *
   * For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
  */
  public String getRequestId() {
    return requestId;
  }

  /**
   * IP address of the end user for whom the API call is being made.
  */
  public String getUserIp() {
    return userIp;
  }


  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(PatchAddressHttpRequest prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  public static PatchAddressHttpRequest getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }
  private static final PatchAddressHttpRequest DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new PatchAddressHttpRequest();
  }

  public static class Builder {
    private String access_token;
    private String address;
    private Address addressResource;
    private String callback;
    private List<String> fieldMask;
    private String fields;
    private String key;
    private String prettyPrint;
    private String quotaUser;
    private String region;
    private String requestId;
    private String userIp;

    Builder() {}

    public Builder mergeFrom(PatchAddressHttpRequest other) {
      if (other == PatchAddressHttpRequest.getDefaultInstance()) return this;
      if (other.getAccessToken() != null) {
        this.access_token = other.access_token;
      }
      if (other.getAddress() != null) {
        this.address = other.address;
      }
      if (other.getAddressResource() != null) {
        this.addressResource = other.addressResource;
      }
      if (other.getCallback() != null) {
        this.callback = other.callback;
      }
      if (other.getFieldMask() != null) {
        this.fieldMask = other.fieldMask;
      }
      if (other.getFields() != null) {
        this.fields = other.fields;
      }
      if (other.getKey() != null) {
        this.key = other.key;
      }
      if (other.getPrettyPrint() != null) {
        this.prettyPrint = other.prettyPrint;
      }
      if (other.getQuotaUser() != null) {
        this.quotaUser = other.quotaUser;
      }
      if (other.getRegion() != null) {
        this.region = other.region;
      }
      if (other.getRequestId() != null) {
        this.requestId = other.requestId;
      }
      if (other.getUserIp() != null) {
        this.userIp = other.userIp;
      }
      return this;
    }

    Builder(PatchAddressHttpRequest source) {
      this.access_token = source.access_token;
      this.address = source.address;
      this.addressResource = source.addressResource;
      this.callback = source.callback;
      this.fieldMask = source.fieldMask;
      this.fields = source.fields;
      this.key = source.key;
      this.prettyPrint = source.prettyPrint;
      this.quotaUser = source.quotaUser;
      this.region = source.region;
      this.requestId = source.requestId;
      this.userIp = source.userIp;
    }

    /**
     * OAuth 2.0 token for the current user.
    */
    public String getAccessToken() {
      return access_token;
    }

    /**
     * OAuth 2.0 token for the current user.
    */
    public Builder setAccessToken(String access_token) {
      this.access_token = access_token;
      return this;
    }

    /**
     * Name of the address to patch.
    */
    public String getAddress() {
      return address;
    }

    /**
     * Name of the address to patch.
    */
    public Builder setAddress(String address) {
      this.address = address;
      return this;
    }

    /**
     * A reserved address resource.
    */
    public Address getAddressResource() {
      return addressResource;
    }

    /**
     * A reserved address resource.
    */
    public Builder setAddressResource(Address addressResource) {
      this.addressResource = addressResource;
      return this;
    }

    /**
     * Name of the JavaScript callback function that handles the response.
    */
    public String getCallback() {
      return callback;
    }

    /**
     * Name of the JavaScript callback function that handles the response.
    */
    public Builder setCallback(String callback) {
      this.callback = callback;
      return this;
    }

    /**
     * The fields that should be serialized (even if they have empty values). If the containing message object has a non-null fieldmask, then all the fields in the field mask (and only those fields in the field mask) will be serialized. If the containing object does not have a fieldmask, then only non-empty fields will be serialized.
    */
    public List<String> getFieldMask() {
      return fieldMask;
    }

    /**
     * The fields that should be serialized (even if they have empty values). If the containing message object has a non-null fieldmask, then all the fields in the field mask (and only those fields in the field mask) will be serialized. If the containing object does not have a fieldmask, then only non-empty fields will be serialized.
    */
    public Builder addAllFieldMask(List<String> fieldMask) {
      if (this.fieldMask == null) {
        this.fieldMask = new LinkedList<>();
      }
      this.fieldMask.addAll(fieldMask);
      return this;
    }

    /**
     * The fields that should be serialized (even if they have empty values). If the containing message object has a non-null fieldmask, then all the fields in the field mask (and only those fields in the field mask) will be serialized. If the containing object does not have a fieldmask, then only non-empty fields will be serialized.
    */
    public Builder addFieldMask(String fieldMask) {
      if (this.fieldMask == null) {
        this.fieldMask = new LinkedList<>();
      }
      this.fieldMask.add(fieldMask);
      return this;
    }

    /**
     * Selector specifying a subset of fields to include in the response.
    */
    public String getFields() {
      return fields;
    }

    /**
     * Selector specifying a subset of fields to include in the response.
    */
    public Builder setFields(String fields) {
      this.fields = fields;
      return this;
    }

    /**
     * API key. Required unless you provide an OAuth 2.0 token.
    */
    public String getKey() {
      return key;
    }

    /**
     * API key. Required unless you provide an OAuth 2.0 token.
    */
    public Builder setKey(String key) {
      this.key = key;
      return this;
    }

    /**
     * Returns response with indentations and line breaks.
    */
    public String getPrettyPrint() {
      return prettyPrint;
    }

    /**
     * Returns response with indentations and line breaks.
    */
    public Builder setPrettyPrint(String prettyPrint) {
      this.prettyPrint = prettyPrint;
      return this;
    }

    /**
     * Alternative to userIp.
    */
    public String getQuotaUser() {
      return quotaUser;
    }

    /**
     * Alternative to userIp.
    */
    public Builder setQuotaUser(String quotaUser) {
      this.quotaUser = quotaUser;
      return this;
    }

    /**
     * Name of the region for this request.
     * It must have the format `{project}/regions/{region}/addresses`. \`{region}\` must start with a letter,
     * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
     *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
     *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
     *      &#42; must not start with \`"goog"\`.
    */
    public String getRegion() {
      return region;
    }

    /**
     * Name of the region for this request.
     * It must have the format `{project}/regions/{region}/addresses`. \`{region}\` must start with a letter,
     * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
     *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
     *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
     *      &#42; must not start with \`"goog"\`.
    */
    public Builder setRegion(String region) {
      this.region = region;
      return this;
    }

    /**
     * An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.
     *
     * For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.
     *
     * The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
    */
    public String getRequestId() {
      return requestId;
    }

    /**
     * An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.
     *
     * For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.
     *
     * The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
    */
    public Builder setRequestId(String requestId) {
      this.requestId = requestId;
      return this;
    }

    /**
     * IP address of the end user for whom the API call is being made.
    */
    public String getUserIp() {
      return userIp;
    }

    /**
     * IP address of the end user for whom the API call is being made.
    */
    public Builder setUserIp(String userIp) {
      this.userIp = userIp;
      return this;
    }


    public PatchAddressHttpRequest build() {
      String missing = "";




      if (fieldMask == null) {
        missing += " fieldMask";
      }




      if (region == null) {
        missing += " region";
      }


      if (!missing.isEmpty()) {
        throw new IllegalStateException("Missing required properties:" + missing);
      }
      return new PatchAddressHttpRequest(
        access_token,
        address,
        addressResource,
        callback,
        fieldMask,
        fields,
        key,
        prettyPrint,
        quotaUser,
        region,
        requestId,
        userIp
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setAccessToken(this.access_token);
      newBuilder.setAddress(this.address);
      newBuilder.setAddressResource(this.addressResource);
      newBuilder.setCallback(this.callback);
      newBuilder.addAllFieldMask(this.fieldMask);
      newBuilder.setFields(this.fields);
      newBuilder.setKey(this.key);
      newBuilder.setPrettyPrint(this.prettyPrint);
      newBuilder.setQuotaUser(this.quotaUser);
      newBuilder.setRegion(this.region);
      newBuilder.setRequestId(this.requestId);
      newBuilder.setUserIp(this.userIp);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "PatchAddressHttpRequest{"
        + "access_token=" + access_token + ", "
        + "address=" + address + ", "
        + "addressResource=" + addressResource + ", "
        + "callback=" + callback + ", "
        + "fieldMask=" + fieldMask + ", "
        + "fields=" + fields + ", "
        + "key=" + key + ", "
        + "prettyPrint=" + prettyPrint + ", "
        + "quotaUser=" + quotaUser + ", "
        + "region=" + region + ", "
        + "requestId=" + requestId + ", "
        + "userIp=" + userIp
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof PatchAddressHttpRequest) {
      PatchAddressHttpRequest that = (PatchAddressHttpRequest) o;
      return
          Objects.equals(this.access_token, that.getAccessToken()) &&
          Objects.equals(this.address, that.getAddress()) &&
          Objects.equals(this.addressResource, that.getAddressResource()) &&
          Objects.equals(this.callback, that.getCallback()) &&
          Objects.equals(this.fieldMask, that.getFieldMask()) &&
          Objects.equals(this.fields, that.getFields()) &&
          Objects.equals(this.key, that.getKey()) &&
          Objects.equals(this.prettyPrint, that.getPrettyPrint()) &&
          Objects.equals(this.quotaUser, that.getQuotaUser()) &&
          Objects.equals(this.region, that.getRegion()) &&
          Objects.equals(this.requestId, that.getRequestId()) &&
          Objects.equals(this.userIp, that.getUserIp())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      access_token,
      address,
      addressResource,
      callback,
      fieldMask,
      fields,
      key,
      prettyPrint,
      quotaUser,
      region,
      requestId,
      userIp
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/UpdateAddressHttpRequest.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.BetaApi;
import com.google.api.gax.httpjson.ApiMessage;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.gson.annotations.SerializedName;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.Generated;
import javax.annotation.Nullable;

@Generated("by GAPIC")
@BetaApi
/**
 * Request object for method compute.addresses.update. Updates the specified Address resource with the data included in the request. There are several restrictions and guidelines to keep in mind when updating an address. Read  Restrictions and Guidelines for more information.
*/
public final class UpdateAddressHttpRequest implements ApiMessage {
  private final String access_token;
  private final String address;
  private final Address addressResource;
  private final String callback;
  private final List<String> fieldMask;
  private final String fields;
  private final String key;
  private final String prettyPrint;
  private final String quotaUser;
  private final String requestId;
  private final String userIp;

  private UpdateAddressHttpRequest() {
    this.access_token = null;
    this.address = null;
    this.addressResource = null;
    this.callback = null;
    this.fieldMask = null;
    this.fields = null;
    this.key = null;
    this.prettyPrint = null;
    this.quotaUser = null;
    this.requestId = null;
    this.userIp = null;
  }


  private UpdateAddressHttpRequest(
      String access_token,
      String address,
      Address addressResource,
      String callback,
      List<String> fieldMask,
      String fields,
      String key,
      String prettyPrint,
      String quotaUser,
      String requestId,
      String userIp
      ) {
    this.access_token = access_token;
    this.address = address;
    this.addressResource = addressResource;
    this.callback = callback;
    this.fieldMask = fieldMask;
    this.fields = fields;
    this.key = key;
    this.prettyPrint = prettyPrint;
    this.quotaUser = quotaUser;
    this.requestId = requestId;
    this.userIp = userIp;
  }

  @Override
  public Object getFieldValue(String fieldName) {
    if ("access_token".equals(fieldName)) {
      return access_token;
    }
    if ("address".equals(fieldName)) {
      return address;
    }
    if ("addressResource".equals(fieldName)) {
      return addressResource;
    }
    if ("callback".equals(fieldName)) {
      return callback;
    }
    if ("fieldMask".equals(fieldName)) {
      return fieldMask;
    }
    if ("fields".equals(fieldName)) {
      return fields;
    }
    if ("key".equals(fieldName)) {
      return key;
    }
    if ("prettyPrint".equals(fieldName)) {
      return prettyPrint;
    }
    if ("quotaUser".equals(fieldName)) {
      return quotaUser;
    }
    if ("requestId".equals(fieldName)) {
      return requestId;
    }
    if ("userIp".equals(fieldName)) {
      return userIp;
    }
    return null;
  }

  @Nullable
  @Override
  public Address getApiMessageRequestBody() {
    return addressResource;
  }


  /**
   * OAuth 2.0 token for the current user.
  */
  public String getAccessToken() {
    return access_token;
  }

  /**
   * Name of the Address resource to update.
   * It must have the format `{project}/global/addresses/{address}`. \`{address}\` must start with a letter,
   * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
   *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
   *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
   *      &#42; must not start with \`"goog"\`.
  */
  public String getAddress() {
    return address;
  }

  /**
   * A reserved address resource.
  */
  public Address getAddressResource() {
    return addressResource;
  }

  /**
   * Name of the JavaScript callback function that handles the response.
  */
  public String getCallback() {
    return callback;
  }

  /**
   * The fields that should be serialized (even if they have empty values). If the containing message object has a non-null fieldmask, then all the fields in the field mask (and only those fields in the field mask) will be serialized. If the containing object does not have a fieldmask, then only non-empty fields will be serialized.
  */
  public List<String> getFieldMask() {
    return fieldMask;
  }

  /**
   * Selector specifying a subset of fields to include in the response.
  */
  public String getFields() {
    return fields;
  }

  /**
   * API key. Required unless you provide an OAuth 2.0 token.
  */
  public String getKey() {
    return key;
  }

  /**
   * Returns response with indentations and line breaks.
  */
  public String getPrettyPrint() {
    return prettyPrint;
  }

  /**
   * Alternative to userIp.
  */
  public String getQuotaUser() {
    return quotaUser;
  }

  /**
   * An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.
   *
   * For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
  */
  public String getRequestId() {
    return requestId;
  }

  /**
   * IP address of the end user for whom the API call is being made.
  */
  public String getUserIp() {
    return userIp;
  }


  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(UpdateAddressHttpRequest prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  public static UpdateAddressHttpRequest getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }
  private static final UpdateAddressHttpRequest DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new UpdateAddressHttpRequest();
  }

  public static class Builder {
    private String access_token;
    private String address;
    private Address addressResource;
    private String callback;
    private List<String> fieldMask;
    private String fields;
    private String key;
    private String prettyPrint;
    private String quotaUser;
    private String requestId;
    private String userIp;

    Builder() {}

    public Builder mergeFrom(UpdateAddressHttpRequest other) {
      if (other == UpdateAddressHttpRequest.getDefaultInstance()) return this;
      if (other.getAccessToken() != null) {
        this.access_token = other.access_token;
      }
      if (other.getAddress() != null) {
        this.address = other.address;
      }
      if (other.getAddressResource() != null) {
        this.addressResource = other.addressResource;
      }
      if (other.getCallback() != null) {
        this.callback = other.callback;
      }
      if (other.getFieldMask() != null) {
        this.fieldMask = other.fieldMask;
      }
      if (other.getFields() != null) {
        this.fields = other.fields;
      }
      if (other.getKey() != null) {
        this.key = other.key;
      }
      if (other.getPrettyPrint() != null) {
        this.prettyPrint = other.prettyPrint;
      }
      if (other.getQuotaUser() != null) {
        this.quotaUser = other.quotaUser;
      }
      if (other.getRequestId() != null) {
        this.requestId = other.requestId;
      }
      if (other.getUserIp() != null) {
        this.userIp = other.userIp;
      }
      return this;
    }

    Builder(UpdateAddressHttpRequest source) {
      this.access_token = source.access_token;
      this.address = source.address;
      this.addressResource = source.addressResource;
      this.callback = source.callback;
      this.fieldMask = source.fieldMask;
      this.fields = source.fields;
      this.key = source.key;
      this.prettyPrint = source.prettyPrint;
      this.quotaUser = source.quotaUser;
      this.requestId = source.requestId;
      this.userIp = source.userIp;
    }

    /**
     * OAuth 2.0 token for the current user.
    */
    public String getAccessToken() {
      return access_token;
    }

    /**
     * OAuth 2.0 token for the current user.
    */
    public Builder setAccessToken(String access_token) {
      this.access_token = access_token;
      return this;
    }

    /**
     * Name of the Address resource to update.
     * It must have the format `{project}/global/addresses/{address}`. \`{address}\` must start with a letter,
     * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
     *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
     *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
     *      &#42; must not start with \`"goog"\`.
    */
    public String getAddress() {
      return address;
    }

    /**
     * Name of the Address resource to update.
     * It must have the format `{project}/global/addresses/{address}`. \`{address}\` must start with a letter,
     * and contain only letters (\`[A-Za-z]\`), numbers (\`[0-9]\`), dashes (\`-\`),
     *      &#42; underscores (\`_\`), periods (\`.\`), tildes (\`~\`), plus (\`+\`) or percent
     *      &#42; signs (\`%\`). It must be between 3 and 255 characters in length, and it
     *      &#42; must not start with \`"goog"\`.
    */
    public Builder setAddress(String address) {
      this.address = address;
      return this;
    }

    /**
     * A reserved address resource.
    */
    public Address getAddressResource() {
      return addressResource;
    }

    /**
     * A reserved address resource.
    */
    public Builder setAddressResource(Address addressResource) {
      this.addressResource = addressResource;
      return this;
    }

    /**
     * Name of the JavaScript callback function that handles the response.
    */
    public String getCallback() {
      return callback;
    }

    /**
     * Name of the JavaScript callback function that handles the response.
    */
    public Builder setCallback(String callback) {
      this.callback = callback;
      return this;
    }

    /**
     * The fields that should be serialized (even if they have empty values). If the containing message object has a non-null fieldmask, then all the fields in the field mask (and only those fields in the field mask) will be serialized. If the containing object does not have a fieldmask, then only non-empty fields will be serialized.
    */
    public List<String> getFieldMask() {
      return fieldMask;
    }

    /**
     * The fields that should be serialized (even if they have empty values). If the containing message object has a non-null fieldmask, then all the fields in the field mask (and only those fields in the field mask) will be serialized. If the containing object does not have a fieldmask, then only non-empty fields will be serialized.
    */
    public Builder addAllFieldMask(List<String> fieldMask) {
      if (this.fieldMask == null) {
        this.fieldMask = new LinkedList<>();
      }
      this.fieldMask.addAll(fieldMask);
      return this;
    }

    /**
     * The fields that should be serialized (even if they have empty values). If the containing message object has a non-null fieldmask, then all the fields in the field mask (and only those fields in the field mask) will be serialized. If the containing object does not have a fieldmask, then only non-empty fields will be serialized.
    */
    public Builder addFieldMask(String fieldMask) {
      if (this.fieldMask == null) {
        this.fieldMask = new LinkedList<>();
      }
      this.fieldMask.add(fieldMask);
      return this;
    }

    /**
     * Selector specifying a subset of fields to include in the response.
    */
    public String getFields() {
      return fields;
    }

    /**
     * Selector specifying a subset of fields to include in the response.
    */
    public Builder setFields(String fields) {
      this.fields = fields;
      return this;
    }

    /**
     * API key. Required unless you provide an OAuth 2.0 token.
    */
    public String getKey() {
      return key;
    }

    /**
     * API key. Required unless you provide an OAuth 2.0 token.
    */
    public Builder setKey(String key) {
      this.key = key;
      return this;
    }

    /**
     * Returns response with indentations and line breaks.
    */
    public String getPrettyPrint() {
      return prettyPrint;
    }

    /**
     * Returns response with indentations and line breaks.
    */
    public Builder setPrettyPrint(String prettyPrint) {
      this.prettyPrint = prettyPrint;
      return this;
    }

    /**
     * Alternative to userIp.
    */
    public String getQuotaUser() {
      return quotaUser;
    }

    /**
     * Alternative to userIp.
    */
    public Builder setQuotaUser(String quotaUser) {
      this.quotaUser = quotaUser;
      return this;
    }

    /**
     * An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.
     *
     * For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.
     *
     * The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
    */
    public String getRequestId() {
      return requestId;
    }

    /**
     * An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed.
     *
     * For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments.
     *
     * The request ID must be a valid UUID with the exception that zero UUID is not supported (00000000-0000-0000-0000-000000000000).
    */
    public Builder setRequestId(String requestId) {
      this.requestId = requestId;
      return this;
    }

    /**
     * IP address of the end user for whom the API call is being made.
    */
    public String getUserIp() {
      return userIp;
    }

    /**
     * IP address of the end user for whom the API call is being made.
    */
    public Builder setUserIp(String userIp) {
      this.userIp = userIp;
      return this;
    }


    public UpdateAddressHttpRequest build() {
      String missing = "";

      if (address == null) {
        missing += " address";
      }


      if (fieldMask == null) {
        missing += " fieldMask";
      }






      if (!missing.isEmpty()) {
        throw new IllegalStateException("Missing required properties:" + missing);
      }
      return new UpdateAddressHttpRequest(
        access_token,
        address,
        addressResource,
        callback,
        fieldMask,
        fields,
        key,
        prettyPrint,
        quotaUser,
        requestId,
        userIp
      );
    }

    public Builder clone() {
      Builder newBuilder = new Builder();
      newBuilder.setAccessToken(this.access_token);
      newBuilder.setAddress(this.address);
      newBuilder.setAddressResource(this.addressResource);
      newBuilder.setCallback(this.callback);
      newBuilder.addAllFieldMask(this.fieldMask);
      newBuilder.setFields(this.fields);
      newBuilder.setKey(this.key);
      newBuilder.setPrettyPrint(this.prettyPrint);
      newBuilder.setQuotaUser(this.quotaUser);
      newBuilder.setRequestId(this.requestId);
      newBuilder.setUserIp(this.userIp);
      return newBuilder;
    }
  }

  @Override
  public String toString() {
    return "UpdateAddressHttpRequest{"
        + "access_token=" + access_token + ", "
        + "address=" + address + ", "
        + "addressResource=" + addressResource + ", "
        + "callback=" + callback + ", "
        + "fieldMask=" + fieldMask + ", "
        + "fields=" + fields + ", "
        + "key=" + key + ", "
        + "prettyPrint=" + prettyPrint + ", "
        + "quotaUser=" + quotaUser + ", "
        + "requestId=" + requestId + ", "
        + "userIp=" + userIp
        + "}";
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof UpdateAddressHttpRequest) {
      UpdateAddressHttpRequest that = (UpdateAddressHttpRequest) o;
      return
          Objects.equals(this.access_token, that.getAccessToken()) &&
          Objects.equals(this.address, that.getAddress()) &&
          Objects.equals(this.addressResource, that.getAddressResource()) &&
          Objects.equals(this.callback, that.getCallback()) &&
          Objects.equals(this.fieldMask, that.getFieldMask()) &&
          Objects.equals(this.fields, that.getFields()) &&
          Objects.equals(this.key, that.getKey()) &&
          Objects.equals(this.prettyPrint, that.getPrettyPrint()) &&
          Objects.equals(this.quotaUser, that.getQuotaUser()) &&
          Objects.equals(this.requestId, that.getRequestId()) &&
          Objects.equals(this.userIp, that.getUserIp())
          ;
    }
    return false;
  }

  @Override
  public int hashCode() {
    return Objects.hash(
      access_token,
      address,
      addressResource,
      callback,
      fieldMask,
      fields,
      key,
      prettyPrint,
      quotaUser,
      requestId,
      userIp
    );
  }
}

============== file: src/main/java/com/google/cloud/simplecompute/v1/AddressClient.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.ApiFunction;
import com.google.api.core.ApiFuture;
import com.google.api.core.ApiFutures;
import com.google.api.core.BetaApi;
import com.google.api.gax.core.BackgroundResource;
import com.google.api.gax.paging.AbstractFixedSizeCollection;
import com.google.api.gax.paging.AbstractPage;
import com.google.api.gax.paging.AbstractPagedListResponse;
import com.google.api.gax.paging.FixedSizeCollection;
import com.google.api.gax.paging.Page;
import com.google.api.gax.rpc.ApiExceptions;
import com.google.api.gax.rpc.PageContext;
import com.google.api.gax.rpc.UnaryCallable;
import com.google.api.pathtemplate.PathTemplate;
import com.google.cloud.simplecompute.v1.stub.AddressStub;
import com.google.cloud.simplecompute.v1.stub.AddressStubSettings;
import com.google.common.base.Function;
import com.google.common.collect.Iterables;
import com.google.common.util.concurrent.MoreExecutors;
import java.io.Closeable;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import javax.annotation.Generated;

// AUTO-GENERATED DOCUMENTATION AND SERVICE
/**
 * Service Description: Creates and runs virtual machines on Google Cloud Platform.
 *
 * <p>This class provides the ability to make remote calls to the backing service through method
 * calls that map to API methods. Sample code to get started:
 *
 * <pre>
 * <code>
 * try (AddressClient addressClient = AddressClient.create()) {
 *   ProjectRegionAddressName address = ProjectRegionAddressName.of("[PROJECT]", "[REGION]", "[ADDRESS]");
 *   Operation response = addressClient.deleteAddress(address);
 * }
 * </code>
 * </pre>
 *
 * <p>Note: close() needs to be called on the addressClient object to clean up resources such
 * as threads. In the example above, try-with-resources is used, which automatically calls
 * close().
 *
 * <p>The surface of this class includes several types of Java methods for each of the API's methods:
 *
 * <ol>
 * <li> A "flattened" method. With this type of method, the fields of the request type have been
 * converted into function parameters. It may be the case that not all fields are available
 * as parameters, and not every API method will have a flattened method entry point.
 * <li> A "request object" method. This type of method only takes one parameter, a request
 * object, which must be constructed before the call. Not every API method will have a request
 * object method.
 * <li> A "callable" method. This type of method takes no parameters and returns an immutable
 * API callable object, which can be used to initiate calls to the service.
 * </ol>
 *
 * <p>See the individual methods for example code.
 *
 * <p>Many parameters require resource names to be formatted in a particular way. To assist
 * with these names, this class includes a format method for each type of name, and additionally
 * a parse method to extract the individual identifiers contained within names that are
 * returned.
 *
 * <p>This class can be customized by passing in a custom instance of AddressSettings to
 * create(). For example:
 *
 * To customize credentials:
 *
 * <pre>
 * <code>
 * AddressSettings addressSettings =
 *     AddressSettings.newBuilder()
 *         .setCredentialsProvider(FixedCredentialsProvider.create(myCredentials))
 *         .build();
 * AddressClient addressClient =
 *     AddressClient.create(addressSettings);
 * </code>
 * </pre>
 *
 * To customize the endpoint:
 *
 * <pre>
 * <code>
 * AddressSettings addressSettings =
 *     AddressSettings.newBuilder().setEndpoint(myEndpoint).build();
 * AddressClient addressClient =
 *     AddressClient.create(addressSettings);
 * </code>
 * </pre>
 */
@Generated("by gapic-generator")
@BetaApi
public class AddressClient implements BackgroundResource {
  private final AddressSettings settings;
  private final AddressStub stub;



  /**
   * Constructs an instance of AddressClient with default settings.
   */
  public static final AddressClient create() throws IOException {
    return create(AddressSettings.newBuilder().build());
  }

  /**
   * Constructs an instance of AddressClient, using the given settings.
   * The channels are created based on the settings passed in, or defaults for any
   * settings that are not set.
   */
  public static final AddressClient create(AddressSettings settings) throws IOException {
    return new AddressClient(settings);
  }

  /**
   * Constructs an instance of AddressClient, using the given stub for making calls. This is for
   * advanced usage - prefer to use AddressSettings}.
   */
  @BetaApi("A restructuring of stub classes is planned, so this may break in the future")
  public static final AddressClient create(AddressStub stub) {
    return new AddressClient(stub);
  }

  /**
   * Constructs an instance of AddressClient, using the given settings.
   * This is protected so that it is easy to make a subclass, but otherwise, the static
   * factory methods should be preferred.
   */
  protected AddressClient(AddressSettings settings) throws IOException {
    this.settings = settings;
    this.stub = ((AddressStubSettings) settings.getStubSettings()).createStub();
  }

  @BetaApi("A restructuring of stub classes is planned, so this may break in the future")
  protected AddressClient(AddressStub stub) {
    this.settings = null;
    this.stub = stub;
  }

  public final AddressSettings getSettings() {
    return settings;
  }

  @BetaApi("A restructuring of stub classes is planned, so this may break in the future")
  public AddressStub getStub() {
    return stub;
  }


  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Retrieves an aggregated list of addresses.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   ProjectName project = ProjectName.of("[PROJECT]");
   *   for (AddressesScopedList element : addressClient.aggregatedListAddresses(project).iterateAll()) {
   *     // doThingsWith(element);
   *   }
   * }
   * </code></pre>
   *
   * @param project Project ID for this request.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final AggregatedListAddressesPagedResponse aggregatedListAddresses(ProjectName project) {
    AggregatedListAddressesHttpRequest request =
        AggregatedListAddressesHttpRequest.newBuilder()
            .setProject(project == null ? null : project.toString())
            .build();
    return aggregatedListAddresses(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Retrieves an aggregated list of addresses.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   ProjectName project = ProjectName.of("[PROJECT]");
   *   for (AddressesScopedList element : addressClient.aggregatedListAddresses(project.toString()).iterateAll()) {
   *     // doThingsWith(element);
   *   }
   * }
   * </code></pre>
   *
   * @param project Project ID for this request.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final AggregatedListAddressesPagedResponse aggregatedListAddresses(String project) {
    AggregatedListAddressesHttpRequest request =
        AggregatedListAddressesHttpRequest.newBuilder()
            .setProject(project)
            .build();
    return aggregatedListAddresses(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Retrieves an aggregated list of addresses.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   String formattedProject = ProjectName.format("[PROJECT]");
   *   AggregatedListAddressesHttpRequest request = AggregatedListAddressesHttpRequest.newBuilder()
   *     .setProject(formattedProject)
   *     .build();
   *   for (AddressesScopedList element : addressClient.aggregatedListAddresses(request).iterateAll()) {
   *     // doThingsWith(element);
   *   }
   * }
   * </code></pre>
   *
   * @param request The request object containing all of the parameters for the API call.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final AggregatedListAddressesPagedResponse aggregatedListAddresses(AggregatedListAddressesHttpRequest request) {
    return aggregatedListAddressesPagedCallable()
        .call(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Retrieves an aggregated list of addresses.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   String formattedProject = ProjectName.format("[PROJECT]");
   *   AggregatedListAddressesHttpRequest request = AggregatedListAddressesHttpRequest.newBuilder()
   *     .setProject(formattedProject)
   *     .build();
   *   ApiFuture&lt;AggregatedListAddressesPagedResponse&gt; future = addressClient.aggregatedListAddressesPagedCallable().futureCall(request);
   *   // Do something
   *   for (AddressesScopedList element : future.get().iterateAll()) {
   *     // doThingsWith(element);
   *   }
   * }
   * </code></pre>
   */
  @BetaApi
  public final UnaryCallable<AggregatedListAddressesHttpRequest, AggregatedListAddressesPagedResponse> aggregatedListAddressesPagedCallable() {
    return stub.aggregatedListAddressesPagedCallable();
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Retrieves an aggregated list of addresses.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   String formattedProject = ProjectName.format("[PROJECT]");
   *   AggregatedListAddressesHttpRequest request = AggregatedListAddressesHttpRequest.newBuilder()
   *     .setProject(formattedProject)
   *     .build();
   *   while (true) {
   *     AddressAggregatedList response = addressClient.aggregatedListAddressesCallable().call(request);
   *     for (AddressesScopedList element : response.getItemsMap()) {
   *       // doThingsWith(element);
   *     }
   *     String nextPageToken = response.getNextPageToken();
   *     if (!Strings.isNullOrEmpty(nextPageToken)) {
   *       request = request.toBuilder().setPageToken(nextPageToken).build();
   *     } else {
   *       break;
   *     }
   *   }
   * }
   * </code></pre>
   */
  @BetaApi
  public final UnaryCallable<AggregatedListAddressesHttpRequest, AddressAggregatedList> aggregatedListAddressesCallable() {
    return stub.aggregatedListAddressesCallable();
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Deletes the specified address resource.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   ProjectRegionAddressName address = ProjectRegionAddressName.of("[PROJECT]", "[REGION]", "[ADDRESS]");
   *   Operation response = addressClient.deleteAddress(address);
   * }
   * </code></pre>
   *
   * @param address Name of the address resource to delete.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final Operation deleteAddress(ProjectRegionAddressName address) {
    DeleteAddressHttpRequest request =
        DeleteAddressHttpRequest.newBuilder()
            .setAddress(address == null ? null : address.toString())
            .build();
    return deleteAddress(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Deletes the specified address resource.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   ProjectRegionAddressName address = ProjectRegionAddressName.of("[PROJECT]", "[REGION]", "[ADDRESS]");
   *   Operation response = addressClient.deleteAddress(address.toString());
   * }
   * </code></pre>
   *
   * @param address Name of the address resource to delete.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final Operation deleteAddress(String address) {
    DeleteAddressHttpRequest request =
        DeleteAddressHttpRequest.newBuilder()
            .setAddress(address)
            .build();
    return deleteAddress(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Deletes the specified address resource.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   String formattedAddress = ProjectRegionAddressName.format("[PROJECT]", "[REGION]", "[ADDRESS]");
   *   DeleteAddressHttpRequest request = DeleteAddressHttpRequest.newBuilder()
   *     .setAddress(formattedAddress)
   *     .build();
   *   Operation response = addressClient.deleteAddress(request);
   * }
   * </code></pre>
   *
   * @param request The request object containing all of the parameters for the API call.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final Operation deleteAddress(DeleteAddressHttpRequest request) {
    return deleteAddressCallable().call(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Deletes the specified address resource.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   String formattedAddress = ProjectRegionAddressName.format("[PROJECT]", "[REGION]", "[ADDRESS]");
   *   DeleteAddressHttpRequest request = DeleteAddressHttpRequest.newBuilder()
   *     .setAddress(formattedAddress)
   *     .build();
   *   ApiFuture&lt;Operation&gt; future = addressClient.deleteAddressCallable().futureCall(request);
   *   // Do something
   *   Operation response = future.get();
   * }
   * </code></pre>
   */
  @BetaApi
  public final UnaryCallable<DeleteAddressHttpRequest, Operation> deleteAddressCallable() {
    return stub.deleteAddressCallable();
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Returns the specified address resource.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   ProjectRegionAddressName address = ProjectRegionAddressName.of("[PROJECT]", "[REGION]", "[ADDRESS]");
   *   Address response = addressClient.getAddress(address);
   * }
   * </code></pre>
   *
   * @param address Name of the address resource to return.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final Address getAddress(ProjectRegionAddressName address) {
    GetAddressHttpRequest request =
        GetAddressHttpRequest.newBuilder()
            .setAddress(address == null ? null : address.toString())
            .build();
    return getAddress(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Returns the specified address resource.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   ProjectRegionAddressName address = ProjectRegionAddressName.of("[PROJECT]", "[REGION]", "[ADDRESS]");
   *   Address response = addressClient.getAddress(address.toString());
   * }
   * </code></pre>
   *
   * @param address Name of the address resource to return.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final Address getAddress(String address) {
    GetAddressHttpRequest request =
        GetAddressHttpRequest.newBuilder()
            .setAddress(address)
            .build();
    return getAddress(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Returns the specified address resource.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   String formattedAddress = ProjectRegionAddressName.format("[PROJECT]", "[REGION]", "[ADDRESS]");
   *   GetAddressHttpRequest request = GetAddressHttpRequest.newBuilder()
   *     .setAddress(formattedAddress)
   *     .build();
   *   Address response = addressClient.getAddress(request);
   * }
   * </code></pre>
   *
   * @param request The request object containing all of the parameters for the API call.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final Address getAddress(GetAddressHttpRequest request) {
    return getAddressCallable().call(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Returns the specified address resource.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   String formattedAddress = ProjectRegionAddressName.format("[PROJECT]", "[REGION]", "[ADDRESS]");
   *   GetAddressHttpRequest request = GetAddressHttpRequest.newBuilder()
   *     .setAddress(formattedAddress)
   *     .build();
   *   ApiFuture&lt;Address&gt; future = addressClient.getAddressCallable().futureCall(request);
   *   // Do something
   *   Address response = future.get();
   * }
   * </code></pre>
   */
  @BetaApi
  public final UnaryCallable<GetAddressHttpRequest, Address> getAddressCallable() {
    return stub.getAddressCallable();
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Creates an address resource in the specified project using the data included in the request.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   ProjectRegionName region = ProjectRegionName.of("[PROJECT]", "[REGION]");
   *   Address addressResource = Address.newBuilder().build();
   *   Operation response = addressClient.insertAddress(region, addressResource);
   * }
   * </code></pre>
   *
   * @param region Name of the region for this request.
   * @param addressResource A reserved address resource.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final Operation insertAddress(ProjectRegionName region, Address addressResource) {
    InsertAddressHttpRequest request =
        InsertAddressHttpRequest.newBuilder()
            .setRegion(region == null ? null : region.toString())
            .setAddressResource(addressResource)
            .build();
    return insertAddress(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Creates an address resource in the specified project using the data included in the request.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   ProjectRegionName region = ProjectRegionName.of("[PROJECT]", "[REGION]");
   *   Address addressResource = Address.newBuilder().build();
   *   Operation response = addressClient.insertAddress(region.toString(), addressResource);
   * }
   * </code></pre>
   *
   * @param region Name of the region for this request.
   * @param addressResource A reserved address resource.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final Operation insertAddress(String region, Address addressResource) {
    InsertAddressHttpRequest request =
        InsertAddressHttpRequest.newBuilder()
            .setRegion(region)
            .setAddressResource(addressResource)
            .build();
    return insertAddress(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Creates an address resource in the specified project using the data included in the request.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   String formattedRegion = ProjectRegionName.format("[PROJECT]", "[REGION]");
   *   Address addressResource = Address.newBuilder().build();
   *   InsertAddressHttpRequest request = InsertAddressHttpRequest.newBuilder()
   *     .setRegion(formattedRegion)
   *     .setAddressResource(addressResource)
   *     .build();
   *   Operation response = addressClient.insertAddress(request);
   * }
   * </code></pre>
   *
   * @param request The request object containing all of the parameters for the API call.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final Operation insertAddress(InsertAddressHttpRequest request) {
    return insertAddressCallable().call(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Creates an address resource in the specified project using the data included in the request.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   String formattedRegion = ProjectRegionName.format("[PROJECT]", "[REGION]");
   *   Address addressResource = Address.newBuilder().build();
   *   InsertAddressHttpRequest request = InsertAddressHttpRequest.newBuilder()
   *     .setRegion(formattedRegion)
   *     .setAddressResource(addressResource)
   *     .build();
   *   ApiFuture&lt;Operation&gt; future = addressClient.insertAddressCallable().futureCall(request);
   *   // Do something
   *   Operation response = future.get();
   * }
   * </code></pre>
   */
  @BetaApi
  public final UnaryCallable<InsertAddressHttpRequest, Operation> insertAddressCallable() {
    return stub.insertAddressCallable();
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Retrieves a list of addresses contained within the specified region.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   ProjectRegionName region = ProjectRegionName.of("[PROJECT]", "[REGION]");
   *   for (Address element : addressClient.listAddresses(region).iterateAll()) {
   *     // doThingsWith(element);
   *   }
   * }
   * </code></pre>
   *
   * @param region Name of the region for this request.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final ListAddressesPagedResponse listAddresses(ProjectRegionName region) {
    ListAddressesHttpRequest request =
        ListAddressesHttpRequest.newBuilder()
            .setRegion(region == null ? null : region.toString())
            .build();
    return listAddresses(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Retrieves a list of addresses contained within the specified region.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   ProjectRegionName region = ProjectRegionName.of("[PROJECT]", "[REGION]");
   *   for (Address element : addressClient.listAddresses(region.toString()).iterateAll()) {
   *     // doThingsWith(element);
   *   }
   * }
   * </code></pre>
   *
   * @param region Name of the region for this request.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final ListAddressesPagedResponse listAddresses(String region) {
    ListAddressesHttpRequest request =
        ListAddressesHttpRequest.newBuilder()
            .setRegion(region)
            .build();
    return listAddresses(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Retrieves a list of addresses contained within the specified region.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   String formattedRegion = ProjectRegionName.format("[PROJECT]", "[REGION]");
   *   ListAddressesHttpRequest request = ListAddressesHttpRequest.newBuilder()
   *     .setRegion(formattedRegion)
   *     .build();
   *   for (Address element : addressClient.listAddresses(request).iterateAll()) {
   *     // doThingsWith(element);
   *   }
   * }
   * </code></pre>
   *
   * @param request The request object containing all of the parameters for the API call.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final ListAddressesPagedResponse listAddresses(ListAddressesHttpRequest request) {
    return listAddressesPagedCallable()
        .call(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Retrieves a list of addresses contained within the specified region.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   String formattedRegion = ProjectRegionName.format("[PROJECT]", "[REGION]");
   *   ListAddressesHttpRequest request = ListAddressesHttpRequest.newBuilder()
   *     .setRegion(formattedRegion)
   *     .build();
   *   ApiFuture&lt;ListAddressesPagedResponse&gt; future = addressClient.listAddressesPagedCallable().futureCall(request);
   *   // Do something
   *   for (Address element : future.get().iterateAll()) {
   *     // doThingsWith(element);
   *   }
   * }
   * </code></pre>
   */
  @BetaApi
  public final UnaryCallable<ListAddressesHttpRequest, ListAddressesPagedResponse> listAddressesPagedCallable() {
    return stub.listAddressesPagedCallable();
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Retrieves a list of addresses contained within the specified region.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   String formattedRegion = ProjectRegionName.format("[PROJECT]", "[REGION]");
   *   ListAddressesHttpRequest request = ListAddressesHttpRequest.newBuilder()
   *     .setRegion(formattedRegion)
   *     .build();
   *   while (true) {
   *     AddressList response = addressClient.listAddressesCallable().call(request);
   *     for (Address element : response.getItemsList()) {
   *       // doThingsWith(element);
   *     }
   *     String nextPageToken = response.getNextPageToken();
   *     if (!Strings.isNullOrEmpty(nextPageToken)) {
   *       request = request.toBuilder().setPageToken(nextPageToken).build();
   *     } else {
   *       break;
   *     }
   *   }
   * }
   * </code></pre>
   */
  @BetaApi
  public final UnaryCallable<ListAddressesHttpRequest, AddressList> listAddressesCallable() {
    return stub.listAddressesCallable();
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Updates an address in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   String address = "";
   *   ProjectRegionName region = ProjectRegionName.of("[PROJECT]", "[REGION]");
   *   Address addressResource = Address.newBuilder().build();
   *   List&lt;String&gt; fieldMask = new ArrayList&lt;&gt;();
   *   addressClient.patchAddress(address, region, addressResource, fieldMask);
   * }
   * </code></pre>
   *
   * @param address Name of the address to patch.
   * @param region Name of the region for this request.
   * @param addressResource A reserved address resource.
   * @param fieldMask The fields that should be serialized (even if they have empty values). If the containing message object has a non-null fieldmask, then all the fields in the field mask (and only those fields in the field mask) will be serialized. If the containing object does not have a fieldmask, then only non-empty fields will be serialized.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final void patchAddress(String address, ProjectRegionName region, Address addressResource, List<String> fieldMask) {
    PatchAddressHttpRequest request =
        PatchAddressHttpRequest.newBuilder()
            .setAddress(address)
            .setRegion(region == null ? null : region.toString())
            .setAddressResource(addressResource)
            .addAllFieldMask(fieldMask)
            .build();
    patchAddress(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Updates an address in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   String address = "";
   *   ProjectRegionName region = ProjectRegionName.of("[PROJECT]", "[REGION]");
   *   Address addressResource = Address.newBuilder().build();
   *   List&lt;String&gt; fieldMask = new ArrayList&lt;&gt;();
   *   addressClient.patchAddress(address, region.toString(), addressResource, fieldMask);
   * }
   * </code></pre>
   *
   * @param address Name of the address to patch.
   * @param region Name of the region for this request.
   * @param addressResource A reserved address resource.
   * @param fieldMask The fields that should be serialized (even if they have empty values). If the containing message object has a non-null fieldmask, then all the fields in the field mask (and only those fields in the field mask) will be serialized. If the containing object does not have a fieldmask, then only non-empty fields will be serialized.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final void patchAddress(String address, String region, Address addressResource, List<String> fieldMask) {
    PatchAddressHttpRequest request =
        PatchAddressHttpRequest.newBuilder()
            .setAddress(address)
            .setRegion(region)
            .setAddressResource(addressResource)
            .addAllFieldMask(fieldMask)
            .build();
    patchAddress(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Updates an address in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   String address = "";
   *   String formattedRegion = ProjectRegionName.format("[PROJECT]", "[REGION]");
   *   Address addressResource = Address.newBuilder().build();
   *   List&lt;String&gt; fieldMask = new ArrayList&lt;&gt;();
   *   PatchAddressHttpRequest request = PatchAddressHttpRequest.newBuilder()
   *     .setAddress(address)
   *     .setRegion(formattedRegion)
   *     .setAddressResource(addressResource)
   *     .addAllFieldMask(fieldMask)
   *     .build();
   *   addressClient.patchAddress(request);
   * }
   * </code></pre>
   *
   * @param request The request object containing all of the parameters for the API call.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final void patchAddress(PatchAddressHttpRequest request) {
    patchAddressCallable().call(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Updates an address in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   String address = "";
   *   String formattedRegion = ProjectRegionName.format("[PROJECT]", "[REGION]");
   *   Address addressResource = Address.newBuilder().build();
   *   List&lt;String&gt; fieldMask = new ArrayList&lt;&gt;();
   *   PatchAddressHttpRequest request = PatchAddressHttpRequest.newBuilder()
   *     .setAddress(address)
   *     .setRegion(formattedRegion)
   *     .setAddressResource(addressResource)
   *     .addAllFieldMask(fieldMask)
   *     .build();
   *   ApiFuture&lt;Void&gt; future = addressClient.patchAddressCallable().futureCall(request);
   *   // Do something
   *   future.get();
   * }
   * </code></pre>
   */
  @BetaApi
  public final UnaryCallable<PatchAddressHttpRequest, Void> patchAddressCallable() {
    return stub.patchAddressCallable();
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Updates the specified Address resource with the data included in the request. There are several restrictions and guidelines to keep in mind when updating an address. Read  Restrictions and Guidelines for more information.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   ProjectGlobalAddressName address = ProjectGlobalAddressName.of("[PROJECT]", "[ADDRESS]");
   *   Address addressResource = Address.newBuilder().build();
   *   List&lt;String&gt; fieldMask = new ArrayList&lt;&gt;();
   *   Operation response = addressClient.updateAddress(address, addressResource, fieldMask);
   * }
   * </code></pre>
   *
   * @param address Name of the Address resource to update.
   * @param addressResource A reserved address resource.
   * @param fieldMask The fields that should be serialized (even if they have empty values). If the containing message object has a non-null fieldmask, then all the fields in the field mask (and only those fields in the field mask) will be serialized. If the containing object does not have a fieldmask, then only non-empty fields will be serialized.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final Operation updateAddress(ProjectGlobalAddressName address, Address addressResource, List<String> fieldMask) {
    UpdateAddressHttpRequest request =
        UpdateAddressHttpRequest.newBuilder()
            .setAddress(address == null ? null : address.toString())
            .setAddressResource(addressResource)
            .addAllFieldMask(fieldMask)
            .build();
    return updateAddress(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Updates the specified Address resource with the data included in the request. There are several restrictions and guidelines to keep in mind when updating an address. Read  Restrictions and Guidelines for more information.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   ProjectGlobalAddressName address = ProjectGlobalAddressName.of("[PROJECT]", "[ADDRESS]");
   *   Address addressResource = Address.newBuilder().build();
   *   List&lt;String&gt; fieldMask = new ArrayList&lt;&gt;();
   *   Operation response = addressClient.updateAddress(address.toString(), addressResource, fieldMask);
   * }
   * </code></pre>
   *
   * @param address Name of the Address resource to update.
   * @param addressResource A reserved address resource.
   * @param fieldMask The fields that should be serialized (even if they have empty values). If the containing message object has a non-null fieldmask, then all the fields in the field mask (and only those fields in the field mask) will be serialized. If the containing object does not have a fieldmask, then only non-empty fields will be serialized.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final Operation updateAddress(String address, Address addressResource, List<String> fieldMask) {
    UpdateAddressHttpRequest request =
        UpdateAddressHttpRequest.newBuilder()
            .setAddress(address)
            .setAddressResource(addressResource)
            .addAllFieldMask(fieldMask)
            .build();
    return updateAddress(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Updates the specified Address resource with the data included in the request. There are several restrictions and guidelines to keep in mind when updating an address. Read  Restrictions and Guidelines for more information.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   String formattedAddress = ProjectGlobalAddressName.format("[PROJECT]", "[ADDRESS]");
   *   Address addressResource = Address.newBuilder().build();
   *   List&lt;String&gt; fieldMask = new ArrayList&lt;&gt;();
   *   UpdateAddressHttpRequest request = UpdateAddressHttpRequest.newBuilder()
   *     .setAddress(formattedAddress)
   *     .setAddressResource(addressResource)
   *     .addAllFieldMask(fieldMask)
   *     .build();
   *   Operation response = addressClient.updateAddress(request);
   * }
   * </code></pre>
   *
   * @param request The request object containing all of the parameters for the API call.
   * @throws com.google.api.gax.rpc.ApiException if the remote call fails
   */
  @BetaApi
  public final Operation updateAddress(UpdateAddressHttpRequest request) {
    return updateAddressCallable().call(request);
  }

  // AUTO-GENERATED DOCUMENTATION AND METHOD
  /**
   * Updates the specified Address resource with the data included in the request. There are several restrictions and guidelines to keep in mind when updating an address. Read  Restrictions and Guidelines for more information.
   *
   * Sample code:
   * <pre><code>
   * try (AddressClient addressClient = AddressClient.create()) {
   *   String formattedAddress = ProjectGlobalAddressName.format("[PROJECT]", "[ADDRESS]");
   *   Address addressResource = Address.newBuilder().build();
   *   List&lt;String&gt; fieldMask = new ArrayList&lt;&gt;();
   *   UpdateAddressHttpRequest request = UpdateAddressHttpRequest.newBuilder()
   *     .setAddress(formattedAddress)
   *     .setAddressResource(addressResource)
   *     .addAllFieldMask(fieldMask)
   *     .build();
   *   ApiFuture&lt;Operation&gt; future = addressClient.updateAddressCallable().futureCall(request);
   *   // Do something
   *   Operation response = future.get();
   * }
   * </code></pre>
   */
  @BetaApi
  public final UnaryCallable<UpdateAddressHttpRequest, Operation> updateAddressCallable() {
    return stub.updateAddressCallable();
  }

  @Override
  public final void close() {
    stub.close();
  }

  @Override
  public void shutdown() {
    stub.shutdown();
  }

  @Override
  public boolean isShutdown() {
    return stub.isShutdown();
  }

  @Override
  public boolean isTerminated() {
    return stub.isTerminated();
  }

  @Override
  public void shutdownNow() {
    stub.shutdownNow();
  }

  @Override
  public boolean awaitTermination(long duration, TimeUnit unit) throws InterruptedException {
    return stub.awaitTermination(duration, unit);
  }

  public static class AggregatedListAddressesPagedResponse extends AbstractPagedListResponse<
      AggregatedListAddressesHttpRequest,
      AddressAggregatedList,
      AddressesScopedList,
      AggregatedListAddressesPage,
      AggregatedListAddressesFixedSizeCollection> {

    public static ApiFuture<AggregatedListAddressesPagedResponse> createAsync(
        PageContext<AggregatedListAddressesHttpRequest, AddressAggregatedList, AddressesScopedList> context,
        ApiFuture<AddressAggregatedList> futureResponse) {
      ApiFuture<AggregatedListAddressesPage> futurePage =
          AggregatedListAddressesPage.createEmptyPage().createPageAsync(context, futureResponse);
      return ApiFutures.transform(
          futurePage,
          new ApiFunction<AggregatedListAddressesPage, AggregatedListAddressesPagedResponse>() {
            @Override
            public AggregatedListAddressesPagedResponse apply(AggregatedListAddressesPage input) {
              return new AggregatedListAddressesPagedResponse(input);
            }
          },
          MoreExecutors.directExecutor());
    }

    private AggregatedListAddressesPagedResponse(AggregatedListAddressesPage page) {
      super(page, AggregatedListAddressesFixedSizeCollection.createEmptyCollection());
    }


  }

  public static class AggregatedListAddressesPage extends AbstractPage<
      AggregatedListAddressesHttpRequest,
      AddressAggregatedList,
      AddressesScopedList,
      AggregatedListAddressesPage> {

    private AggregatedListAddressesPage(
        PageContext<AggregatedListAddressesHttpRequest, AddressAggregatedList, AddressesScopedList> context,
        AddressAggregatedList response) {
      super(context, response);
    }

    private static AggregatedListAddressesPage createEmptyPage() {
      return new AggregatedListAddressesPage(null, null);
    }

    @Override
    protected AggregatedListAddressesPage createPage(
        PageContext<AggregatedListAddressesHttpRequest, AddressAggregatedList, AddressesScopedList> context,
        AddressAggregatedList response) {
      return new AggregatedListAddressesPage(context, response);
    }

    @Override
    public ApiFuture<AggregatedListAddressesPage> createPageAsync(
        PageContext<AggregatedListAddressesHttpRequest, AddressAggregatedList, AddressesScopedList> context,
        ApiFuture<AddressAggregatedList> futureResponse) {
      return super.createPageAsync(context, futureResponse);
    }




  }

  public static class AggregatedListAddressesFixedSizeCollection extends AbstractFixedSizeCollection<
      AggregatedListAddressesHttpRequest,
      AddressAggregatedList,
      AddressesScopedList,
      AggregatedListAddressesPage,
      AggregatedListAddressesFixedSizeCollection> {

    private AggregatedListAddressesFixedSizeCollection(List<AggregatedListAddressesPage> pages, int collectionSize) {
      super(pages, collectionSize);
    }

    private static AggregatedListAddressesFixedSizeCollection createEmptyCollection() {
      return new AggregatedListAddressesFixedSizeCollection(null, 0);
    }

    @Override
    protected AggregatedListAddressesFixedSizeCollection createCollection(
        List<AggregatedListAddressesPage> pages, int collectionSize) {
      return new AggregatedListAddressesFixedSizeCollection(pages, collectionSize);
    }


  }
  public static class ListAddressesPagedResponse extends AbstractPagedListResponse<
      ListAddressesHttpRequest,
      AddressList,
      Address,
      ListAddressesPage,
      ListAddressesFixedSizeCollection> {

    public static ApiFuture<ListAddressesPagedResponse> createAsync(
        PageContext<ListAddressesHttpRequest, AddressList, Address> context,
        ApiFuture<AddressList> futureResponse) {
      ApiFuture<ListAddressesPage> futurePage =
          ListAddressesPage.createEmptyPage().createPageAsync(context, futureResponse);
      return ApiFutures.transform(
          futurePage,
          new ApiFunction<ListAddressesPage, ListAddressesPagedResponse>() {
            @Override
            public ListAddressesPagedResponse apply(ListAddressesPage input) {
              return new ListAddressesPagedResponse(input);
            }
          },
          MoreExecutors.directExecutor());
    }

    private ListAddressesPagedResponse(ListAddressesPage page) {
      super(page, ListAddressesFixedSizeCollection.createEmptyCollection());
    }


  }

  public static class ListAddressesPage extends AbstractPage<
      ListAddressesHttpRequest,
      AddressList,
      Address,
      ListAddressesPage> {

    private ListAddressesPage(
        PageContext<ListAddressesHttpRequest, AddressList, Address> context,
        AddressList response) {
      super(context, response);
    }

    private static ListAddressesPage createEmptyPage() {
      return new ListAddressesPage(null, null);
    }

    @Override
    protected ListAddressesPage createPage(
        PageContext<ListAddressesHttpRequest, AddressList, Address> context,
        AddressList response) {
      return new ListAddressesPage(context, response);
    }

    @Override
    public ApiFuture<ListAddressesPage> createPageAsync(
        PageContext<ListAddressesHttpRequest, AddressList, Address> context,
        ApiFuture<AddressList> futureResponse) {
      return super.createPageAsync(context, futureResponse);
    }




  }

  public static class ListAddressesFixedSizeCollection extends AbstractFixedSizeCollection<
      ListAddressesHttpRequest,
      AddressList,
      Address,
      ListAddressesPage,
      ListAddressesFixedSizeCollection> {

    private ListAddressesFixedSizeCollection(List<ListAddressesPage> pages, int collectionSize) {
      super(pages, collectionSize);
    }

    private static ListAddressesFixedSizeCollection createEmptyCollection() {
      return new ListAddressesFixedSizeCollection(null, 0);
    }

    @Override
    protected ListAddressesFixedSizeCollection createCollection(
        List<ListAddressesPage> pages, int collectionSize) {
      return new ListAddressesFixedSizeCollection(pages, collectionSize);
    }


  }
}
============== file: src/main/java/com/google/cloud/simplecompute/v1/AddressSettings.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.core.ApiFunction;
import com.google.api.core.ApiFuture;
import com.google.api.core.BetaApi;
import com.google.api.gax.core.CredentialsProvider;
import com.google.api.gax.core.ExecutorProvider;
import com.google.api.gax.core.GaxProperties;
import com.google.api.gax.core.GoogleCredentialsProvider;
import com.google.api.gax.core.InstantiatingExecutorProvider;
import com.google.api.gax.httpjson.GaxHttpJsonProperties;
import com.google.api.gax.httpjson.HttpJsonTransportChannel;
import com.google.api.gax.httpjson.InstantiatingHttpJsonChannelProvider;
import com.google.api.gax.retrying.RetrySettings;
import com.google.api.gax.rpc.ApiCallContext;
import com.google.api.gax.rpc.ApiClientHeaderProvider;
import com.google.api.gax.rpc.ClientContext;
import com.google.api.gax.rpc.ClientSettings;
import com.google.api.gax.rpc.HeaderProvider;
import com.google.api.gax.rpc.PageContext;
import com.google.api.gax.rpc.PagedCallSettings;
import com.google.api.gax.rpc.PagedListDescriptor;
import com.google.api.gax.rpc.PagedListResponseFactory;
import com.google.api.gax.rpc.StatusCode;
import com.google.api.gax.rpc.StubSettings;
import com.google.api.gax.rpc.TransportChannelProvider;
import com.google.api.gax.rpc.UnaryCallSettings;
import com.google.api.gax.rpc.UnaryCallable;
import com.google.auth.Credentials;
import static com.google.cloud.simplecompute.v1.AddressClient.AggregatedListAddressesPagedResponse;
import static com.google.cloud.simplecompute.v1.AddressClient.ListAddressesPagedResponse;
import com.google.cloud.simplecompute.v1.stub.AddressStubSettings;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import javax.annotation.Generated;
import org.threeten.bp.Duration;

// AUTO-GENERATED DOCUMENTATION AND CLASS
/**
 * Settings class to configure an instance of {@link AddressClient}.
 *
 * <p>The default instance has everything set to sensible defaults:
 *
 * <ul>
 * <li>The default service address (https://www.googleapis.com/compute/v1/projects/) and default port (443)
 * are used.
 * <li>Credentials are acquired automatically through Application Default Credentials.
 * <li>Retries are configured for idempotent methods but not for non-idempotent methods.
 * </ul>
 *
 * <p>The builder of this class is recursive, so contained classes are themselves builders.
 * When build() is called, the tree of builders is called to create the complete settings
 * object.
 *
 * For example, to set the total timeout of deleteAddress to 30 seconds:
 *
 * <pre>
 * <code>
 * AddressSettings.Builder addressSettingsBuilder =
 *     AddressSettings.newBuilder();
 * addressSettingsBuilder
 *     .deleteAddressSettings()
 *     .setRetrySettings(
 *         addressSettingsBuilder.deleteAddressSettings().getRetrySettings().toBuilder()
 *             .setTotalTimeout(Duration.ofSeconds(30))
 *             .build());
 * AddressSettings addressSettings = addressSettingsBuilder.build();
 * </code>
 * </pre>
 */
@Generated("by gapic-generator")
@BetaApi
public class AddressSettings extends ClientSettings<AddressSettings> {
  /**
   * Returns the object with the settings used for calls to aggregatedListAddresses.
   */
  public PagedCallSettings<AggregatedListAddressesHttpRequest, AddressAggregatedList, AggregatedListAddressesPagedResponse> aggregatedListAddressesSettings() {
    return ((AddressStubSettings) getStubSettings()).aggregatedListAddressesSettings();
  }

  /**
   * Returns the object with the settings used for calls to deleteAddress.
   */
  public UnaryCallSettings<DeleteAddressHttpRequest, Operation> deleteAddressSettings() {
    return ((AddressStubSettings) getStubSettings()).deleteAddressSettings();
  }

  /**
   * Returns the object with the settings used for calls to getAddress.
   */
  public UnaryCallSettings<GetAddressHttpRequest, Address> getAddressSettings() {
    return ((AddressStubSettings) getStubSettings()).getAddressSettings();
  }

  /**
   * Returns the object with the settings used for calls to insertAddress.
   */
  public UnaryCallSettings<InsertAddressHttpRequest, Operation> insertAddressSettings() {
    return ((AddressStubSettings) getStubSettings()).insertAddressSettings();
  }

  /**
   * Returns the object with the settings used for calls to listAddresses.
   */
  public PagedCallSettings<ListAddressesHttpRequest, AddressList, ListAddressesPagedResponse> listAddressesSettings() {
    return ((AddressStubSettings) getStubSettings()).listAddressesSettings();
  }

  /**
   * Returns the object with the settings used for calls to patchAddress.
   */
  public UnaryCallSettings<PatchAddressHttpRequest, Void> patchAddressSettings() {
    return ((AddressStubSettings) getStubSettings()).patchAddressSettings();
  }

  /**
   * Returns the object with the settings used for calls to updateAddress.
   */
  public UnaryCallSettings<UpdateAddressHttpRequest, Operation> updateAddressSettings() {
    return ((AddressStubSettings) getStubSettings()).updateAddressSettings();
  }


  public static final AddressSettings create(AddressStubSettings stub) throws IOException {
    return new AddressSettings.Builder(stub.toBuilder()).build();
  }

  /**
   * Returns a builder for the default ExecutorProvider for this service.
   */
  public static InstantiatingExecutorProvider.Builder defaultExecutorProviderBuilder() {
    return AddressStubSettings.defaultExecutorProviderBuilder();
  }

  /**
   * Returns the default service endpoint.
   */
   public static String getDefaultEndpoint() {
     return AddressStubSettings.getDefaultEndpoint();
   }
  /**
   * Returns the default service port.
   */
  public static int getDefaultServicePort() {
    return AddressStubSettings.getDefaultServicePort();
  }


  /**
   * Returns the default service scopes.
   */
  public static List<String> getDefaultServiceScopes() {
    return AddressStubSettings.getDefaultServiceScopes();
  }


  /**
   * Returns a builder for the default credentials for this service.
   */
  public static GoogleCredentialsProvider.Builder defaultCredentialsProviderBuilder() {
    return AddressStubSettings.defaultCredentialsProviderBuilder();
  }

  /** Returns a builder for the default ChannelProvider for this service. */
  public static InstantiatingHttpJsonChannelProvider.Builder defaultHttpJsonTransportProviderBuilder() {
    return AddressStubSettings.defaultHttpJsonTransportProviderBuilder();
  }

  public static TransportChannelProvider defaultTransportChannelProvider() {
    return AddressStubSettings.defaultTransportChannelProvider();
  }

  @BetaApi("The surface for customizing headers is not stable yet and may change in the future.")
  public static ApiClientHeaderProvider.Builder defaultApiClientHeaderProviderBuilder() {
    return AddressStubSettings.defaultApiClientHeaderProviderBuilder();
  }

  /**
   * Returns a new builder for this class.
   */
  public static Builder newBuilder() {
    return Builder.createDefault();
  }

  /**
   * Returns a new builder for this class.
   */
  public static Builder newBuilder(ClientContext clientContext) {
    return new Builder(clientContext);
  }

  /**
   * Returns a builder containing all the values of this settings class.
   */
  public Builder toBuilder() {
    return new Builder(this);
  }

  protected AddressSettings(Builder settingsBuilder) throws IOException {
    super(settingsBuilder);
  }

  /**
   * Builder for AddressSettings.
   */
  public static class Builder extends ClientSettings.Builder<AddressSettings, Builder> {
    protected Builder() throws IOException {
      this((ClientContext) null);
    }

    protected Builder(ClientContext clientContext) {
      super(AddressStubSettings.newBuilder(clientContext));
    }

    private static Builder createDefault() {
      return new Builder(AddressStubSettings.newBuilder());
    }

    protected Builder(AddressSettings settings) {
      super(settings.getStubSettings().toBuilder());
    }

    protected Builder(AddressStubSettings.Builder stubSettings) {
      super(stubSettings);
    }


    public AddressStubSettings.Builder getStubSettingsBuilder() {
      return ((AddressStubSettings.Builder) getStubSettings());
    }

    // NEXT_MAJOR_VER: remove 'throws Exception'
    /**
     * Applies the given settings updater function to all of the unary API methods in this service.
     *
     * Note: This method does not support applying settings to streaming methods.
     */
    public Builder applyToAllUnaryMethods(ApiFunction<UnaryCallSettings.Builder<?, ?>, Void> settingsUpdater) throws Exception {
      super.applyToAllUnaryMethods(getStubSettingsBuilder().unaryMethodSettingsBuilders(), settingsUpdater);
      return this;
    }

    /**
     * Returns the builder for the settings used for calls to aggregatedListAddresses.
     */
    public PagedCallSettings.Builder<AggregatedListAddressesHttpRequest, AddressAggregatedList, AggregatedListAddressesPagedResponse> aggregatedListAddressesSettings() {
      return getStubSettingsBuilder().aggregatedListAddressesSettings();
    }

    /**
     * Returns the builder for the settings used for calls to deleteAddress.
     */
    public UnaryCallSettings.Builder<DeleteAddressHttpRequest, Operation> deleteAddressSettings() {
      return getStubSettingsBuilder().deleteAddressSettings();
    }

    /**
     * Returns the builder for the settings used for calls to getAddress.
     */
    public UnaryCallSettings.Builder<GetAddressHttpRequest, Address> getAddressSettings() {
      return getStubSettingsBuilder().getAddressSettings();
    }

    /**
     * Returns the builder for the settings used for calls to insertAddress.
     */
    public UnaryCallSettings.Builder<InsertAddressHttpRequest, Operation> insertAddressSettings() {
      return getStubSettingsBuilder().insertAddressSettings();
    }

    /**
     * Returns the builder for the settings used for calls to listAddresses.
     */
    public PagedCallSettings.Builder<ListAddressesHttpRequest, AddressList, ListAddressesPagedResponse> listAddressesSettings() {
      return getStubSettingsBuilder().listAddressesSettings();
    }

    /**
     * Returns the builder for the settings used for calls to patchAddress.
     */
    public UnaryCallSettings.Builder<PatchAddressHttpRequest, Void> patchAddressSettings() {
      return getStubSettingsBuilder().patchAddressSettings();
    }

    /**
     * Returns the builder for the settings used for calls to updateAddress.
     */
    public UnaryCallSettings.Builder<UpdateAddressHttpRequest, Operation> updateAddressSettings() {
      return getStubSettingsBuilder().updateAddressSettings();
    }

    @Override
    public AddressSettings build() throws IOException {
      return new AddressSettings(this);
    }
  }
}
============== file: src/main/java/com/google/cloud/simplecompute/v1/stub/AddressStubSettings.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1.stub;

import com.google.api.core.ApiFunction;
import com.google.api.core.ApiFuture;
import com.google.api.core.BetaApi;
import com.google.api.gax.core.CredentialsProvider;
import com.google.api.gax.core.ExecutorProvider;
import com.google.api.gax.core.GaxProperties;
import com.google.api.gax.core.GoogleCredentialsProvider;
import com.google.api.gax.core.InstantiatingExecutorProvider;
import com.google.api.gax.httpjson.GaxHttpJsonProperties;
import com.google.api.gax.httpjson.HttpJsonTransportChannel;
import com.google.api.gax.httpjson.InstantiatingHttpJsonChannelProvider;
import com.google.api.gax.retrying.RetrySettings;
import com.google.api.gax.rpc.ApiCallContext;
import com.google.api.gax.rpc.ApiClientHeaderProvider;
import com.google.api.gax.rpc.ClientContext;
import com.google.api.gax.rpc.ClientSettings;
import com.google.api.gax.rpc.HeaderProvider;
import com.google.api.gax.rpc.PageContext;
import com.google.api.gax.rpc.PagedCallSettings;
import com.google.api.gax.rpc.PagedListDescriptor;
import com.google.api.gax.rpc.PagedListResponseFactory;
import com.google.api.gax.rpc.StatusCode;
import com.google.api.gax.rpc.StubSettings;
import com.google.api.gax.rpc.TransportChannelProvider;
import com.google.api.gax.rpc.UnaryCallSettings;
import com.google.api.gax.rpc.UnaryCallable;
import com.google.auth.Credentials;
import com.google.cloud.simplecompute.v1.Address;
import com.google.cloud.simplecompute.v1.AddressAggregatedList;
import static com.google.cloud.simplecompute.v1.AddressClient.AggregatedListAddressesPagedResponse;
import static com.google.cloud.simplecompute.v1.AddressClient.ListAddressesPagedResponse;
import com.google.cloud.simplecompute.v1.AddressList;
import com.google.cloud.simplecompute.v1.AddressesScopedList;
import com.google.cloud.simplecompute.v1.AggregatedListAddressesHttpRequest;
import com.google.cloud.simplecompute.v1.DeleteAddressHttpRequest;
import com.google.cloud.simplecompute.v1.GetAddressHttpRequest;
import com.google.cloud.simplecompute.v1.InsertAddressHttpRequest;
import com.google.cloud.simplecompute.v1.ListAddressesHttpRequest;
import com.google.cloud.simplecompute.v1.Operation;
import com.google.cloud.simplecompute.v1.PatchAddressHttpRequest;
import com.google.cloud.simplecompute.v1.UpdateAddressHttpRequest;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import javax.annotation.Generated;
import org.threeten.bp.Duration;

// AUTO-GENERATED DOCUMENTATION AND CLASS
/**
 * Settings class to configure an instance of {@link AddressStub}.
 *
 * <p>The default instance has everything set to sensible defaults:
 *
 * <ul>
 * <li>The default service address (https://www.googleapis.com/compute/v1/projects/) and default port (443)
 * are used.
 * <li>Credentials are acquired automatically through Application Default Credentials.
 * <li>Retries are configured for idempotent methods but not for non-idempotent methods.
 * </ul>
 *
 * <p>The builder of this class is recursive, so contained classes are themselves builders.
 * When build() is called, the tree of builders is called to create the complete settings
 * object.
 *
 * For example, to set the total timeout of deleteAddress to 30 seconds:
 *
 * <pre>
 * <code>
 * AddressStubSettings.Builder addressSettingsBuilder =
 *     AddressStubSettings.newBuilder();
 * addressSettingsBuilder
 *     .deleteAddressSettings()
 *     .setRetrySettings(
 *         addressSettingsBuilder.deleteAddressSettings().getRetrySettings().toBuilder()
 *             .setTotalTimeout(Duration.ofSeconds(30))
 *             .build());
 * AddressStubSettings addressSettings = addressSettingsBuilder.build();
 * </code>
 * </pre>
 */
@Generated("by gapic-generator")
@BetaApi
public class AddressStubSettings extends StubSettings<AddressStubSettings> {
  /**
   * The default scopes of the service.
   */
  private static final ImmutableList<String> DEFAULT_SERVICE_SCOPES = ImmutableList.<String>builder()
      .add("https://www.googleapis.com/auth/cloud-platform")
      .add("https://www.googleapis.com/auth/compute")
      .add("https://www.googleapis.com/auth/compute.readonly")
      .add("https://www.googleapis.com/auth/devstorage.full_control")
      .build();

  private final PagedCallSettings<AggregatedListAddressesHttpRequest, AddressAggregatedList, AggregatedListAddressesPagedResponse> aggregatedListAddressesSettings;
  private final UnaryCallSettings<DeleteAddressHttpRequest, Operation> deleteAddressSettings;
  private final UnaryCallSettings<GetAddressHttpRequest, Address> getAddressSettings;
  private final UnaryCallSettings<InsertAddressHttpRequest, Operation> insertAddressSettings;
  private final PagedCallSettings<ListAddressesHttpRequest, AddressList, ListAddressesPagedResponse> listAddressesSettings;
  private final UnaryCallSettings<PatchAddressHttpRequest, Void> patchAddressSettings;
  private final UnaryCallSettings<UpdateAddressHttpRequest, Operation> updateAddressSettings;

  /**
   * Returns the object with the settings used for calls to aggregatedListAddresses.
   */
  public PagedCallSettings<AggregatedListAddressesHttpRequest, AddressAggregatedList, AggregatedListAddressesPagedResponse> aggregatedListAddressesSettings() {
    return aggregatedListAddressesSettings;
  }

  /**
   * Returns the object with the settings used for calls to deleteAddress.
   */
  public UnaryCallSettings<DeleteAddressHttpRequest, Operation> deleteAddressSettings() {
    return deleteAddressSettings;
  }

  /**
   * Returns the object with the settings used for calls to getAddress.
   */
  public UnaryCallSettings<GetAddressHttpRequest, Address> getAddressSettings() {
    return getAddressSettings;
  }

  /**
   * Returns the object with the settings used for calls to insertAddress.
   */
  public UnaryCallSettings<InsertAddressHttpRequest, Operation> insertAddressSettings() {
    return insertAddressSettings;
  }

  /**
   * Returns the object with the settings used for calls to listAddresses.
   */
  public PagedCallSettings<ListAddressesHttpRequest, AddressList, ListAddressesPagedResponse> listAddressesSettings() {
    return listAddressesSettings;
  }

  /**
   * Returns the object with the settings used for calls to patchAddress.
   */
  public UnaryCallSettings<PatchAddressHttpRequest, Void> patchAddressSettings() {
    return patchAddressSettings;
  }

  /**
   * Returns the object with the settings used for calls to updateAddress.
   */
  public UnaryCallSettings<UpdateAddressHttpRequest, Operation> updateAddressSettings() {
    return updateAddressSettings;
  }


  @BetaApi("A restructuring of stub classes is planned, so this may break in the future")
  public AddressStub createStub() throws IOException {
    if (getTransportChannelProvider()
        .getTransportName()
        .equals(HttpJsonTransportChannel.getHttpJsonTransportName())) {
      return HttpJsonAddressStub.create(this);
    } else {
      throw new UnsupportedOperationException(
          "Transport not supported: " + getTransportChannelProvider().getTransportName());
    }
  }

  /**
   * Returns a builder for the default ExecutorProvider for this service.
   */
  public static InstantiatingExecutorProvider.Builder defaultExecutorProviderBuilder() {
    return InstantiatingExecutorProvider.newBuilder();
  }

  /**
   * Returns the default service endpoint.
   */
  public static String getDefaultEndpoint() {
    return "https://www.googleapis.com/compute/v1/projects/";
  }

  /**
   * Returns the default service port.
   */
  public static int getDefaultServicePort() {
    return 443;
  }


  /**
   * Returns the default service scopes.
   */
  public static List<String> getDefaultServiceScopes() {
    return DEFAULT_SERVICE_SCOPES;
  }


  /**
   * Returns a builder for the default credentials for this service.
   */
  public static GoogleCredentialsProvider.Builder defaultCredentialsProviderBuilder() {
    return GoogleCredentialsProvider.newBuilder()
        .setScopesToApply(DEFAULT_SERVICE_SCOPES)
        ;
  }

  /** Returns a builder for the default ChannelProvider for this service. */
  public static InstantiatingHttpJsonChannelProvider.Builder defaultHttpJsonTransportProviderBuilder() {
    return InstantiatingHttpJsonChannelProvider.newBuilder();
  }

  public static TransportChannelProvider defaultTransportChannelProvider() {
    return defaultHttpJsonTransportProviderBuilder().build();
  }

  @BetaApi("The surface for customizing headers is not stable yet and may change in the future.")
  public static ApiClientHeaderProvider.Builder defaultApiClientHeaderProviderBuilder() {
    return ApiClientHeaderProvider.newBuilder()
        .setGeneratedLibToken("gapic", GaxProperties.getLibraryVersion(AddressStubSettings.class))
        .setTransportToken(GaxHttpJsonProperties.getHttpJsonTokenName(), GaxHttpJsonProperties.getHttpJsonVersion());
  }

  /**
   * Returns a new builder for this class.
   */
  public static Builder newBuilder() {
    return Builder.createDefault();
  }

  /**
   * Returns a new builder for this class.
   */
  public static Builder newBuilder(ClientContext clientContext) {
    return new Builder(clientContext);
  }

  /**
   * Returns a builder containing all the values of this settings class.
   */
  public Builder toBuilder() {
    return new Builder(this);
  }

  protected AddressStubSettings(Builder settingsBuilder) throws IOException {
    super(settingsBuilder);

    aggregatedListAddressesSettings = settingsBuilder.aggregatedListAddressesSettings().build();
    deleteAddressSettings = settingsBuilder.deleteAddressSettings().build();
    getAddressSettings = settingsBuilder.getAddressSettings().build();
    insertAddressSettings = settingsBuilder.insertAddressSettings().build();
    listAddressesSettings = settingsBuilder.listAddressesSettings().build();
    patchAddressSettings = settingsBuilder.patchAddressSettings().build();
    updateAddressSettings = settingsBuilder.updateAddressSettings().build();
  }

  private static final PagedListDescriptor<AggregatedListAddressesHttpRequest, AddressAggregatedList, AddressesScopedList> AGGREGATED_LIST_ADDRESSES_PAGE_STR_DESC =
      new PagedListDescriptor<AggregatedListAddressesHttpRequest, AddressAggregatedList, AddressesScopedList>() {
        @Override
        public String emptyToken() {
          return "";
        }
        @Override
        public AggregatedListAddressesHttpRequest injectToken(AggregatedListAddressesHttpRequest payload, String token) {
          return AggregatedListAddressesHttpRequest
            .newBuilder(payload)
            .setPageToken(token)
            .build();
        }
        @Override
        public AggregatedListAddressesHttpRequest injectPageSize(AggregatedListAddressesHttpRequest payload, int pageSize) {
          return AggregatedListAddressesHttpRequest
            .newBuilder(payload)
            .setMaxResults(pageSize)
            .build();
        }
        @Override
        public Integer extractPageSize(AggregatedListAddressesHttpRequest payload) {
          return payload.getMaxResults();
        }
        @Override
        public String extractNextToken(AddressAggregatedList payload) {
          return payload.getNextPageToken();
        }
        @Override
        public Iterable<AddressesScopedList> extractResources(AddressAggregatedList payload) {
          return payload.getItemsMap() != null ? payload.getItemsMap().values() :
            ImmutableList.<AddressesScopedList>of();
        }
      };

  private static final PagedListDescriptor<ListAddressesHttpRequest, AddressList, Address> LIST_ADDRESSES_PAGE_STR_DESC =
      new PagedListDescriptor<ListAddressesHttpRequest, AddressList, Address>() {
        @Override
        public String emptyToken() {
          return "";
        }
        @Override
        public ListAddressesHttpRequest injectToken(ListAddressesHttpRequest payload, String token) {
          return ListAddressesHttpRequest
            .newBuilder(payload)
            .setPageToken(token)
            .build();
        }
        @Override
        public ListAddressesHttpRequest injectPageSize(ListAddressesHttpRequest payload, int pageSize) {
          return ListAddressesHttpRequest
            .newBuilder(payload)
            .setMaxResults(pageSize)
            .build();
        }
        @Override
        public Integer extractPageSize(ListAddressesHttpRequest payload) {
          return payload.getMaxResults();
        }
        @Override
        public String extractNextToken(AddressList payload) {
          return payload.getNextPageToken();
        }
        @Override
        public Iterable<Address> extractResources(AddressList payload) {
          return payload.getItemsList() != null ? payload.getItemsList() :
            ImmutableList.<Address>of();
        }
      };

  private static final PagedListResponseFactory<AggregatedListAddressesHttpRequest, AddressAggregatedList, AggregatedListAddressesPagedResponse> AGGREGATED_LIST_ADDRESSES_PAGE_STR_FACT =
      new PagedListResponseFactory<AggregatedListAddressesHttpRequest, AddressAggregatedList, AggregatedListAddressesPagedResponse>() {
        @Override
        public ApiFuture<AggregatedListAddressesPagedResponse> getFuturePagedResponse(
            UnaryCallable<AggregatedListAddressesHttpRequest, AddressAggregatedList> callable,
            AggregatedListAddressesHttpRequest request,
            ApiCallContext context,
            ApiFuture<AddressAggregatedList> futureResponse) {
          PageContext<AggregatedListAddressesHttpRequest, AddressAggregatedList, AddressesScopedList> pageContext =
              PageContext.create(callable, AGGREGATED_LIST_ADDRESSES_PAGE_STR_DESC, request, context);
          return AggregatedListAddressesPagedResponse.createAsync(pageContext, futureResponse);
        }
      };

  private static final PagedListResponseFactory<ListAddressesHttpRequest, AddressList, ListAddressesPagedResponse> LIST_ADDRESSES_PAGE_STR_FACT =
      new PagedListResponseFactory<ListAddressesHttpRequest, AddressList, ListAddressesPagedResponse>() {
        @Override
        public ApiFuture<ListAddressesPagedResponse> getFuturePagedResponse(
            UnaryCallable<ListAddressesHttpRequest, AddressList> callable,
            ListAddressesHttpRequest request,
            ApiCallContext context,
            ApiFuture<AddressList> futureResponse) {
          PageContext<ListAddressesHttpRequest, AddressList, Address> pageContext =
              PageContext.create(callable, LIST_ADDRESSES_PAGE_STR_DESC, request, context);
          return ListAddressesPagedResponse.createAsync(pageContext, futureResponse);
        }
      };


  /**
   * Builder for AddressStubSettings.
   */
  public static class Builder extends StubSettings.Builder<AddressStubSettings, Builder> {
    private final ImmutableList<UnaryCallSettings.Builder<?, ?>> unaryMethodSettingsBuilders;

    private final PagedCallSettings.Builder<AggregatedListAddressesHttpRequest, AddressAggregatedList, AggregatedListAddressesPagedResponse> aggregatedListAddressesSettings;
    private final UnaryCallSettings.Builder<DeleteAddressHttpRequest, Operation> deleteAddressSettings;
    private final UnaryCallSettings.Builder<GetAddressHttpRequest, Address> getAddressSettings;
    private final UnaryCallSettings.Builder<InsertAddressHttpRequest, Operation> insertAddressSettings;
    private final PagedCallSettings.Builder<ListAddressesHttpRequest, AddressList, ListAddressesPagedResponse> listAddressesSettings;
    private final UnaryCallSettings.Builder<PatchAddressHttpRequest, Void> patchAddressSettings;
    private final UnaryCallSettings.Builder<UpdateAddressHttpRequest, Operation> updateAddressSettings;

    private static final ImmutableMap<String, ImmutableSet<StatusCode.Code>> RETRYABLE_CODE_DEFINITIONS;

    static {
      ImmutableMap.Builder<String, ImmutableSet<StatusCode.Code>> definitions = ImmutableMap.builder();
      definitions.put(
          "idempotent",
          ImmutableSet.copyOf(Lists.<StatusCode.Code>newArrayList(StatusCode.Code.DEADLINE_EXCEEDED, StatusCode.Code.UNAVAILABLE)));
      definitions.put(
          "non_idempotent",
          ImmutableSet.copyOf(Lists.<StatusCode.Code>newArrayList()));
      RETRYABLE_CODE_DEFINITIONS = definitions.build();
    }

    private static final ImmutableMap<String, RetrySettings> RETRY_PARAM_DEFINITIONS;

    static {
      ImmutableMap.Builder<String, RetrySettings> definitions = ImmutableMap.builder();
      RetrySettings settings = null;
      settings = RetrySettings.newBuilder()
          .setInitialRetryDelay(Duration.ofMillis(100L))
          .setRetryDelayMultiplier(1.3)
          .setMaxRetryDelay(Duration.ofMillis(60000L))
          .setInitialRpcTimeout(Duration.ofMillis(20000L))
          .setRpcTimeoutMultiplier(1.0)
          .setMaxRpcTimeout(Duration.ofMillis(20000L))
          .setTotalTimeout(Duration.ofMillis(600000L))
          .build();
      definitions.put("default", settings);
      RETRY_PARAM_DEFINITIONS = definitions.build();
    }

    protected Builder() {
      this((ClientContext) null);
    }

    protected Builder(ClientContext clientContext) {
      super(clientContext);

      aggregatedListAddressesSettings = PagedCallSettings.newBuilder(
          AGGREGATED_LIST_ADDRESSES_PAGE_STR_FACT);

      deleteAddressSettings = UnaryCallSettings.newUnaryCallSettingsBuilder();

      getAddressSettings = UnaryCallSettings.newUnaryCallSettingsBuilder();

      insertAddressSettings = UnaryCallSettings.newUnaryCallSettingsBuilder();

      listAddressesSettings = PagedCallSettings.newBuilder(
          LIST_ADDRESSES_PAGE_STR_FACT);

      patchAddressSettings = UnaryCallSettings.newUnaryCallSettingsBuilder();

      updateAddressSettings = UnaryCallSettings.newUnaryCallSettingsBuilder();

      unaryMethodSettingsBuilders = ImmutableList.<UnaryCallSettings.Builder<?, ?>>of(
          aggregatedListAddressesSettings,
          deleteAddressSettings,
          getAddressSettings,
          insertAddressSettings,
          listAddressesSettings,
          patchAddressSettings,
          updateAddressSettings
      );

      initDefaults(this);
    }

    private static Builder createDefault() {
      Builder builder = new Builder((ClientContext) null);
      builder.setTransportChannelProvider(defaultTransportChannelProvider());
      builder.setCredentialsProvider(defaultCredentialsProviderBuilder().build());
      builder.setInternalHeaderProvider(defaultApiClientHeaderProviderBuilder().build());
      builder.setEndpoint(getDefaultEndpoint());
      return initDefaults(builder);
    }

    private static Builder initDefaults(Builder builder) {

      builder.aggregatedListAddressesSettings()
          .setRetryableCodes(RETRYABLE_CODE_DEFINITIONS.get("idempotent"))
          .setRetrySettings(RETRY_PARAM_DEFINITIONS.get("default"));

      builder.deleteAddressSettings()
          .setRetryableCodes(RETRYABLE_CODE_DEFINITIONS.get("idempotent"))
          .setRetrySettings(RETRY_PARAM_DEFINITIONS.get("default"));

      builder.getAddressSettings()
          .setRetryableCodes(RETRYABLE_CODE_DEFINITIONS.get("idempotent"))
          .setRetrySettings(RETRY_PARAM_DEFINITIONS.get("default"));

      builder.insertAddressSettings()
          .setRetryableCodes(RETRYABLE_CODE_DEFINITIONS.get("non_idempotent"))
          .setRetrySettings(RETRY_PARAM_DEFINITIONS.get("default"));

      builder.listAddressesSettings()
          .setRetryableCodes(RETRYABLE_CODE_DEFINITIONS.get("idempotent"))
          .setRetrySettings(RETRY_PARAM_DEFINITIONS.get("default"));

      builder.patchAddressSettings()
          .setRetryableCodes(RETRYABLE_CODE_DEFINITIONS.get("non_idempotent"))
          .setRetrySettings(RETRY_PARAM_DEFINITIONS.get("default"));

      builder.updateAddressSettings()
          .setRetryableCodes(RETRYABLE_CODE_DEFINITIONS.get("idempotent"))
          .setRetrySettings(RETRY_PARAM_DEFINITIONS.get("default"));

      return builder;
    }

    protected Builder(AddressStubSettings settings) {
      super(settings);

      aggregatedListAddressesSettings = settings.aggregatedListAddressesSettings.toBuilder();
      deleteAddressSettings = settings.deleteAddressSettings.toBuilder();
      getAddressSettings = settings.getAddressSettings.toBuilder();
      insertAddressSettings = settings.insertAddressSettings.toBuilder();
      listAddressesSettings = settings.listAddressesSettings.toBuilder();
      patchAddressSettings = settings.patchAddressSettings.toBuilder();
      updateAddressSettings = settings.updateAddressSettings.toBuilder();

      unaryMethodSettingsBuilders = ImmutableList.<UnaryCallSettings.Builder<?, ?>>of(
          aggregatedListAddressesSettings,
          deleteAddressSettings,
          getAddressSettings,
          insertAddressSettings,
          listAddressesSettings,
          patchAddressSettings,
          updateAddressSettings
      );
    }

    // NEXT_MAJOR_VER: remove 'throws Exception'
    /**
     * Applies the given settings updater function to all of the unary API methods in this service.
     *
     * Note: This method does not support applying settings to streaming methods.
     */
    public Builder applyToAllUnaryMethods(ApiFunction<UnaryCallSettings.Builder<?, ?>, Void> settingsUpdater) throws Exception {
      super.applyToAllUnaryMethods(unaryMethodSettingsBuilders, settingsUpdater);
      return this;
    }

    public ImmutableList<UnaryCallSettings.Builder<?, ?>> unaryMethodSettingsBuilders() {
      return unaryMethodSettingsBuilders;
    }

    /**
     * Returns the builder for the settings used for calls to aggregatedListAddresses.
     */
    public PagedCallSettings.Builder<AggregatedListAddressesHttpRequest, AddressAggregatedList, AggregatedListAddressesPagedResponse> aggregatedListAddressesSettings() {
      return aggregatedListAddressesSettings;
    }

    /**
     * Returns the builder for the settings used for calls to deleteAddress.
     */
    public UnaryCallSettings.Builder<DeleteAddressHttpRequest, Operation> deleteAddressSettings() {
      return deleteAddressSettings;
    }

    /**
     * Returns the builder for the settings used for calls to getAddress.
     */
    public UnaryCallSettings.Builder<GetAddressHttpRequest, Address> getAddressSettings() {
      return getAddressSettings;
    }

    /**
     * Returns the builder for the settings used for calls to insertAddress.
     */
    public UnaryCallSettings.Builder<InsertAddressHttpRequest, Operation> insertAddressSettings() {
      return insertAddressSettings;
    }

    /**
     * Returns the builder for the settings used for calls to listAddresses.
     */
    public PagedCallSettings.Builder<ListAddressesHttpRequest, AddressList, ListAddressesPagedResponse> listAddressesSettings() {
      return listAddressesSettings;
    }

    /**
     * Returns the builder for the settings used for calls to patchAddress.
     */
    public UnaryCallSettings.Builder<PatchAddressHttpRequest, Void> patchAddressSettings() {
      return patchAddressSettings;
    }

    /**
     * Returns the builder for the settings used for calls to updateAddress.
     */
    public UnaryCallSettings.Builder<UpdateAddressHttpRequest, Operation> updateAddressSettings() {
      return updateAddressSettings;
    }

    @Override
    public AddressStubSettings build() throws IOException {
      return new AddressStubSettings(this);
    }
  }
}
============== file: src/main/java/com/google/cloud/simplecompute/v1/stub/AddressStub.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1.stub;

import com.google.api.core.BetaApi;
import com.google.api.gax.core.BackgroundResource;
import com.google.api.gax.rpc.UnaryCallable;
import com.google.cloud.simplecompute.v1.Address;
import com.google.cloud.simplecompute.v1.AddressAggregatedList;
import static com.google.cloud.simplecompute.v1.AddressClient.AggregatedListAddressesPagedResponse;
import static com.google.cloud.simplecompute.v1.AddressClient.ListAddressesPagedResponse;
import com.google.cloud.simplecompute.v1.AddressList;
import com.google.cloud.simplecompute.v1.AddressesScopedList;
import com.google.cloud.simplecompute.v1.AggregatedListAddressesHttpRequest;
import com.google.cloud.simplecompute.v1.DeleteAddressHttpRequest;
import com.google.cloud.simplecompute.v1.GetAddressHttpRequest;
import com.google.cloud.simplecompute.v1.InsertAddressHttpRequest;
import com.google.cloud.simplecompute.v1.ListAddressesHttpRequest;
import com.google.cloud.simplecompute.v1.Operation;
import com.google.cloud.simplecompute.v1.PatchAddressHttpRequest;
import com.google.cloud.simplecompute.v1.ProjectGlobalAddressName;
import com.google.cloud.simplecompute.v1.ProjectName;
import com.google.cloud.simplecompute.v1.ProjectRegionAddressName;
import com.google.cloud.simplecompute.v1.ProjectRegionName;
import com.google.cloud.simplecompute.v1.UpdateAddressHttpRequest;
import java.util.List;
import javax.annotation.Generated;

// AUTO-GENERATED DOCUMENTATION AND CLASS
/**
 * Base stub class for simplecompute.
 *
 * <p>This class is for advanced usage and reflects the underlying API directly.
 */
@Generated("by gapic-generator")
@BetaApi("A restructuring of stub classes is planned, so this may break in the future")
public abstract class AddressStub implements BackgroundResource {


  @BetaApi
  public UnaryCallable<AggregatedListAddressesHttpRequest, AggregatedListAddressesPagedResponse> aggregatedListAddressesPagedCallable() {
    throw new UnsupportedOperationException("Not implemented: aggregatedListAddressesPagedCallable()");
  }

  @BetaApi
  public UnaryCallable<AggregatedListAddressesHttpRequest, AddressAggregatedList> aggregatedListAddressesCallable() {
    throw new UnsupportedOperationException("Not implemented: aggregatedListAddressesCallable()");
  }

  @BetaApi
  public UnaryCallable<DeleteAddressHttpRequest, Operation> deleteAddressCallable() {
    throw new UnsupportedOperationException("Not implemented: deleteAddressCallable()");
  }

  @BetaApi
  public UnaryCallable<GetAddressHttpRequest, Address> getAddressCallable() {
    throw new UnsupportedOperationException("Not implemented: getAddressCallable()");
  }

  @BetaApi
  public UnaryCallable<InsertAddressHttpRequest, Operation> insertAddressCallable() {
    throw new UnsupportedOperationException("Not implemented: insertAddressCallable()");
  }

  @BetaApi
  public UnaryCallable<ListAddressesHttpRequest, ListAddressesPagedResponse> listAddressesPagedCallable() {
    throw new UnsupportedOperationException("Not implemented: listAddressesPagedCallable()");
  }

  @BetaApi
  public UnaryCallable<ListAddressesHttpRequest, AddressList> listAddressesCallable() {
    throw new UnsupportedOperationException("Not implemented: listAddressesCallable()");
  }

  @BetaApi
  public UnaryCallable<PatchAddressHttpRequest, Void> patchAddressCallable() {
    throw new UnsupportedOperationException("Not implemented: patchAddressCallable()");
  }

  @BetaApi
  public UnaryCallable<UpdateAddressHttpRequest, Operation> updateAddressCallable() {
    throw new UnsupportedOperationException("Not implemented: updateAddressCallable()");
  }

  @Override
  public abstract void close();
}
============== file: src/main/java/com/google/cloud/simplecompute/v1/stub/HttpJsonAddressStub.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1.stub;

import com.google.api.client.http.HttpMethods;
import com.google.api.core.BetaApi;
import com.google.api.core.InternalApi;
import com.google.api.gax.core.BackgroundResource;
import com.google.api.gax.core.BackgroundResourceAggregation;
import com.google.api.gax.httpjson.ApiMessageHttpRequestFormatter;
import com.google.api.gax.httpjson.ApiMessageHttpResponseParser;
import com.google.api.gax.httpjson.ApiMethodDescriptor;
import com.google.api.gax.httpjson.HttpJsonCallSettings;
import com.google.api.gax.httpjson.HttpJsonStubCallableFactory;
import com.google.api.gax.rpc.ClientContext;
import com.google.api.gax.rpc.RequestParamsExtractor;
import com.google.api.gax.rpc.UnaryCallable;
import com.google.api.pathtemplate.PathTemplate;
import com.google.cloud.simplecompute.v1.Address;
import com.google.cloud.simplecompute.v1.AddressAggregatedList;
import static com.google.cloud.simplecompute.v1.AddressClient.AggregatedListAddressesPagedResponse;
import static com.google.cloud.simplecompute.v1.AddressClient.ListAddressesPagedResponse;
import com.google.cloud.simplecompute.v1.AddressList;
import com.google.cloud.simplecompute.v1.AddressSettings;
import com.google.cloud.simplecompute.v1.AddressesScopedList;
import com.google.cloud.simplecompute.v1.AggregatedListAddressesHttpRequest;
import com.google.cloud.simplecompute.v1.DeleteAddressHttpRequest;
import com.google.cloud.simplecompute.v1.GetAddressHttpRequest;
import com.google.cloud.simplecompute.v1.InsertAddressHttpRequest;
import com.google.cloud.simplecompute.v1.ListAddressesHttpRequest;
import com.google.cloud.simplecompute.v1.Operation;
import com.google.cloud.simplecompute.v1.PatchAddressHttpRequest;
import com.google.cloud.simplecompute.v1.ProjectGlobalAddressName;
import com.google.cloud.simplecompute.v1.ProjectName;
import com.google.cloud.simplecompute.v1.ProjectRegionAddressName;
import com.google.cloud.simplecompute.v1.ProjectRegionName;
import com.google.cloud.simplecompute.v1.UpdateAddressHttpRequest;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Sets;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import javax.annotation.Generated;

// AUTO-GENERATED DOCUMENTATION AND CLASS
/**
 * HTTP stub implementation for simplecompute.
 *
 * <p>This class is for advanced usage and reflects the underlying API directly.
 */
@Generated("by gapic-generator")
@BetaApi("A restructuring of stub classes is planned, so this may break in the future")
public class HttpJsonAddressStub extends AddressStub {
  @InternalApi
  public static final ApiMethodDescriptor<AggregatedListAddressesHttpRequest, AddressAggregatedList> aggregatedListAddressesMethodDescriptor =
      ApiMethodDescriptor.<AggregatedListAddressesHttpRequest, AddressAggregatedList>newBuilder()
          .setFullMethodName("compute.addresses.aggregatedList")
          .setHttpMethod(HttpMethods.GET)
          .setRequestFormatter(
              ApiMessageHttpRequestFormatter.<AggregatedListAddressesHttpRequest>newBuilder()
                  .setPathTemplate(PathTemplate.create("{project}/aggregated/addresses"))
                  .setQueryParams(Sets.<String>newHashSet(
                                     "filter",    "maxResults",    "orderBy",    "pageToken"
                                     ))
                  .setResourceNameFactory(ProjectName.newFactory())
                  .setResourceNameField("project")
                  .build())
          .setResponseParser(
              ApiMessageHttpResponseParser.<AddressAggregatedList>newBuilder()
                  .setResponseInstance(AddressAggregatedList.getDefaultInstance())
                  .build())
          .build();
  @InternalApi
  public static final ApiMethodDescriptor<DeleteAddressHttpRequest, Operation> deleteAddressMethodDescriptor =
      ApiMethodDescriptor.<DeleteAddressHttpRequest, Operation>newBuilder()
          .setFullMethodName("compute.addresses.delete")
          .setHttpMethod(HttpMethods.DELETE)
          .setRequestFormatter(
              ApiMessageHttpRequestFormatter.<DeleteAddressHttpRequest>newBuilder()
                  .setPathTemplate(PathTemplate.create("{project}/regions/{region}/addresses/{address}"))
                  .setQueryParams(Sets.<String>newHashSet(
                                     ))
                  .setResourceNameFactory(ProjectRegionAddressName.newFactory())
                  .setResourceNameField("address")
                  .build())
          .setResponseParser(
              ApiMessageHttpResponseParser.<Operation>newBuilder()
                  .setResponseInstance(Operation.getDefaultInstance())
                  .build())
          .build();
  @InternalApi
  public static final ApiMethodDescriptor<GetAddressHttpRequest, Address> getAddressMethodDescriptor =
      ApiMethodDescriptor.<GetAddressHttpRequest, Address>newBuilder()
          .setFullMethodName("compute.addresses.get")
          .setHttpMethod(HttpMethods.GET)
          .setRequestFormatter(
              ApiMessageHttpRequestFormatter.<GetAddressHttpRequest>newBuilder()
                  .setPathTemplate(PathTemplate.create("{project}/regions/{region}/addresses/{address}"))
                  .setQueryParams(Sets.<String>newHashSet(
                                     ))
                  .setResourceNameFactory(ProjectRegionAddressName.newFactory())
                  .setResourceNameField("address")
                  .build())
          .setResponseParser(
              ApiMessageHttpResponseParser.<Address>newBuilder()
                  .setResponseInstance(Address.getDefaultInstance())
                  .build())
          .build();
  @InternalApi
  public static final ApiMethodDescriptor<InsertAddressHttpRequest, Operation> insertAddressMethodDescriptor =
      ApiMethodDescriptor.<InsertAddressHttpRequest, Operation>newBuilder()
          .setFullMethodName("compute.addresses.insert")
          .setHttpMethod(HttpMethods.POST)
          .setRequestFormatter(
              ApiMessageHttpRequestFormatter.<InsertAddressHttpRequest>newBuilder()
                  .setPathTemplate(PathTemplate.create("{project}/regions/{region}/addresses"))
                  .setQueryParams(Sets.<String>newHashSet(
                                     ))
                  .setResourceNameFactory(ProjectRegionName.newFactory())
                  .setResourceNameField("region")
                  .build())
          .setResponseParser(
              ApiMessageHttpResponseParser.<Operation>newBuilder()
                  .setResponseInstance(Operation.getDefaultInstance())
                  .build())
          .build();
  @InternalApi
  public static final ApiMethodDescriptor<ListAddressesHttpRequest, AddressList> listAddressesMethodDescriptor =
      ApiMethodDescriptor.<ListAddressesHttpRequest, AddressList>newBuilder()
          .setFullMethodName("compute.addresses.list")
          .setHttpMethod(HttpMethods.GET)
          .setRequestFormatter(
              ApiMessageHttpRequestFormatter.<ListAddressesHttpRequest>newBuilder()
                  .setPathTemplate(PathTemplate.create("{project}/regions/{region}/addresses"))
                  .setQueryParams(Sets.<String>newHashSet(
                                     "filter",    "maxResults",    "orderBy",    "pageToken"
                                     ))
                  .setResourceNameFactory(ProjectRegionName.newFactory())
                  .setResourceNameField("region")
                  .build())
          .setResponseParser(
              ApiMessageHttpResponseParser.<AddressList>newBuilder()
                  .setResponseInstance(AddressList.getDefaultInstance())
                  .build())
          .build();
  @InternalApi
  public static final ApiMethodDescriptor<PatchAddressHttpRequest, Void> patchAddressMethodDescriptor =
      ApiMethodDescriptor.<PatchAddressHttpRequest, Void>newBuilder()
          .setFullMethodName("compute.addresses.patch")
          .setHttpMethod(HttpMethods.PATCH)
          .setRequestFormatter(
              ApiMessageHttpRequestFormatter.<PatchAddressHttpRequest>newBuilder()
                  .setPathTemplate(PathTemplate.create("{project}/regions/{region}/addresses"))
                  .setQueryParams(Sets.<String>newHashSet(
                                     "address",    "requestId"
                                     ))
                  .setResourceNameFactory(ProjectRegionName.newFactory())
                  .setResourceNameField("region")
                  .build())
          .build();
  @InternalApi
  public static final ApiMethodDescriptor<UpdateAddressHttpRequest, Operation> updateAddressMethodDescriptor =
      ApiMethodDescriptor.<UpdateAddressHttpRequest, Operation>newBuilder()
          .setFullMethodName("compute.addresses.update")
          .setHttpMethod(HttpMethods.PUT)
          .setRequestFormatter(
              ApiMessageHttpRequestFormatter.<UpdateAddressHttpRequest>newBuilder()
                  .setPathTemplate(PathTemplate.create("{project}/global/addresses/{address}"))
                  .setQueryParams(Sets.<String>newHashSet(
                                     "requestId"
                                     ))
                  .setResourceNameFactory(ProjectGlobalAddressName.newFactory())
                  .setResourceNameField("address")
                  .build())
          .setResponseParser(
              ApiMessageHttpResponseParser.<Operation>newBuilder()
                  .setResponseInstance(Operation.getDefaultInstance())
                  .build())
          .build();
  private final BackgroundResource backgroundResources;

  private final UnaryCallable<AggregatedListAddressesHttpRequest, AddressAggregatedList> aggregatedListAddressesCallable;
  private final UnaryCallable<AggregatedListAddressesHttpRequest, AggregatedListAddressesPagedResponse> aggregatedListAddressesPagedCallable;
  private final UnaryCallable<DeleteAddressHttpRequest, Operation> deleteAddressCallable;
  private final UnaryCallable<GetAddressHttpRequest, Address> getAddressCallable;
  private final UnaryCallable<InsertAddressHttpRequest, Operation> insertAddressCallable;
  private final UnaryCallable<ListAddressesHttpRequest, AddressList> listAddressesCallable;
  private final UnaryCallable<ListAddressesHttpRequest, ListAddressesPagedResponse> listAddressesPagedCallable;
  private final UnaryCallable<PatchAddressHttpRequest, Void> patchAddressCallable;
  private final UnaryCallable<UpdateAddressHttpRequest, Operation> updateAddressCallable;

  private final HttpJsonStubCallableFactory callableFactory;
  public static final HttpJsonAddressStub create(AddressStubSettings settings) throws IOException {
    return new HttpJsonAddressStub(settings, ClientContext.create(settings));
  }

  public static final HttpJsonAddressStub create(ClientContext clientContext) throws IOException {
    return new HttpJsonAddressStub(AddressStubSettings.newBuilder().build(), clientContext);
  }

  public static final HttpJsonAddressStub create(ClientContext clientContext, HttpJsonStubCallableFactory callableFactory) throws IOException {
    return new HttpJsonAddressStub(AddressStubSettings.newBuilder().build(), clientContext, callableFactory);
  }

  /**
   * Constructs an instance of HttpJsonAddressStub, using the given settings.
   * This is protected so that it is easy to make a subclass, but otherwise, the static
   * factory methods should be preferred.
   */
  protected HttpJsonAddressStub(AddressStubSettings settings, ClientContext clientContext) throws IOException {
    this(settings, clientContext, new HttpJsonAddressCallableFactory());
  }

  /**
   * Constructs an instance of HttpJsonAddressStub, using the given settings.
   * This is protected so that it is easy to make a subclass, but otherwise, the static
   * factory methods should be preferred.
   */
  protected HttpJsonAddressStub(AddressStubSettings settings, ClientContext clientContext, HttpJsonStubCallableFactory callableFactory) throws IOException {
    this.callableFactory = callableFactory;

    HttpJsonCallSettings<AggregatedListAddressesHttpRequest, AddressAggregatedList> aggregatedListAddressesTransportSettings =
        HttpJsonCallSettings.<AggregatedListAddressesHttpRequest, AddressAggregatedList>newBuilder()
            .setMethodDescriptor(aggregatedListAddressesMethodDescriptor)
            .build();
    HttpJsonCallSettings<DeleteAddressHttpRequest, Operation> deleteAddressTransportSettings =
        HttpJsonCallSettings.<DeleteAddressHttpRequest, Operation>newBuilder()
            .setMethodDescriptor(deleteAddressMethodDescriptor)
            .build();
    HttpJsonCallSettings<GetAddressHttpRequest, Address> getAddressTransportSettings =
        HttpJsonCallSettings.<GetAddressHttpRequest, Address>newBuilder()
            .setMethodDescriptor(getAddressMethodDescriptor)
            .build();
    HttpJsonCallSettings<InsertAddressHttpRequest, Operation> insertAddressTransportSettings =
        HttpJsonCallSettings.<InsertAddressHttpRequest, Operation>newBuilder()
            .setMethodDescriptor(insertAddressMethodDescriptor)
            .build();
    HttpJsonCallSettings<ListAddressesHttpRequest, AddressList> listAddressesTransportSettings =
        HttpJsonCallSettings.<ListAddressesHttpRequest, AddressList>newBuilder()
            .setMethodDescriptor(listAddressesMethodDescriptor)
            .build();
    HttpJsonCallSettings<PatchAddressHttpRequest, Void> patchAddressTransportSettings =
        HttpJsonCallSettings.<PatchAddressHttpRequest, Void>newBuilder()
            .setMethodDescriptor(patchAddressMethodDescriptor)
            .build();
    HttpJsonCallSettings<UpdateAddressHttpRequest, Operation> updateAddressTransportSettings =
        HttpJsonCallSettings.<UpdateAddressHttpRequest, Operation>newBuilder()
            .setMethodDescriptor(updateAddressMethodDescriptor)
            .build();

    this.aggregatedListAddressesCallable = callableFactory.createUnaryCallable(aggregatedListAddressesTransportSettings,settings.aggregatedListAddressesSettings(), clientContext);
    this.aggregatedListAddressesPagedCallable = callableFactory.createPagedCallable(aggregatedListAddressesTransportSettings,settings.aggregatedListAddressesSettings(), clientContext);
    this.deleteAddressCallable = callableFactory.createUnaryCallable(deleteAddressTransportSettings,settings.deleteAddressSettings(), clientContext);
    this.getAddressCallable = callableFactory.createUnaryCallable(getAddressTransportSettings,settings.getAddressSettings(), clientContext);
    this.insertAddressCallable = callableFactory.createUnaryCallable(insertAddressTransportSettings,settings.insertAddressSettings(), clientContext);
    this.listAddressesCallable = callableFactory.createUnaryCallable(listAddressesTransportSettings,settings.listAddressesSettings(), clientContext);
    this.listAddressesPagedCallable = callableFactory.createPagedCallable(listAddressesTransportSettings,settings.listAddressesSettings(), clientContext);
    this.patchAddressCallable = callableFactory.createUnaryCallable(patchAddressTransportSettings,settings.patchAddressSettings(), clientContext);
    this.updateAddressCallable = callableFactory.createUnaryCallable(updateAddressTransportSettings,settings.updateAddressSettings(), clientContext);

    backgroundResources = new BackgroundResourceAggregation(clientContext.getBackgroundResources());
  }

  @BetaApi
  public UnaryCallable<AggregatedListAddressesHttpRequest, AggregatedListAddressesPagedResponse> aggregatedListAddressesPagedCallable() {
    return aggregatedListAddressesPagedCallable;
  }

  @BetaApi
  public UnaryCallable<AggregatedListAddressesHttpRequest, AddressAggregatedList> aggregatedListAddressesCallable() {
    return aggregatedListAddressesCallable;
  }

  @BetaApi
  public UnaryCallable<DeleteAddressHttpRequest, Operation> deleteAddressCallable() {
    return deleteAddressCallable;
  }

  @BetaApi
  public UnaryCallable<GetAddressHttpRequest, Address> getAddressCallable() {
    return getAddressCallable;
  }

  @BetaApi
  public UnaryCallable<InsertAddressHttpRequest, Operation> insertAddressCallable() {
    return insertAddressCallable;
  }

  @BetaApi
  public UnaryCallable<ListAddressesHttpRequest, ListAddressesPagedResponse> listAddressesPagedCallable() {
    return listAddressesPagedCallable;
  }

  @BetaApi
  public UnaryCallable<ListAddressesHttpRequest, AddressList> listAddressesCallable() {
    return listAddressesCallable;
  }

  @BetaApi
  public UnaryCallable<PatchAddressHttpRequest, Void> patchAddressCallable() {
    return patchAddressCallable;
  }

  @BetaApi
  public UnaryCallable<UpdateAddressHttpRequest, Operation> updateAddressCallable() {
    return updateAddressCallable;
  }

  @Override
  public final void close() {
    shutdown();
  }

  @Override
  public void shutdown() {
    backgroundResources.shutdown();
  }

  @Override
  public boolean isShutdown() {
    return backgroundResources.isShutdown();
  }

  @Override
  public boolean isTerminated() {
    return backgroundResources.isTerminated();
  }

  @Override
  public void shutdownNow() {
    backgroundResources.shutdownNow();
  }

  @Override
  public boolean awaitTermination(long duration, TimeUnit unit) throws InterruptedException {
    return backgroundResources.awaitTermination(duration, unit);
  }

}
============== file: src/main/java/com/google/cloud/simplecompute/v1/stub/HttpJsonAddressCallableFactory.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1.stub;

import com.google.api.client.http.HttpMethods;
import com.google.api.core.BetaApi;
import com.google.api.core.InternalApi;
import com.google.api.gax.core.BackgroundResource;
import com.google.api.gax.core.BackgroundResourceAggregation;
import com.google.api.gax.httpjson.ApiMessage;
import com.google.api.gax.httpjson.ApiMessageHttpRequestFormatter;
import com.google.api.gax.httpjson.ApiMessageHttpResponseParser;
import com.google.api.gax.httpjson.ApiMethodDescriptor;
import com.google.api.gax.httpjson.HttpJsonCallSettings;
import com.google.api.gax.httpjson.HttpJsonCallableFactory;
import com.google.api.gax.httpjson.HttpJsonStubCallableFactory;
import com.google.api.gax.rpc.BatchingCallSettings;
import com.google.api.gax.rpc.BidiStreamingCallable;
import com.google.api.gax.rpc.ClientContext;
import com.google.api.gax.rpc.ClientStreamingCallable;
import com.google.api.gax.rpc.OperationCallSettings;
import com.google.api.gax.rpc.OperationCallable;
import com.google.api.gax.rpc.PagedCallSettings;
import com.google.api.gax.rpc.RequestParamsExtractor;
import com.google.api.gax.rpc.ServerStreamingCallSettings;
import com.google.api.gax.rpc.ServerStreamingCallable;
import com.google.api.gax.rpc.StreamingCallSettings;
import com.google.api.gax.rpc.UnaryCallSettings;
import com.google.api.gax.rpc.UnaryCallable;
import com.google.api.pathtemplate.PathTemplate;
import com.google.cloud.simplecompute.v1.Address;
import com.google.cloud.simplecompute.v1.AddressAggregatedList;
import static com.google.cloud.simplecompute.v1.AddressClient.AggregatedListAddressesPagedResponse;
import static com.google.cloud.simplecompute.v1.AddressClient.ListAddressesPagedResponse;
import com.google.cloud.simplecompute.v1.AddressList;
import com.google.cloud.simplecompute.v1.AddressSettings;
import com.google.cloud.simplecompute.v1.AddressesScopedList;
import com.google.cloud.simplecompute.v1.AggregatedListAddressesHttpRequest;
import com.google.cloud.simplecompute.v1.DeleteAddressHttpRequest;
import com.google.cloud.simplecompute.v1.GetAddressHttpRequest;
import com.google.cloud.simplecompute.v1.InsertAddressHttpRequest;
import com.google.cloud.simplecompute.v1.ListAddressesHttpRequest;
import com.google.cloud.simplecompute.v1.Operation;
import com.google.cloud.simplecompute.v1.PatchAddressHttpRequest;
import com.google.cloud.simplecompute.v1.ProjectGlobalAddressName;
import com.google.cloud.simplecompute.v1.ProjectName;
import com.google.cloud.simplecompute.v1.ProjectRegionAddressName;
import com.google.cloud.simplecompute.v1.ProjectRegionName;
import com.google.cloud.simplecompute.v1.UpdateAddressHttpRequest;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Sets;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import javax.annotation.Generated;
import javax.annotation.Nullable;

// AUTO-GENERATED DOCUMENTATION AND CLASS
/**
 * HTTP callable factory implementation for simplecompute.
 *
 * <p>This class is for advanced usage.
 */
@Generated("by gapic-generator")
@BetaApi("The surface for use by generated code is not stable yet and may change in the future.")
public class HttpJsonAddressCallableFactory implements HttpJsonStubCallableFactory<
    ApiMessage, BackgroundResource> {
  @Override
  public <RequestT, ResponseT> UnaryCallable<RequestT, ResponseT> createUnaryCallable(
      HttpJsonCallSettings<RequestT, ResponseT> httpJsonCallSettings,
      UnaryCallSettings<RequestT, ResponseT> callSettings,
      ClientContext clientContext) {
    return HttpJsonCallableFactory.createUnaryCallable(httpJsonCallSettings, callSettings, clientContext);
  }


  @BetaApi("The surface for long-running operations is not stable yet and may change in the future.")
  @Override
  @Nullable
  public <RequestT, ResponseT, MetadataT> OperationCallable<RequestT, ResponseT, MetadataT> createOperationCallable(
      HttpJsonCallSettings<RequestT, ApiMessage> httpJsonCallSettings,
      OperationCallSettings<RequestT, ResponseT, MetadataT> operationCallSettings,
      ClientContext clientContext, BackgroundResource operationsStub) {
      return null;
  }

  @Override
  public <RequestT, ResponseT, PagedListResponseT>
      UnaryCallable<RequestT, PagedListResponseT> createPagedCallable(
      HttpJsonCallSettings<RequestT, ResponseT> httpJsonCallSettings,
      PagedCallSettings<RequestT, ResponseT, PagedListResponseT> pagedCallSettings,
      ClientContext clientContext) {
    return HttpJsonCallableFactory.createPagedCallable(httpJsonCallSettings, pagedCallSettings, clientContext);
  }

  @Override
  public <RequestT, ResponseT> UnaryCallable<RequestT, ResponseT> createBatchingCallable(
      HttpJsonCallSettings<RequestT, ResponseT> httpJsonCallSettings,
      BatchingCallSettings<RequestT, ResponseT> batchingCallSettings,
      ClientContext clientContext) {
    return HttpJsonCallableFactory.createBatchingCallable(httpJsonCallSettings, batchingCallSettings, clientContext);
  }
}
============== file: src/main/java/com/google/cloud/simplecompute/v1/package-info.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A client to Compute Engine API.
 *
 * The interfaces provided are listed below, along with usage samples.
 *
 * =============
 * AddressClient
 * =============
 *
 * Service Description: Creates and runs virtual machines on Google Cloud Platform.
 *
 * Sample for AddressClient:
 * <pre>
 * <code>
 * try (AddressClient addressClient = AddressClient.create()) {
 *   ProjectRegionAddressName address = ProjectRegionAddressName.of("[PROJECT]", "[REGION]", "[ADDRESS]");
 *   Operation response = addressClient.deleteAddress(address);
 * }
 * </code>
 * </pre>
 *
 */
@Generated("by gapic-generator")
package com.google.cloud.simplecompute.v1;

import  javax.annotation.Generated;
============== file: build.gradle ==============
buildscript {
  repositories {
    mavenCentral()
  }
}

apply plugin: 'java'

description = 'GAPIC library for google-cloud-simplecompute-v1'
group = 'com.google.cloud'
version = (findProperty('version') == 'unspecified') ? '0.0.0-SNAPSHOT' : version
sourceCompatibility = 1.7
targetCompatibility = 1.7

repositories {
  mavenCentral()
  mavenLocal()
}

compileJava.options.encoding = 'UTF-8'
javadoc.options.encoding = 'UTF-8'

dependencies {
  compile 'com.google.api:gax:1.0.0'
  testCompile 'com.google.api:gax:1.0.0:testlib'
  compile 'com.google.api:gax-httpjson:0.18.0'
  testCompile 'com.google.api:gax-httpjson:0.18.0:testlib'
  testCompile 'junit:junit:4.12'
}

task smokeTest(type: Test) {
  filter {
    includeTestsMatching "*SmokeTest"
    setFailOnNoMatchingTests false
  }
}

test {
  exclude "**/*SmokeTest*"
}

sourceSets {
  main {
    java {
      srcDir 'src/main/java'
    }
  }
}

clean {
  delete 'all-jars'
}

task allJars(type: Copy) {
  dependsOn test, jar
  into 'all-jars'
  // Replace with `from configurations.testRuntime, jar` to include test dependencies
  from configurations.runtime, jar
}
============== file: src/test/java/com/google/cloud/simplecompute/v1/AddressClientTest.java ==============
/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.simplecompute.v1;

import com.google.api.gax.core.NoCredentialsProvider;
import com.google.api.gax.httpjson.ApiMethodDescriptor;
import com.google.api.gax.httpjson.GaxHttpJsonProperties;
import com.google.api.gax.httpjson.testing.MockHttpService;
import com.google.api.gax.rpc.ApiClientHeaderProvider;
import com.google.api.gax.rpc.ApiException;
import com.google.api.gax.rpc.ApiExceptionFactory;
import com.google.api.gax.rpc.InvalidArgumentException;
import com.google.api.gax.rpc.StatusCode.Code;
import com.google.api.gax.rpc.testing.FakeStatusCode;
import static com.google.cloud.simplecompute.v1.AddressClient.AggregatedListAddressesPagedResponse;
import static com.google.cloud.simplecompute.v1.AddressClient.ListAddressesPagedResponse;
import com.google.cloud.simplecompute.v1.stub.AddressStubSettings;
import static com.google.cloud.simplecompute.v1.stub.HttpJsonAddressStub.aggregatedListAddressesMethodDescriptor;
import static com.google.cloud.simplecompute.v1.stub.HttpJsonAddressStub.deleteAddressMethodDescriptor;
import static com.google.cloud.simplecompute.v1.stub.HttpJsonAddressStub.getAddressMethodDescriptor;
import static com.google.cloud.simplecompute.v1.stub.HttpJsonAddressStub.insertAddressMethodDescriptor;
import static com.google.cloud.simplecompute.v1.stub.HttpJsonAddressStub.listAddressesMethodDescriptor;
import static com.google.cloud.simplecompute.v1.stub.HttpJsonAddressStub.patchAddressMethodDescriptor;
import static com.google.cloud.simplecompute.v1.stub.HttpJsonAddressStub.updateAddressMethodDescriptor;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Assert;
import org.junit.BeforeClass;
import org.junit.Test;

@javax.annotation.Generated("by GAPIC")
public class AddressClientTest {

   private static final List<ApiMethodDescriptor> METHOD_DESCRIPTORS = ImmutableList.copyOf(
        Lists.<ApiMethodDescriptor>newArrayList(
          aggregatedListAddressesMethodDescriptor,
          deleteAddressMethodDescriptor,
          getAddressMethodDescriptor,
          insertAddressMethodDescriptor,
          listAddressesMethodDescriptor,
          patchAddressMethodDescriptor,
          updateAddressMethodDescriptor
        ));
  private static final MockHttpService mockService
      = new MockHttpService(METHOD_DESCRIPTORS, AddressStubSettings.getDefaultEndpoint());

  private static AddressClient client;
  private static AddressSettings clientSettings;

  @BeforeClass
  public static void setUp() throws IOException {
    clientSettings =
        AddressSettings.newBuilder()
           .setTransportChannelProvider(
               AddressSettings.defaultHttpJsonTransportProviderBuilder()
                   .setHttpTransport(mockService).build())
           .setCredentialsProvider(NoCredentialsProvider.create())
           .build();
    client =
       AddressClient.create(clientSettings);
  }

  @After
  public void cleanUp() {
    mockService.reset();
  }

  @AfterClass
  public static void tearDown() throws Exception {
    client.close();
  }

  @Test
  @SuppressWarnings("all")
  public void aggregatedListAddressesTest() {
    String id = "id3355";
    String kind = "kind3292052";
    String nextPageToken = "";
    String selfLink = "selfLink-1691268851";
    AddressesScopedList itemsItem = AddressesScopedList.newBuilder().build();
    Map<String, AddressesScopedList> items = new HashMap<>();
    items.put("items", itemsItem);
    AddressAggregatedList expectedResponse = AddressAggregatedList.newBuilder()
      .setId(id)
      .setKind(kind)
      .setNextPageToken(nextPageToken)
      .setSelfLink(selfLink)
      .putAllItems(items)
      .build();
    mockService.addResponse(expectedResponse);

    ProjectName project = ProjectName.of("[PROJECT]");

    AggregatedListAddressesPagedResponse pagedListResponse = client.aggregatedListAddresses(project);

    List<AddressesScopedList> resources = Lists.newArrayList(pagedListResponse.iterateAll());
    Assert.assertEquals(1, resources.size());
    Assert.assertEquals(expectedResponse.getItemsMap().values().iterator().next(),
        resources.get(0));

    List<String> actualRequests = mockService.getRequestPaths();
    Assert.assertEquals(1, actualRequests.size());

    String apiClientHeaderKey = mockService.getRequestHeaders()
        .get(ApiClientHeaderProvider.getDefaultApiClientHeaderKey()).iterator().next();
    Assert.assertTrue(GaxHttpJsonProperties.getDefaultApiClientHeaderPattern()
        .matcher(apiClientHeaderKey).matches());
  }

  @Test
  @SuppressWarnings("all")
  public void aggregatedListAddressesExceptionTest() throws Exception {
    ApiException exception = ApiExceptionFactory.createException(new Exception(), FakeStatusCode.of(Code.INVALID_ARGUMENT), false);
    mockService.addException(exception);

    try {
      ProjectName project = ProjectName.of("[PROJECT]");

      client.aggregatedListAddresses(project);
      Assert.fail("No exception raised");
    } catch (InvalidArgumentException e) {
      // Expected exception
    }
  }

  @Test
  @SuppressWarnings("all")
  public void deleteAddressTest() {
    String clientOperationId = "clientOperationId-239630617";
    String description = "description-1724546052";
    String httpErrorMessage = "httpErrorMessage1276263769";
    Integer httpErrorStatusCode = 1386087020;
    String id = "id3355";
    String kind = "kind3292052";
    String name = "name3373707";
    String operationType = "operationType-1432962286";
    Integer progress = 1001078227;
    ProjectRegionName region = ProjectRegionName.of("[PROJECT]", "[REGION]");
    String selfLink = "selfLink-1691268851";
    String startTime = "startTime-1573145462";
    String status = "status-892481550";
    String statusMessage = "statusMessage-239442758";
    String targetId = "targetId-815576439";
    String targetLink = "targetLink-2084812312";
    String zone = "zone3744684";
    Operation expectedResponse = Operation.newBuilder()
      .setClientOperationId(clientOperationId)
      .setDescription(description)
      .setHttpErrorMessage(httpErrorMessage)
      .setHttpErrorStatusCode(httpErrorStatusCode)
      .setId(id)
      .setKind(kind)
      .setName(name)
      .setOperationType(operationType)
      .setProgress(progress)
      .setRegion(region.toString())
      .setSelfLink(selfLink)
      .setStartTime(startTime)
      .setStatus(status)
      .setStatusMessage(statusMessage)
      .setTargetId(targetId)
      .setTargetLink(targetLink)
      .setZone(zone)
      .build();
    mockService.addResponse(expectedResponse);

    ProjectRegionAddressName address = ProjectRegionAddressName.of("[PROJECT]", "[REGION]", "[ADDRESS]");

    Operation actualResponse =
        client.deleteAddress(address);
    Assert.assertEquals(expectedResponse, actualResponse);

    List<String> actualRequests = mockService.getRequestPaths();
    Assert.assertEquals(1, actualRequests.size());

    String apiClientHeaderKey = mockService.getRequestHeaders()
        .get(ApiClientHeaderProvider.getDefaultApiClientHeaderKey()).iterator().next();
    Assert.assertTrue(GaxHttpJsonProperties.getDefaultApiClientHeaderPattern()
        .matcher(apiClientHeaderKey).matches());
  }

  @Test
  @SuppressWarnings("all")
  public void deleteAddressExceptionTest() throws Exception {
    ApiException exception = ApiExceptionFactory.createException(new Exception(), FakeStatusCode.of(Code.INVALID_ARGUMENT), false);
    mockService.addException(exception);

    try {
      ProjectRegionAddressName address = ProjectRegionAddressName.of("[PROJECT]", "[REGION]", "[ADDRESS]");

      client.deleteAddress(address);
      Assert.fail("No exception raised");
    } catch (InvalidArgumentException e) {
      // Expected exception
    }
  }

  @Test
  @SuppressWarnings("all")
  public void getAddressTest() {
    ProjectRegionAddressName address2 = ProjectRegionAddressName.of("[PROJECT]", "[REGION]", "[ADDRESS]");
    String description = "description-1724546052";
    String id = "id3355";
    String kind = "kind3292052";
    String name = "name3373707";
    ProjectRegionName region = ProjectRegionName.of("[PROJECT]", "[REGION]");
    String selfLink = "selfLink-1691268851";
    String status = "status-892481550";
    Address expectedResponse = Address.newBuilder()
      .setAddress(address2.toString())
      .setDescription(description)
      .setId(id)
      .setKind(kind)
      .setName(name)
      .setRegion(region.toString())
      .setSelfLink(selfLink)
      .setStatus(status)
      .build();
    mockService.addResponse(expectedResponse);

    ProjectRegionAddressName address = ProjectRegionAddressName.of("[PROJECT]", "[REGION]", "[ADDRESS]");

    Address actualResponse =
        client.getAddress(address);
    Assert.assertEquals(expectedResponse, actualResponse);

    List<String> actualRequests = mockService.getRequestPaths();
    Assert.assertEquals(1, actualRequests.size());

    String apiClientHeaderKey = mockService.getRequestHeaders()
        .get(ApiClientHeaderProvider.getDefaultApiClientHeaderKey()).iterator().next();
    Assert.assertTrue(GaxHttpJsonProperties.getDefaultApiClientHeaderPattern()
        .matcher(apiClientHeaderKey).matches());
  }

  @Test
  @SuppressWarnings("all")
  public void getAddressExceptionTest() throws Exception {
    ApiException exception = ApiExceptionFactory.createException(new Exception(), FakeStatusCode.of(Code.INVALID_ARGUMENT), false);
    mockService.addException(exception);

    try {
      ProjectRegionAddressName address = ProjectRegionAddressName.of("[PROJECT]", "[REGION]", "[ADDRESS]");

      client.getAddress(address);
      Assert.fail("No exception raised");
    } catch (InvalidArgumentException e) {
      // Expected exception
    }
  }

  @Test
  @SuppressWarnings("all")
  public void insertAddressTest() {
    String clientOperationId = "clientOperationId-239630617";
    String description = "description-1724546052";
    String httpErrorMessage = "httpErrorMessage1276263769";
    Integer httpErrorStatusCode = 1386087020;
    String id = "id3355";
    String kind = "kind3292052";
    String name = "name3373707";
    String operationType = "operationType-1432962286";
    Integer progress = 1001078227;
    ProjectRegionName region2 = ProjectRegionName.of("[PROJECT]", "[REGION]");
    String selfLink = "selfLink-1691268851";
    String startTime = "startTime-1573145462";
    String status = "status-892481550";
    String statusMessage = "statusMessage-239442758";
    String targetId = "targetId-815576439";
    String targetLink = "targetLink-2084812312";
    String zone = "zone3744684";
    Operation expectedResponse = Operation.newBuilder()
      .setClientOperationId(clientOperationId)
      .setDescription(description)
      .setHttpErrorMessage(httpErrorMessage)
      .setHttpErrorStatusCode(httpErrorStatusCode)
      .setId(id)
      .setKind(kind)
      .setName(name)
      .setOperationType(operationType)
      .setProgress(progress)
      .setRegion(region2.toString())
      .setSelfLink(selfLink)
      .setStartTime(startTime)
      .setStatus(status)
      .setStatusMessage(statusMessage)
      .setTargetId(targetId)
      .setTargetLink(targetLink)
      .setZone(zone)
      .build();
    mockService.addResponse(expectedResponse);

    ProjectRegionName region = ProjectRegionName.of("[PROJECT]", "[REGION]");
    Address addressResource = Address.newBuilder().build();

    Operation actualResponse =
        client.insertAddress(region, addressResource);
    Assert.assertEquals(expectedResponse, actualResponse);

    List<String> actualRequests = mockService.getRequestPaths();
    Assert.assertEquals(1, actualRequests.size());

    String apiClientHeaderKey = mockService.getRequestHeaders()
        .get(ApiClientHeaderProvider.getDefaultApiClientHeaderKey()).iterator().next();
    Assert.assertTrue(GaxHttpJsonProperties.getDefaultApiClientHeaderPattern()
        .matcher(apiClientHeaderKey).matches());
  }

  @Test
  @SuppressWarnings("all")
  public void insertAddressExceptionTest() throws Exception {
    ApiException exception = ApiExceptionFactory.createException(new Exception(), FakeStatusCode.of(Code.INVALID_ARGUMENT), false);
    mockService.addException(exception);

    try {
      ProjectRegionName region = ProjectRegionName.of("[PROJECT]", "[REGION]");
      Address addressResource = Address.newBuilder().build();

      client.insertAddress(region, addressResource);
      Assert.fail("No exception raised");
    } catch (InvalidArgumentException e) {
      // Expected exception
    }
  }

  @Test
  @SuppressWarnings("all")
  public void listAddressesTest() {
    String id = "id3355";
    String kind = "kind3292052";
    String nextPageToken = "";
    String selfLink = "selfLink-1691268851";
    Address itemsElement = Address.newBuilder().build();
    List<Address> items = Arrays.asList(itemsElement);
    AddressList expectedResponse = AddressList.newBuilder()
      .setId(id)
      .setKind(kind)
      .setNextPageToken(nextPageToken)
      .setSelfLink(selfLink)
      .addAllItems(items)
      .build();
    mockService.addResponse(expectedResponse);

    ProjectRegionName region = ProjectRegionName.of("[PROJECT]", "[REGION]");

    ListAddressesPagedResponse pagedListResponse = client.listAddresses(region);

    List<Address> resources = Lists.newArrayList(pagedListResponse.iterateAll());
    Assert.assertEquals(1, resources.size());
    Assert.assertEquals(expectedResponse.getItemsList().get(0),
        resources.get(0));

    List<String> actualRequests = mockService.getRequestPaths();
    Assert.assertEquals(1, actualRequests.size());

    String apiClientHeaderKey = mockService.getRequestHeaders()
        .get(ApiClientHeaderProvider.getDefaultApiClientHeaderKey()).iterator().next();
    Assert.assertTrue(GaxHttpJsonProperties.getDefaultApiClientHeaderPattern()
        .matcher(apiClientHeaderKey).matches());
  }

  @Test
  @SuppressWarnings("all")
  public void listAddressesExceptionTest() throws Exception {
    ApiException exception = ApiExceptionFactory.createException(new Exception(), FakeStatusCode.of(Code.INVALID_ARGUMENT), false);
    mockService.addException(exception);

    try {
      ProjectRegionName region = ProjectRegionName.of("[PROJECT]", "[REGION]");

      client.listAddresses(region);
      Assert.fail("No exception raised");
    } catch (InvalidArgumentException e) {
      // Expected exception
    }
  }

  @Test
  @SuppressWarnings("all")
  public void patchAddressTest() {
    mockService.addNullResponse();

    String address = "address-1147692044";
    ProjectRegionName region = ProjectRegionName.of("[PROJECT]", "[REGION]");
    Address addressResource = Address.newBuilder().build();
    List<String> fieldMask = new ArrayList<>();

    client.patchAddress(address, region, addressResource, fieldMask);

    List<String> actualRequests = mockService.getRequestPaths();
    Assert.assertEquals(1, actualRequests.size());

    String apiClientHeaderKey = mockService.getRequestHeaders()
        .get(ApiClientHeaderProvider.getDefaultApiClientHeaderKey()).iterator().next();
    Assert.assertTrue(GaxHttpJsonProperties.getDefaultApiClientHeaderPattern()
        .matcher(apiClientHeaderKey).matches());
  }

  @Test
  @SuppressWarnings("all")
  public void patchAddressExceptionTest() throws Exception {
    ApiException exception = ApiExceptionFactory.createException(new Exception(), FakeStatusCode.of(Code.INVALID_ARGUMENT), false);
    mockService.addException(exception);

    try {
      String address = "address-1147692044";
      ProjectRegionName region = ProjectRegionName.of("[PROJECT]", "[REGION]");
      Address addressResource = Address.newBuilder().build();
      List<String> fieldMask = new ArrayList<>();

      client.patchAddress(address, region, addressResource, fieldMask);
      Assert.fail("No exception raised");
    } catch (InvalidArgumentException e) {
      // Expected exception
    }
  }

  @Test
  @SuppressWarnings("all")
  public void updateAddressTest() {
    String clientOperationId = "clientOperationId-239630617";
    String description = "description-1724546052";
    String httpErrorMessage = "httpErrorMessage1276263769";
    Integer httpErrorStatusCode = 1386087020;
    String id = "id3355";
    String kind = "kind3292052";
    String name = "name3373707";
    String operationType = "operationType-1432962286";
    Integer progress = 1001078227;
    ProjectRegionName region = ProjectRegionName.of("[PROJECT]", "[REGION]");
    String selfLink = "selfLink-1691268851";
    String startTime = "startTime-1573145462";
    String status = "status-892481550";
    String statusMessage = "statusMessage-239442758";
    String targetId = "targetId-815576439";
    String targetLink = "targetLink-2084812312";
    String zone = "zone3744684";
    Operation expectedResponse = Operation.newBuilder()
      .setClientOperationId(clientOperationId)
      .setDescription(description)
      .setHttpErrorMessage(httpErrorMessage)
      .setHttpErrorStatusCode(httpErrorStatusCode)
      .setId(id)
      .setKind(kind)
      .setName(name)
      .setOperationType(operationType)
      .setProgress(progress)
      .setRegion(region.toString())
      .setSelfLink(selfLink)
      .setStartTime(startTime)
      .setStatus(status)
      .setStatusMessage(statusMessage)
      .setTargetId(targetId)
      .setTargetLink(targetLink)
      .setZone(zone)
      .build();
    mockService.addResponse(expectedResponse);

    ProjectGlobalAddressName address = ProjectGlobalAddressName.of("[PROJECT]", "[ADDRESS]");
    Address addressResource = Address.newBuilder().build();
    List<String> fieldMask = new ArrayList<>();

    Operation actualResponse =
        client.updateAddress(address, addressResource, fieldMask);
    Assert.assertEquals(expectedResponse, actualResponse);

    List<String> actualRequests = mockService.getRequestPaths();
    Assert.assertEquals(1, actualRequests.size());

    String apiClientHeaderKey = mockService.getRequestHeaders()
        .get(ApiClientHeaderProvider.getDefaultApiClientHeaderKey()).iterator().next();
    Assert.assertTrue(GaxHttpJsonProperties.getDefaultApiClientHeaderPattern()
        .matcher(apiClientHeaderKey).matches());
  }

  @Test
  @SuppressWarnings("all")
  public void updateAddressExceptionTest() throws Exception {
    ApiException exception = ApiExceptionFactory.createException(new Exception(), FakeStatusCode.of(Code.INVALID_ARGUMENT), false);
    mockService.addException(exception);

    try {
      ProjectGlobalAddressName address = ProjectGlobalAddressName.of("[PROJECT]", "[ADDRESS]");
      Address addressResource = Address.newBuilder().build();
      List<String> fieldMask = new ArrayList<>();

      client.updateAddress(address, addressResource, fieldMask);
      Assert.fail("No exception raised");
    } catch (InvalidArgumentException e) {
      // Expected exception
    }
  }

}
