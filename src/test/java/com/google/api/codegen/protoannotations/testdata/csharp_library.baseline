============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/DeleteShelfAsyncFlattenedAsyncEmptyResponseTypeWithResponseHandling.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedAsync", "empty_response_type_with_response_handling")

// sample-metadata
//   title: Test response handling for methods that return empty
//   description: Test response handling for methods that return empty
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System;
    using System.Threading.Tasks;

    public class DeleteShelfAsyncFlattenedAsyncEmptyResponseTypeWithResponseHandling
    {
        /// <summary>
        /// Test response handling for methods that return empty
        /// </summary>
        public static async Task SampleDeleteShelfAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            ShelfName name = new ShelfName("[SHELF]");
            await libraryServiceClient.DeleteShelfAsync(name);
            // Shelf deleted
            Console.WriteLine("Shelf deleted.");
        }
    }

    // [END sample]

    public class DeleteShelfAsyncFlattenedAsyncEmptyResponseTypeWithResponseHandlingMain
    {
        public static void Main(string[] args)
        {
            DeleteShelfAsyncFlattenedAsyncEmptyResponseTypeWithResponseHandling.SampleDeleteShelfAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/DeleteShelfAsyncFlattenedAsyncEmptyResponseTypeWithoutResponseHandling.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedAsync", "empty_response_type_without_response_handling")

// sample-metadata
//   title: Test default response handling is turned off for methods that return empty
//   description: Test default response handling is turned off for methods that return empty
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System.Threading.Tasks;

    public class DeleteShelfAsyncFlattenedAsyncEmptyResponseTypeWithoutResponseHandling
    {
        /// <summary>
        /// Test default response handling is turned off for methods that return empty
        /// </summary>
        public static async Task SampleDeleteShelfAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            ShelfName name = new ShelfName("[SHELF]");
            await libraryServiceClient.DeleteShelfAsync(name);
        }
    }

    // [END sample]

    public class DeleteShelfAsyncFlattenedAsyncEmptyResponseTypeWithoutResponseHandlingMain
    {
        public static void Main(string[] args)
        {
            DeleteShelfAsyncFlattenedAsyncEmptyResponseTypeWithoutResponseHandling.SampleDeleteShelfAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/DeleteShelfAsyncRequestAsyncEmptyResponseTypeWithResponseHandling.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestAsync", "empty_response_type_with_response_handling")

// sample-metadata
//   title: Test response handling for methods that return empty
//   description: Test response handling for methods that return empty
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System;
    using System.Threading.Tasks;

    public class DeleteShelfAsyncRequestAsyncEmptyResponseTypeWithResponseHandling
    {
        /// <summary>
        /// Test response handling for methods that return empty
        /// </summary>
        public static async Task SampleDeleteShelfAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            DeleteShelfRequest request = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
            };
            await libraryServiceClient.DeleteShelfAsync(request);
            // Shelf deleted
            Console.WriteLine("Shelf deleted.");
        }
    }

    // [END sample]

    public class DeleteShelfAsyncRequestAsyncEmptyResponseTypeWithResponseHandlingMain
    {
        public static void Main(string[] args)
        {
            DeleteShelfAsyncRequestAsyncEmptyResponseTypeWithResponseHandling.SampleDeleteShelfAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/DeleteShelfAsyncRequestAsyncEmptyResponseTypeWithoutResponseHandling.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestAsync", "empty_response_type_without_response_handling")

// sample-metadata
//   title: Test default response handling is turned off for methods that return empty
//   description: Test default response handling is turned off for methods that return empty
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System.Threading.Tasks;

    public class DeleteShelfAsyncRequestAsyncEmptyResponseTypeWithoutResponseHandling
    {
        /// <summary>
        /// Test default response handling is turned off for methods that return empty
        /// </summary>
        public static async Task SampleDeleteShelfAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            DeleteShelfRequest request = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
            };
            await libraryServiceClient.DeleteShelfAsync(request);
        }
    }

    // [END sample]

    public class DeleteShelfAsyncRequestAsyncEmptyResponseTypeWithoutResponseHandlingMain
    {
        public static void Main(string[] args)
        {
            DeleteShelfAsyncRequestAsyncEmptyResponseTypeWithoutResponseHandling.SampleDeleteShelfAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/DeleteShelfFlattenedEmptyResponseTypeWithResponseHandling.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Flattened", "empty_response_type_with_response_handling")

// sample-metadata
//   title: Test response handling for methods that return empty
//   description: Test response handling for methods that return empty
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System;

    public class DeleteShelfFlattenedEmptyResponseTypeWithResponseHandling
    {
        /// <summary>
        /// Test response handling for methods that return empty
        /// </summary>
        public static void SampleDeleteShelf()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            ShelfName name = new ShelfName("[SHELF]");
            libraryServiceClient.DeleteShelf(name);
            // Shelf deleted
            Console.WriteLine("Shelf deleted.");
        }
    }

    // [END sample]

    public class DeleteShelfFlattenedEmptyResponseTypeWithResponseHandlingMain
    {
        public static void Main(string[] args)
        {
            DeleteShelfFlattenedEmptyResponseTypeWithResponseHandling.SampleDeleteShelf();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/DeleteShelfFlattenedEmptyResponseTypeWithoutResponseHandling.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Flattened", "empty_response_type_without_response_handling")

// sample-metadata
//   title: Test default response handling is turned off for methods that return empty
//   description: Test default response handling is turned off for methods that return empty
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;

    public class DeleteShelfFlattenedEmptyResponseTypeWithoutResponseHandling
    {
        /// <summary>
        /// Test default response handling is turned off for methods that return empty
        /// </summary>
        public static void SampleDeleteShelf()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            ShelfName name = new ShelfName("[SHELF]");
            libraryServiceClient.DeleteShelf(name);
        }
    }

    // [END sample]

    public class DeleteShelfFlattenedEmptyResponseTypeWithoutResponseHandlingMain
    {
        public static void Main(string[] args)
        {
            DeleteShelfFlattenedEmptyResponseTypeWithoutResponseHandling.SampleDeleteShelf();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/DeleteShelfRequestEmptyResponseTypeWithResponseHandling.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "empty_response_type_with_response_handling")

// sample-metadata
//   title: Test response handling for methods that return empty
//   description: Test response handling for methods that return empty
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System;

    public class DeleteShelfRequestEmptyResponseTypeWithResponseHandling
    {
        /// <summary>
        /// Test response handling for methods that return empty
        /// </summary>
        public static void SampleDeleteShelf()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            DeleteShelfRequest request = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
            };
            libraryServiceClient.DeleteShelf(request);
            // Shelf deleted
            Console.WriteLine("Shelf deleted.");
        }
    }

    // [END sample]

    public class DeleteShelfRequestEmptyResponseTypeWithResponseHandlingMain
    {
        public static void Main(string[] args)
        {
            DeleteShelfRequestEmptyResponseTypeWithResponseHandling.SampleDeleteShelf();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/DeleteShelfRequestEmptyResponseTypeWithoutResponseHandling.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "empty_response_type_without_response_handling")

// sample-metadata
//   title: Test default response handling is turned off for methods that return empty
//   description: Test default response handling is turned off for methods that return empty
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;

    public class DeleteShelfRequestEmptyResponseTypeWithoutResponseHandling
    {
        /// <summary>
        /// Test default response handling is turned off for methods that return empty
        /// </summary>
        public static void SampleDeleteShelf()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            DeleteShelfRequest request = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
            };
            libraryServiceClient.DeleteShelf(request);
        }
    }

    // [END sample]

    public class DeleteShelfRequestEmptyResponseTypeWithoutResponseHandlingMain
    {
        public static void Main(string[] args)
        {
            DeleteShelfRequestEmptyResponseTypeWithoutResponseHandling.SampleDeleteShelf();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/DiscussBookFlattenedStreamingBidiProg.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedStreamingBidi", "prog")

// sample-metadata
//   title: Programming Books
//   description: Testing calling forms
//   usage: dotnet run [--image_file_name "image_file.jpg"] [--stage DRAFT]

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START turing_prog_flattened_streaming_bidi]
    using Google.Example.Library.V1;
    using Google.Protobuf;
    using System;
    using System.IO;
    using System.Threading.Tasks;

    public class DiscussBookFlattenedStreamingBidiProg
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static async Task SampleDiscussBookAsync(string imageFileName, Comment.Types.Stage stage)
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();

            // Initialize streaming call, retrieving the stream object
            LibraryServiceClient.DiscussBookStream duplexStream =
                libraryServiceClient.DiscussBook();

            // Sending requests are retrieving responses can be arbitrarily interleaved.
            // Exact sequence will depend on client/server behavior.

            // Create task to do something with responses from server
            Task responseHandlerTask = Task.Run(async () =>
                {
                    IAsyncEnumerator<Comment> responseStream = duplexStream.ResponseStream;
                    while (await responseStream.MoveNext())
                    {
                        Comment item = responseStream.Current;
                        Console.WriteLine(item);
                    }
                    // The response stream has completed
                });

            // Send requests to the server
            bool done = false;
            while (!done)
            {
                // Initialize a request
                BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
                Comment comment2 = new Comment
                {
                    Comment = ByteString.CopyFrom(File.ReadAllBytes("comment_file")),
                    Stage = Comment.Types.Stage.Draft,
                };
                ByteString image = ByteString.CopyFrom(File.ReadAllBytes(imageFileName));
                // Stream a request to the server
                await duplexStream.WriteAsync(request);

                // Set "done" to true when sending requests is complete
                done = true;
            }
            // Complete writing requests to the stream
            await duplexStream.WriteCompleteAsync();
            // Await the response handler.
            // This will complete once all server responses have been processed.
            await responseHandlerTask;
        }
    }

    // [END turing_prog_flattened_streaming_bidi]

    public class DiscussBookFlattenedStreamingBidiProgMain
    {
        public static void Main(string[] args)
        {
            new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
                .WithParsed<Options>(opts =>
                    DiscussBookFlattenedStreamingBidiProg.SampleDiscussBookAsync(opts.ImageFileName, opts.Stage).Wait());
        }

        public class Options
        {
            [Option("image_file_name", Default = "image_file.jpg")]
            public string ImageFileName { get; set; }

            [Option("stage", Default = Comment.Types.Stage.Draft)]
            public Comment.Types.Stage Stage { get; set; }
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/DiscussBookFlattenedStreamingServerProg.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedStreamingServer", "prog")

// sample-metadata
//   title: Programming Books
//   description: Testing calling forms
//   usage: dotnet run [--image_file_name "image_file.jpg"] [--stage DRAFT]

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START turing_prog_flattened_streaming_server]
    using Google.Example.Library.V1;
    using Google.Protobuf;
    using System;
    using System.IO;
    using System.Threading.Tasks;

    public class DiscussBookFlattenedStreamingServerProg
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static async Task SampleDiscussBookAsync(string imageFileName, Comment.Types.Stage stage)
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            Comment comment2 = new Comment
            {
                Comment = ByteString.CopyFrom(File.ReadAllBytes("comment_file")),
                Stage = Comment.Types.Stage.Draft,
            };
            ByteString image = ByteString.CopyFrom(File.ReadAllBytes(imageFileName));

            // Make the request, returning a streaming response
            LibraryServiceClient.DiscussBookStream streamingResponse = libraryServiceClient.DiscussBook(name, comment2, image);

            // Read streaming responses from server until complete
            IAsyncEnumerator<Comment> responsestream = streamingResponse.ResponseStream;
            await responseStream.ForEachAsync(item =>
            {
                Console.WriteLine(item);
            });
            // The response stream has completed
        }
    }

    // [END turing_prog_flattened_streaming_server]

    public class DiscussBookFlattenedStreamingServerProgMain
    {
        public static void Main(string[] args)
        {
            new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
                .WithParsed<Options>(opts =>
                    DiscussBookFlattenedStreamingServerProg.SampleDiscussBookAsync(opts.ImageFileName, opts.Stage).Wait());
        }

        public class Options
        {
            [Option("image_file_name", Default = "image_file.jpg")]
            public string ImageFileName { get; set; }

            [Option("stage", Default = Comment.Types.Stage.Draft)]
            public Comment.Types.Stage Stage { get; set; }
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksAsyncFlattenedAsyncPagedAllOdyssey.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedAsyncPagedAll", "odyssey")

// sample-metadata
//   title: The Odyssey
//   description: Testing calling forms
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Api.Gax;
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;

    public class FindRelatedBooksAsyncFlattenedAsyncPagedAllOdyssey
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static async Task SampleFindRelatedBooksAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            IEnumerable<BookNameOneof> names = new[]
            {
                BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            IEnumerable<ShelfName> shelves = new[]
            {
                new ShelfName("[SHELF]"),
            };
            PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> response = await libraryServiceClient.FindRelatedBooksAsync(names, shelves);
            // Iterate over pages (of server-defined size), performing one RPC per page
            await response.ForEachAsync((BookNameOneof item) =>
            {
                BookNameOneof book = item;
                Console.WriteLine($"Here's a related book: {book}");
            });
        }
    }

    // [END sample]

    public class FindRelatedBooksAsyncFlattenedAsyncPagedAllOdysseyMain
    {
        public static void Main(string[] args)
        {
            FindRelatedBooksAsyncFlattenedAsyncPagedAllOdyssey.SampleFindRelatedBooksAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksAsyncFlattenedAsyncPagedOdyssey.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedAsyncPaged", "odyssey")

// sample-metadata
//   title: The Odyssey
//   description: Testing calling forms
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Api.Gax;
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;

    public class FindRelatedBooksAsyncFlattenedAsyncPagedOdyssey
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static async Task SampleFindRelatedBooksAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            IEnumerable<BookNameOneof> names = new[]
            {
                BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            IEnumerable<ShelfName> shelves = new[]
            {
                new ShelfName("[SHELF]"),
            };
            PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> response = await libraryServiceClient.FindRelatedBooksAsync(names, shelves);
            // Iterate over all response items, lazily performing RPCs as required
            await response.AsRawResponses().ForEachAsync((FindRelatedBooksResponse page) =>
            {
                foreach (BookNameOneof item in page)
                {
                    BookNameOneof book = item;
                    Console.WriteLine($"Here's a related book: {book}");
                }
            });
        }
    }

    // [END sample]

    public class FindRelatedBooksAsyncFlattenedAsyncPagedOdysseyMain
    {
        public static void Main(string[] args)
        {
            FindRelatedBooksAsyncFlattenedAsyncPagedOdyssey.SampleFindRelatedBooksAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksAsyncFlattenedAsyncPagedPageSizeOdyssey.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedAsyncPagedPageSize", "odyssey")

// sample-metadata
//   title: The Odyssey
//   description: Testing calling forms
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;

    public class FindRelatedBooksAsyncFlattenedAsyncPagedPageSizeOdyssey
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static async Task SampleFindRelatedBooksAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            IEnumerable<BookNameOneof> names = new[]
            {
                BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            IEnumerable<ShelfName> shelves = new[]
            {
                new ShelfName("[SHELF]"),
            };
            PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> response = await libraryServiceClient.FindRelatedBooksAsync(names, shelves);
            // Retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookNameOneof> singlePage = await response.ReadPageAsync(pageSize);
            foreach (BookNameOneof item in response)
            {
                BookNameOneof book = item;
                Console.WriteLine($"Here's a related book: {book}");
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
        }
    }

    // [END sample]

    public class FindRelatedBooksAsyncFlattenedAsyncPagedPageSizeOdysseyMain
    {
        public static void Main(string[] args)
        {
            FindRelatedBooksAsyncFlattenedAsyncPagedPageSizeOdyssey.SampleFindRelatedBooksAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksAsyncRequestAsyncPagedAllOdyssey.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestAsyncPagedAll", "odyssey")

// sample-metadata
//   title: The Odyssey
//   description: Testing calling forms
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Api.Gax;
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;

    public class FindRelatedBooksAsyncRequestAsyncPagedAllOdyssey
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static async Task SampleFindRelatedBooksAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            FindRelatedBooksRequest request = new FindRelatedBooksRequest
            {
                BookNameOneofs =
                {
                    BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                },
                ShelvesAsShelfNames =
                {
                    new ShelfName("[SHELF]"),
                },
            };
            PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> response = await libraryServiceClient.FindRelatedBooksAsync(request);
            // Iterate over pages (of server-defined size), performing one RPC per page
            await response.ForEachAsync((BookNameOneof item) =>
            {
                BookNameOneof book = item;
                Console.WriteLine($"Here's a related book: {book}");
            });
        }
    }

    // [END sample]

    public class FindRelatedBooksAsyncRequestAsyncPagedAllOdysseyMain
    {
        public static void Main(string[] args)
        {
            FindRelatedBooksAsyncRequestAsyncPagedAllOdyssey.SampleFindRelatedBooksAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksAsyncRequestAsyncPagedOdyssey.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestAsyncPaged", "odyssey")

// sample-metadata
//   title: The Odyssey
//   description: Testing calling forms
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Api.Gax;
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;

    public class FindRelatedBooksAsyncRequestAsyncPagedOdyssey
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static async Task SampleFindRelatedBooksAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            FindRelatedBooksRequest request = new FindRelatedBooksRequest
            {
                BookNameOneofs =
                {
                    BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                },
                ShelvesAsShelfNames =
                {
                    new ShelfName("[SHELF]"),
                },
            };
            PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> response = await libraryServiceClient.FindRelatedBooksAsync(request);
            // Iterate over all response items, lazily performing RPCs as required
            await response.AsRawResponses().ForEachAsync((FindRelatedBooksResponse page) =>
            {
                foreach (BookNameOneof item in page)
                {
                    BookNameOneof book = item;
                    Console.WriteLine($"Here's a related book: {book}");
                }
            });
        }
    }

    // [END sample]

    public class FindRelatedBooksAsyncRequestAsyncPagedOdysseyMain
    {
        public static void Main(string[] args)
        {
            FindRelatedBooksAsyncRequestAsyncPagedOdyssey.SampleFindRelatedBooksAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksAsyncRequestAsyncPagedPageSizeOdyssey.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestAsyncPagedPageSize", "odyssey")

// sample-metadata
//   title: The Odyssey
//   description: Testing calling forms
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;

    public class FindRelatedBooksAsyncRequestAsyncPagedPageSizeOdyssey
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static async Task SampleFindRelatedBooksAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            FindRelatedBooksRequest request = new FindRelatedBooksRequest
            {
                BookNameOneofs =
                {
                    BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                },
                ShelvesAsShelfNames =
                {
                    new ShelfName("[SHELF]"),
                },
            };
            PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> response = await libraryServiceClient.FindRelatedBooksAsync(request);
            // Retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookNameOneof> singlePage = await response.ReadPageAsync(pageSize);
            foreach (BookNameOneof item in response)
            {
                BookNameOneof book = item;
                Console.WriteLine($"Here's a related book: {book}");
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
        }
    }

    // [END sample]

    public class FindRelatedBooksAsyncRequestAsyncPagedPageSizeOdysseyMain
    {
        public static void Main(string[] args)
        {
            FindRelatedBooksAsyncRequestAsyncPagedPageSizeOdyssey.SampleFindRelatedBooksAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksFlattenedPagedAllOdyssey.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedPagedAll", "odyssey")

// sample-metadata
//   title: The Odyssey
//   description: Testing calling forms
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Api.Gax;
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;

    public class FindRelatedBooksFlattenedPagedAllOdyssey
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static void SampleFindRelatedBooks()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            IEnumerable<BookNameOneof> names = new[]
            {
                BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            IEnumerable<ShelfName> shelves = new[]
            {
                new ShelfName("[SHELF]"),
            };
            PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> response = libraryServiceClient.FindRelatedBooks(names, shelves);
            // Iterate over pages (of server-defined size), performing one RPC per page
            foreach (BookNameOneof item in response)
            {
                BookNameOneof book = item;
                Console.WriteLine($"Here's a related book: {book}");
            }
        }
    }

    // [END sample]

    public class FindRelatedBooksFlattenedPagedAllOdysseyMain
    {
        public static void Main(string[] args)
        {
            FindRelatedBooksFlattenedPagedAllOdyssey.SampleFindRelatedBooks();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksFlattenedPagedOdyssey.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedPaged", "odyssey")

// sample-metadata
//   title: The Odyssey
//   description: Testing calling forms
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Api.Gax;
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;

    public class FindRelatedBooksFlattenedPagedOdyssey
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static void SampleFindRelatedBooks()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            IEnumerable<BookNameOneof> names = new[]
            {
                BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            IEnumerable<ShelfName> shelves = new[]
            {
                new ShelfName("[SHELF]"),
            };
            PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> response = libraryServiceClient.FindRelatedBooks(names, shelves);
            // Iterate over all response items, lazily performing RPCs as required
            foreach (FindRelatedBooksResponse page in response.asRawResponses())
            {
                foreach (BookNameOneof item in page)
                {
                    BookNameOneof book = item;
                    Console.WriteLine($"Here's a related book: {book}");
                }
            }
        }
    }

    // [END sample]

    public class FindRelatedBooksFlattenedPagedOdysseyMain
    {
        public static void Main(string[] args)
        {
            FindRelatedBooksFlattenedPagedOdyssey.SampleFindRelatedBooks();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksFlattenedPagedPageSizeOdyssey.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedPagedPageSize", "odyssey")

// sample-metadata
//   title: The Odyssey
//   description: Testing calling forms
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Api.Gax;
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;

    public class FindRelatedBooksFlattenedPagedPageSizeOdyssey
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static void SampleFindRelatedBooks()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            IEnumerable<BookNameOneof> names = new[]
            {
                BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            IEnumerable<ShelfName> shelves = new[]
            {
                new ShelfName("[SHELF]"),
            };
            PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> response = libraryServiceClient.FindRelatedBooks(names, shelves);
            // Retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookNameOneof> singlePage = response.ReadPage(pageSize);
            foreach (BookNameOneof item in response)
            {
                BookNameOneof book = item;
                Console.WriteLine($"Here's a related book: {book}");
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
        }
    }

    // [END sample]

    public class FindRelatedBooksFlattenedPagedPageSizeOdysseyMain
    {
        public static void Main(string[] args)
        {
            FindRelatedBooksFlattenedPagedPageSizeOdyssey.SampleFindRelatedBooks();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksRequestPagedAllOdyssey.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestPagedAll", "odyssey")

// sample-metadata
//   title: The Odyssey
//   description: Testing calling forms
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Api.Gax;
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;

    public class FindRelatedBooksRequestPagedAllOdyssey
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static void SampleFindRelatedBooks()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            FindRelatedBooksRequest request = new FindRelatedBooksRequest
            {
                BookNameOneofs =
                {
                    BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                },
                ShelvesAsShelfNames =
                {
                    new ShelfName("[SHELF]"),
                },
            };
            PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> response = libraryServiceClient.FindRelatedBooks(request);
            // Iterate over pages (of server-defined size), performing one RPC per page
            foreach (BookNameOneof item in response)
            {
                BookNameOneof book = item;
                Console.WriteLine($"Here's a related book: {book}");
            }
        }
    }

    // [END sample]

    public class FindRelatedBooksRequestPagedAllOdysseyMain
    {
        public static void Main(string[] args)
        {
            FindRelatedBooksRequestPagedAllOdyssey.SampleFindRelatedBooks();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksRequestPagedOdyssey.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestPaged", "odyssey")

// sample-metadata
//   title: The Odyssey
//   description: Testing calling forms
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Api.Gax;
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;

    public class FindRelatedBooksRequestPagedOdyssey
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static void SampleFindRelatedBooks()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            FindRelatedBooksRequest request = new FindRelatedBooksRequest
            {
                BookNameOneofs =
                {
                    BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                },
                ShelvesAsShelfNames =
                {
                    new ShelfName("[SHELF]"),
                },
            };
            PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> response = libraryServiceClient.FindRelatedBooks(request);
            // Iterate over all response items, lazily performing RPCs as required
            foreach (FindRelatedBooksResponse page in response.asRawResponses())
            {
                foreach (BookNameOneof item in page)
                {
                    BookNameOneof book = item;
                    Console.WriteLine($"Here's a related book: {book}");
                }
            }
        }
    }

    // [END sample]

    public class FindRelatedBooksRequestPagedOdysseyMain
    {
        public static void Main(string[] args)
        {
            FindRelatedBooksRequestPagedOdyssey.SampleFindRelatedBooks();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksRequestPagedPageSizeOdyssey.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestPagedPageSize", "odyssey")

// sample-metadata
//   title: The Odyssey
//   description: Testing calling forms
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Api.Gax;
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;

    public class FindRelatedBooksRequestPagedPageSizeOdyssey
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static void SampleFindRelatedBooks()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            FindRelatedBooksRequest request = new FindRelatedBooksRequest
            {
                BookNameOneofs =
                {
                    BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                },
                ShelvesAsShelfNames =
                {
                    new ShelfName("[SHELF]"),
                },
            };
            PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> response = libraryServiceClient.FindRelatedBooks(request);
            // Retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookNameOneof> singlePage = response.ReadPage(pageSize);
            foreach (BookNameOneof item in response)
            {
                BookNameOneof book = item;
                Console.WriteLine($"Here's a related book: {book}");
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
        }
    }

    // [END sample]

    public class FindRelatedBooksRequestPagedPageSizeOdysseyMain
    {
        public static void Main(string[] args)
        {
            FindRelatedBooksRequestPagedPageSizeOdyssey.SampleFindRelatedBooks();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBigBookAsyncLongRunningFlattenedAsyncPollUntilCompleteWap.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("LongRunningFlattenedAsyncPollUntilComplete", "wap")

// sample-metadata
//   title: GetBigBook: 'War and Peace'
//   description: Testing calling forms
//   usage: dotnet run [--shelf "Novel\\\"\`\b\t\n\r"]

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START hopper]
    using Google.Example.Library.V1;
    using Google.Protobuf.WellKnownTypes;
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;

    public class GetBigBookAsyncLongRunningFlattenedAsyncPollUntilCompleteWap
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static async Task SampleGetBigBookAsync(string shelf)
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "War and Peace"));
            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> operation = await libraryServiceClient.GetBigBookAsync(name);
            Book response = (await operation.PollUntilCompletedAsync()).Result;
            // Testing iterating over map fields when both key and value are specified.
            foreach (KeyValuePair<string, ListValue> entry in response.MapListValueValue)
            {
                string myKey = entry.Key;
                ListValue myValue = entry.Value;
                Console.WriteLine($"key: {myKey}, value: {myValue}");
            }
            // Testing iterating over map fields when only key is specified.
            foreach (string anotherKey in response.MapListValueValue.Keys)
            {
                Console.WriteLine($"key: {anotherKey}");
            }
            // Testing iterating over map fields when only value is specified.
            for (ListValue anotherValue in response.MapListValueValue.Values){
                Console.WriteLine($"value: {anotherValue}");
            }
            Console.WriteLine($"name: {response.Name}");
            Console.WriteLine($"author: {response.Author}");
        }
    }

    // [END hopper]

    public class GetBigBookAsyncLongRunningFlattenedAsyncPollUntilCompleteWapMain
    {
        public static void Main(string[] args)
        {
            new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
                .WithParsed<Options>(opts =>
                    GetBigBookAsyncLongRunningFlattenedAsyncPollUntilCompleteWap.SampleGetBigBookAsync(opts.Shelf).Wait());
        }

        public class Options
        {
            [Option("shelf", Default = "Novel\\\"`\b\t\n\r")]
            public string Shelf { get; set; }
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBigBookAsyncLongRunningFlattenedAsyncPollUntilCompleteWap2.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("LongRunningFlattenedAsyncPollUntilComplete", "wap2")

// sample-metadata
//   title: GetBigBook: 'War and Peace'
//   description: Testing resource name overlap
//   usage: dotnet run [--shelf Novel] [--big_book_name "War and Peace"]

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START hopper]
    using Google.Example.Library.V1;
    using System;
    using System.Threading.Tasks;

    public class GetBigBookAsyncLongRunningFlattenedAsyncPollUntilCompleteWap2
    {
        /// <summary>
        /// Testing resource name overlap
        /// </summary>
        /// <param name="shelf">Test word wrapping for long lines. This is a long comment. The name of the
        /// shelf to retrieve the big book from.</param>
        /// <param name="bigBookName">The name of the book.</param>
        public static async Task SampleGetBigBookAsync(string shelf, string bigBookName)
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", bigBookName));
            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> operation = await libraryServiceClient.GetBigBookAsync(name);
            Book response = (await operation.PollUntilCompletedAsync()).Result;
            Console.WriteLine(response);
        }
    }

    // [END hopper]

    public class GetBigBookAsyncLongRunningFlattenedAsyncPollUntilCompleteWap2Main
    {
        public static void Main(string[] args)
        {
            new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
                .WithParsed<Options>(opts =>
                    GetBigBookAsyncLongRunningFlattenedAsyncPollUntilCompleteWap2.SampleGetBigBookAsync(opts.Shelf, opts.BigBookName).Wait());
        }

        public class Options
        {
            [Option("shelf", Default = "Novel")]
            public string Shelf { get; set; }

            [Option("big_book_name", Default = "War and Peace")]
            public string BigBookName { get; set; }
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBigBookAsyncLongRunningRequestAsyncPollUntilCompleteWap.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("LongRunningRequestAsyncPollUntilComplete", "wap")

// sample-metadata
//   title: GetBigBook: 'War and Peace'
//   description: Testing calling forms
//   usage: dotnet run [--shelf "Novel\\\"\`\b\t\n\r"]

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START hopper]
    using Google.Example.Library.V1;
    using Google.Protobuf.WellKnownTypes;
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;

    public class GetBigBookAsyncLongRunningRequestAsyncPollUntilCompleteWap
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static async Task SampleGetBigBookAsync(string shelf)
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "War and Peace")),
            };
            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> operation = await libraryServiceClient.GetBigBookAsync(request);
            Book response = (await operation.PollUntilCompletedAsync()).Result;
            // Testing iterating over map fields when both key and value are specified.
            foreach (KeyValuePair<string, ListValue> entry in response.MapListValueValue)
            {
                string myKey = entry.Key;
                ListValue myValue = entry.Value;
                Console.WriteLine($"key: {myKey}, value: {myValue}");
            }
            // Testing iterating over map fields when only key is specified.
            foreach (string anotherKey in response.MapListValueValue.Keys)
            {
                Console.WriteLine($"key: {anotherKey}");
            }
            // Testing iterating over map fields when only value is specified.
            for (ListValue anotherValue in response.MapListValueValue.Values){
                Console.WriteLine($"value: {anotherValue}");
            }
            Console.WriteLine($"name: {response.Name}");
            Console.WriteLine($"author: {response.Author}");
        }
    }

    // [END hopper]

    public class GetBigBookAsyncLongRunningRequestAsyncPollUntilCompleteWapMain
    {
        public static void Main(string[] args)
        {
            new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
                .WithParsed<Options>(opts =>
                    GetBigBookAsyncLongRunningRequestAsyncPollUntilCompleteWap.SampleGetBigBookAsync(opts.Shelf).Wait());
        }

        public class Options
        {
            [Option("shelf", Default = "Novel\\\"`\b\t\n\r")]
            public string Shelf { get; set; }
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBigBookAsyncLongRunningRequestAsyncPollUntilCompleteWap2.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("LongRunningRequestAsyncPollUntilComplete", "wap2")

// sample-metadata
//   title: GetBigBook: 'War and Peace'
//   description: Testing resource name overlap
//   usage: dotnet run [--shelf Novel] [--big_book_name "War and Peace"]

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START hopper]
    using Google.Example.Library.V1;
    using System;
    using System.Threading.Tasks;

    public class GetBigBookAsyncLongRunningRequestAsyncPollUntilCompleteWap2
    {
        /// <summary>
        /// Testing resource name overlap
        /// </summary>
        /// <param name="shelf">Test word wrapping for long lines. This is a long comment. The name of the
        /// shelf to retrieve the big book from.</param>
        /// <param name="bigBookName">The name of the book.</param>
        public static async Task SampleGetBigBookAsync(string shelf, string bigBookName)
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", bigBookName)),
            };
            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> operation = await libraryServiceClient.GetBigBookAsync(request);
            Book response = (await operation.PollUntilCompletedAsync()).Result;
            Console.WriteLine(response);
        }
    }

    // [END hopper]

    public class GetBigBookAsyncLongRunningRequestAsyncPollUntilCompleteWap2Main
    {
        public static void Main(string[] args)
        {
            new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
                .WithParsed<Options>(opts =>
                    GetBigBookAsyncLongRunningRequestAsyncPollUntilCompleteWap2.SampleGetBigBookAsync(opts.Shelf, opts.BigBookName).Wait());
        }

        public class Options
        {
            [Option("shelf", Default = "Novel")]
            public string Shelf { get; set; }

            [Option("big_book_name", Default = "War and Peace")]
            public string BigBookName { get; set; }
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBigBookLongRunningFlattenedPollUntilCompleteWap.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("LongRunningFlattenedPollUntilComplete", "wap")

// sample-metadata
//   title: GetBigBook: 'War and Peace'
//   description: Testing calling forms
//   usage: dotnet run [--shelf "Novel\\\"\`\b\t\n\r"]

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START hopper]
    using Google.Example.Library.V1;
    using Google.Protobuf.WellKnownTypes;
    using System;
    using System.Collections.Generic;

    public class GetBigBookLongRunningFlattenedPollUntilCompleteWap
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static void SampleGetBigBook(string shelf)
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "War and Peace"));
            // Poll until the returned long-running operation is complete
            Book response = libraryServiceClient.GetBigBook(name).PollUntilCompleted().Result;
            // Testing iterating over map fields when both key and value are specified.
            foreach (KeyValuePair<string, ListValue> entry in response.MapListValueValue)
            {
                string myKey = entry.Key;
                ListValue myValue = entry.Value;
                Console.WriteLine($"key: {myKey}, value: {myValue}");
            }
            // Testing iterating over map fields when only key is specified.
            foreach (string anotherKey in response.MapListValueValue.Keys)
            {
                Console.WriteLine($"key: {anotherKey}");
            }
            // Testing iterating over map fields when only value is specified.
            for (ListValue anotherValue in response.MapListValueValue.Values){
                Console.WriteLine($"value: {anotherValue}");
            }
            Console.WriteLine($"name: {response.Name}");
            Console.WriteLine($"author: {response.Author}");
        }
    }

    // [END hopper]

    public class GetBigBookLongRunningFlattenedPollUntilCompleteWapMain
    {
        public static void Main(string[] args)
        {
            new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
                .WithParsed<Options>(opts =>
                    GetBigBookLongRunningFlattenedPollUntilCompleteWap.SampleGetBigBook(opts.Shelf));
        }

        public class Options
        {
            [Option("shelf", Default = "Novel\\\"`\b\t\n\r")]
            public string Shelf { get; set; }
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBigBookLongRunningFlattenedPollUntilCompleteWap2.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("LongRunningFlattenedPollUntilComplete", "wap2")

// sample-metadata
//   title: GetBigBook: 'War and Peace'
//   description: Testing resource name overlap
//   usage: dotnet run [--shelf Novel] [--big_book_name "War and Peace"]

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START hopper]
    using Google.Example.Library.V1;
    using System;

    public class GetBigBookLongRunningFlattenedPollUntilCompleteWap2
    {
        /// <summary>
        /// Testing resource name overlap
        /// </summary>
        /// <param name="shelf">Test word wrapping for long lines. This is a long comment. The name of the
        /// shelf to retrieve the big book from.</param>
        /// <param name="bigBookName">The name of the book.</param>
        public static void SampleGetBigBook(string shelf, string bigBookName)
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", bigBookName));
            // Poll until the returned long-running operation is complete
            Book response = libraryServiceClient.GetBigBook(name).PollUntilCompleted().Result;
            Console.WriteLine(response);
        }
    }

    // [END hopper]

    public class GetBigBookLongRunningFlattenedPollUntilCompleteWap2Main
    {
        public static void Main(string[] args)
        {
            new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
                .WithParsed<Options>(opts =>
                    GetBigBookLongRunningFlattenedPollUntilCompleteWap2.SampleGetBigBook(opts.Shelf, opts.BigBookName));
        }

        public class Options
        {
            [Option("shelf", Default = "Novel")]
            public string Shelf { get; set; }

            [Option("big_book_name", Default = "War and Peace")]
            public string BigBookName { get; set; }
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBigBookLongRunningRequestPollUntilCompleteWap.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("LongRunningRequestPollUntilComplete", "wap")

// sample-metadata
//   title: GetBigBook: 'War and Peace'
//   description: Testing calling forms
//   usage: dotnet run [--shelf "Novel\\\"\`\b\t\n\r"]

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START hopper]
    using Google.Example.Library.V1;
    using Google.Protobuf.WellKnownTypes;
    using System;
    using System.Collections.Generic;

    public class GetBigBookLongRunningRequestPollUntilCompleteWap
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static void SampleGetBigBook(string shelf)
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "War and Peace")),
            };
            // Poll until the returned long-running operation is complete
            Book response = libraryServiceClient.GetBigBook(request).PollUntilCompleted().Result;
            // Testing iterating over map fields when both key and value are specified.
            foreach (KeyValuePair<string, ListValue> entry in response.MapListValueValue)
            {
                string myKey = entry.Key;
                ListValue myValue = entry.Value;
                Console.WriteLine($"key: {myKey}, value: {myValue}");
            }
            // Testing iterating over map fields when only key is specified.
            foreach (string anotherKey in response.MapListValueValue.Keys)
            {
                Console.WriteLine($"key: {anotherKey}");
            }
            // Testing iterating over map fields when only value is specified.
            for (ListValue anotherValue in response.MapListValueValue.Values){
                Console.WriteLine($"value: {anotherValue}");
            }
            Console.WriteLine($"name: {response.Name}");
            Console.WriteLine($"author: {response.Author}");
        }
    }

    // [END hopper]

    public class GetBigBookLongRunningRequestPollUntilCompleteWapMain
    {
        public static void Main(string[] args)
        {
            new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
                .WithParsed<Options>(opts =>
                    GetBigBookLongRunningRequestPollUntilCompleteWap.SampleGetBigBook(opts.Shelf));
        }

        public class Options
        {
            [Option("shelf", Default = "Novel\\\"`\b\t\n\r")]
            public string Shelf { get; set; }
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBigBookLongRunningRequestPollUntilCompleteWap2.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("LongRunningRequestPollUntilComplete", "wap2")

// sample-metadata
//   title: GetBigBook: 'War and Peace'
//   description: Testing resource name overlap
//   usage: dotnet run [--shelf Novel] [--big_book_name "War and Peace"]

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START hopper]
    using Google.Example.Library.V1;
    using System;

    public class GetBigBookLongRunningRequestPollUntilCompleteWap2
    {
        /// <summary>
        /// Testing resource name overlap
        /// </summary>
        /// <param name="shelf">Test word wrapping for long lines. This is a long comment. The name of the
        /// shelf to retrieve the big book from.</param>
        /// <param name="bigBookName">The name of the book.</param>
        public static void SampleGetBigBook(string shelf, string bigBookName)
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", bigBookName)),
            };
            // Poll until the returned long-running operation is complete
            Book response = libraryServiceClient.GetBigBook(request).PollUntilCompleted().Result;
            Console.WriteLine(response);
        }
    }

    // [END hopper]

    public class GetBigBookLongRunningRequestPollUntilCompleteWap2Main
    {
        public static void Main(string[] args)
        {
            new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
                .WithParsed<Options>(opts =>
                    GetBigBookLongRunningRequestPollUntilCompleteWap2.SampleGetBigBook(opts.Shelf, opts.BigBookName));
        }

        public class Options
        {
            [Option("shelf", Default = "Novel")]
            public string Shelf { get; set; }

            [Option("big_book_name", Default = "War and Peace")]
            public string BigBookName { get; set; }
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBigNothingAsyncLongRunningFlattenedAsyncPollUntilCompleteEmptyResponseTypeWithResponseHandling.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("LongRunningFlattenedAsyncPollUntilComplete", "empty_response_type_with_response_handling")

// sample-metadata
//   title: Test response handling for methods that return empty
//   description: Test response handling for methods that return empty
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System;
    using System.Threading.Tasks;

    public class GetBigNothingAsyncLongRunningFlattenedAsyncPollUntilCompleteEmptyResponseTypeWithResponseHandling
    {
        /// <summary>
        /// Test response handling for methods that return empty
        /// </summary>
        public static async Task SampleGetBigNothingAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> operation = await libraryServiceClient.GetBigNothingAsync(name);
            await operation.PollUntilCompletedAsync();
            // Got nothing
            Console.WriteLine("Got nothing.");
        }
    }

    // [END sample]

    public class GetBigNothingAsyncLongRunningFlattenedAsyncPollUntilCompleteEmptyResponseTypeWithResponseHandlingMain
    {
        public static void Main(string[] args)
        {
            GetBigNothingAsyncLongRunningFlattenedAsyncPollUntilCompleteEmptyResponseTypeWithResponseHandling.SampleGetBigNothingAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBigNothingAsyncLongRunningFlattenedAsyncPollUntilCompleteEmptyResponseTypeWithoutResponseHandling.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("LongRunningFlattenedAsyncPollUntilComplete", "empty_response_type_without_response_handling")

// sample-metadata
//   title: Test default response handling is turned off for methods that return empty
//   description: Test default response handling is turned off for methods that return empty
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System.Threading.Tasks;

    public class GetBigNothingAsyncLongRunningFlattenedAsyncPollUntilCompleteEmptyResponseTypeWithoutResponseHandling
    {
        /// <summary>
        /// Test default response handling is turned off for methods that return empty
        /// </summary>
        public static async Task SampleGetBigNothingAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> operation = await libraryServiceClient.GetBigNothingAsync(name);
            await operation.PollUntilCompletedAsync();
        }
    }

    // [END sample]

    public class GetBigNothingAsyncLongRunningFlattenedAsyncPollUntilCompleteEmptyResponseTypeWithoutResponseHandlingMain
    {
        public static void Main(string[] args)
        {
            GetBigNothingAsyncLongRunningFlattenedAsyncPollUntilCompleteEmptyResponseTypeWithoutResponseHandling.SampleGetBigNothingAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBigNothingAsyncLongRunningRequestAsyncPollUntilCompleteEmptyResponseTypeWithResponseHandling.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("LongRunningRequestAsyncPollUntilComplete", "empty_response_type_with_response_handling")

// sample-metadata
//   title: Test response handling for methods that return empty
//   description: Test response handling for methods that return empty
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System;
    using System.Threading.Tasks;

    public class GetBigNothingAsyncLongRunningRequestAsyncPollUntilCompleteEmptyResponseTypeWithResponseHandling
    {
        /// <summary>
        /// Test response handling for methods that return empty
        /// </summary>
        public static async Task SampleGetBigNothingAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> operation = await libraryServiceClient.GetBigNothingAsync(request);
            await operation.PollUntilCompletedAsync();
            // Got nothing
            Console.WriteLine("Got nothing.");
        }
    }

    // [END sample]

    public class GetBigNothingAsyncLongRunningRequestAsyncPollUntilCompleteEmptyResponseTypeWithResponseHandlingMain
    {
        public static void Main(string[] args)
        {
            GetBigNothingAsyncLongRunningRequestAsyncPollUntilCompleteEmptyResponseTypeWithResponseHandling.SampleGetBigNothingAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBigNothingAsyncLongRunningRequestAsyncPollUntilCompleteEmptyResponseTypeWithoutResponseHandling.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("LongRunningRequestAsyncPollUntilComplete", "empty_response_type_without_response_handling")

// sample-metadata
//   title: Test default response handling is turned off for methods that return empty
//   description: Test default response handling is turned off for methods that return empty
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System.Threading.Tasks;

    public class GetBigNothingAsyncLongRunningRequestAsyncPollUntilCompleteEmptyResponseTypeWithoutResponseHandling
    {
        /// <summary>
        /// Test default response handling is turned off for methods that return empty
        /// </summary>
        public static async Task SampleGetBigNothingAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> operation = await libraryServiceClient.GetBigNothingAsync(request);
            await operation.PollUntilCompletedAsync();
        }
    }

    // [END sample]

    public class GetBigNothingAsyncLongRunningRequestAsyncPollUntilCompleteEmptyResponseTypeWithoutResponseHandlingMain
    {
        public static void Main(string[] args)
        {
            GetBigNothingAsyncLongRunningRequestAsyncPollUntilCompleteEmptyResponseTypeWithoutResponseHandling.SampleGetBigNothingAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBigNothingLongRunningFlattenedPollUntilCompleteEmptyResponseTypeWithResponseHandling.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("LongRunningFlattenedPollUntilComplete", "empty_response_type_with_response_handling")

// sample-metadata
//   title: Test response handling for methods that return empty
//   description: Test response handling for methods that return empty
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System;

    public class GetBigNothingLongRunningFlattenedPollUntilCompleteEmptyResponseTypeWithResponseHandling
    {
        /// <summary>
        /// Test response handling for methods that return empty
        /// </summary>
        public static void SampleGetBigNothing()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            // Poll until the returned long-running operation is complete
            libraryServiceClient.GetBigNothing(name).PollUntilCompleted();
            // Got nothing
            Console.WriteLine("Got nothing.");
        }
    }

    // [END sample]

    public class GetBigNothingLongRunningFlattenedPollUntilCompleteEmptyResponseTypeWithResponseHandlingMain
    {
        public static void Main(string[] args)
        {
            GetBigNothingLongRunningFlattenedPollUntilCompleteEmptyResponseTypeWithResponseHandling.SampleGetBigNothing();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBigNothingLongRunningFlattenedPollUntilCompleteEmptyResponseTypeWithoutResponseHandling.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("LongRunningFlattenedPollUntilComplete", "empty_response_type_without_response_handling")

// sample-metadata
//   title: Test default response handling is turned off for methods that return empty
//   description: Test default response handling is turned off for methods that return empty
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;

    public class GetBigNothingLongRunningFlattenedPollUntilCompleteEmptyResponseTypeWithoutResponseHandling
    {
        /// <summary>
        /// Test default response handling is turned off for methods that return empty
        /// </summary>
        public static void SampleGetBigNothing()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            // Poll until the returned long-running operation is complete
            libraryServiceClient.GetBigNothing(name).PollUntilCompleted();
        }
    }

    // [END sample]

    public class GetBigNothingLongRunningFlattenedPollUntilCompleteEmptyResponseTypeWithoutResponseHandlingMain
    {
        public static void Main(string[] args)
        {
            GetBigNothingLongRunningFlattenedPollUntilCompleteEmptyResponseTypeWithoutResponseHandling.SampleGetBigNothing();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBigNothingLongRunningRequestPollUntilCompleteEmptyResponseTypeWithResponseHandling.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("LongRunningRequestPollUntilComplete", "empty_response_type_with_response_handling")

// sample-metadata
//   title: Test response handling for methods that return empty
//   description: Test response handling for methods that return empty
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System;

    public class GetBigNothingLongRunningRequestPollUntilCompleteEmptyResponseTypeWithResponseHandling
    {
        /// <summary>
        /// Test response handling for methods that return empty
        /// </summary>
        public static void SampleGetBigNothing()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            // Poll until the returned long-running operation is complete
            libraryServiceClient.GetBigNothing(request).PollUntilCompleted();
            // Got nothing
            Console.WriteLine("Got nothing.");
        }
    }

    // [END sample]

    public class GetBigNothingLongRunningRequestPollUntilCompleteEmptyResponseTypeWithResponseHandlingMain
    {
        public static void Main(string[] args)
        {
            GetBigNothingLongRunningRequestPollUntilCompleteEmptyResponseTypeWithResponseHandling.SampleGetBigNothing();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBigNothingLongRunningRequestPollUntilCompleteEmptyResponseTypeWithoutResponseHandling.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("LongRunningRequestPollUntilComplete", "empty_response_type_without_response_handling")

// sample-metadata
//   title: Test default response handling is turned off for methods that return empty
//   description: Test default response handling is turned off for methods that return empty
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;

    public class GetBigNothingLongRunningRequestPollUntilCompleteEmptyResponseTypeWithoutResponseHandling
    {
        /// <summary>
        /// Test default response handling is turned off for methods that return empty
        /// </summary>
        public static void SampleGetBigNothing()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            // Poll until the returned long-running operation is complete
            libraryServiceClient.GetBigNothing(request).PollUntilCompleted();
        }
    }

    // [END sample]

    public class GetBigNothingLongRunningRequestPollUntilCompleteEmptyResponseTypeWithoutResponseHandlingMain
    {
        public static void Main(string[] args)
        {
            GetBigNothingLongRunningRequestPollUntilCompleteEmptyResponseTypeWithoutResponseHandling.SampleGetBigNothing();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBookAsyncFlattenedAsyncTestOnSuccessMap.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedAsync", "test_on_success_map")

// sample-metadata
//   title: test maps in response handling
//   description: When there is a very long description for a sample file we can split
//     the description into multiple lines and the samples will be just fine
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System;
    using System.Threading.Tasks;

    public class GetBookAsyncFlattenedAsyncTestOnSuccessMap
    {
        /// <summary>
        /// When there is a very long description for a sample file we can split
        /// the description into multiple lines and the samples will be just fine
        /// </summary>
        public static async Task SampleGetBookAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            Book response = await libraryServiceClient.GetBookAsync(name);
            string intKeyVal = response.MapStringValue[123];
            string booleanKeyVal = response.MapBoolKey[true];
            int mapValueField = response.MapMessageValue["key"].Field;
            Console.WriteLine($"Test printing map fields: {response.MapListValueValue["quoted_key"]}");
            Console.WriteLine($"Test printing enum fields of a map value: {response.MapMessageValue["key"].Alignment}");
        }
    }

    // [END sample]

    public class GetBookAsyncFlattenedAsyncTestOnSuccessMapMain
    {
        public static void Main(string[] args)
        {
            GetBookAsyncFlattenedAsyncTestOnSuccessMap.SampleGetBookAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBookAsyncRequestAsyncTestOnSuccessMap.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestAsync", "test_on_success_map")

// sample-metadata
//   title: test maps in response handling
//   description: When there is a very long description for a sample file we can split
//     the description into multiple lines and the samples will be just fine
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System;
    using System.Threading.Tasks;

    public class GetBookAsyncRequestAsyncTestOnSuccessMap
    {
        /// <summary>
        /// When there is a very long description for a sample file we can split
        /// the description into multiple lines and the samples will be just fine
        /// </summary>
        public static async Task SampleGetBookAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            Book response = await libraryServiceClient.GetBookAsync(request);
            string intKeyVal = response.MapStringValue[123];
            string booleanKeyVal = response.MapBoolKey[true];
            int mapValueField = response.MapMessageValue["key"].Field;
            Console.WriteLine($"Test printing map fields: {response.MapListValueValue["quoted_key"]}");
            Console.WriteLine($"Test printing enum fields of a map value: {response.MapMessageValue["key"].Alignment}");
        }
    }

    // [END sample]

    public class GetBookAsyncRequestAsyncTestOnSuccessMapMain
    {
        public static void Main(string[] args)
        {
            GetBookAsyncRequestAsyncTestOnSuccessMap.SampleGetBookAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBookFlattenedTestOnSuccessMap.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Flattened", "test_on_success_map")

// sample-metadata
//   title: test maps in response handling
//   description: When there is a very long description for a sample file we can split
//     the description into multiple lines and the samples will be just fine
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System;

    public class GetBookFlattenedTestOnSuccessMap
    {
        /// <summary>
        /// When there is a very long description for a sample file we can split
        /// the description into multiple lines and the samples will be just fine
        /// </summary>
        public static void SampleGetBook()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            Book response = libraryServiceClient.GetBook(name);
            string intKeyVal = response.MapStringValue[123];
            string booleanKeyVal = response.MapBoolKey[true];
            int mapValueField = response.MapMessageValue["key"].Field;
            Console.WriteLine($"Test printing map fields: {response.MapListValueValue["quoted_key"]}");
            Console.WriteLine($"Test printing enum fields of a map value: {response.MapMessageValue["key"].Alignment}");
        }
    }

    // [END sample]

    public class GetBookFlattenedTestOnSuccessMapMain
    {
        public static void Main(string[] args)
        {
            GetBookFlattenedTestOnSuccessMap.SampleGetBook();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBookRequestTestOnSuccessMap.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "test_on_success_map")

// sample-metadata
//   title: test maps in response handling
//   description: When there is a very long description for a sample file we can split
//     the description into multiple lines and the samples will be just fine
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System;

    public class GetBookRequestTestOnSuccessMap
    {
        /// <summary>
        /// When there is a very long description for a sample file we can split
        /// the description into multiple lines and the samples will be just fine
        /// </summary>
        public static void SampleGetBook()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            Book response = libraryServiceClient.GetBook(request);
            string intKeyVal = response.MapStringValue[123];
            string booleanKeyVal = response.MapBoolKey[true];
            int mapValueField = response.MapMessageValue["key"].Field;
            Console.WriteLine($"Test printing map fields: {response.MapListValueValue["quoted_key"]}");
            Console.WriteLine($"Test printing enum fields of a map value: {response.MapMessageValue["key"].Alignment}");
        }
    }

    // [END sample]

    public class GetBookRequestTestOnSuccessMapMain
    {
        public static void Main(string[] args)
        {
            GetBookRequestTestOnSuccessMap.SampleGetBook();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/Google.Example.Library.V1.Samples.csproj ==============
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.1</TargetFramework>
    <OutputType>Exe</OutputType>
    <LangVersion>latest</LangVersion>
    <IsPackable>false</IsPackable>
  </PropertyGroup>
  <ItemGroup>
    <ProjectReference Include="../Google.Example.Library.V1/Google.Example.Library.V1.csproj" />
    <PackageReference Include="CommandLineParser" Version="2.5.0" />
  </ItemGroup>

</Project>

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/Lovelace.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestStreamingServer", "prog")

// sample-metadata
//   title: Programming Books
//   description: Testing calling forms
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START lovelace]
    using Google.Example.Library.V1;
    using System;
    using System.Threading.Tasks;

    public class Lovelace
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static async Task SampleStreamBooksAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            StreamBooksRequest request = new StreamBooksRequest
            {
                Name = "BASIC",
            };

            // Make the request, returning a streaming response
            LibraryServiceClient.StreamBooksStream streamingResponse = libraryServiceClient.StreamBooks(request);

            // Read streaming responses from server until complete
            IAsyncEnumerator<Book> responsestream = streamingResponse.ResponseStream;
            await responseStream.ForEachAsync(item =>
            {
                Console.WriteLine(item);
            });
            // The response stream has completed
        }
    }

    // [END lovelace]

    public class LovelaceMain
    {
        public static void Main(string[] args)
        {
            Lovelace.SampleStreamBooksAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/Program.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

using Google.Cloud.SampleUtil;

namespace Google.Example.Library.V1.Samples
{
    class Program
    {
        static void Main(string[] args) => ApplicationChooser.Run(args);
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesAsyncFlattenedAsyncPiVersion.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedAsync", "pi_version")

// sample-metadata
//   title: Pi version
//   description: Testing <@calling forms>
//   usage: dotnet run [--shelf_name Math] [--edition 123]

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START canonical]
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;

    public class PublishSeriesAsyncFlattenedAsyncPiVersion
    {
        /// <summary>
        /// Testing &lt;@calling forms&gt;
        /// </summary>
        /// <param name="shelfName">The name of the shelf where books are published to.</param>
        /// <param name="edition">The edition of the series.</param>
        public static async Task SamplePublishSeriesAsync(string shelfName, uint edition)
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            Shelf shelf = new Shelf
            {
                Name = "Math",
            };
            IEnumerable<Book> books = new List<Book>();
            uint edition = 123;
            SeriesUuid seriesUuid = new SeriesUuid
            {
                SeriesString = "xyz3141592654",
            };
            PublisherName publisher = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]");
            PublishSeriesResponse response = await libraryServiceClient.PublishSeriesAsync(shelf, books, edition, seriesUuid, publisher);
            // % % % output handling % % % %
            // fourScoreAndSevenYears ago
            //
            // our fathers brought forth upon this continent
            // a new nation
            // conceived in liberty
            //
            // and dedicated to the proposition that allMenAreCreatedEqual.
            // Do something with bookNames one by one
            IEnumerable<string> bookNames = response.BookNames;
            foreach (string title in response.BookNames)
            {
                // Now we deal with thisSingleBook!
                Console.WriteLine($"\t%`` The book's title: \"{title}\", \\\nand the book costs $50.00 ``%");
            }
            Console.WriteLine($"The first book is: {response.BookNames[0]}");
            Console.WriteLine($"The author of the first book is: {response.Books[0].Author}");
            Console.WriteLine("That's all!");
            Console.WriteLine($"series_uuid: {response.SeriesUuid.SeriesBytes}");
        }
    }

    // [END canonical]

    public class PublishSeriesAsyncFlattenedAsyncPiVersionMain
    {
        public static void Main(string[] args)
        {
            new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
                .WithParsed<Options>(opts =>
                    PublishSeriesAsyncFlattenedAsyncPiVersion.SamplePublishSeriesAsync(opts.ShelfName, opts.Edition).Wait());
        }

        public class Options
        {
            [Option("shelf_name", Default = "Math")]
            public string ShelfName { get; set; }

            [Option("edition", Default = 123)]
            public uint Edition { get; set; }
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesAsyncFlattenedAsyncSecondEdition.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedAsync", "second_edition")

// sample-metadata
//   title: Second edition
//   description: Testing calling forms
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START canonical]
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;

    public class PublishSeriesAsyncFlattenedAsyncSecondEdition
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static async Task SamplePublishSeriesAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            Shelf shelf = new Shelf();
            IEnumerable<Book> books = new List<Book>();
            uint edition = 2;
            SeriesUuid seriesUuid = new SeriesUuid();
            PublisherName publisher = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]");
            PublishSeriesResponse response = await libraryServiceClient.PublishSeriesAsync(shelf, books, edition, seriesUuid, publisher);
            Console.WriteLine(response);
        }
    }

    // [END canonical]

    public class PublishSeriesAsyncFlattenedAsyncSecondEditionMain
    {
        public static void Main(string[] args)
        {
            PublishSeriesAsyncFlattenedAsyncSecondEdition.SamplePublishSeriesAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesAsyncRequestAsyncPiVersion.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestAsync", "pi_version")

// sample-metadata
//   title: Pi version
//   description: Testing <@calling forms>
//   usage: dotnet run [--shelf_name Math] [--edition 123]

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START canonical]
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;

    public class PublishSeriesAsyncRequestAsyncPiVersion
    {
        /// <summary>
        /// Testing &lt;@calling forms&gt;
        /// </summary>
        /// <param name="shelfName">The name of the shelf where books are published to.</param>
        /// <param name="edition">The edition of the series.</param>
        public static async Task SamplePublishSeriesAsync(string shelfName, uint edition)
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf
                {
                    // The name of the shelf where books are published to.
                    Name = "Math",
                },
                Books = { },
                SeriesUuid = new SeriesUuid
                {
                    SeriesString = "xyz3141592654",
                },
                Edition = 123,
            };
            PublishSeriesResponse response = await libraryServiceClient.PublishSeriesAsync(request);
            // % % % output handling % % % %
            // fourScoreAndSevenYears ago
            //
            // our fathers brought forth upon this continent
            // a new nation
            // conceived in liberty
            //
            // and dedicated to the proposition that allMenAreCreatedEqual.
            // Do something with bookNames one by one
            IEnumerable<string> bookNames = response.BookNames;
            foreach (string title in response.BookNames)
            {
                // Now we deal with thisSingleBook!
                Console.WriteLine($"\t%`` The book's title: \"{title}\", \\\nand the book costs $50.00 ``%");
            }
            Console.WriteLine($"The first book is: {response.BookNames[0]}");
            Console.WriteLine($"The author of the first book is: {response.Books[0].Author}");
            Console.WriteLine("That's all!");
            Console.WriteLine($"series_uuid: {response.SeriesUuid.SeriesBytes}");
        }
    }

    // [END canonical]

    public class PublishSeriesAsyncRequestAsyncPiVersionMain
    {
        public static void Main(string[] args)
        {
            new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
                .WithParsed<Options>(opts =>
                    PublishSeriesAsyncRequestAsyncPiVersion.SamplePublishSeriesAsync(opts.ShelfName, opts.Edition).Wait());
        }

        public class Options
        {
            [Option("shelf_name", Default = "Math")]
            public string ShelfName { get; set; }

            [Option("edition", Default = 123)]
            public uint Edition { get; set; }
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesAsyncRequestAsyncSecondEdition.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestAsync", "second_edition")

// sample-metadata
//   title: Second edition
//   description: Testing calling forms
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START canonical]
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;

    public class PublishSeriesAsyncRequestAsyncSecondEdition
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static async Task SamplePublishSeriesAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                SeriesUuid = new SeriesUuid(),
                Edition = 2,
            };
            PublishSeriesResponse response = await libraryServiceClient.PublishSeriesAsync(request);
            Console.WriteLine(response);
        }
    }

    // [END canonical]

    public class PublishSeriesAsyncRequestAsyncSecondEditionMain
    {
        public static void Main(string[] args)
        {
            PublishSeriesAsyncRequestAsyncSecondEdition.SamplePublishSeriesAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesFlattenedPiVersion.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Flattened", "pi_version")

// sample-metadata
//   title: Pi version
//   description: Testing <@calling forms>
//   usage: dotnet run [--shelf_name Math] [--edition 123]

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START canonical]
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;

    public class PublishSeriesFlattenedPiVersion
    {
        /// <summary>
        /// Testing &lt;@calling forms&gt;
        /// </summary>
        /// <param name="shelfName">The name of the shelf where books are published to.</param>
        /// <param name="edition">The edition of the series.</param>
        public static void SamplePublishSeries(string shelfName, uint edition)
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            Shelf shelf = new Shelf
            {
                Name = "Math",
            };
            IEnumerable<Book> books = new List<Book>();
            uint edition = 123;
            SeriesUuid seriesUuid = new SeriesUuid
            {
                SeriesString = "xyz3141592654",
            };
            PublisherName publisher = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]");
            PublishSeriesResponse response = libraryServiceClient.PublishSeries(shelf, books, edition, seriesUuid, publisher);
            // % % % output handling % % % %
            // fourScoreAndSevenYears ago
            //
            // our fathers brought forth upon this continent
            // a new nation
            // conceived in liberty
            //
            // and dedicated to the proposition that allMenAreCreatedEqual.
            // Do something with bookNames one by one
            IEnumerable<string> bookNames = response.BookNames;
            foreach (string title in response.BookNames)
            {
                // Now we deal with thisSingleBook!
                Console.WriteLine($"\t%`` The book's title: \"{title}\", \\\nand the book costs $50.00 ``%");
            }
            Console.WriteLine($"The first book is: {response.BookNames[0]}");
            Console.WriteLine($"The author of the first book is: {response.Books[0].Author}");
            Console.WriteLine("That's all!");
            Console.WriteLine($"series_uuid: {response.SeriesUuid.SeriesBytes}");
        }
    }

    // [END canonical]

    public class PublishSeriesFlattenedPiVersionMain
    {
        public static void Main(string[] args)
        {
            new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
                .WithParsed<Options>(opts =>
                    PublishSeriesFlattenedPiVersion.SamplePublishSeries(opts.ShelfName, opts.Edition));
        }

        public class Options
        {
            [Option("shelf_name", Default = "Math")]
            public string ShelfName { get; set; }

            [Option("edition", Default = 123)]
            public uint Edition { get; set; }
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesFlattenedSecondEdition.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Flattened", "second_edition")

// sample-metadata
//   title: Second edition
//   description: Testing calling forms
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START canonical]
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;

    public class PublishSeriesFlattenedSecondEdition
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static void SamplePublishSeries()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            Shelf shelf = new Shelf();
            IEnumerable<Book> books = new List<Book>();
            uint edition = 2;
            SeriesUuid seriesUuid = new SeriesUuid();
            PublisherName publisher = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]");
            PublishSeriesResponse response = libraryServiceClient.PublishSeries(shelf, books, edition, seriesUuid, publisher);
            Console.WriteLine(response);
        }
    }

    // [END canonical]

    public class PublishSeriesFlattenedSecondEditionMain
    {
        public static void Main(string[] args)
        {
            PublishSeriesFlattenedSecondEdition.SamplePublishSeries();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesRequestPiVersion.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "pi_version")

// sample-metadata
//   title: Pi version
//   description: Testing <@calling forms>
//   usage: dotnet run [--shelf_name Math] [--edition 123]

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START canonical]
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;

    public class PublishSeriesRequestPiVersion
    {
        /// <summary>
        /// Testing &lt;@calling forms&gt;
        /// </summary>
        /// <param name="shelfName">The name of the shelf where books are published to.</param>
        /// <param name="edition">The edition of the series.</param>
        public static void SamplePublishSeries(string shelfName, uint edition)
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf
                {
                    // The name of the shelf where books are published to.
                    Name = "Math",
                },
                Books = { },
                SeriesUuid = new SeriesUuid
                {
                    SeriesString = "xyz3141592654",
                },
                Edition = 123,
            };
            PublishSeriesResponse response = libraryServiceClient.PublishSeries(request);
            // % % % output handling % % % %
            // fourScoreAndSevenYears ago
            //
            // our fathers brought forth upon this continent
            // a new nation
            // conceived in liberty
            //
            // and dedicated to the proposition that allMenAreCreatedEqual.
            // Do something with bookNames one by one
            IEnumerable<string> bookNames = response.BookNames;
            foreach (string title in response.BookNames)
            {
                // Now we deal with thisSingleBook!
                Console.WriteLine($"\t%`` The book's title: \"{title}\", \\\nand the book costs $50.00 ``%");
            }
            Console.WriteLine($"The first book is: {response.BookNames[0]}");
            Console.WriteLine($"The author of the first book is: {response.Books[0].Author}");
            Console.WriteLine("That's all!");
            Console.WriteLine($"series_uuid: {response.SeriesUuid.SeriesBytes}");
        }
    }

    // [END canonical]

    public class PublishSeriesRequestPiVersionMain
    {
        public static void Main(string[] args)
        {
            new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
                .WithParsed<Options>(opts =>
                    PublishSeriesRequestPiVersion.SamplePublishSeries(opts.ShelfName, opts.Edition));
        }

        public class Options
        {
            [Option("shelf_name", Default = "Math")]
            public string ShelfName { get; set; }

            [Option("edition", Default = 123)]
            public uint Edition { get; set; }
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesRequestSecondEdition.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "second_edition")

// sample-metadata
//   title: Second edition
//   description: Testing calling forms
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START canonical]
    using Google.Example.Library.V1;
    using System;
    using System.Collections.Generic;

    public class PublishSeriesRequestSecondEdition
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static void SamplePublishSeries()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                SeriesUuid = new SeriesUuid(),
                Edition = 2,
            };
            PublishSeriesResponse response = libraryServiceClient.PublishSeries(request);
            Console.WriteLine(response);
        }
    }

    // [END canonical]

    public class PublishSeriesRequestSecondEditionMain
    {
        public static void Main(string[] args)
        {
            PublishSeriesRequestSecondEdition.SamplePublishSeries();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesRequestTestRequestObjectFieldComments.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "test_request_object_field_comments")

// sample-metadata
//   title: request object field comments
//   description: Test request object field comments
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using Google.Protobuf;
    using System;
    using System.Collections.Generic;
    using System.IO;

    public class PublishSeriesRequestTestRequestObjectFieldComments
    {
        /// <summary>
        /// Test request object field comments
        /// </summary>
        public static void SamplePublishSeries()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf
                {
                    // Comment on a resource name
                    Name = new ShelfName("math").ToString(),
                    // A super long comment
                    // wraps words at newline characters
                    // as well
                    Theme = "Math",
                    // Comment on a primitive field
                    InternalTheme = "Statistics",
                },
                Books = { },
                SeriesUuid = new SeriesUuid
                {
                    // Comment on a file input field
                    SeriesBytes = ByteString.CopyFrom(File.ReadAllBytes("xyz3141592654")),
                },
                Edition = 123,
            };
            PublishSeriesResponse response = libraryServiceClient.PublishSeries(request);
            Console.WriteLine(response);
        }
    }

    // [END sample]

    public class PublishSeriesRequestTestRequestObjectFieldCommentsMain
    {
        public static void Main(string[] args)
        {
            PublishSeriesRequestTestRequestObjectFieldComments.SamplePublishSeries();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesRequestTestWriteToFile.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "test_write_to_file")

// sample-metadata
//   title: test writing fields to files
//   description: Testing write fields to files.
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;

    public class PublishSeriesRequestTestWriteToFile
    {
        /// <summary>
        /// Testing write fields to files.
        /// </summary>
        public static void SamplePublishSeries()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                SeriesUuid = new SeriesUuid(),
            };
            PublishSeriesResponse response = libraryServiceClient.PublishSeries(request);
            // testing writing bytes field.
            File.WriteAllBytes($"uuid_of_series_with_book_{response.BookNames[0]}.raw", response.SeriesUuid.SeriesBytes.ToArray());
            // testing writing string field.
            File.WriteAllText("series_uuid_in_plain_text.txt", response.SeriesUuid.SeriesString);
        }
    }

    // [END sample]

    public class PublishSeriesRequestTestWriteToFileMain
    {
        public static void Main(string[] args)
        {
            PublishSeriesRequestTestWriteToFile.SamplePublishSeries();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/SampleGetShelf.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "test_default_calling_form_unary")

// sample-metadata
//   title: test_default_calling_form_unary
//   description: Test default calling forms for unary methods.
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample_get_shelf]
    using Google.Example.Library.V1;
    using System;

    public class SampleGetShelf
    {
        /// <summary>
        /// Test default calling forms for unary methods.
        /// </summary>
        public static void SampleGetShelf()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            GetShelfRequest request = new GetShelfRequest
            {
                ShelfName = new ShelfName("my-shelf"),
                Options = "",
            };
            Shelf response = libraryServiceClient.GetShelf(request);
            Console.WriteLine($"The theme of the shelf is: {response.Theme}");
        }
    }

    // [END sample_get_shelf]

    public class SampleGetShelfMain
    {
        public static void Main(string[] args)
        {
            SampleGetShelf.SampleGetShelf();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/StreamShelvesRequestStreamingBidiEmpty.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestStreamingBidi", "empty")

// sample-metadata
//   title: Server streaming
//   description: Testing calling forms
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System;
    using System.Threading.Tasks;

    public class StreamShelvesRequestStreamingBidiEmpty
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static async Task SampleStreamShelvesAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();

            // Initialize streaming call, retrieving the stream object
            LibraryServiceClient.StreamShelvesStream duplexStream =
                libraryServiceClient.StreamShelves();

            // Sending requests are retrieving responses can be arbitrarily interleaved.
            // Exact sequence will depend on client/server behavior.

            // Create task to do something with responses from server
            Task responseHandlerTask = Task.Run(async () =>
                {
                    IAsyncEnumerator<StreamShelvesResponse> responseStream = duplexStream.ResponseStream;
                    while (await responseStream.MoveNext())
                    {
                        StreamShelvesResponse item = responseStream.Current;
                        Console.WriteLine(item);
                    }
                    // The response stream has completed
                });

            // Send requests to the server
            bool done = false;
            while (!done)
            {
                // Initialize a request
                StreamShelvesRequest request = new StreamShelvesRequest
                {
                    ShelfName = new ShelfName("[SHELF]"),
                };
                // Stream a request to the server
                await duplexStream.WriteAsync(request);

                // Set "done" to true when sending requests is complete
                done = true;
            }
            // Complete writing requests to the stream
            await duplexStream.WriteCompleteAsync();
            // Await the response handler.
            // This will complete once all server responses have been processed.
            await responseHandlerTask;
        }
    }

    // [END sample]

    public class StreamShelvesRequestStreamingBidiEmptyMain
    {
        public static void Main(string[] args)
        {
            StreamShelvesRequestStreamingBidiEmpty.SampleStreamShelvesAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/StreamShelvesRequestStreamingServerEmpty.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestStreamingServer", "empty")

// sample-metadata
//   title: Server streaming
//   description: Testing calling forms
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START sample]
    using Google.Example.Library.V1;
    using System;
    using System.Threading.Tasks;

    public class StreamShelvesRequestStreamingServerEmpty
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static async Task SampleStreamShelvesAsync()
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            StreamShelvesRequest request = new StreamShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
            };

            // Make the request, returning a streaming response
            LibraryServiceClient.StreamShelvesStream streamingResponse = libraryServiceClient.StreamShelves(request);

            // Read streaming responses from server until complete
            IAsyncEnumerator<StreamShelvesResponse> responsestream = streamingResponse.ResponseStream;
            await responseStream.ForEachAsync(item =>
            {
                Console.WriteLine(item);
            });
            // The response stream has completed
        }
    }

    // [END sample]

    public class StreamShelvesRequestStreamingServerEmptyMain
    {
        public static void Main(string[] args)
        {
            StreamShelvesRequestStreamingServerEmpty.SampleStreamShelvesAsync().Wait();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/TestDefaultCallingFormForPaging.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestPagedAll", "test_default_calling_form_paging")

// sample-metadata
//   title: test default calling form for paging
//   description: Test default calling form for paging methods.
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START test_default_calling_form_for_paging]
    using Google.Api.Gax;
    using Google.Example.Library.V1;
    using System;

    public class TestDefaultCallingFormForPaging
    {
        /// <summary>
        /// Test default calling form for paging methods.
        /// </summary>
        public static void SampleListShelves()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            ListShelvesRequest request = new ListShelvesRequest();
            PagedEnumerable<ListShelvesResponse, Shelf> response = libraryServiceClient.ListShelves(request);
            // Iterate over pages (of server-defined size), performing one RPC per page
            foreach (Shelf item in response)
            {
                Console.WriteLine($"shelf name: {item}");
            }
        }
    }

    // [END test_default_calling_form_for_paging]

    public class TestDefaultCallingFormForPagingMain
    {
        public static void Main(string[] args)
        {
            TestDefaultCallingFormForPaging.SampleListShelves();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/TestFloatAndInt64.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "test_float_and_int64")

// sample-metadata
//   title:
//   usage: dotnet run [--param_float 1.2345] [--param_long 67890]

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START test_float_and_int64]
    using Google.Example.Library.V1;
    using Google.Protobuf;
    using Google.Protobuf.WellKnownTypes;
    using System;
    using System.Collections.Generic;

    public class TestFloatAndInt64
    {
        public static void SampleTestOptionalRequiredFlatteningParams(float paramFloat, long paramLong)
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            TestOptionalRequiredFlatteningParamsRequest request = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 0,
                RequiredSingularInt64 = 67890L,
                RequiredSingularFloat = 1.2345f,
                RequiredSingularDouble = 0.0,
                RequiredSingularBool = false,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "",
                RequiredSingularBytes = ByteString.Empty,
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                RequiredSingularResourceNameCommon = "",
                RequiredSingularFixed32 = 0,
                RequiredSingularFixed64 = 0L,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNameOneofs = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedResourceNameCommon = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
                RequiredAnyValue = new Any(),
                RequiredStructValue = new Struct(),
                RequiredValueValue = new Value(),
                RequiredListValueValue = new ListValue(),
                RequiredTimeValue = new Timestamp(),
                RequiredDurationValue = new Duration(),
                RequiredFieldMaskValue = new FieldMask(),
                RequiredInt32Value = null,
                RequiredUint32Value = null,
                RequiredInt64Value = null,
                RequiredUint64Value = null,
                RequiredFloatValue = null,
                RequiredDoubleValue = null,
                RequiredStringValue = null,
                RequiredBoolValue = null,
                RequiredBytesValue = null,
                RequiredRepeatedAnyValue = { },
                RequiredRepeatedStructValue = { },
                RequiredRepeatedValueValue = { },
                RequiredRepeatedListValueValue = { },
                RequiredRepeatedTimeValue = { },
                RequiredRepeatedDurationValue = { },
                RequiredRepeatedFieldMaskValue = { },
                RequiredRepeatedInt32Value = { },
                RequiredRepeatedUint32Value = { },
                RequiredRepeatedInt64Value = { },
                RequiredRepeatedUint64Value = { },
                RequiredRepeatedFloatValue = { },
                RequiredRepeatedDoubleValue = { },
                RequiredRepeatedStringValue = { },
                RequiredRepeatedBoolValue = { },
                RequiredRepeatedBytesValue = { },
            };
            TestOptionalRequiredFlatteningParamsResponse response = libraryServiceClient.TestOptionalRequiredFlatteningParams(request);
            Console.WriteLine(response);
        }
    }

    // [END test_float_and_int64]

    public class TestFloatAndInt64Main
    {
        public static void Main(string[] args)
        {
            new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
                .WithParsed<Options>(opts =>
                    TestFloatAndInt64.SampleTestOptionalRequiredFlatteningParams(opts.ParamFloat, opts.ParamLong));
        }

        public class Options
        {
            [Option("param_float", Default = 1.2345f)]
            public float ParamFloat { get; set; }

            [Option("param_long", Default = 67890L)]
            public long ParamLong { get; set; }
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/TestResourceNameOneof.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "test_resource_name_oneof")

// sample-metadata
//   title:
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START test_resource_name_oneof]
    using Google.Example.Library.V1;
    using System;

    public class TestResourceNameOneof
    {
        public static void SampleGetBookFromAbsolutelyAnywhere()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            GetBookFromAbsolutelyAnywhereRequest request = new GetBookFromAbsolutelyAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "The ID of the book")),
            };
            BookFromAnywhere response = libraryServiceClient.GetBookFromAbsolutelyAnywhere(request);
            Console.WriteLine("Archived book found.");
        }
    }

    // [END test_resource_name_oneof]

    public class TestResourceNameOneofMain
    {
        public static void Main(string[] args)
        {
            TestResourceNameOneof.SampleGetBookFromAbsolutelyAnywhere();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/TestResourceNameOneof2.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "test_resource_name_oneof_2")

// sample-metadata
//   title:
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START test_resource_name_oneof_2]
    using Google.Example.Library.V1;
    using System;

    public class TestResourceNameOneof2
    {
        public static void SampleGetBookFromAbsolutelyAnywhere()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            GetBookFromAbsolutelyAnywhereRequest request = new GetBookFromAbsolutelyAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "The ID of the book")),
            };
            BookFromAnywhere response = libraryServiceClient.GetBookFromAbsolutelyAnywhere(request);
            Console.WriteLine("Book on shelf found.");
        }
    }

    // [END test_resource_name_oneof_2]

    public class TestResourceNameOneof2Main
    {
        public static void Main(string[] args)
        {
            TestResourceNameOneof2.SampleGetBookFromAbsolutelyAnywhere();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/TestSettingUpEmptyObjectsInRequest.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "test_setting_up_empty_objects_in_request")

// sample-metadata
//   title: test_setting_up_empty_objects_in_request
//   description: Test setting up empty objects in the request objects.
//   usage: dotnet run

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START test_setting_up_empty_objects_in_request]
    using Google.Example.Library.V1;
    using System;

    public class TestSettingUpEmptyObjectsInRequest
    {
        /// <summary>
        /// Test setting up empty objects in the request objects.
        /// </summary>
        public static void SampleGetShelf()
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            GetShelfRequest request = new GetShelfRequest
            {
                ShelfName = new ShelfName("my-shelf"),
                Options = "",
                Message = new SomeMessage(),
                StringBuilder = new StringBuilder(),
            };
            Shelf response = libraryServiceClient.GetShelf(request);
            Console.WriteLine("Shelf found.");
        }
    }

    // [END test_setting_up_empty_objects_in_request]

    public class TestSettingUpEmptyObjectsInRequestMain
    {
        public static void Main(string[] args)
        {
            TestSettingUpEmptyObjectsInRequest.SampleGetShelf();
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/ThisTagShouldBeTheNameOfTheFile.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("LongRunningRequestPollUntilComplete", "wap")

// sample-metadata
//   title: GetBigBook: 'War and Peace'
//   description: Testing calling forms
//   usage: dotnet run [--shelf "Novel\\\"\`\b\t\n\r"]

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START this_tag_should_be_the_name_of_the_file]
    using Google.Example.Library.V1;
    using Google.Protobuf.WellKnownTypes;
    using System;
    using System.Collections.Generic;

    public class ThisTagShouldBeTheNameOfTheFile
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static void SampleGetBigBook(string shelf)
        {
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "War and Peace")),
            };
            // Poll until the returned long-running operation is complete
            Book response = libraryServiceClient.GetBigBook(request).PollUntilCompleted().Result;
            // Testing iterating over map fields when both key and value are specified.
            foreach (KeyValuePair<string, ListValue> entry in response.MapListValueValue)
            {
                string myKey = entry.Key;
                ListValue myValue = entry.Value;
                Console.WriteLine($"key: {myKey}, value: {myValue}");
            }
            // Testing iterating over map fields when only key is specified.
            foreach (string anotherKey in response.MapListValueValue.Keys)
            {
                Console.WriteLine($"key: {anotherKey}");
            }
            // Testing iterating over map fields when only value is specified.
            for (ListValue anotherValue in response.MapListValueValue.Values){
                Console.WriteLine($"value: {anotherValue}");
            }
            Console.WriteLine($"name: {response.Name}");
            Console.WriteLine($"author: {response.Author}");
        }
    }

    // [END this_tag_should_be_the_name_of_the_file]

    public class ThisTagShouldBeTheNameOfTheFileMain
    {
        public static void Main(string[] args)
        {
            new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
                .WithParsed<Options>(opts =>
                    ThisTagShouldBeTheNameOfTheFile.SampleGetBigBook(opts.Shelf));
        }

        public class Options
        {
            [Option("shelf", Default = "Novel\\\"`\b\t\n\r")]
            public string Shelf { get; set; }
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/TuringProgRequestStreamingBidi.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestStreamingBidi", "prog")

// sample-metadata
//   title: Programming Books
//   description: Testing calling forms
//   usage: dotnet run [--image_file_name "image_file.jpg"] [--stage DRAFT]

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START turing_prog_request_streaming_bidi]
    using Google.Example.Library.V1;
    using Google.Protobuf;
    using System;
    using System.IO;
    using System.Threading.Tasks;

    public class TuringProgRequestStreamingBidi
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static async Task SampleDiscussBookAsync(string imageFileName, Comment.Types.Stage stage)
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();

            // Initialize streaming call, retrieving the stream object
            LibraryServiceClient.DiscussBookStream duplexStream =
                libraryServiceClient.DiscussBook();

            // Sending requests are retrieving responses can be arbitrarily interleaved.
            // Exact sequence will depend on client/server behavior.

            // Create task to do something with responses from server
            Task responseHandlerTask = Task.Run(async () =>
                {
                    IAsyncEnumerator<Comment> responseStream = duplexStream.ResponseStream;
                    while (await responseStream.MoveNext())
                    {
                        Comment item = responseStream.Current;
                        Console.WriteLine(item);
                    }
                    // The response stream has completed
                });

            // Send requests to the server
            bool done = false;
            while (!done)
            {
                // Initialize a request
                DiscussBookRequest request = new DiscussBookRequest
                {
                    BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                    Comment = new Comment
                    {
                        Comment = ByteString.CopyFrom(File.ReadAllBytes("comment_file")),
                        Stage = Comment.Types.Stage.Draft,
                    },
                    Image = ByteString.CopyFrom(File.ReadAllBytes(imageFileName)),
                };
                // Stream a request to the server
                await duplexStream.WriteAsync(request);

                // Set "done" to true when sending requests is complete
                done = true;
            }
            // Complete writing requests to the stream
            await duplexStream.WriteCompleteAsync();
            // Await the response handler.
            // This will complete once all server responses have been processed.
            await responseHandlerTask;
        }
    }

    // [END turing_prog_request_streaming_bidi]

    public class TuringProgRequestStreamingBidiMain
    {
        public static void Main(string[] args)
        {
            new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
                .WithParsed<Options>(opts =>
                    TuringProgRequestStreamingBidi.SampleDiscussBookAsync(opts.ImageFileName, opts.Stage).Wait());
        }

        public class Options
        {
            [Option("image_file_name", Default = "image_file.jpg")]
            public string ImageFileName { get; set; }

            [Option("stage", Default = Comment.Types.Stage.Draft)]
            public Comment.Types.Stage Stage { get; set; }
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/TuringProgRequestStreamingServer.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestStreamingServer", "prog")

// sample-metadata
//   title: Programming Books
//   description: Testing calling forms
//   usage: dotnet run [--image_file_name "image_file.jpg"] [--stage DRAFT]

using CommandLine;

namespace Google.Example.Library.V1.Samples
{
    // [START turing_prog_request_streaming_server]
    using Google.Example.Library.V1;
    using Google.Protobuf;
    using System;
    using System.IO;
    using System.Threading.Tasks;

    public class TuringProgRequestStreamingServer
    {
        /// <summary>
        /// Testing calling forms
        /// </summary>
        public static async Task SampleDiscussBookAsync(string imageFileName, Comment.Types.Stage stage)
        {
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            DiscussBookRequest request = new DiscussBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Comment = new Comment
                {
                    Comment = ByteString.CopyFrom(File.ReadAllBytes("comment_file")),
                    Stage = Comment.Types.Stage.Draft,
                },
                Image = ByteString.CopyFrom(File.ReadAllBytes(imageFileName)),
            };

            // Make the request, returning a streaming response
            LibraryServiceClient.DiscussBookStream streamingResponse = libraryServiceClient.DiscussBook(request);

            // Read streaming responses from server until complete
            IAsyncEnumerator<Comment> responsestream = streamingResponse.ResponseStream;
            await responseStream.ForEachAsync(item =>
            {
                Console.WriteLine(item);
            });
            // The response stream has completed
        }
    }

    // [END turing_prog_request_streaming_server]

    public class TuringProgRequestStreamingServerMain
    {
        public static void Main(string[] args)
        {
            new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
                .WithParsed<Options>(opts =>
                    TuringProgRequestStreamingServer.SampleDiscussBookAsync(opts.ImageFileName, opts.Stage).Wait());
        }

        public class Options
        {
            [Option("image_file_name", Default = "image_file.jpg")]
            public string ImageFileName { get; set; }

            [Option("stage", Default = Comment.Types.Stage.Draft)]
            public Comment.Types.Stage Stage { get; set; }
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.SmokeTests/Google.Example.Library.V1.SmokeTests.csproj ==============
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netcoreapp1.0</TargetFramework>
    <OutputType>Exe</OutputType>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="../Google.Example.Library.V1/Google.Example.Library.V1.csproj" />
  </ItemGroup>

</Project>

============== file: Google.Example.Library.V1/Google.Example.Library.V1.SmokeTests/LibraryServiceSmokeTest.g.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

namespace Google.Example.Library.V1.SmokeTests
{
    using Google.Api.Gax;
    using Google.Api.Gax.Grpc;
    using Google.Protobuf.WellKnownTypes;
    using Grpc.Core;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Threading;
    using System.Threading.Tasks;

    public class LibraryServiceSmokeTest
    {
        public static int Main(string[] args)
        {
            // Read projectId from args
            if (args.Length != 1)
            {
                Console.WriteLine("Usage: Project ID must be passed as first argument.");
                Console.WriteLine();
                return 1;
            }
            string projectId = args[0];

            // Create client
            LibraryServiceClient client = LibraryServiceClient.Create();

            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", projectId));
            Book book = new Book
            {
                Rating = Book.Types.Rating.Good,
            };

            // Call API method
            Book response = client.UpdateBook(name, book);
            // Show the result
            Console.WriteLine(response);

            // Success
            Console.WriteLine("Smoke test passed OK");
            return 0;
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Snippets/Google.Example.Library.V1.Snippets.csproj ==============
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>netcoreapp1.0;netcoreapp2.0;net452</TargetFrameworks>
    <TargetFrameworks Condition=" '$(OS)' != 'Windows_NT' ">netcoreapp1.0;netcoreapp2.0</TargetFrameworks>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="../Google.Example.Library.V1/Google.Example.Library.V1.csproj" />
  </ItemGroup>

</Project>

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Snippets/LibraryServiceClientSnippets.g.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

namespace Google.Example.Library.V1.Snippets
{
    using Google.Api.Gax;
    using Google.Api.Gax.Grpc;
    using apis = Google.Example.Library.V1;
    using Google.LongRunning;
    using Google.Protobuf;
    using Google.Protobuf.WellKnownTypes;
    using Google.Tagger.V1;
    using Grpc.Core;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Linq;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>Generated snippets</summary>
    public class GeneratedLibraryServiceClientSnippets
    {
        /// <summary>Snippet for CreateShelfAsync</summary>
        public async Task CreateShelfAsync()
        {
            // Snippet: CreateShelfAsync(Shelf,CallSettings)
            // Additional: CreateShelfAsync(Shelf,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            Shelf shelf = new Shelf();
            // Make the request
            Shelf response = await libraryServiceClient.CreateShelfAsync(shelf);
            // End snippet
        }

        /// <summary>Snippet for CreateShelf</summary>
        public void CreateShelf()
        {
            // Snippet: CreateShelf(Shelf,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            Shelf shelf = new Shelf();
            // Make the request
            Shelf response = libraryServiceClient.CreateShelf(shelf);
            // End snippet
        }

        /// <summary>Snippet for CreateShelfAsync</summary>
        public async Task CreateShelfAsync_RequestObject()
        {
            // Snippet: CreateShelfAsync(CreateShelfRequest,CallSettings)
            // Additional: CreateShelfAsync(CreateShelfRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            CreateShelfRequest request = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            // Make the request
            Shelf response = await libraryServiceClient.CreateShelfAsync(request);
            // End snippet
        }

        /// <summary>Snippet for CreateShelf</summary>
        public void CreateShelf_RequestObject()
        {
            // Snippet: CreateShelf(CreateShelfRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            CreateShelfRequest request = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            // Make the request
            Shelf response = libraryServiceClient.CreateShelf(request);
            // End snippet
        }

        /// <summary>Snippet for GetShelfAsync</summary>
        public async Task GetShelfAsync1()
        {
            // Snippet: GetShelfAsync(ShelfName,CallSettings)
            // Additional: GetShelfAsync(ShelfName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF]");
            // Make the request
            Shelf response = await libraryServiceClient.GetShelfAsync(name);
            // End snippet
        }

        /// <summary>Snippet for GetShelf</summary>
        public void GetShelf1()
        {
            // Snippet: GetShelf(ShelfName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF]");
            // Make the request
            Shelf response = libraryServiceClient.GetShelf(name);
            // End snippet
        }

        /// <summary>Snippet for GetShelfAsync</summary>
        public async Task GetShelfAsync2()
        {
            // Snippet: GetShelfAsync(ShelfName,SomeMessage,CallSettings)
            // Additional: GetShelfAsync(ShelfName,SomeMessage,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF]");
            SomeMessage message = new SomeMessage();
            // Make the request
            Shelf response = await libraryServiceClient.GetShelfAsync(name, message);
            // End snippet
        }

        /// <summary>Snippet for GetShelf</summary>
        public void GetShelf2()
        {
            // Snippet: GetShelf(ShelfName,SomeMessage,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF]");
            SomeMessage message = new SomeMessage();
            // Make the request
            Shelf response = libraryServiceClient.GetShelf(name, message);
            // End snippet
        }

        /// <summary>Snippet for GetShelfAsync</summary>
        public async Task GetShelfAsync3()
        {
            // Snippet: GetShelfAsync(ShelfName,SomeMessage,StringBuilder,CallSettings)
            // Additional: GetShelfAsync(ShelfName,SomeMessage,StringBuilder,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF]");
            SomeMessage message = new SomeMessage();
            StringBuilder stringBuilder = new StringBuilder();
            // Make the request
            Shelf response = await libraryServiceClient.GetShelfAsync(name, message, stringBuilder);
            // End snippet
        }

        /// <summary>Snippet for GetShelf</summary>
        public void GetShelf3()
        {
            // Snippet: GetShelf(ShelfName,SomeMessage,StringBuilder,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF]");
            SomeMessage message = new SomeMessage();
            StringBuilder stringBuilder = new StringBuilder();
            // Make the request
            Shelf response = libraryServiceClient.GetShelf(name, message, stringBuilder);
            // End snippet
        }

        /// <summary>Snippet for GetShelfAsync</summary>
        public async Task GetShelfAsync_RequestObject()
        {
            // Snippet: GetShelfAsync(GetShelfRequest,CallSettings)
            // Additional: GetShelfAsync(GetShelfRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetShelfRequest request = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                Options = "",
            };
            // Make the request
            Shelf response = await libraryServiceClient.GetShelfAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetShelf</summary>
        public void GetShelf_RequestObject()
        {
            // Snippet: GetShelf(GetShelfRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetShelfRequest request = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                Options = "",
            };
            // Make the request
            Shelf response = libraryServiceClient.GetShelf(request);
            // End snippet
        }

        /// <summary>Snippet for ListShelvesAsync</summary>
        public async Task ListShelvesAsync()
        {
            // Snippet: ListShelvesAsync(string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Make the request
            PagedAsyncEnumerable<ListShelvesResponse, Shelf> response =
                libraryServiceClient.ListShelvesAsync();

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((Shelf item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListShelvesResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Shelf item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Shelf> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Shelf item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListShelves</summary>
        public void ListShelves()
        {
            // Snippet: ListShelves(string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Make the request
            PagedEnumerable<ListShelvesResponse, Shelf> response =
                libraryServiceClient.ListShelves();

            // Iterate over all response items, lazily performing RPCs as required
            foreach (Shelf item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListShelvesResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Shelf item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Shelf> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Shelf item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListShelvesAsync</summary>
        public async Task ListShelvesAsync_RequestObject()
        {
            // Snippet: ListShelvesAsync(ListShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ListShelvesRequest request = new ListShelvesRequest();
            // Make the request
            PagedAsyncEnumerable<ListShelvesResponse, Shelf> response =
                libraryServiceClient.ListShelvesAsync(request);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((Shelf item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListShelvesResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Shelf item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Shelf> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Shelf item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListShelves</summary>
        public void ListShelves_RequestObject()
        {
            // Snippet: ListShelves(ListShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ListShelvesRequest request = new ListShelvesRequest();
            // Make the request
            PagedEnumerable<ListShelvesResponse, Shelf> response =
                libraryServiceClient.ListShelves(request);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (Shelf item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListShelvesResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Shelf item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Shelf> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Shelf item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for DeleteShelfAsync</summary>
        public async Task DeleteShelfAsync()
        {
            // Snippet: DeleteShelfAsync(ShelfName,CallSettings)
            // Additional: DeleteShelfAsync(ShelfName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF]");
            // Make the request
            await libraryServiceClient.DeleteShelfAsync(name);
            // End snippet
        }

        /// <summary>Snippet for DeleteShelf</summary>
        public void DeleteShelf()
        {
            // Snippet: DeleteShelf(ShelfName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF]");
            // Make the request
            libraryServiceClient.DeleteShelf(name);
            // End snippet
        }

        /// <summary>Snippet for DeleteShelfAsync</summary>
        public async Task DeleteShelfAsync_RequestObject()
        {
            // Snippet: DeleteShelfAsync(DeleteShelfRequest,CallSettings)
            // Additional: DeleteShelfAsync(DeleteShelfRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            DeleteShelfRequest request = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
            };
            // Make the request
            await libraryServiceClient.DeleteShelfAsync(request);
            // End snippet
        }

        /// <summary>Snippet for DeleteShelf</summary>
        public void DeleteShelf_RequestObject()
        {
            // Snippet: DeleteShelf(DeleteShelfRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            DeleteShelfRequest request = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
            };
            // Make the request
            libraryServiceClient.DeleteShelf(request);
            // End snippet
        }

        /// <summary>Snippet for MergeShelvesAsync</summary>
        public async Task MergeShelvesAsync()
        {
            // Snippet: MergeShelvesAsync(ShelfName,ShelfName,CallSettings)
            // Additional: MergeShelvesAsync(ShelfName,ShelfName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF]");
            ShelfName otherShelfName = new ShelfName("[SHELF]");
            // Make the request
            Shelf response = await libraryServiceClient.MergeShelvesAsync(name, otherShelfName);
            // End snippet
        }

        /// <summary>Snippet for MergeShelves</summary>
        public void MergeShelves()
        {
            // Snippet: MergeShelves(ShelfName,ShelfName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF]");
            ShelfName otherShelfName = new ShelfName("[SHELF]");
            // Make the request
            Shelf response = libraryServiceClient.MergeShelves(name, otherShelfName);
            // End snippet
        }

        /// <summary>Snippet for MergeShelvesAsync</summary>
        public async Task MergeShelvesAsync_RequestObject()
        {
            // Snippet: MergeShelvesAsync(MergeShelvesRequest,CallSettings)
            // Additional: MergeShelvesAsync(MergeShelvesRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            MergeShelvesRequest request = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF]"),
            };
            // Make the request
            Shelf response = await libraryServiceClient.MergeShelvesAsync(request);
            // End snippet
        }

        /// <summary>Snippet for MergeShelves</summary>
        public void MergeShelves_RequestObject()
        {
            // Snippet: MergeShelves(MergeShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            MergeShelvesRequest request = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF]"),
            };
            // Make the request
            Shelf response = libraryServiceClient.MergeShelves(request);
            // End snippet
        }

        /// <summary>Snippet for CreateBookAsync</summary>
        public async Task CreateBookAsync()
        {
            // Snippet: CreateBookAsync(ShelfName,Book,CallSettings)
            // Additional: CreateBookAsync(ShelfName,Book,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF]");
            Book book = new Book();
            // Make the request
            Book response = await libraryServiceClient.CreateBookAsync(name, book);
            // End snippet
        }

        /// <summary>Snippet for CreateBook</summary>
        public void CreateBook()
        {
            // Snippet: CreateBook(ShelfName,Book,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF]");
            Book book = new Book();
            // Make the request
            Book response = libraryServiceClient.CreateBook(name, book);
            // End snippet
        }

        /// <summary>Snippet for CreateBookAsync</summary>
        public async Task CreateBookAsync_RequestObject()
        {
            // Snippet: CreateBookAsync(CreateBookRequest,CallSettings)
            // Additional: CreateBookAsync(CreateBookRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            CreateBookRequest request = new CreateBookRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                Book = new Book(),
            };
            // Make the request
            Book response = await libraryServiceClient.CreateBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for CreateBook</summary>
        public void CreateBook_RequestObject()
        {
            // Snippet: CreateBook(CreateBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            CreateBookRequest request = new CreateBookRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                Book = new Book(),
            };
            // Make the request
            Book response = libraryServiceClient.CreateBook(request);
            // End snippet
        }

        /// <summary>Snippet for PublishSeriesAsync</summary>
        public async Task PublishSeriesAsync()
        {
            // Snippet: PublishSeriesAsync(Shelf,IEnumerable<Book>,uint?,SeriesUuid,PublisherName,CallSettings)
            // Additional: PublishSeriesAsync(Shelf,IEnumerable<Book>,uint?,SeriesUuid,PublisherName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            Shelf shelf = new Shelf();
            IEnumerable<Book> books = new List<Book>();
            uint edition = 0;
            SeriesUuid seriesUuid = new SeriesUuid
            {
                SeriesString = "foobar",
            };
            PublisherName publisher = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]");
            // Make the request
            PublishSeriesResponse response = await libraryServiceClient.PublishSeriesAsync(shelf, books, edition, seriesUuid, publisher);
            // End snippet
        }

        /// <summary>Snippet for PublishSeries</summary>
        public void PublishSeries()
        {
            // Snippet: PublishSeries(Shelf,IEnumerable<Book>,uint?,SeriesUuid,PublisherName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            Shelf shelf = new Shelf();
            IEnumerable<Book> books = new List<Book>();
            uint edition = 0;
            SeriesUuid seriesUuid = new SeriesUuid
            {
                SeriesString = "foobar",
            };
            PublisherName publisher = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]");
            // Make the request
            PublishSeriesResponse response = libraryServiceClient.PublishSeries(shelf, books, edition, seriesUuid, publisher);
            // End snippet
        }

        /// <summary>Snippet for PublishSeriesAsync</summary>
        public async Task PublishSeriesAsync_RequestObject()
        {
            // Snippet: PublishSeriesAsync(PublishSeriesRequest,CallSettings)
            // Additional: PublishSeriesAsync(PublishSeriesRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                SeriesUuid = new SeriesUuid
                {
                    SeriesString = "foobar",
                },
            };
            // Make the request
            PublishSeriesResponse response = await libraryServiceClient.PublishSeriesAsync(request);
            // End snippet
        }

        /// <summary>Snippet for PublishSeries</summary>
        public void PublishSeries_RequestObject()
        {
            // Snippet: PublishSeries(PublishSeriesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                SeriesUuid = new SeriesUuid
                {
                    SeriesString = "foobar",
                },
            };
            // Make the request
            PublishSeriesResponse response = libraryServiceClient.PublishSeries(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookAsync</summary>
        public async Task GetBookAsync()
        {
            // Snippet: GetBookAsync(BookNameOneof,CallSettings)
            // Additional: GetBookAsync(BookNameOneof,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            // Make the request
            Book response = await libraryServiceClient.GetBookAsync(name);
            // End snippet
        }

        /// <summary>Snippet for GetBook</summary>
        public void GetBook()
        {
            // Snippet: GetBook(BookNameOneof,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            // Make the request
            Book response = libraryServiceClient.GetBook(name);
            // End snippet
        }

        /// <summary>Snippet for GetBookAsync</summary>
        public async Task GetBookAsync_RequestObject()
        {
            // Snippet: GetBookAsync(GetBookRequest,CallSettings)
            // Additional: GetBookAsync(GetBookRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            // Make the request
            Book response = await libraryServiceClient.GetBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetBook</summary>
        public void GetBook_RequestObject()
        {
            // Snippet: GetBook(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            // Make the request
            Book response = libraryServiceClient.GetBook(request);
            // End snippet
        }

        /// <summary>Snippet for ListBooksAsync</summary>
        public async Task ListBooksAsync()
        {
            // Snippet: ListBooksAsync(ShelfName,string,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF]");
            string filter = "book-filter-string";
            // Make the request
            PagedAsyncEnumerable<ListBooksResponse, Book> response =
                libraryServiceClient.ListBooksAsync(name, filter);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((Book item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListBooksResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Book item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Book> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Book item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListBooks</summary>
        public void ListBooks()
        {
            // Snippet: ListBooks(ShelfName,string,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF]");
            string filter = "book-filter-string";
            // Make the request
            PagedEnumerable<ListBooksResponse, Book> response =
                libraryServiceClient.ListBooks(name, filter);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (Book item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListBooksResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Book item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Book> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Book item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListBooksAsync</summary>
        public async Task ListBooksAsync_RequestObject()
        {
            // Snippet: ListBooksAsync(ListBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ListBooksRequest request = new ListBooksRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                Filter = "book-filter-string",
            };
            // Make the request
            PagedAsyncEnumerable<ListBooksResponse, Book> response =
                libraryServiceClient.ListBooksAsync(request);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((Book item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListBooksResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Book item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Book> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Book item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListBooks</summary>
        public void ListBooks_RequestObject()
        {
            // Snippet: ListBooks(ListBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ListBooksRequest request = new ListBooksRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                Filter = "book-filter-string",
            };
            // Make the request
            PagedEnumerable<ListBooksResponse, Book> response =
                libraryServiceClient.ListBooks(request);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (Book item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListBooksResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Book item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Book> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Book item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for DeleteBookAsync</summary>
        public async Task DeleteBookAsync()
        {
            // Snippet: DeleteBookAsync(BookNameOneof,CallSettings)
            // Additional: DeleteBookAsync(BookNameOneof,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            // Make the request
            await libraryServiceClient.DeleteBookAsync(name);
            // End snippet
        }

        /// <summary>Snippet for DeleteBook</summary>
        public void DeleteBook()
        {
            // Snippet: DeleteBook(BookNameOneof,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            // Make the request
            libraryServiceClient.DeleteBook(name);
            // End snippet
        }

        /// <summary>Snippet for DeleteBookAsync</summary>
        public async Task DeleteBookAsync_RequestObject()
        {
            // Snippet: DeleteBookAsync(DeleteBookRequest,CallSettings)
            // Additional: DeleteBookAsync(DeleteBookRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            DeleteBookRequest request = new DeleteBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            // Make the request
            await libraryServiceClient.DeleteBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for DeleteBook</summary>
        public void DeleteBook_RequestObject()
        {
            // Snippet: DeleteBook(DeleteBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            DeleteBookRequest request = new DeleteBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            // Make the request
            libraryServiceClient.DeleteBook(request);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookAsync</summary>
        public async Task UpdateBookAsync1()
        {
            // Snippet: UpdateBookAsync(BookNameOneof,Book,CallSettings)
            // Additional: UpdateBookAsync(BookNameOneof,Book,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            Book book = new Book();
            // Make the request
            Book response = await libraryServiceClient.UpdateBookAsync(name, book);
            // End snippet
        }

        /// <summary>Snippet for UpdateBook</summary>
        public void UpdateBook1()
        {
            // Snippet: UpdateBook(BookNameOneof,Book,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            Book book = new Book();
            // Make the request
            Book response = libraryServiceClient.UpdateBook(name, book);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookAsync</summary>
        public async Task UpdateBookAsync2()
        {
            // Snippet: UpdateBookAsync(BookNameOneof,string,Book,FieldMask,apis::FieldMask,CallSettings)
            // Additional: UpdateBookAsync(BookNameOneof,string,Book,FieldMask,apis::FieldMask,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string optionalFoo = "";
            Book book = new Book();
            FieldMask updateMask = new FieldMask();
            apis::FieldMask physicalMask = new apis::FieldMask();
            // Make the request
            Book response = await libraryServiceClient.UpdateBookAsync(name, optionalFoo, book, updateMask, physicalMask);
            // End snippet
        }

        /// <summary>Snippet for UpdateBook</summary>
        public void UpdateBook2()
        {
            // Snippet: UpdateBook(BookNameOneof,string,Book,FieldMask,apis::FieldMask,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string optionalFoo = "";
            Book book = new Book();
            FieldMask updateMask = new FieldMask();
            apis::FieldMask physicalMask = new apis::FieldMask();
            // Make the request
            Book response = libraryServiceClient.UpdateBook(name, optionalFoo, book, updateMask, physicalMask);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookAsync</summary>
        public async Task UpdateBookAsync_RequestObject()
        {
            // Snippet: UpdateBookAsync(UpdateBookRequest,CallSettings)
            // Additional: UpdateBookAsync(UpdateBookRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            UpdateBookRequest request = new UpdateBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Book = new Book(),
            };
            // Make the request
            Book response = await libraryServiceClient.UpdateBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for UpdateBook</summary>
        public void UpdateBook_RequestObject()
        {
            // Snippet: UpdateBook(UpdateBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            UpdateBookRequest request = new UpdateBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Book = new Book(),
            };
            // Make the request
            Book response = libraryServiceClient.UpdateBook(request);
            // End snippet
        }

        /// <summary>Snippet for MoveBookAsync</summary>
        public async Task MoveBookAsync()
        {
            // Snippet: MoveBookAsync(BookNameOneof,ShelfName,CallSettings)
            // Additional: MoveBookAsync(BookNameOneof,ShelfName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            ShelfName otherShelfName = new ShelfName("[SHELF]");
            // Make the request
            Book response = await libraryServiceClient.MoveBookAsync(name, otherShelfName);
            // End snippet
        }

        /// <summary>Snippet for MoveBook</summary>
        public void MoveBook()
        {
            // Snippet: MoveBook(BookNameOneof,ShelfName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            ShelfName otherShelfName = new ShelfName("[SHELF]");
            // Make the request
            Book response = libraryServiceClient.MoveBook(name, otherShelfName);
            // End snippet
        }

        /// <summary>Snippet for MoveBookAsync</summary>
        public async Task MoveBookAsync_RequestObject()
        {
            // Snippet: MoveBookAsync(MoveBookRequest,CallSettings)
            // Additional: MoveBookAsync(MoveBookRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            MoveBookRequest request = new MoveBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF]"),
            };
            // Make the request
            Book response = await libraryServiceClient.MoveBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for MoveBook</summary>
        public void MoveBook_RequestObject()
        {
            // Snippet: MoveBook(MoveBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            MoveBookRequest request = new MoveBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF]"),
            };
            // Make the request
            Book response = libraryServiceClient.MoveBook(request);
            // End snippet
        }

        /// <summary>Snippet for ListStringsAsync</summary>
        public async Task ListStringsAsync1()
        {
            // Snippet: ListStringsAsync(string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Make the request
            PagedAsyncEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStringsAsync();

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((IResourceName item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListStringsResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStrings</summary>
        public void ListStrings1()
        {
            // Snippet: ListStrings(string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Make the request
            PagedEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStrings();

            // Iterate over all response items, lazily performing RPCs as required
            foreach (IResourceName item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListStringsResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStringsAsync</summary>
        public async Task ListStringsAsync2()
        {
            // Snippet: ListStringsAsync(IResourceName,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            IResourceName name = new ArchiveName("[ARCHIVE]");
            // Make the request
            PagedAsyncEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStringsAsync(name);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((IResourceName item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListStringsResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStrings</summary>
        public void ListStrings2()
        {
            // Snippet: ListStrings(IResourceName,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            IResourceName name = new ArchiveName("[ARCHIVE]");
            // Make the request
            PagedEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStrings(name);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (IResourceName item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListStringsResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStringsAsync</summary>
        public async Task ListStringsAsync_RequestObject()
        {
            // Snippet: ListStringsAsync(ListStringsRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ListStringsRequest request = new ListStringsRequest();
            // Make the request
            PagedAsyncEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStringsAsync(request);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((IResourceName item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListStringsResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStrings</summary>
        public void ListStrings_RequestObject()
        {
            // Snippet: ListStrings(ListStringsRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ListStringsRequest request = new ListStringsRequest();
            // Make the request
            PagedEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStrings(request);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (IResourceName item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListStringsResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for AddCommentsAsync</summary>
        public async Task AddCommentsAsync()
        {
            // Snippet: AddCommentsAsync(BookNameOneof,IEnumerable<Comment>,CallSettings)
            // Additional: AddCommentsAsync(BookNameOneof,IEnumerable<Comment>,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            IEnumerable<Comment> comments = new[]
            {
                new Comment
                {
                    Comment = ByteString.Empty,
                    Stage = Comment.Types.Stage.Unset,
                    Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                },
            };
            // Make the request
            await libraryServiceClient.AddCommentsAsync(name, comments);
            // End snippet
        }

        /// <summary>Snippet for AddComments</summary>
        public void AddComments()
        {
            // Snippet: AddComments(BookNameOneof,IEnumerable<Comment>,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            IEnumerable<Comment> comments = new[]
            {
                new Comment
                {
                    Comment = ByteString.Empty,
                    Stage = Comment.Types.Stage.Unset,
                    Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                },
            };
            // Make the request
            libraryServiceClient.AddComments(name, comments);
            // End snippet
        }

        /// <summary>Snippet for AddCommentsAsync</summary>
        public async Task AddCommentsAsync_RequestObject()
        {
            // Snippet: AddCommentsAsync(AddCommentsRequest,CallSettings)
            // Additional: AddCommentsAsync(AddCommentsRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            AddCommentsRequest request = new AddCommentsRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Comments =
                {
                    new Comment
                    {
                        Comment = ByteString.Empty,
                        Stage = Comment.Types.Stage.Unset,
                        Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                    },
                },
            };
            // Make the request
            await libraryServiceClient.AddCommentsAsync(request);
            // End snippet
        }

        /// <summary>Snippet for AddComments</summary>
        public void AddComments_RequestObject()
        {
            // Snippet: AddComments(AddCommentsRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            AddCommentsRequest request = new AddCommentsRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Comments =
                {
                    new Comment
                    {
                        Comment = ByteString.Empty,
                        Stage = Comment.Types.Stage.Unset,
                        Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                    },
                },
            };
            // Make the request
            libraryServiceClient.AddComments(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromArchiveAsync</summary>
        public async Task GetBookFromArchiveAsync()
        {
            // Snippet: GetBookFromArchiveAsync(ArchivedBookName,ProjectName,CallSettings)
            // Additional: GetBookFromArchiveAsync(ArchivedBookName,ProjectName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ArchivedBookName name = new ArchivedBookName("[ARCHIVE]", "[BOOK]");
            ProjectName parent = new ProjectName("[PROJECT]");
            // Make the request
            BookFromArchive response = await libraryServiceClient.GetBookFromArchiveAsync(name, parent);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromArchive</summary>
        public void GetBookFromArchive()
        {
            // Snippet: GetBookFromArchive(ArchivedBookName,ProjectName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ArchivedBookName name = new ArchivedBookName("[ARCHIVE]", "[BOOK]");
            ProjectName parent = new ProjectName("[PROJECT]");
            // Make the request
            BookFromArchive response = libraryServiceClient.GetBookFromArchive(name, parent);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromArchiveAsync</summary>
        public async Task GetBookFromArchiveAsync_RequestObject()
        {
            // Snippet: GetBookFromArchiveAsync(GetBookFromArchiveRequest,CallSettings)
            // Additional: GetBookFromArchiveAsync(GetBookFromArchiveRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookFromArchiveRequest request = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
                ParentAsProjectName = new ProjectName("[PROJECT]"),
            };
            // Make the request
            BookFromArchive response = await libraryServiceClient.GetBookFromArchiveAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromArchive</summary>
        public void GetBookFromArchive_RequestObject()
        {
            // Snippet: GetBookFromArchive(GetBookFromArchiveRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookFromArchiveRequest request = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
                ParentAsProjectName = new ProjectName("[PROJECT]"),
            };
            // Make the request
            BookFromArchive response = libraryServiceClient.GetBookFromArchive(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAnywhereAsync</summary>
        public async Task GetBookFromAnywhereAsync()
        {
            // Snippet: GetBookFromAnywhereAsync(BookNameOneof,BookNameOneof,LocationName,FolderName,CallSettings)
            // Additional: GetBookFromAnywhereAsync(BookNameOneof,BookNameOneof,LocationName,FolderName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            BookNameOneof altBookName = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            LocationName place = new LocationName("[PROJECT]", "[LOCATION]");
            FolderName folder = new FolderName("[FOLDER]");
            // Make the request
            BookFromAnywhere response = await libraryServiceClient.GetBookFromAnywhereAsync(name, altBookName, place, folder);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAnywhere</summary>
        public void GetBookFromAnywhere()
        {
            // Snippet: GetBookFromAnywhere(BookNameOneof,BookNameOneof,LocationName,FolderName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            BookNameOneof altBookName = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            LocationName place = new LocationName("[PROJECT]", "[LOCATION]");
            FolderName folder = new FolderName("[FOLDER]");
            // Make the request
            BookFromAnywhere response = libraryServiceClient.GetBookFromAnywhere(name, altBookName, place, folder);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAnywhereAsync</summary>
        public async Task GetBookFromAnywhereAsync_RequestObject()
        {
            // Snippet: GetBookFromAnywhereAsync(GetBookFromAnywhereRequest,CallSettings)
            // Additional: GetBookFromAnywhereAsync(GetBookFromAnywhereRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookFromAnywhereRequest request = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                PlaceAsLocationName = new LocationName("[PROJECT]", "[LOCATION]"),
                FolderAsFolderName = new FolderName("[FOLDER]"),
            };
            // Make the request
            BookFromAnywhere response = await libraryServiceClient.GetBookFromAnywhereAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAnywhere</summary>
        public void GetBookFromAnywhere_RequestObject()
        {
            // Snippet: GetBookFromAnywhere(GetBookFromAnywhereRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookFromAnywhereRequest request = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                PlaceAsLocationName = new LocationName("[PROJECT]", "[LOCATION]"),
                FolderAsFolderName = new FolderName("[FOLDER]"),
            };
            // Make the request
            BookFromAnywhere response = libraryServiceClient.GetBookFromAnywhere(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAbsolutelyAnywhereAsync</summary>
        public async Task GetBookFromAbsolutelyAnywhereAsync()
        {
            // Snippet: GetBookFromAbsolutelyAnywhereAsync(BookNameOneof,CallSettings)
            // Additional: GetBookFromAbsolutelyAnywhereAsync(BookNameOneof,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            // Make the request
            BookFromAnywhere response = await libraryServiceClient.GetBookFromAbsolutelyAnywhereAsync(name);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAbsolutelyAnywhere</summary>
        public void GetBookFromAbsolutelyAnywhere()
        {
            // Snippet: GetBookFromAbsolutelyAnywhere(BookNameOneof,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            // Make the request
            BookFromAnywhere response = libraryServiceClient.GetBookFromAbsolutelyAnywhere(name);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAbsolutelyAnywhereAsync</summary>
        public async Task GetBookFromAbsolutelyAnywhereAsync_RequestObject()
        {
            // Snippet: GetBookFromAbsolutelyAnywhereAsync(GetBookFromAbsolutelyAnywhereRequest,CallSettings)
            // Additional: GetBookFromAbsolutelyAnywhereAsync(GetBookFromAbsolutelyAnywhereRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookFromAbsolutelyAnywhereRequest request = new GetBookFromAbsolutelyAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            // Make the request
            BookFromAnywhere response = await libraryServiceClient.GetBookFromAbsolutelyAnywhereAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAbsolutelyAnywhere</summary>
        public void GetBookFromAbsolutelyAnywhere_RequestObject()
        {
            // Snippet: GetBookFromAbsolutelyAnywhere(GetBookFromAbsolutelyAnywhereRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookFromAbsolutelyAnywhereRequest request = new GetBookFromAbsolutelyAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            // Make the request
            BookFromAnywhere response = libraryServiceClient.GetBookFromAbsolutelyAnywhere(request);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookIndexAsync</summary>
        public async Task UpdateBookIndexAsync()
        {
            // Snippet: UpdateBookIndexAsync(BookNameOneof,string,IDictionary<string, string>,CallSettings)
            // Additional: UpdateBookIndexAsync(BookNameOneof,string,IDictionary<string, string>,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string indexName = "default index";
            IDictionary<string, string> indexMap = new Dictionary<string, string>
            {
                { "default_key", "" },
            };
            // Make the request
            await libraryServiceClient.UpdateBookIndexAsync(name, indexName, indexMap);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookIndex</summary>
        public void UpdateBookIndex()
        {
            // Snippet: UpdateBookIndex(BookNameOneof,string,IDictionary<string, string>,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string indexName = "default index";
            IDictionary<string, string> indexMap = new Dictionary<string, string>
            {
                { "default_key", "" },
            };
            // Make the request
            libraryServiceClient.UpdateBookIndex(name, indexName, indexMap);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookIndexAsync</summary>
        public async Task UpdateBookIndexAsync_RequestObject()
        {
            // Snippet: UpdateBookIndexAsync(UpdateBookIndexRequest,CallSettings)
            // Additional: UpdateBookIndexAsync(UpdateBookIndexRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            UpdateBookIndexRequest request = new UpdateBookIndexRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                IndexName = "default index",
                IndexMap =
                {
                    { "default_key", "" },
                },
            };
            // Make the request
            await libraryServiceClient.UpdateBookIndexAsync(request);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookIndex</summary>
        public void UpdateBookIndex_RequestObject()
        {
            // Snippet: UpdateBookIndex(UpdateBookIndexRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            UpdateBookIndexRequest request = new UpdateBookIndexRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                IndexName = "default index",
                IndexMap =
                {
                    { "default_key", "" },
                },
            };
            // Make the request
            libraryServiceClient.UpdateBookIndex(request);
            // End snippet
        }

        /// <summary>Snippet for StreamShelves</summary>
        public async Task StreamShelves()
        {
            // Snippet: StreamShelves(StreamShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument
            StreamShelvesRequest request = new StreamShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
            };
            // Make the request, returning a streaming response
            LibraryServiceClient.StreamShelvesStream streamingResponse = libraryServiceClient.StreamShelves(request);

            // Read streaming responses from server until complete
            IAsyncEnumerator<StreamShelvesResponse> responseStream = streamingResponse.ResponseStream;
            while (await responseStream.MoveNext())
            {
                StreamShelvesResponse response = responseStream.Current;
                // Do something with streamed response
            }
            // The response stream has completed
            // End snippet
        }

        /// <summary>Snippet for StreamBooks</summary>
        public async Task StreamBooks()
        {
            // Snippet: StreamBooks(StreamBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument
            StreamBooksRequest request = new StreamBooksRequest
            {
                Name = "",
            };
            // Make the request, returning a streaming response
            LibraryServiceClient.StreamBooksStream streamingResponse = libraryServiceClient.StreamBooks(request);

            // Read streaming responses from server until complete
            IAsyncEnumerator<Book> responseStream = streamingResponse.ResponseStream;
            while (await responseStream.MoveNext())
            {
                Book response = responseStream.Current;
                // Do something with streamed response
            }
            // The response stream has completed
            // End snippet
        }

        /// <summary>Snippet for DiscussBook</summary>
        public async Task DiscussBook()
        {
            // Snippet: DiscussBook(CallSettings,BidirectionalStreamingSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize streaming call, retrieving the stream object
            LibraryServiceClient.DiscussBookStream duplexStream = libraryServiceClient.DiscussBook();

            // Sending requests and retrieving responses can be arbitrarily interleaved.
            // Exact sequence will depend on client/server behavior.

            // Create task to do something with responses from server
            Task responseHandlerTask = Task.Run(async () =>
            {
                IAsyncEnumerator<Comment> responseStream = duplexStream.ResponseStream;
                while (await responseStream.MoveNext())
                {
                    Comment response = responseStream.Current;
                    // Do something with streamed response
                }
                // The response stream has completed
            });

            // Send requests to the server
            bool done = false;
            while (!done)
            {
                // Initialize a request
                DiscussBookRequest request = new DiscussBookRequest
                {
                    BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                };
                // Stream a request to the server
                await duplexStream.WriteAsync(request);

                // Set "done" to true when sending requests is complete
            }
            // Complete writing requests to the stream
            await duplexStream.WriteCompleteAsync();
            // Await the response handler.
            // This will complete once all server responses have been processed.
            await responseHandlerTask;
            // End snippet
        }

        /// <summary>Snippet for FindRelatedBooksAsync</summary>
        public async Task FindRelatedBooksAsync()
        {
            // Snippet: FindRelatedBooksAsync(IEnumerable<BookNameOneof>,IEnumerable<ShelfName>,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            IEnumerable<BookNameOneof> names = new[]
            {
                BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            IEnumerable<ShelfName> shelves = new List<ShelfName>();
            // Make the request
            PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> response =
                libraryServiceClient.FindRelatedBooksAsync(names, shelves);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((BookNameOneof item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((FindRelatedBooksResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (BookNameOneof item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookNameOneof> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (BookNameOneof item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for FindRelatedBooks</summary>
        public void FindRelatedBooks()
        {
            // Snippet: FindRelatedBooks(IEnumerable<BookNameOneof>,IEnumerable<ShelfName>,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            IEnumerable<BookNameOneof> names = new[]
            {
                BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            IEnumerable<ShelfName> shelves = new List<ShelfName>();
            // Make the request
            PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> response =
                libraryServiceClient.FindRelatedBooks(names, shelves);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (BookNameOneof item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (FindRelatedBooksResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (BookNameOneof item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookNameOneof> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (BookNameOneof item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for FindRelatedBooksAsync</summary>
        public async Task FindRelatedBooksAsync_RequestObject()
        {
            // Snippet: FindRelatedBooksAsync(FindRelatedBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            FindRelatedBooksRequest request = new FindRelatedBooksRequest
            {
                BookNameOneofs =
                {
                    BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                },
                ShelvesAsShelfNames = { },
            };
            // Make the request
            PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> response =
                libraryServiceClient.FindRelatedBooksAsync(request);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((BookNameOneof item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((FindRelatedBooksResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (BookNameOneof item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookNameOneof> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (BookNameOneof item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for FindRelatedBooks</summary>
        public void FindRelatedBooks_RequestObject()
        {
            // Snippet: FindRelatedBooks(FindRelatedBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            FindRelatedBooksRequest request = new FindRelatedBooksRequest
            {
                BookNameOneofs =
                {
                    BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                },
                ShelvesAsShelfNames = { },
            };
            // Make the request
            PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> response =
                libraryServiceClient.FindRelatedBooks(request);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (BookNameOneof item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (FindRelatedBooksResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (BookNameOneof item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookNameOneof> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (BookNameOneof item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for AddLabelAsync</summary>
        public async Task AddLabelAsync_RequestObject()
        {
            // Snippet: AddLabelAsync(AddLabelRequest,CallSettings)
            // Additional: AddLabelAsync(AddLabelRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            AddLabelRequest request = new AddLabelRequest
            {
                ResourceAsResourceName = new ArchiveName("[ARCHIVE]"),
                Label = "",
            };
            // Make the request
            AddLabelResponse response = await libraryServiceClient.AddLabelAsync(request);
            // End snippet
        }

        /// <summary>Snippet for AddLabel</summary>
        public void AddLabel_RequestObject()
        {
            // Snippet: AddLabel(AddLabelRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            AddLabelRequest request = new AddLabelRequest
            {
                ResourceAsResourceName = new ArchiveName("[ARCHIVE]"),
                Label = "",
            };
            // Make the request
            AddLabelResponse response = libraryServiceClient.AddLabel(request);
            // End snippet
        }

        /// <summary>Snippet for GetBigBookAsync</summary>
        public async Task GetBigBookAsync()
        {
            // Snippet: GetBigBookAsync(BookNameOneof,CallSettings)
            // Additional: GetBigBookAsync(BookNameOneof,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            // Make the request
            Operation<Book, GetBigBookMetadata> response =
                await libraryServiceClient.GetBigBookAsync(name);

            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> completedResponse =
                await response.PollUntilCompletedAsync();
            // Retrieve the operation result
            Book result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Book, GetBigBookMetadata> retrievedResponse =
                await libraryServiceClient.PollOnceGetBigBookAsync(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                Book retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigBook</summary>
        public void GetBigBook()
        {
            // Snippet: GetBigBook(BookNameOneof,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            // Make the request
            Operation<Book, GetBigBookMetadata> response =
                libraryServiceClient.GetBigBook(name);

            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> completedResponse =
                response.PollUntilCompleted();
            // Retrieve the operation result
            Book result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Book, GetBigBookMetadata> retrievedResponse =
                libraryServiceClient.PollOnceGetBigBook(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                Book retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigBookAsync</summary>
        public async Task GetBigBookAsync_RequestObject()
        {
            // Snippet: GetBigBookAsync(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            // Make the request
            Operation<Book, GetBigBookMetadata> response =
                await libraryServiceClient.GetBigBookAsync(request);

            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> completedResponse =
                await response.PollUntilCompletedAsync();
            // Retrieve the operation result
            Book result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Book, GetBigBookMetadata> retrievedResponse =
                await libraryServiceClient.PollOnceGetBigBookAsync(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                Book retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigBook</summary>
        public void GetBigBook_RequestObject()
        {
            // Snippet: GetBigBook(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            // Make the request
            Operation<Book, GetBigBookMetadata> response =
                libraryServiceClient.GetBigBook(request);

            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> completedResponse =
                response.PollUntilCompleted();
            // Retrieve the operation result
            Book result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Book, GetBigBookMetadata> retrievedResponse =
                libraryServiceClient.PollOnceGetBigBook(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                Book retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigNothingAsync</summary>
        public async Task GetBigNothingAsync()
        {
            // Snippet: GetBigNothingAsync(BookNameOneof,CallSettings)
            // Additional: GetBigNothingAsync(BookNameOneof,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            // Make the request
            Operation<Empty, GetBigBookMetadata> response =
                await libraryServiceClient.GetBigNothingAsync(name);

            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> completedResponse =
                await response.PollUntilCompletedAsync();
            // The long-running operation is now complete.

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Empty, GetBigBookMetadata> retrievedResponse =
                await libraryServiceClient.PollOnceGetBigNothingAsync(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // The long-running operation is now complete.
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigNothing</summary>
        public void GetBigNothing()
        {
            // Snippet: GetBigNothing(BookNameOneof,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            // Make the request
            Operation<Empty, GetBigBookMetadata> response =
                libraryServiceClient.GetBigNothing(name);

            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> completedResponse =
                response.PollUntilCompleted();
            // The long-running operation is now complete.

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Empty, GetBigBookMetadata> retrievedResponse =
                libraryServiceClient.PollOnceGetBigNothing(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // The long-running operation is now complete.
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigNothingAsync</summary>
        public async Task GetBigNothingAsync_RequestObject()
        {
            // Snippet: GetBigNothingAsync(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            // Make the request
            Operation<Empty, GetBigBookMetadata> response =
                await libraryServiceClient.GetBigNothingAsync(request);

            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> completedResponse =
                await response.PollUntilCompletedAsync();
            // The long-running operation is now complete.

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Empty, GetBigBookMetadata> retrievedResponse =
                await libraryServiceClient.PollOnceGetBigNothingAsync(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // The long-running operation is now complete.
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigNothing</summary>
        public void GetBigNothing_RequestObject()
        {
            // Snippet: GetBigNothing(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            // Make the request
            Operation<Empty, GetBigBookMetadata> response =
                libraryServiceClient.GetBigNothing(request);

            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> completedResponse =
                response.PollUntilCompleted();
            // The long-running operation is now complete.

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Empty, GetBigBookMetadata> retrievedResponse =
                libraryServiceClient.PollOnceGetBigNothing(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // The long-running operation is now complete.
            }
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParamsAsync</summary>
        public async Task TestOptionalRequiredFlatteningParamsAsync1()
        {
            // Snippet: TestOptionalRequiredFlatteningParamsAsync(CallSettings)
            // Additional: TestOptionalRequiredFlatteningParamsAsync(CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = await libraryServiceClient.TestOptionalRequiredFlatteningParamsAsync();
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParams</summary>
        public void TestOptionalRequiredFlatteningParams1()
        {
            // Snippet: TestOptionalRequiredFlatteningParams(CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = libraryServiceClient.TestOptionalRequiredFlatteningParams();
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParamsAsync</summary>
        public async Task TestOptionalRequiredFlatteningParamsAsync2()
        {
            // Snippet: TestOptionalRequiredFlatteningParamsAsync(int,long,float,double,bool,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookNameOneof,BookNameOneof,string,int,long,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookNameOneof>,IEnumerable<BookNameOneof>,IEnumerable<string>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,Any,Struct,Value,ListValue,Timestamp,Duration,FieldMask,int?,uint?,long?,ulong?,float?,double?,string,bool?,ByteString,IEnumerable<Any>,IEnumerable<Struct>,IEnumerable<Value>,IEnumerable<ListValue>,IEnumerable<Timestamp>,IEnumerable<Duration>,IEnumerable<FieldMask>,IEnumerable<int?>,IEnumerable<uint?>,IEnumerable<long?>,IEnumerable<ulong?>,IEnumerable<float?>,IEnumerable<double?>,IEnumerable<string>,IEnumerable<bool?>,IEnumerable<ByteString>,int?,long?,float?,double?,bool?,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum?,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookNameOneof,BookNameOneof,string,int?,long?,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookNameOneof>,IEnumerable<BookNameOneof>,IEnumerable<string>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,Any,Struct,Value,ListValue,Timestamp,Duration,FieldMask,int?,uint?,long?,ulong?,float?,double?,string,bool?,ByteString,IEnumerable<Any>,IEnumerable<Struct>,IEnumerable<Value>,IEnumerable<ListValue>,IEnumerable<Timestamp>,IEnumerable<Duration>,IEnumerable<FieldMask>,IEnumerable<int?>,IEnumerable<uint?>,IEnumerable<long?>,IEnumerable<ulong?>,IEnumerable<float?>,IEnumerable<double?>,IEnumerable<string>,IEnumerable<bool?>,IEnumerable<ByteString>,CallSettings)
            // Additional: TestOptionalRequiredFlatteningParamsAsync(int,long,float,double,bool,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookNameOneof,BookNameOneof,string,int,long,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookNameOneof>,IEnumerable<BookNameOneof>,IEnumerable<string>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,Any,Struct,Value,ListValue,Timestamp,Duration,FieldMask,int?,uint?,long?,ulong?,float?,double?,string,bool?,ByteString,IEnumerable<Any>,IEnumerable<Struct>,IEnumerable<Value>,IEnumerable<ListValue>,IEnumerable<Timestamp>,IEnumerable<Duration>,IEnumerable<FieldMask>,IEnumerable<int?>,IEnumerable<uint?>,IEnumerable<long?>,IEnumerable<ulong?>,IEnumerable<float?>,IEnumerable<double?>,IEnumerable<string>,IEnumerable<bool?>,IEnumerable<ByteString>,int?,long?,float?,double?,bool?,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum?,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookNameOneof,BookNameOneof,string,int?,long?,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookNameOneof>,IEnumerable<BookNameOneof>,IEnumerable<string>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,Any,Struct,Value,ListValue,Timestamp,Duration,FieldMask,int?,uint?,long?,ulong?,float?,double?,string,bool?,ByteString,IEnumerable<Any>,IEnumerable<Struct>,IEnumerable<Value>,IEnumerable<ListValue>,IEnumerable<Timestamp>,IEnumerable<Duration>,IEnumerable<FieldMask>,IEnumerable<int?>,IEnumerable<uint?>,IEnumerable<long?>,IEnumerable<ulong?>,IEnumerable<float?>,IEnumerable<double?>,IEnumerable<string>,IEnumerable<bool?>,IEnumerable<ByteString>,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            int requiredSingularInt32 = 0;
            long requiredSingularInt64 = 0L;
            float requiredSingularFloat = 0.0f;
            double requiredSingularDouble = 0.0;
            bool requiredSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string requiredSingularString = "";
            ByteString requiredSingularBytes = ByteString.Empty;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookNameOneof requiredSingularResourceName = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            BookNameOneof requiredSingularResourceNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string requiredSingularResourceNameCommon = "";
            int requiredSingularFixed32 = 0;
            long requiredSingularFixed64 = 0L;
            IEnumerable<int> requiredRepeatedInt32 = new List<int>();
            IEnumerable<long> requiredRepeatedInt64 = new List<long>();
            IEnumerable<float> requiredRepeatedFloat = new List<float>();
            IEnumerable<double> requiredRepeatedDouble = new List<double>();
            IEnumerable<bool> requiredRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> requiredRepeatedString = new List<string>();
            IEnumerable<ByteString> requiredRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceName = new List<BookNameOneof>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<string> requiredRepeatedResourceNameCommon = new List<string>();
            IEnumerable<int> requiredRepeatedFixed32 = new List<int>();
            IEnumerable<long> requiredRepeatedFixed64 = new List<long>();
            IDictionary<int, string> requiredMap = new Dictionary<int, string>();
            Any requiredAnyValue = new Any();
            Struct requiredStructValue = new Struct();
            Value requiredValueValue = new Value();
            ListValue requiredListValueValue = new ListValue();
            Timestamp requiredTimeValue = new Timestamp();
            Duration requiredDurationValue = new Duration();
            FieldMask requiredFieldMaskValue = new FieldMask();
            int? requiredInt32Value = null;
            uint? requiredUint32Value = null;
            long? requiredInt64Value = null;
            ulong? requiredUint64Value = null;
            float? requiredFloatValue = null;
            double? requiredDoubleValue = null;
            string requiredStringValue = null;
            bool? requiredBoolValue = null;
            ByteString requiredBytesValue = null;
            IEnumerable<Any> requiredRepeatedAnyValue = new List<Any>();
            IEnumerable<Struct> requiredRepeatedStructValue = new List<Struct>();
            IEnumerable<Value> requiredRepeatedValueValue = new List<Value>();
            IEnumerable<ListValue> requiredRepeatedListValueValue = new List<ListValue>();
            IEnumerable<Timestamp> requiredRepeatedTimeValue = new List<Timestamp>();
            IEnumerable<Duration> requiredRepeatedDurationValue = new List<Duration>();
            IEnumerable<FieldMask> requiredRepeatedFieldMaskValue = new List<FieldMask>();
            IEnumerable<int?> requiredRepeatedInt32Value = new List<int?>();
            IEnumerable<uint?> requiredRepeatedUint32Value = new List<uint?>();
            IEnumerable<long?> requiredRepeatedInt64Value = new List<long?>();
            IEnumerable<ulong?> requiredRepeatedUint64Value = new List<ulong?>();
            IEnumerable<float?> requiredRepeatedFloatValue = new List<float?>();
            IEnumerable<double?> requiredRepeatedDoubleValue = new List<double?>();
            IEnumerable<string> requiredRepeatedStringValue = new List<string>();
            IEnumerable<bool?> requiredRepeatedBoolValue = new List<bool?>();
            IEnumerable<ByteString> requiredRepeatedBytesValue = new List<ByteString>();
            int optionalSingularInt32 = 0;
            long optionalSingularInt64 = 0L;
            float optionalSingularFloat = 0.0f;
            double optionalSingularDouble = 0.0;
            bool optionalSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum optionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string optionalSingularString = "";
            ByteString optionalSingularBytes = ByteString.Empty;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookNameOneof optionalSingularResourceName = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            BookNameOneof optionalSingularResourceNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string optionalSingularResourceNameCommon = "";
            int optionalSingularFixed32 = 0;
            long optionalSingularFixed64 = 0L;
            IEnumerable<int> optionalRepeatedInt32 = new List<int>();
            IEnumerable<long> optionalRepeatedInt64 = new List<long>();
            IEnumerable<float> optionalRepeatedFloat = new List<float>();
            IEnumerable<double> optionalRepeatedDouble = new List<double>();
            IEnumerable<bool> optionalRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> optionalRepeatedString = new List<string>();
            IEnumerable<ByteString> optionalRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceName = new List<BookNameOneof>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<string> optionalRepeatedResourceNameCommon = new List<string>();
            IEnumerable<int> optionalRepeatedFixed32 = new List<int>();
            IEnumerable<long> optionalRepeatedFixed64 = new List<long>();
            IDictionary<int, string> optionalMap = new Dictionary<int, string>();
            Any anyValue = new Any();
            Struct structValue = new Struct();
            Value valueValue = new Value();
            ListValue listValueValue = new ListValue();
            Timestamp timeValue = new Timestamp();
            Duration durationValue = new Duration();
            FieldMask fieldMaskValue = new FieldMask();
            int? int32Value = null;
            uint? uint32Value = null;
            long? int64Value = null;
            ulong? uint64Value = null;
            float? floatValue = null;
            double? doubleValue = null;
            string stringValue = null;
            bool? boolValue = null;
            ByteString bytesValue = null;
            IEnumerable<Any> repeatedAnyValue = new List<Any>();
            IEnumerable<Struct> repeatedStructValue = new List<Struct>();
            IEnumerable<Value> repeatedValueValue = new List<Value>();
            IEnumerable<ListValue> repeatedListValueValue = new List<ListValue>();
            IEnumerable<Timestamp> repeatedTimeValue = new List<Timestamp>();
            IEnumerable<Duration> repeatedDurationValue = new List<Duration>();
            IEnumerable<FieldMask> repeatedFieldMaskValue = new List<FieldMask>();
            IEnumerable<int?> repeatedInt32Value = new List<int?>();
            IEnumerable<uint?> repeatedUint32Value = new List<uint?>();
            IEnumerable<long?> repeatedInt64Value = new List<long?>();
            IEnumerable<ulong?> repeatedUint64Value = new List<ulong?>();
            IEnumerable<float?> repeatedFloatValue = new List<float?>();
            IEnumerable<double?> repeatedDoubleValue = new List<double?>();
            IEnumerable<string> repeatedStringValue = new List<string>();
            IEnumerable<bool?> repeatedBoolValue = new List<bool?>();
            IEnumerable<ByteString> repeatedBytesValue = new List<ByteString>();
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = await libraryServiceClient.TestOptionalRequiredFlatteningParamsAsync(requiredSingularInt32, requiredSingularInt64, requiredSingularFloat, requiredSingularDouble, requiredSingularBool, requiredSingularEnum, requiredSingularString, requiredSingularBytes, requiredSingularMessage, requiredSingularResourceName, requiredSingularResourceNameOneof, requiredSingularResourceNameCommon, requiredSingularFixed32, requiredSingularFixed64, requiredRepeatedInt32, requiredRepeatedInt64, requiredRepeatedFloat, requiredRepeatedDouble, requiredRepeatedBool, requiredRepeatedEnum, requiredRepeatedString, requiredRepeatedBytes, requiredRepeatedMessage, requiredRepeatedResourceName, requiredRepeatedResourceNameOneof, requiredRepeatedResourceNameCommon, requiredRepeatedFixed32, requiredRepeatedFixed64, requiredMap, requiredAnyValue, requiredStructValue, requiredValueValue, requiredListValueValue, requiredTimeValue, requiredDurationValue, requiredFieldMaskValue, requiredInt32Value, requiredUint32Value, requiredInt64Value, requiredUint64Value, requiredFloatValue, requiredDoubleValue, requiredStringValue, requiredBoolValue, requiredBytesValue, requiredRepeatedAnyValue, requiredRepeatedStructValue, requiredRepeatedValueValue, requiredRepeatedListValueValue, requiredRepeatedTimeValue, requiredRepeatedDurationValue, requiredRepeatedFieldMaskValue, requiredRepeatedInt32Value, requiredRepeatedUint32Value, requiredRepeatedInt64Value, requiredRepeatedUint64Value, requiredRepeatedFloatValue, requiredRepeatedDoubleValue, requiredRepeatedStringValue, requiredRepeatedBoolValue, requiredRepeatedBytesValue, optionalSingularInt32, optionalSingularInt64, optionalSingularFloat, optionalSingularDouble, optionalSingularBool, optionalSingularEnum, optionalSingularString, optionalSingularBytes, optionalSingularMessage, optionalSingularResourceName, optionalSingularResourceNameOneof, optionalSingularResourceNameCommon, optionalSingularFixed32, optionalSingularFixed64, optionalRepeatedInt32, optionalRepeatedInt64, optionalRepeatedFloat, optionalRepeatedDouble, optionalRepeatedBool, optionalRepeatedEnum, optionalRepeatedString, optionalRepeatedBytes, optionalRepeatedMessage, optionalRepeatedResourceName, optionalRepeatedResourceNameOneof, optionalRepeatedResourceNameCommon, optionalRepeatedFixed32, optionalRepeatedFixed64, optionalMap, anyValue, structValue, valueValue, listValueValue, timeValue, durationValue, fieldMaskValue, int32Value, uint32Value, int64Value, uint64Value, floatValue, doubleValue, stringValue, boolValue, bytesValue, repeatedAnyValue, repeatedStructValue, repeatedValueValue, repeatedListValueValue, repeatedTimeValue, repeatedDurationValue, repeatedFieldMaskValue, repeatedInt32Value, repeatedUint32Value, repeatedInt64Value, repeatedUint64Value, repeatedFloatValue, repeatedDoubleValue, repeatedStringValue, repeatedBoolValue, repeatedBytesValue);
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParams</summary>
        public void TestOptionalRequiredFlatteningParams2()
        {
            // Snippet: TestOptionalRequiredFlatteningParams(int,long,float,double,bool,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookNameOneof,BookNameOneof,string,int,long,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookNameOneof>,IEnumerable<BookNameOneof>,IEnumerable<string>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,Any,Struct,Value,ListValue,Timestamp,Duration,FieldMask,int?,uint?,long?,ulong?,float?,double?,string,bool?,ByteString,IEnumerable<Any>,IEnumerable<Struct>,IEnumerable<Value>,IEnumerable<ListValue>,IEnumerable<Timestamp>,IEnumerable<Duration>,IEnumerable<FieldMask>,IEnumerable<int?>,IEnumerable<uint?>,IEnumerable<long?>,IEnumerable<ulong?>,IEnumerable<float?>,IEnumerable<double?>,IEnumerable<string>,IEnumerable<bool?>,IEnumerable<ByteString>,int?,long?,float?,double?,bool?,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum?,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookNameOneof,BookNameOneof,string,int?,long?,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookNameOneof>,IEnumerable<BookNameOneof>,IEnumerable<string>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,Any,Struct,Value,ListValue,Timestamp,Duration,FieldMask,int?,uint?,long?,ulong?,float?,double?,string,bool?,ByteString,IEnumerable<Any>,IEnumerable<Struct>,IEnumerable<Value>,IEnumerable<ListValue>,IEnumerable<Timestamp>,IEnumerable<Duration>,IEnumerable<FieldMask>,IEnumerable<int?>,IEnumerable<uint?>,IEnumerable<long?>,IEnumerable<ulong?>,IEnumerable<float?>,IEnumerable<double?>,IEnumerable<string>,IEnumerable<bool?>,IEnumerable<ByteString>,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            int requiredSingularInt32 = 0;
            long requiredSingularInt64 = 0L;
            float requiredSingularFloat = 0.0f;
            double requiredSingularDouble = 0.0;
            bool requiredSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string requiredSingularString = "";
            ByteString requiredSingularBytes = ByteString.Empty;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookNameOneof requiredSingularResourceName = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            BookNameOneof requiredSingularResourceNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string requiredSingularResourceNameCommon = "";
            int requiredSingularFixed32 = 0;
            long requiredSingularFixed64 = 0L;
            IEnumerable<int> requiredRepeatedInt32 = new List<int>();
            IEnumerable<long> requiredRepeatedInt64 = new List<long>();
            IEnumerable<float> requiredRepeatedFloat = new List<float>();
            IEnumerable<double> requiredRepeatedDouble = new List<double>();
            IEnumerable<bool> requiredRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> requiredRepeatedString = new List<string>();
            IEnumerable<ByteString> requiredRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceName = new List<BookNameOneof>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<string> requiredRepeatedResourceNameCommon = new List<string>();
            IEnumerable<int> requiredRepeatedFixed32 = new List<int>();
            IEnumerable<long> requiredRepeatedFixed64 = new List<long>();
            IDictionary<int, string> requiredMap = new Dictionary<int, string>();
            Any requiredAnyValue = new Any();
            Struct requiredStructValue = new Struct();
            Value requiredValueValue = new Value();
            ListValue requiredListValueValue = new ListValue();
            Timestamp requiredTimeValue = new Timestamp();
            Duration requiredDurationValue = new Duration();
            FieldMask requiredFieldMaskValue = new FieldMask();
            int? requiredInt32Value = null;
            uint? requiredUint32Value = null;
            long? requiredInt64Value = null;
            ulong? requiredUint64Value = null;
            float? requiredFloatValue = null;
            double? requiredDoubleValue = null;
            string requiredStringValue = null;
            bool? requiredBoolValue = null;
            ByteString requiredBytesValue = null;
            IEnumerable<Any> requiredRepeatedAnyValue = new List<Any>();
            IEnumerable<Struct> requiredRepeatedStructValue = new List<Struct>();
            IEnumerable<Value> requiredRepeatedValueValue = new List<Value>();
            IEnumerable<ListValue> requiredRepeatedListValueValue = new List<ListValue>();
            IEnumerable<Timestamp> requiredRepeatedTimeValue = new List<Timestamp>();
            IEnumerable<Duration> requiredRepeatedDurationValue = new List<Duration>();
            IEnumerable<FieldMask> requiredRepeatedFieldMaskValue = new List<FieldMask>();
            IEnumerable<int?> requiredRepeatedInt32Value = new List<int?>();
            IEnumerable<uint?> requiredRepeatedUint32Value = new List<uint?>();
            IEnumerable<long?> requiredRepeatedInt64Value = new List<long?>();
            IEnumerable<ulong?> requiredRepeatedUint64Value = new List<ulong?>();
            IEnumerable<float?> requiredRepeatedFloatValue = new List<float?>();
            IEnumerable<double?> requiredRepeatedDoubleValue = new List<double?>();
            IEnumerable<string> requiredRepeatedStringValue = new List<string>();
            IEnumerable<bool?> requiredRepeatedBoolValue = new List<bool?>();
            IEnumerable<ByteString> requiredRepeatedBytesValue = new List<ByteString>();
            int optionalSingularInt32 = 0;
            long optionalSingularInt64 = 0L;
            float optionalSingularFloat = 0.0f;
            double optionalSingularDouble = 0.0;
            bool optionalSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum optionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string optionalSingularString = "";
            ByteString optionalSingularBytes = ByteString.Empty;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookNameOneof optionalSingularResourceName = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            BookNameOneof optionalSingularResourceNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string optionalSingularResourceNameCommon = "";
            int optionalSingularFixed32 = 0;
            long optionalSingularFixed64 = 0L;
            IEnumerable<int> optionalRepeatedInt32 = new List<int>();
            IEnumerable<long> optionalRepeatedInt64 = new List<long>();
            IEnumerable<float> optionalRepeatedFloat = new List<float>();
            IEnumerable<double> optionalRepeatedDouble = new List<double>();
            IEnumerable<bool> optionalRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> optionalRepeatedString = new List<string>();
            IEnumerable<ByteString> optionalRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceName = new List<BookNameOneof>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<string> optionalRepeatedResourceNameCommon = new List<string>();
            IEnumerable<int> optionalRepeatedFixed32 = new List<int>();
            IEnumerable<long> optionalRepeatedFixed64 = new List<long>();
            IDictionary<int, string> optionalMap = new Dictionary<int, string>();
            Any anyValue = new Any();
            Struct structValue = new Struct();
            Value valueValue = new Value();
            ListValue listValueValue = new ListValue();
            Timestamp timeValue = new Timestamp();
            Duration durationValue = new Duration();
            FieldMask fieldMaskValue = new FieldMask();
            int? int32Value = null;
            uint? uint32Value = null;
            long? int64Value = null;
            ulong? uint64Value = null;
            float? floatValue = null;
            double? doubleValue = null;
            string stringValue = null;
            bool? boolValue = null;
            ByteString bytesValue = null;
            IEnumerable<Any> repeatedAnyValue = new List<Any>();
            IEnumerable<Struct> repeatedStructValue = new List<Struct>();
            IEnumerable<Value> repeatedValueValue = new List<Value>();
            IEnumerable<ListValue> repeatedListValueValue = new List<ListValue>();
            IEnumerable<Timestamp> repeatedTimeValue = new List<Timestamp>();
            IEnumerable<Duration> repeatedDurationValue = new List<Duration>();
            IEnumerable<FieldMask> repeatedFieldMaskValue = new List<FieldMask>();
            IEnumerable<int?> repeatedInt32Value = new List<int?>();
            IEnumerable<uint?> repeatedUint32Value = new List<uint?>();
            IEnumerable<long?> repeatedInt64Value = new List<long?>();
            IEnumerable<ulong?> repeatedUint64Value = new List<ulong?>();
            IEnumerable<float?> repeatedFloatValue = new List<float?>();
            IEnumerable<double?> repeatedDoubleValue = new List<double?>();
            IEnumerable<string> repeatedStringValue = new List<string>();
            IEnumerable<bool?> repeatedBoolValue = new List<bool?>();
            IEnumerable<ByteString> repeatedBytesValue = new List<ByteString>();
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = libraryServiceClient.TestOptionalRequiredFlatteningParams(requiredSingularInt32, requiredSingularInt64, requiredSingularFloat, requiredSingularDouble, requiredSingularBool, requiredSingularEnum, requiredSingularString, requiredSingularBytes, requiredSingularMessage, requiredSingularResourceName, requiredSingularResourceNameOneof, requiredSingularResourceNameCommon, requiredSingularFixed32, requiredSingularFixed64, requiredRepeatedInt32, requiredRepeatedInt64, requiredRepeatedFloat, requiredRepeatedDouble, requiredRepeatedBool, requiredRepeatedEnum, requiredRepeatedString, requiredRepeatedBytes, requiredRepeatedMessage, requiredRepeatedResourceName, requiredRepeatedResourceNameOneof, requiredRepeatedResourceNameCommon, requiredRepeatedFixed32, requiredRepeatedFixed64, requiredMap, requiredAnyValue, requiredStructValue, requiredValueValue, requiredListValueValue, requiredTimeValue, requiredDurationValue, requiredFieldMaskValue, requiredInt32Value, requiredUint32Value, requiredInt64Value, requiredUint64Value, requiredFloatValue, requiredDoubleValue, requiredStringValue, requiredBoolValue, requiredBytesValue, requiredRepeatedAnyValue, requiredRepeatedStructValue, requiredRepeatedValueValue, requiredRepeatedListValueValue, requiredRepeatedTimeValue, requiredRepeatedDurationValue, requiredRepeatedFieldMaskValue, requiredRepeatedInt32Value, requiredRepeatedUint32Value, requiredRepeatedInt64Value, requiredRepeatedUint64Value, requiredRepeatedFloatValue, requiredRepeatedDoubleValue, requiredRepeatedStringValue, requiredRepeatedBoolValue, requiredRepeatedBytesValue, optionalSingularInt32, optionalSingularInt64, optionalSingularFloat, optionalSingularDouble, optionalSingularBool, optionalSingularEnum, optionalSingularString, optionalSingularBytes, optionalSingularMessage, optionalSingularResourceName, optionalSingularResourceNameOneof, optionalSingularResourceNameCommon, optionalSingularFixed32, optionalSingularFixed64, optionalRepeatedInt32, optionalRepeatedInt64, optionalRepeatedFloat, optionalRepeatedDouble, optionalRepeatedBool, optionalRepeatedEnum, optionalRepeatedString, optionalRepeatedBytes, optionalRepeatedMessage, optionalRepeatedResourceName, optionalRepeatedResourceNameOneof, optionalRepeatedResourceNameCommon, optionalRepeatedFixed32, optionalRepeatedFixed64, optionalMap, anyValue, structValue, valueValue, listValueValue, timeValue, durationValue, fieldMaskValue, int32Value, uint32Value, int64Value, uint64Value, floatValue, doubleValue, stringValue, boolValue, bytesValue, repeatedAnyValue, repeatedStructValue, repeatedValueValue, repeatedListValueValue, repeatedTimeValue, repeatedDurationValue, repeatedFieldMaskValue, repeatedInt32Value, repeatedUint32Value, repeatedInt64Value, repeatedUint64Value, repeatedFloatValue, repeatedDoubleValue, repeatedStringValue, repeatedBoolValue, repeatedBytesValue);
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParamsAsync</summary>
        public async Task TestOptionalRequiredFlatteningParamsAsync_RequestObject()
        {
            // Snippet: TestOptionalRequiredFlatteningParamsAsync(TestOptionalRequiredFlatteningParamsRequest,CallSettings)
            // Additional: TestOptionalRequiredFlatteningParamsAsync(TestOptionalRequiredFlatteningParamsRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            TestOptionalRequiredFlatteningParamsRequest request = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 0,
                RequiredSingularInt64 = 0L,
                RequiredSingularFloat = 0.0f,
                RequiredSingularDouble = 0.0,
                RequiredSingularBool = false,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "",
                RequiredSingularBytes = ByteString.Empty,
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                RequiredSingularResourceNameCommon = "",
                RequiredSingularFixed32 = 0,
                RequiredSingularFixed64 = 0L,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNameOneofs = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedResourceNameCommon = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
                RequiredAnyValue = new Any(),
                RequiredStructValue = new Struct(),
                RequiredValueValue = new Value(),
                RequiredListValueValue = new ListValue(),
                RequiredTimeValue = new Timestamp(),
                RequiredDurationValue = new Duration(),
                RequiredFieldMaskValue = new FieldMask(),
                RequiredInt32Value = null,
                RequiredUint32Value = null,
                RequiredInt64Value = null,
                RequiredUint64Value = null,
                RequiredFloatValue = null,
                RequiredDoubleValue = null,
                RequiredStringValue = null,
                RequiredBoolValue = null,
                RequiredBytesValue = null,
                RequiredRepeatedAnyValue = { },
                RequiredRepeatedStructValue = { },
                RequiredRepeatedValueValue = { },
                RequiredRepeatedListValueValue = { },
                RequiredRepeatedTimeValue = { },
                RequiredRepeatedDurationValue = { },
                RequiredRepeatedFieldMaskValue = { },
                RequiredRepeatedInt32Value = { },
                RequiredRepeatedUint32Value = { },
                RequiredRepeatedInt64Value = { },
                RequiredRepeatedUint64Value = { },
                RequiredRepeatedFloatValue = { },
                RequiredRepeatedDoubleValue = { },
                RequiredRepeatedStringValue = { },
                RequiredRepeatedBoolValue = { },
                RequiredRepeatedBytesValue = { },
            };
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = await libraryServiceClient.TestOptionalRequiredFlatteningParamsAsync(request);
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParams</summary>
        public void TestOptionalRequiredFlatteningParams_RequestObject()
        {
            // Snippet: TestOptionalRequiredFlatteningParams(TestOptionalRequiredFlatteningParamsRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            TestOptionalRequiredFlatteningParamsRequest request = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 0,
                RequiredSingularInt64 = 0L,
                RequiredSingularFloat = 0.0f,
                RequiredSingularDouble = 0.0,
                RequiredSingularBool = false,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "",
                RequiredSingularBytes = ByteString.Empty,
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                RequiredSingularResourceNameCommon = "",
                RequiredSingularFixed32 = 0,
                RequiredSingularFixed64 = 0L,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNameOneofs = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedResourceNameCommon = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
                RequiredAnyValue = new Any(),
                RequiredStructValue = new Struct(),
                RequiredValueValue = new Value(),
                RequiredListValueValue = new ListValue(),
                RequiredTimeValue = new Timestamp(),
                RequiredDurationValue = new Duration(),
                RequiredFieldMaskValue = new FieldMask(),
                RequiredInt32Value = null,
                RequiredUint32Value = null,
                RequiredInt64Value = null,
                RequiredUint64Value = null,
                RequiredFloatValue = null,
                RequiredDoubleValue = null,
                RequiredStringValue = null,
                RequiredBoolValue = null,
                RequiredBytesValue = null,
                RequiredRepeatedAnyValue = { },
                RequiredRepeatedStructValue = { },
                RequiredRepeatedValueValue = { },
                RequiredRepeatedListValueValue = { },
                RequiredRepeatedTimeValue = { },
                RequiredRepeatedDurationValue = { },
                RequiredRepeatedFieldMaskValue = { },
                RequiredRepeatedInt32Value = { },
                RequiredRepeatedUint32Value = { },
                RequiredRepeatedInt64Value = { },
                RequiredRepeatedUint64Value = { },
                RequiredRepeatedFloatValue = { },
                RequiredRepeatedDoubleValue = { },
                RequiredRepeatedStringValue = { },
                RequiredRepeatedBoolValue = { },
                RequiredRepeatedBytesValue = { },
            };
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = libraryServiceClient.TestOptionalRequiredFlatteningParams(request);
            // End snippet
        }

        /// <summary>Snippet for ListAggregatedShelvesAsync</summary>
        public async Task ListAggregatedShelvesAsync()
        {
            // Snippet: ListAggregatedShelvesAsync(CallSettings)
            // Additional: ListAggregatedShelvesAsync(CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Make the request
            ListAggregatedShelvesResponse response = await libraryServiceClient.ListAggregatedShelvesAsync();
            // End snippet
        }

        /// <summary>Snippet for ListAggregatedShelves</summary>
        public void ListAggregatedShelves()
        {
            // Snippet: ListAggregatedShelves(CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Make the request
            ListAggregatedShelvesResponse response = libraryServiceClient.ListAggregatedShelves();
            // End snippet
        }

        /// <summary>Snippet for ListAggregatedShelvesAsync</summary>
        public async Task ListAggregatedShelvesAsync_RequestObject()
        {
            // Snippet: ListAggregatedShelvesAsync(ListAggregatedShelvesRequest,CallSettings)
            // Additional: ListAggregatedShelvesAsync(ListAggregatedShelvesRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ListAggregatedShelvesRequest request = new ListAggregatedShelvesRequest();
            // Make the request
            ListAggregatedShelvesResponse response = await libraryServiceClient.ListAggregatedShelvesAsync(request);
            // End snippet
        }

        /// <summary>Snippet for ListAggregatedShelves</summary>
        public void ListAggregatedShelves_RequestObject()
        {
            // Snippet: ListAggregatedShelves(ListAggregatedShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ListAggregatedShelvesRequest request = new ListAggregatedShelvesRequest();
            // Make the request
            ListAggregatedShelvesResponse response = libraryServiceClient.ListAggregatedShelves(request);
            // End snippet
        }

        /// <summary>Snippet for CreateInventoryAsync</summary>
        public async Task CreateInventoryAsync()
        {
            // Snippet: CreateInventoryAsync(PublisherName,Inventory,IResourceName,IResourceName,IEnumerable<IResourceName>,CallSettings)
            // Additional: CreateInventoryAsync(PublisherName,Inventory,IResourceName,IResourceName,IEnumerable<IResourceName>,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            PublisherName parent = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]");
            Inventory inventory = new Inventory();
            IResourceName asset = new ArchiveName("[ARCHIVE]");
            IResourceName parentAsset = new ArchiveName("[ARCHIVE]");
            IEnumerable<IResourceName> assets = new List<IResourceName>();
            // Make the request
            Inventory response = await libraryServiceClient.CreateInventoryAsync(parent, inventory, asset, parentAsset, assets);
            // End snippet
        }

        /// <summary>Snippet for CreateInventory</summary>
        public void CreateInventory()
        {
            // Snippet: CreateInventory(PublisherName,Inventory,IResourceName,IResourceName,IEnumerable<IResourceName>,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            PublisherName parent = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]");
            Inventory inventory = new Inventory();
            IResourceName asset = new ArchiveName("[ARCHIVE]");
            IResourceName parentAsset = new ArchiveName("[ARCHIVE]");
            IEnumerable<IResourceName> assets = new List<IResourceName>();
            // Make the request
            Inventory response = libraryServiceClient.CreateInventory(parent, inventory, asset, parentAsset, assets);
            // End snippet
        }

        /// <summary>Snippet for CreateInventoryAsync</summary>
        public async Task CreateInventoryAsync_RequestObject()
        {
            // Snippet: CreateInventoryAsync(CreateInventoryRequest,CallSettings)
            // Additional: CreateInventoryAsync(CreateInventoryRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            CreateInventoryRequest request = new CreateInventoryRequest
            {
                ParentAsPublisherName = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]"),
                AssetAsResourceName = new ArchiveName("[ARCHIVE]"),
                ParentAssetAsResourceName = new ArchiveName("[ARCHIVE]"),
                AssetsAsResourceNames = { },
            };
            // Make the request
            Inventory response = await libraryServiceClient.CreateInventoryAsync(request);
            // End snippet
        }

        /// <summary>Snippet for CreateInventory</summary>
        public void CreateInventory_RequestObject()
        {
            // Snippet: CreateInventory(CreateInventoryRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            CreateInventoryRequest request = new CreateInventoryRequest
            {
                ParentAsPublisherName = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]"),
                AssetAsResourceName = new ArchiveName("[ARCHIVE]"),
                ParentAssetAsResourceName = new ArchiveName("[ARCHIVE]"),
                AssetsAsResourceNames = { },
            };
            // Make the request
            Inventory response = libraryServiceClient.CreateInventory(request);
            // End snippet
        }

        /// <summary>Snippet for MoveBooksAsync</summary>
        public async Task MoveBooksAsync()
        {
            // Snippet: MoveBooksAsync(ArchiveName,ArchiveName,IEnumerable<PublisherName>,ProjectName,CallSettings)
            // Additional: MoveBooksAsync(ArchiveName,ArchiveName,IEnumerable<PublisherName>,ProjectName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ArchiveName source = new ArchiveName("[ARCHIVE]");
            ArchiveName destination = new ArchiveName("[ARCHIVE]");
            IEnumerable<PublisherName> publishers = new List<PublisherName>();
            ProjectName project = new ProjectName("[PROJECT]");
            // Make the request
            MoveBooksResponse response = await libraryServiceClient.MoveBooksAsync(source, destination, publishers, project);
            // End snippet
        }

        /// <summary>Snippet for MoveBooks</summary>
        public void MoveBooks()
        {
            // Snippet: MoveBooks(ArchiveName,ArchiveName,IEnumerable<PublisherName>,ProjectName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ArchiveName source = new ArchiveName("[ARCHIVE]");
            ArchiveName destination = new ArchiveName("[ARCHIVE]");
            IEnumerable<PublisherName> publishers = new List<PublisherName>();
            ProjectName project = new ProjectName("[PROJECT]");
            // Make the request
            MoveBooksResponse response = libraryServiceClient.MoveBooks(source, destination, publishers, project);
            // End snippet
        }

        /// <summary>Snippet for MoveBooksAsync</summary>
        public async Task MoveBooksAsync_RequestObject()
        {
            // Snippet: MoveBooksAsync(MoveBooksRequest,CallSettings)
            // Additional: MoveBooksAsync(MoveBooksRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            MoveBooksRequest request = new MoveBooksRequest();
            // Make the request
            MoveBooksResponse response = await libraryServiceClient.MoveBooksAsync(request);
            // End snippet
        }

        /// <summary>Snippet for MoveBooks</summary>
        public void MoveBooks_RequestObject()
        {
            // Snippet: MoveBooks(MoveBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            MoveBooksRequest request = new MoveBooksRequest();
            // Make the request
            MoveBooksResponse response = libraryServiceClient.MoveBooks(request);
            // End snippet
        }

        /// <summary>Snippet for ArchiveBooksAsync</summary>
        public async Task ArchiveBooksAsync()
        {
            // Snippet: ArchiveBooksAsync(ArchiveName,ArchiveName,CallSettings)
            // Additional: ArchiveBooksAsync(ArchiveName,ArchiveName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ArchiveName source = new ArchiveName("[ARCHIVE]");
            ArchiveName archive = new ArchiveName("[ARCHIVE]");
            // Make the request
            ArchiveBooksResponse response = await libraryServiceClient.ArchiveBooksAsync(source, archive);
            // End snippet
        }

        /// <summary>Snippet for ArchiveBooks</summary>
        public void ArchiveBooks()
        {
            // Snippet: ArchiveBooks(ArchiveName,ArchiveName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ArchiveName source = new ArchiveName("[ARCHIVE]");
            ArchiveName archive = new ArchiveName("[ARCHIVE]");
            // Make the request
            ArchiveBooksResponse response = libraryServiceClient.ArchiveBooks(source, archive);
            // End snippet
        }

        /// <summary>Snippet for ArchiveBooksAsync</summary>
        public async Task ArchiveBooksAsync_RequestObject()
        {
            // Snippet: ArchiveBooksAsync(ArchiveBooksRequest,CallSettings)
            // Additional: ArchiveBooksAsync(ArchiveBooksRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ArchiveBooksRequest request = new ArchiveBooksRequest();
            // Make the request
            ArchiveBooksResponse response = await libraryServiceClient.ArchiveBooksAsync(request);
            // End snippet
        }

        /// <summary>Snippet for ArchiveBooks</summary>
        public void ArchiveBooks_RequestObject()
        {
            // Snippet: ArchiveBooks(ArchiveBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ArchiveBooksRequest request = new ArchiveBooksRequest();
            // Make the request
            ArchiveBooksResponse response = libraryServiceClient.ArchiveBooks(request);
            // End snippet
        }

        /// <summary>Snippet for LongRunningArchiveBooksAsync</summary>
        public async Task LongRunningArchiveBooksAsync()
        {
            // Snippet: LongRunningArchiveBooksAsync(ArchiveName,ArchiveName,CallSettings)
            // Additional: LongRunningArchiveBooksAsync(ArchiveName,ArchiveName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ArchiveName source = new ArchiveName("[ARCHIVE]");
            ArchiveName archive = new ArchiveName("[ARCHIVE]");
            // Make the request
            Operation<ArchiveBooksResponse, ArchiveBooksMetadata> response =
                await libraryServiceClient.LongRunningArchiveBooksAsync(source, archive);

            // Poll until the returned long-running operation is complete
            Operation<ArchiveBooksResponse, ArchiveBooksMetadata> completedResponse =
                await response.PollUntilCompletedAsync();
            // Retrieve the operation result
            ArchiveBooksResponse result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<ArchiveBooksResponse, ArchiveBooksMetadata> retrievedResponse =
                await libraryServiceClient.PollOnceLongRunningArchiveBooksAsync(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                ArchiveBooksResponse retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for LongRunningArchiveBooks</summary>
        public void LongRunningArchiveBooks()
        {
            // Snippet: LongRunningArchiveBooks(ArchiveName,ArchiveName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ArchiveName source = new ArchiveName("[ARCHIVE]");
            ArchiveName archive = new ArchiveName("[ARCHIVE]");
            // Make the request
            Operation<ArchiveBooksResponse, ArchiveBooksMetadata> response =
                libraryServiceClient.LongRunningArchiveBooks(source, archive);

            // Poll until the returned long-running operation is complete
            Operation<ArchiveBooksResponse, ArchiveBooksMetadata> completedResponse =
                response.PollUntilCompleted();
            // Retrieve the operation result
            ArchiveBooksResponse result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<ArchiveBooksResponse, ArchiveBooksMetadata> retrievedResponse =
                libraryServiceClient.PollOnceLongRunningArchiveBooks(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                ArchiveBooksResponse retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for LongRunningArchiveBooksAsync</summary>
        public async Task LongRunningArchiveBooksAsync_RequestObject()
        {
            // Snippet: LongRunningArchiveBooksAsync(ArchiveBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ArchiveBooksRequest request = new ArchiveBooksRequest();
            // Make the request
            Operation<ArchiveBooksResponse, ArchiveBooksMetadata> response =
                await libraryServiceClient.LongRunningArchiveBooksAsync(request);

            // Poll until the returned long-running operation is complete
            Operation<ArchiveBooksResponse, ArchiveBooksMetadata> completedResponse =
                await response.PollUntilCompletedAsync();
            // Retrieve the operation result
            ArchiveBooksResponse result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<ArchiveBooksResponse, ArchiveBooksMetadata> retrievedResponse =
                await libraryServiceClient.PollOnceLongRunningArchiveBooksAsync(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                ArchiveBooksResponse retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for LongRunningArchiveBooks</summary>
        public void LongRunningArchiveBooks_RequestObject()
        {
            // Snippet: LongRunningArchiveBooks(ArchiveBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ArchiveBooksRequest request = new ArchiveBooksRequest();
            // Make the request
            Operation<ArchiveBooksResponse, ArchiveBooksMetadata> response =
                libraryServiceClient.LongRunningArchiveBooks(request);

            // Poll until the returned long-running operation is complete
            Operation<ArchiveBooksResponse, ArchiveBooksMetadata> completedResponse =
                response.PollUntilCompleted();
            // Retrieve the operation result
            ArchiveBooksResponse result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<ArchiveBooksResponse, ArchiveBooksMetadata> retrievedResponse =
                libraryServiceClient.PollOnceLongRunningArchiveBooks(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                ArchiveBooksResponse retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for StreamingArchiveBooks</summary>
        public async Task StreamingArchiveBooks()
        {
            // Snippet: StreamingArchiveBooks(CallSettings,BidirectionalStreamingSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize streaming call, retrieving the stream object
            LibraryServiceClient.StreamingArchiveBooksStream duplexStream = libraryServiceClient.StreamingArchiveBooks();

            // Sending requests and retrieving responses can be arbitrarily interleaved.
            // Exact sequence will depend on client/server behavior.

            // Create task to do something with responses from server
            Task responseHandlerTask = Task.Run(async () =>
            {
                IAsyncEnumerator<ArchiveBooksResponse> responseStream = duplexStream.ResponseStream;
                while (await responseStream.MoveNext())
                {
                    ArchiveBooksResponse response = responseStream.Current;
                    // Do something with streamed response
                }
                // The response stream has completed
            });

            // Send requests to the server
            bool done = false;
            while (!done)
            {
                // Initialize a request
                ArchiveBooksRequest request = new ArchiveBooksRequest();
                // Stream a request to the server
                await duplexStream.WriteAsync(request);

                // Set "done" to true when sending requests is complete
            }
            // Complete writing requests to the stream
            await duplexStream.WriteCompleteAsync();
            // Await the response handler.
            // This will complete once all server responses have been processed.
            await responseHandlerTask;
            // End snippet
        }

        /// <summary>Snippet for SaveBookAsync</summary>
        public async Task SaveBookAsync()
        {
            // Snippet: SaveBookAsync(BookNameOneof,string,string,Book.Types.Rating?,CallSettings)
            // Additional: SaveBookAsync(BookNameOneof,string,string,Book.Types.Rating?,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string author = "";
            string title = "";
            Book.Types.Rating rating = Book.Types.Rating.Good;
            // Make the request
            await libraryServiceClient.SaveBookAsync(name, author, title, rating);
            // End snippet
        }

        /// <summary>Snippet for SaveBook</summary>
        public void SaveBook()
        {
            // Snippet: SaveBook(BookNameOneof,string,string,Book.Types.Rating?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string author = "";
            string title = "";
            Book.Types.Rating rating = Book.Types.Rating.Good;
            // Make the request
            libraryServiceClient.SaveBook(name, author, title, rating);
            // End snippet
        }

        /// <summary>Snippet for SaveBookAsync</summary>
        public async Task SaveBookAsync_RequestObject()
        {
            // Snippet: SaveBookAsync(Book,CallSettings)
            // Additional: SaveBookAsync(Book,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            Book request = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            // Make the request
            await libraryServiceClient.SaveBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for SaveBook</summary>
        public void SaveBook_RequestObject()
        {
            // Snippet: SaveBook(Book,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            Book request = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            // Make the request
            libraryServiceClient.SaveBook(request);
            // End snippet
        }

        /// <summary>Snippet for PrivateListShelvesAsync</summary>
        public async Task PrivateListShelvesAsync()
        {
            // Snippet: PrivateListShelvesAsync(CallSettings)
            // Additional: PrivateListShelvesAsync(CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Make the request
            Book response = await libraryServiceClient.PrivateListShelvesAsync();
            // End snippet
        }

        /// <summary>Snippet for PrivateListShelves</summary>
        public void PrivateListShelves()
        {
            // Snippet: PrivateListShelves(CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Make the request
            Book response = libraryServiceClient.PrivateListShelves();
            // End snippet
        }

        /// <summary>Snippet for PrivateListShelvesAsync</summary>
        public async Task PrivateListShelvesAsync_RequestObject()
        {
            // Snippet: PrivateListShelvesAsync(ListShelvesRequest,CallSettings)
            // Additional: PrivateListShelvesAsync(ListShelvesRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ListShelvesRequest request = new ListShelvesRequest();
            // Make the request
            Book response = await libraryServiceClient.PrivateListShelvesAsync(request);
            // End snippet
        }

        /// <summary>Snippet for PrivateListShelves</summary>
        public void PrivateListShelves_RequestObject()
        {
            // Snippet: PrivateListShelves(ListShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ListShelvesRequest request = new ListShelvesRequest();
            // Make the request
            Book response = libraryServiceClient.PrivateListShelves(request);
            // End snippet
        }

    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Snippets/MyProtoClientSnippets.g.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

namespace Google.Example.Library.V1.Snippets
{
    using Google.Api.Gax;
    using Google.Api.Gax.Grpc;
    using apis = Google.Example.Library.V1;
    using Google.Protobuf;
    using Google.Protobuf.WellKnownTypes;
    using Grpc.Core;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Linq;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>Generated snippets</summary>
    public class GeneratedMyProtoClientSnippets
    {
        /// <summary>Snippet for MyMethodAsync</summary>
        public async Task MyMethodAsync_RequestObject()
        {
            // Snippet: MyMethodAsync(MethodRequest,CallSettings)
            // Additional: MyMethodAsync(MethodRequest,CancellationToken)
            // Create client
            MyProtoClient myProtoClient = await MyProtoClient.CreateAsync();
            // Initialize request argument(s)
            MethodRequest request = new MethodRequest();
            // Make the request
            MethodResponse response = await myProtoClient.MyMethodAsync(request);
            // End snippet
        }

        /// <summary>Snippet for MyMethod</summary>
        public void MyMethod_RequestObject()
        {
            // Snippet: MyMethod(MethodRequest,CallSettings)
            // Create client
            MyProtoClient myProtoClient = MyProtoClient.Create();
            // Initialize request argument(s)
            MethodRequest request = new MethodRequest();
            // Make the request
            MethodResponse response = myProtoClient.MyMethod(request);
            // End snippet
        }

        /// <summary>Snippet for GetNamespaceAsync</summary>
        public async Task GetNamespaceAsync_RequestObject()
        {
            // Snippet: GetNamespaceAsync(MethodRequest,CallSettings)
            // Additional: GetNamespaceAsync(MethodRequest,CancellationToken)
            // Create client
            MyProtoClient myProtoClient = await MyProtoClient.CreateAsync();
            // Initialize request argument(s)
            MethodRequest request = new MethodRequest();
            // Make the request
            Namespace response = await myProtoClient.GetNamespaceAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetNamespace</summary>
        public void GetNamespace_RequestObject()
        {
            // Snippet: GetNamespace(MethodRequest,CallSettings)
            // Create client
            MyProtoClient myProtoClient = MyProtoClient.Create();
            // Initialize request argument(s)
            MethodRequest request = new MethodRequest();
            // Make the request
            Namespace response = myProtoClient.GetNamespace(request);
            // End snippet
        }

    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Tests/Google.Example.Library.V1.Tests.csproj ==============
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>netcoreapp1.0;netcoreapp2.0;net452</TargetFrameworks>
    <TargetFrameworks Condition=" '$(OS)' != 'Windows_NT' ">netcoreapp1.0;netcoreapp2.0</TargetFrameworks>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="15.5.0" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.3.1" />
    <DotNetCliToolReference Include="dotnet-xunit" Version="2.3.1" />
    <PackageReference Include="Moq" Version="4.7.145" />
    <PackageReference Include="xunit" Version="2.3.1" />
    <ProjectReference Include="../Google.Example.Library.V1/Google.Example.Library.V1.csproj" />
  </ItemGroup>

</Project>

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Tests/LibraryServiceClientTest.g.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

namespace Google.Example.Library.V1.Tests
{
    using Google.Api.Gax;
    using Google.Api.Gax.Grpc;
    using Google.Cloud.Tagger.V1;
    using apis = Google.Example.Library.V1;
    using Google.LongRunning;
    using Google.Protobuf;
    using Google.Protobuf.WellKnownTypes;
    using Grpc.Core;
    using Moq;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Threading;
    using System.Threading.Tasks;
    using Xunit;

    /// <summary>Generated unit tests</summary>
    public class GeneratedLibraryServiceClientTest
    {
        [Fact]
        public void CreateShelf()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateShelfRequest expectedRequest = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.CreateShelf(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf shelf = new Shelf();
            Shelf response = client.CreateShelf(shelf);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task CreateShelfAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateShelfRequest expectedRequest = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.CreateShelfAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf shelf = new Shelf();
            Shelf response = await client.CreateShelfAsync(shelf);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void CreateShelf2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateShelfRequest request = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.CreateShelf(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf response = client.CreateShelf(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task CreateShelfAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateShelfRequest request = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.CreateShelfAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf response = await client.CreateShelfAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetShelf()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest expectedRequest = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelf(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF]");
            Shelf response = client.GetShelf(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetShelfAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest expectedRequest = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelfAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF]");
            Shelf response = await client.GetShelfAsync(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetShelf2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest expectedRequest = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                Message = new SomeMessage(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelf(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF]");
            SomeMessage message = new SomeMessage();
            Shelf response = client.GetShelf(name, message);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetShelfAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest expectedRequest = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                Message = new SomeMessage(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelfAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF]");
            SomeMessage message = new SomeMessage();
            Shelf response = await client.GetShelfAsync(name, message);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetShelf3()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest expectedRequest = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                Message = new SomeMessage(),
                StringBuilder = new StringBuilder(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelf(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF]");
            SomeMessage message = new SomeMessage();
            StringBuilder stringBuilder = new StringBuilder();
            Shelf response = client.GetShelf(name, message, stringBuilder);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetShelfAsync3()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest expectedRequest = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                Message = new SomeMessage(),
                StringBuilder = new StringBuilder(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelfAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF]");
            SomeMessage message = new SomeMessage();
            StringBuilder stringBuilder = new StringBuilder();
            Shelf response = await client.GetShelfAsync(name, message, stringBuilder);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetShelf4()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest request = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                Options = "options-1249474914",
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelf(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf response = client.GetShelf(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetShelfAsync4()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest request = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                Options = "options-1249474914",
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelfAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf response = await client.GetShelfAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void DeleteShelf()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteShelfRequest expectedRequest = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteShelf(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF]");
            client.DeleteShelf(name);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task DeleteShelfAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteShelfRequest expectedRequest = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteShelfAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF]");
            await client.DeleteShelfAsync(name);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void DeleteShelf2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteShelfRequest request = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteShelf(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            client.DeleteShelf(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task DeleteShelfAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteShelfRequest request = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteShelfAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            await client.DeleteShelfAsync(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void MergeShelves()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MergeShelvesRequest expectedRequest = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF]"),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.MergeShelves(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF]");
            ShelfName otherShelfName = new ShelfName("[SHELF]");
            Shelf response = client.MergeShelves(name, otherShelfName);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task MergeShelvesAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MergeShelvesRequest expectedRequest = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF]"),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.MergeShelvesAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF]");
            ShelfName otherShelfName = new ShelfName("[SHELF]");
            Shelf response = await client.MergeShelvesAsync(name, otherShelfName);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void MergeShelves2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MergeShelvesRequest request = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF]"),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.MergeShelves(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf response = client.MergeShelves(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task MergeShelvesAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MergeShelvesRequest request = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF]"),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.MergeShelvesAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf response = await client.MergeShelvesAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void CreateBook()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateBookRequest expectedRequest = new CreateBookRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.CreateBook(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF]");
            Book book = new Book();
            Book response = client.CreateBook(name, book);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task CreateBookAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateBookRequest expectedRequest = new CreateBookRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.CreateBookAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF]");
            Book book = new Book();
            Book response = await client.CreateBookAsync(name, book);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void CreateBook2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateBookRequest request = new CreateBookRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.CreateBook(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = client.CreateBook(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task CreateBookAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateBookRequest request = new CreateBookRequest
            {
                ShelfName = new ShelfName("[SHELF]"),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.CreateBookAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = await client.CreateBookAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void PublishSeries()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            PublishSeriesRequest expectedRequest = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                Edition = 1887963714,
                SeriesUuid = new SeriesUuid
                {
                    SeriesString = "foobar",
                },
                PublisherAsPublisherName = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]"),
            };
            PublishSeriesResponse expectedResponse = new PublishSeriesResponse
            {
                BookNames =
                {
                    "bookNamesElement1491670575",
                },
            };
            mockGrpcClient.Setup(x => x.PublishSeries(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf shelf = new Shelf();
            IEnumerable<Book> books = new List<Book>();
            uint edition = 1887963714;
            SeriesUuid seriesUuid = new SeriesUuid
            {
                SeriesString = "foobar",
            };
            PublisherName publisher = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]");
            PublishSeriesResponse response = client.PublishSeries(shelf, books, edition, seriesUuid, publisher);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task PublishSeriesAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            PublishSeriesRequest expectedRequest = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                Edition = 1887963714,
                SeriesUuid = new SeriesUuid
                {
                    SeriesString = "foobar",
                },
                PublisherAsPublisherName = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]"),
            };
            PublishSeriesResponse expectedResponse = new PublishSeriesResponse
            {
                BookNames =
                {
                    "bookNamesElement1491670575",
                },
            };
            mockGrpcClient.Setup(x => x.PublishSeriesAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<PublishSeriesResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf shelf = new Shelf();
            IEnumerable<Book> books = new List<Book>();
            uint edition = 1887963714;
            SeriesUuid seriesUuid = new SeriesUuid
            {
                SeriesString = "foobar",
            };
            PublisherName publisher = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]");
            PublishSeriesResponse response = await client.PublishSeriesAsync(shelf, books, edition, seriesUuid, publisher);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void PublishSeries2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                SeriesUuid = new SeriesUuid
                {
                    SeriesString = "foobar",
                },
            };
            PublishSeriesResponse expectedResponse = new PublishSeriesResponse
            {
                BookNames =
                {
                    "bookNamesElement1491670575",
                },
            };
            mockGrpcClient.Setup(x => x.PublishSeries(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            PublishSeriesResponse response = client.PublishSeries(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task PublishSeriesAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                SeriesUuid = new SeriesUuid
                {
                    SeriesString = "foobar",
                },
            };
            PublishSeriesResponse expectedResponse = new PublishSeriesResponse
            {
                BookNames =
                {
                    "bookNamesElement1491670575",
                },
            };
            mockGrpcClient.Setup(x => x.PublishSeriesAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<PublishSeriesResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            PublishSeriesResponse response = await client.PublishSeriesAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBook()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookRequest expectedRequest = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.GetBook(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            Book response = client.GetBook(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookRequest expectedRequest = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.GetBookAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            Book response = await client.GetBookAsync(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBook2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.GetBook(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = client.GetBook(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.GetBookAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = await client.GetBookAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void DeleteBook()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteBookRequest expectedRequest = new DeleteBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteBook(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            client.DeleteBook(name);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task DeleteBookAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteBookRequest expectedRequest = new DeleteBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteBookAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            await client.DeleteBookAsync(name);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void DeleteBook2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteBookRequest request = new DeleteBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteBook(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            client.DeleteBook(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task DeleteBookAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteBookRequest request = new DeleteBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteBookAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            await client.DeleteBookAsync(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void UpdateBook()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookRequest expectedRequest = new UpdateBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.UpdateBook(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            Book book = new Book();
            Book response = client.UpdateBook(name, book);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task UpdateBookAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookRequest expectedRequest = new UpdateBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.UpdateBookAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            Book book = new Book();
            Book response = await client.UpdateBookAsync(name, book);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void UpdateBook2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookRequest expectedRequest = new UpdateBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                OptionalFoo = "optionalFoo1822578535",
                Book = new Book(),
                UpdateMask = new FieldMask(),
                PhysicalMask = new apis::FieldMask(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.UpdateBook(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string optionalFoo = "optionalFoo1822578535";
            Book book = new Book();
            FieldMask updateMask = new FieldMask();
            apis::FieldMask physicalMask = new apis::FieldMask();
            Book response = client.UpdateBook(name, optionalFoo, book, updateMask, physicalMask);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task UpdateBookAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookRequest expectedRequest = new UpdateBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                OptionalFoo = "optionalFoo1822578535",
                Book = new Book(),
                UpdateMask = new FieldMask(),
                PhysicalMask = new apis::FieldMask(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.UpdateBookAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string optionalFoo = "optionalFoo1822578535";
            Book book = new Book();
            FieldMask updateMask = new FieldMask();
            apis::FieldMask physicalMask = new apis::FieldMask();
            Book response = await client.UpdateBookAsync(name, optionalFoo, book, updateMask, physicalMask);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void UpdateBook3()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookRequest request = new UpdateBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.UpdateBook(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = client.UpdateBook(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task UpdateBookAsync3()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookRequest request = new UpdateBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.UpdateBookAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = await client.UpdateBookAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void MoveBook()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MoveBookRequest expectedRequest = new MoveBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF]"),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.MoveBook(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            ShelfName otherShelfName = new ShelfName("[SHELF]");
            Book response = client.MoveBook(name, otherShelfName);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task MoveBookAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MoveBookRequest expectedRequest = new MoveBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF]"),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.MoveBookAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            ShelfName otherShelfName = new ShelfName("[SHELF]");
            Book response = await client.MoveBookAsync(name, otherShelfName);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void MoveBook2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MoveBookRequest request = new MoveBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF]"),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.MoveBook(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = client.MoveBook(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task MoveBookAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MoveBookRequest request = new MoveBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF]"),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.MoveBookAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = await client.MoveBookAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void AddComments()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            AddCommentsRequest expectedRequest = new AddCommentsRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Comments =
                {
                    new Comment
                    {
                        Comment = ByteString.CopyFromUtf8("95"),
                        Stage = Comment.Types.Stage.Unset,
                        Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                    },
                },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.AddComments(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            IEnumerable<Comment> comments = new[]
            {
                new Comment
                {
                    Comment = ByteString.CopyFromUtf8("95"),
                    Stage = Comment.Types.Stage.Unset,
                    Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                },
            };
            client.AddComments(name, comments);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task AddCommentsAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            AddCommentsRequest expectedRequest = new AddCommentsRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Comments =
                {
                    new Comment
                    {
                        Comment = ByteString.CopyFromUtf8("95"),
                        Stage = Comment.Types.Stage.Unset,
                        Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                    },
                },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.AddCommentsAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            IEnumerable<Comment> comments = new[]
            {
                new Comment
                {
                    Comment = ByteString.CopyFromUtf8("95"),
                    Stage = Comment.Types.Stage.Unset,
                    Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                },
            };
            await client.AddCommentsAsync(name, comments);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void AddComments2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            AddCommentsRequest request = new AddCommentsRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Comments =
                {
                    new Comment
                    {
                        Comment = ByteString.CopyFromUtf8("95"),
                        Stage = Comment.Types.Stage.Unset,
                        Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                    },
                },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.AddComments(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            client.AddComments(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task AddCommentsAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            AddCommentsRequest request = new AddCommentsRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Comments =
                {
                    new Comment
                    {
                        Comment = ByteString.CopyFromUtf8("95"),
                        Stage = Comment.Types.Stage.Unset,
                        Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                    },
                },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.AddCommentsAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            await client.AddCommentsAsync(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBookFromArchive()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromArchiveRequest expectedRequest = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
                ParentAsProjectName = new ProjectName("[PROJECT]"),
            };
            BookFromArchive expectedResponse = new BookFromArchive
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromArchive(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ArchivedBookName name = new ArchivedBookName("[ARCHIVE]", "[BOOK]");
            ProjectName parent = new ProjectName("[PROJECT]");
            BookFromArchive response = client.GetBookFromArchive(name, parent);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookFromArchiveAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromArchiveRequest expectedRequest = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
                ParentAsProjectName = new ProjectName("[PROJECT]"),
            };
            BookFromArchive expectedResponse = new BookFromArchive
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromArchiveAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<BookFromArchive>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ArchivedBookName name = new ArchivedBookName("[ARCHIVE]", "[BOOK]");
            ProjectName parent = new ProjectName("[PROJECT]");
            BookFromArchive response = await client.GetBookFromArchiveAsync(name, parent);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBookFromArchive2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromArchiveRequest request = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
                ParentAsProjectName = new ProjectName("[PROJECT]"),
            };
            BookFromArchive expectedResponse = new BookFromArchive
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromArchive(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookFromArchive response = client.GetBookFromArchive(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookFromArchiveAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromArchiveRequest request = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
                ParentAsProjectName = new ProjectName("[PROJECT]"),
            };
            BookFromArchive expectedResponse = new BookFromArchive
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromArchiveAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<BookFromArchive>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookFromArchive response = await client.GetBookFromArchiveAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBookFromAnywhere()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAnywhereRequest expectedRequest = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                PlaceAsLocationName = new LocationName("[PROJECT]", "[LOCATION]"),
                FolderAsFolderName = new FolderName("[FOLDER]"),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAnywhere(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            BookNameOneof altBookName = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            LocationName place = new LocationName("[PROJECT]", "[LOCATION]");
            FolderName folder = new FolderName("[FOLDER]");
            BookFromAnywhere response = client.GetBookFromAnywhere(name, altBookName, place, folder);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookFromAnywhereAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAnywhereRequest expectedRequest = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                PlaceAsLocationName = new LocationName("[PROJECT]", "[LOCATION]"),
                FolderAsFolderName = new FolderName("[FOLDER]"),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAnywhereAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<BookFromAnywhere>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            BookNameOneof altBookName = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            LocationName place = new LocationName("[PROJECT]", "[LOCATION]");
            FolderName folder = new FolderName("[FOLDER]");
            BookFromAnywhere response = await client.GetBookFromAnywhereAsync(name, altBookName, place, folder);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBookFromAnywhere2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAnywhereRequest request = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                PlaceAsLocationName = new LocationName("[PROJECT]", "[LOCATION]"),
                FolderAsFolderName = new FolderName("[FOLDER]"),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAnywhere(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookFromAnywhere response = client.GetBookFromAnywhere(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookFromAnywhereAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAnywhereRequest request = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                PlaceAsLocationName = new LocationName("[PROJECT]", "[LOCATION]"),
                FolderAsFolderName = new FolderName("[FOLDER]"),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAnywhereAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<BookFromAnywhere>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookFromAnywhere response = await client.GetBookFromAnywhereAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBookFromAbsolutelyAnywhere()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAbsolutelyAnywhereRequest expectedRequest = new GetBookFromAbsolutelyAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAbsolutelyAnywhere(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            BookFromAnywhere response = client.GetBookFromAbsolutelyAnywhere(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookFromAbsolutelyAnywhereAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAbsolutelyAnywhereRequest expectedRequest = new GetBookFromAbsolutelyAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAbsolutelyAnywhereAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<BookFromAnywhere>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            BookFromAnywhere response = await client.GetBookFromAbsolutelyAnywhereAsync(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBookFromAbsolutelyAnywhere2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAbsolutelyAnywhereRequest request = new GetBookFromAbsolutelyAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAbsolutelyAnywhere(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookFromAnywhere response = client.GetBookFromAbsolutelyAnywhere(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookFromAbsolutelyAnywhereAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAbsolutelyAnywhereRequest request = new GetBookFromAbsolutelyAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAbsolutelyAnywhereAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<BookFromAnywhere>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookFromAnywhere response = await client.GetBookFromAbsolutelyAnywhereAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void UpdateBookIndex()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookIndexRequest expectedRequest = new UpdateBookIndexRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                IndexName = "default index",
                IndexMap =
                {
                    { "default_key", "indexMapItem1918721251" },
                },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.UpdateBookIndex(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string indexName = "default index";
            IDictionary<string, string> indexMap = new Dictionary<string, string>
            {
                { "default_key", "indexMapItem1918721251" },
            };
            client.UpdateBookIndex(name, indexName, indexMap);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task UpdateBookIndexAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookIndexRequest expectedRequest = new UpdateBookIndexRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                IndexName = "default index",
                IndexMap =
                {
                    { "default_key", "indexMapItem1918721251" },
                },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.UpdateBookIndexAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string indexName = "default index";
            IDictionary<string, string> indexMap = new Dictionary<string, string>
            {
                { "default_key", "indexMapItem1918721251" },
            };
            await client.UpdateBookIndexAsync(name, indexName, indexMap);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void UpdateBookIndex2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookIndexRequest request = new UpdateBookIndexRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                IndexName = "default index",
                IndexMap =
                {
                    { "default_key", "indexMapItem1918721251" },
                },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.UpdateBookIndex(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            client.UpdateBookIndex(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task UpdateBookIndexAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookIndexRequest request = new UpdateBookIndexRequest
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                IndexName = "default index",
                IndexMap =
                {
                    { "default_key", "indexMapItem1918721251" },
                },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.UpdateBookIndexAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            await client.UpdateBookIndexAsync(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void TestOptionalRequiredFlatteningParams()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            TestOptionalRequiredFlatteningParamsRequest expectedRequest = new TestOptionalRequiredFlatteningParamsRequest();
            TestOptionalRequiredFlatteningParamsResponse expectedResponse = new TestOptionalRequiredFlatteningParamsResponse();
            mockGrpcClient.Setup(x => x.TestOptionalRequiredFlatteningParams(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);

            TestOptionalRequiredFlatteningParamsResponse response = client.TestOptionalRequiredFlatteningParams();
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task TestOptionalRequiredFlatteningParamsAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            TestOptionalRequiredFlatteningParamsRequest expectedRequest = new TestOptionalRequiredFlatteningParamsRequest();
            TestOptionalRequiredFlatteningParamsResponse expectedResponse = new TestOptionalRequiredFlatteningParamsResponse();
            mockGrpcClient.Setup(x => x.TestOptionalRequiredFlatteningParamsAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<TestOptionalRequiredFlatteningParamsResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);

            TestOptionalRequiredFlatteningParamsResponse response = await client.TestOptionalRequiredFlatteningParamsAsync();
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void TestOptionalRequiredFlatteningParams2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            TestOptionalRequiredFlatteningParamsRequest expectedRequest = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 72313594,
                RequiredSingularInt64 = 72313499L,
                RequiredSingularFloat = -7514705.0f,
                RequiredSingularDouble = 1.9111005E8,
                RequiredSingularBool = true,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "requiredSingularString-1949894503",
                RequiredSingularBytes = ByteString.CopyFromUtf8("-29"),
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                RequiredSingularResourceNameCommon = "requiredSingularResourceNameCommon-1126805002",
                RequiredSingularFixed32 = 720656715,
                RequiredSingularFixed64 = 720656810,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNameOneofs = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedResourceNameCommon = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
                RequiredAnyValue = new Any(),
                RequiredStructValue = new Struct(),
                RequiredValueValue = new Value(),
                RequiredListValueValue = new ListValue(),
                RequiredTimeValue = new Timestamp(),
                RequiredDurationValue = new Duration(),
                RequiredFieldMaskValue = new FieldMask(),
                RequiredInt32Value = null,
                RequiredUint32Value = null,
                RequiredInt64Value = null,
                RequiredUint64Value = null,
                RequiredFloatValue = null,
                RequiredDoubleValue = null,
                RequiredStringValue = null,
                RequiredBoolValue = null,
                RequiredBytesValue = null,
                RequiredRepeatedAnyValue = { },
                RequiredRepeatedStructValue = { },
                RequiredRepeatedValueValue = { },
                RequiredRepeatedListValueValue = { },
                RequiredRepeatedTimeValue = { },
                RequiredRepeatedDurationValue = { },
                RequiredRepeatedFieldMaskValue = { },
                RequiredRepeatedInt32Value = { },
                RequiredRepeatedUint32Value = { },
                RequiredRepeatedInt64Value = { },
                RequiredRepeatedUint64Value = { },
                RequiredRepeatedFloatValue = { },
                RequiredRepeatedDoubleValue = { },
                RequiredRepeatedStringValue = { },
                RequiredRepeatedBoolValue = { },
                RequiredRepeatedBytesValue = { },
                OptionalSingularInt32 = 1196565723,
                OptionalSingularInt64 = 1196565628L,
                OptionalSingularFloat = -1.19939918E8f,
                OptionalSingularDouble = 1.41902287E8,
                OptionalSingularBool = false,
                OptionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                OptionalSingularString = "optionalSingularString1852995162",
                OptionalSingularBytes = ByteString.CopyFromUtf8("2"),
                OptionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                OptionalSingularResourceNameAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                OptionalSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                OptionalSingularResourceNameCommon = "optionalSingularResourceNameCommon-108123657",
                OptionalSingularFixed32 = 1648847958,
                OptionalSingularFixed64 = 1648847863,
                OptionalRepeatedInt32 = { },
                OptionalRepeatedInt64 = { },
                OptionalRepeatedFloat = { },
                OptionalRepeatedDouble = { },
                OptionalRepeatedBool = { },
                OptionalRepeatedEnum = { },
                OptionalRepeatedString = { },
                OptionalRepeatedBytes = { },
                OptionalRepeatedMessage = { },
                OptionalRepeatedResourceNameAsBookNameOneofs = { },
                OptionalRepeatedResourceNameOneofAsBookNameOneofs = { },
                OptionalRepeatedResourceNameCommon = { },
                OptionalRepeatedFixed32 = { },
                OptionalRepeatedFixed64 = { },
                OptionalMap = { },
                AnyValue = new Any(),
                StructValue = new Struct(),
                ValueValue = new Value(),
                ListValueValue = new ListValue(),
                TimeValue = new Timestamp(),
                DurationValue = new Duration(),
                FieldMaskValue = new FieldMask(),
                Int32Value = null,
                Uint32Value = null,
                Int64Value = null,
                Uint64Value = null,
                FloatValue = null,
                DoubleValue = null,
                StringValue = null,
                BoolValue = null,
                BytesValue = null,
                RepeatedAnyValue = { },
                RepeatedStructValue = { },
                RepeatedValueValue = { },
                RepeatedListValueValue = { },
                RepeatedTimeValue = { },
                RepeatedDurationValue = { },
                RepeatedFieldMaskValue = { },
                RepeatedInt32Value = { },
                RepeatedUint32Value = { },
                RepeatedInt64Value = { },
                RepeatedUint64Value = { },
                RepeatedFloatValue = { },
                RepeatedDoubleValue = { },
                RepeatedStringValue = { },
                RepeatedBoolValue = { },
                RepeatedBytesValue = { },
            };
            TestOptionalRequiredFlatteningParamsResponse expectedResponse = new TestOptionalRequiredFlatteningParamsResponse();
            mockGrpcClient.Setup(x => x.TestOptionalRequiredFlatteningParams(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            int requiredSingularInt32 = 72313594;
            long requiredSingularInt64 = 72313499L;
            float requiredSingularFloat = -7514705.0f;
            double requiredSingularDouble = 1.9111005E8;
            bool requiredSingularBool = true;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string requiredSingularString = "requiredSingularString-1949894503";
            ByteString requiredSingularBytes = ByteString.CopyFromUtf8("-29");
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookNameOneof requiredSingularResourceName = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            BookNameOneof requiredSingularResourceNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string requiredSingularResourceNameCommon = "requiredSingularResourceNameCommon-1126805002";
            int requiredSingularFixed32 = 720656715;
            long requiredSingularFixed64 = 720656810;
            IEnumerable<int> requiredRepeatedInt32 = new List<int>();
            IEnumerable<long> requiredRepeatedInt64 = new List<long>();
            IEnumerable<float> requiredRepeatedFloat = new List<float>();
            IEnumerable<double> requiredRepeatedDouble = new List<double>();
            IEnumerable<bool> requiredRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> requiredRepeatedString = new List<string>();
            IEnumerable<ByteString> requiredRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceName = new List<BookNameOneof>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<string> requiredRepeatedResourceNameCommon = new List<string>();
            IEnumerable<int> requiredRepeatedFixed32 = new List<int>();
            IEnumerable<long> requiredRepeatedFixed64 = new List<long>();
            IDictionary<int, string> requiredMap = new Dictionary<int, string>();
            Any requiredAnyValue = new Any();
            Struct requiredStructValue = new Struct();
            Value requiredValueValue = new Value();
            ListValue requiredListValueValue = new ListValue();
            Timestamp requiredTimeValue = new Timestamp();
            Duration requiredDurationValue = new Duration();
            FieldMask requiredFieldMaskValue = new FieldMask();
            int? requiredInt32Value = null;
            uint? requiredUint32Value = null;
            long? requiredInt64Value = null;
            ulong? requiredUint64Value = null;
            float? requiredFloatValue = null;
            double? requiredDoubleValue = null;
            string requiredStringValue = null;
            bool? requiredBoolValue = null;
            ByteString requiredBytesValue = null;
            IEnumerable<Any> requiredRepeatedAnyValue = new List<Any>();
            IEnumerable<Struct> requiredRepeatedStructValue = new List<Struct>();
            IEnumerable<Value> requiredRepeatedValueValue = new List<Value>();
            IEnumerable<ListValue> requiredRepeatedListValueValue = new List<ListValue>();
            IEnumerable<Timestamp> requiredRepeatedTimeValue = new List<Timestamp>();
            IEnumerable<Duration> requiredRepeatedDurationValue = new List<Duration>();
            IEnumerable<FieldMask> requiredRepeatedFieldMaskValue = new List<FieldMask>();
            IEnumerable<int?> requiredRepeatedInt32Value = new List<int?>();
            IEnumerable<uint?> requiredRepeatedUint32Value = new List<uint?>();
            IEnumerable<long?> requiredRepeatedInt64Value = new List<long?>();
            IEnumerable<ulong?> requiredRepeatedUint64Value = new List<ulong?>();
            IEnumerable<float?> requiredRepeatedFloatValue = new List<float?>();
            IEnumerable<double?> requiredRepeatedDoubleValue = new List<double?>();
            IEnumerable<string> requiredRepeatedStringValue = new List<string>();
            IEnumerable<bool?> requiredRepeatedBoolValue = new List<bool?>();
            IEnumerable<ByteString> requiredRepeatedBytesValue = new List<ByteString>();
            int optionalSingularInt32 = 1196565723;
            long optionalSingularInt64 = 1196565628L;
            float optionalSingularFloat = -1.19939918E8f;
            double optionalSingularDouble = 1.41902287E8;
            bool optionalSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum optionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string optionalSingularString = "optionalSingularString1852995162";
            ByteString optionalSingularBytes = ByteString.CopyFromUtf8("2");
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookNameOneof optionalSingularResourceName = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            BookNameOneof optionalSingularResourceNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string optionalSingularResourceNameCommon = "optionalSingularResourceNameCommon-108123657";
            int optionalSingularFixed32 = 1648847958;
            long optionalSingularFixed64 = 1648847863;
            IEnumerable<int> optionalRepeatedInt32 = new List<int>();
            IEnumerable<long> optionalRepeatedInt64 = new List<long>();
            IEnumerable<float> optionalRepeatedFloat = new List<float>();
            IEnumerable<double> optionalRepeatedDouble = new List<double>();
            IEnumerable<bool> optionalRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> optionalRepeatedString = new List<string>();
            IEnumerable<ByteString> optionalRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceName = new List<BookNameOneof>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<string> optionalRepeatedResourceNameCommon = new List<string>();
            IEnumerable<int> optionalRepeatedFixed32 = new List<int>();
            IEnumerable<long> optionalRepeatedFixed64 = new List<long>();
            IDictionary<int, string> optionalMap = new Dictionary<int, string>();
            Any anyValue = new Any();
            Struct structValue = new Struct();
            Value valueValue = new Value();
            ListValue listValueValue = new ListValue();
            Timestamp timeValue = new Timestamp();
            Duration durationValue = new Duration();
            FieldMask fieldMaskValue = new FieldMask();
            int? int32Value = null;
            uint? uint32Value = null;
            long? int64Value = null;
            ulong? uint64Value = null;
            float? floatValue = null;
            double? doubleValue = null;
            string stringValue = null;
            bool? boolValue = null;
            ByteString bytesValue = null;
            IEnumerable<Any> repeatedAnyValue = new List<Any>();
            IEnumerable<Struct> repeatedStructValue = new List<Struct>();
            IEnumerable<Value> repeatedValueValue = new List<Value>();
            IEnumerable<ListValue> repeatedListValueValue = new List<ListValue>();
            IEnumerable<Timestamp> repeatedTimeValue = new List<Timestamp>();
            IEnumerable<Duration> repeatedDurationValue = new List<Duration>();
            IEnumerable<FieldMask> repeatedFieldMaskValue = new List<FieldMask>();
            IEnumerable<int?> repeatedInt32Value = new List<int?>();
            IEnumerable<uint?> repeatedUint32Value = new List<uint?>();
            IEnumerable<long?> repeatedInt64Value = new List<long?>();
            IEnumerable<ulong?> repeatedUint64Value = new List<ulong?>();
            IEnumerable<float?> repeatedFloatValue = new List<float?>();
            IEnumerable<double?> repeatedDoubleValue = new List<double?>();
            IEnumerable<string> repeatedStringValue = new List<string>();
            IEnumerable<bool?> repeatedBoolValue = new List<bool?>();
            IEnumerable<ByteString> repeatedBytesValue = new List<ByteString>();
            TestOptionalRequiredFlatteningParamsResponse response = client.TestOptionalRequiredFlatteningParams(requiredSingularInt32, requiredSingularInt64, requiredSingularFloat, requiredSingularDouble, requiredSingularBool, requiredSingularEnum, requiredSingularString, requiredSingularBytes, requiredSingularMessage, requiredSingularResourceName, requiredSingularResourceNameOneof, requiredSingularResourceNameCommon, requiredSingularFixed32, requiredSingularFixed64, requiredRepeatedInt32, requiredRepeatedInt64, requiredRepeatedFloat, requiredRepeatedDouble, requiredRepeatedBool, requiredRepeatedEnum, requiredRepeatedString, requiredRepeatedBytes, requiredRepeatedMessage, requiredRepeatedResourceName, requiredRepeatedResourceNameOneof, requiredRepeatedResourceNameCommon, requiredRepeatedFixed32, requiredRepeatedFixed64, requiredMap, requiredAnyValue, requiredStructValue, requiredValueValue, requiredListValueValue, requiredTimeValue, requiredDurationValue, requiredFieldMaskValue, requiredInt32Value, requiredUint32Value, requiredInt64Value, requiredUint64Value, requiredFloatValue, requiredDoubleValue, requiredStringValue, requiredBoolValue, requiredBytesValue, requiredRepeatedAnyValue, requiredRepeatedStructValue, requiredRepeatedValueValue, requiredRepeatedListValueValue, requiredRepeatedTimeValue, requiredRepeatedDurationValue, requiredRepeatedFieldMaskValue, requiredRepeatedInt32Value, requiredRepeatedUint32Value, requiredRepeatedInt64Value, requiredRepeatedUint64Value, requiredRepeatedFloatValue, requiredRepeatedDoubleValue, requiredRepeatedStringValue, requiredRepeatedBoolValue, requiredRepeatedBytesValue, optionalSingularInt32, optionalSingularInt64, optionalSingularFloat, optionalSingularDouble, optionalSingularBool, optionalSingularEnum, optionalSingularString, optionalSingularBytes, optionalSingularMessage, optionalSingularResourceName, optionalSingularResourceNameOneof, optionalSingularResourceNameCommon, optionalSingularFixed32, optionalSingularFixed64, optionalRepeatedInt32, optionalRepeatedInt64, optionalRepeatedFloat, optionalRepeatedDouble, optionalRepeatedBool, optionalRepeatedEnum, optionalRepeatedString, optionalRepeatedBytes, optionalRepeatedMessage, optionalRepeatedResourceName, optionalRepeatedResourceNameOneof, optionalRepeatedResourceNameCommon, optionalRepeatedFixed32, optionalRepeatedFixed64, optionalMap, anyValue, structValue, valueValue, listValueValue, timeValue, durationValue, fieldMaskValue, int32Value, uint32Value, int64Value, uint64Value, floatValue, doubleValue, stringValue, boolValue, bytesValue, repeatedAnyValue, repeatedStructValue, repeatedValueValue, repeatedListValueValue, repeatedTimeValue, repeatedDurationValue, repeatedFieldMaskValue, repeatedInt32Value, repeatedUint32Value, repeatedInt64Value, repeatedUint64Value, repeatedFloatValue, repeatedDoubleValue, repeatedStringValue, repeatedBoolValue, repeatedBytesValue);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task TestOptionalRequiredFlatteningParamsAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            TestOptionalRequiredFlatteningParamsRequest expectedRequest = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 72313594,
                RequiredSingularInt64 = 72313499L,
                RequiredSingularFloat = -7514705.0f,
                RequiredSingularDouble = 1.9111005E8,
                RequiredSingularBool = true,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "requiredSingularString-1949894503",
                RequiredSingularBytes = ByteString.CopyFromUtf8("-29"),
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                RequiredSingularResourceNameCommon = "requiredSingularResourceNameCommon-1126805002",
                RequiredSingularFixed32 = 720656715,
                RequiredSingularFixed64 = 720656810,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNameOneofs = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedResourceNameCommon = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
                RequiredAnyValue = new Any(),
                RequiredStructValue = new Struct(),
                RequiredValueValue = new Value(),
                RequiredListValueValue = new ListValue(),
                RequiredTimeValue = new Timestamp(),
                RequiredDurationValue = new Duration(),
                RequiredFieldMaskValue = new FieldMask(),
                RequiredInt32Value = null,
                RequiredUint32Value = null,
                RequiredInt64Value = null,
                RequiredUint64Value = null,
                RequiredFloatValue = null,
                RequiredDoubleValue = null,
                RequiredStringValue = null,
                RequiredBoolValue = null,
                RequiredBytesValue = null,
                RequiredRepeatedAnyValue = { },
                RequiredRepeatedStructValue = { },
                RequiredRepeatedValueValue = { },
                RequiredRepeatedListValueValue = { },
                RequiredRepeatedTimeValue = { },
                RequiredRepeatedDurationValue = { },
                RequiredRepeatedFieldMaskValue = { },
                RequiredRepeatedInt32Value = { },
                RequiredRepeatedUint32Value = { },
                RequiredRepeatedInt64Value = { },
                RequiredRepeatedUint64Value = { },
                RequiredRepeatedFloatValue = { },
                RequiredRepeatedDoubleValue = { },
                RequiredRepeatedStringValue = { },
                RequiredRepeatedBoolValue = { },
                RequiredRepeatedBytesValue = { },
                OptionalSingularInt32 = 1196565723,
                OptionalSingularInt64 = 1196565628L,
                OptionalSingularFloat = -1.19939918E8f,
                OptionalSingularDouble = 1.41902287E8,
                OptionalSingularBool = false,
                OptionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                OptionalSingularString = "optionalSingularString1852995162",
                OptionalSingularBytes = ByteString.CopyFromUtf8("2"),
                OptionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                OptionalSingularResourceNameAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                OptionalSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                OptionalSingularResourceNameCommon = "optionalSingularResourceNameCommon-108123657",
                OptionalSingularFixed32 = 1648847958,
                OptionalSingularFixed64 = 1648847863,
                OptionalRepeatedInt32 = { },
                OptionalRepeatedInt64 = { },
                OptionalRepeatedFloat = { },
                OptionalRepeatedDouble = { },
                OptionalRepeatedBool = { },
                OptionalRepeatedEnum = { },
                OptionalRepeatedString = { },
                OptionalRepeatedBytes = { },
                OptionalRepeatedMessage = { },
                OptionalRepeatedResourceNameAsBookNameOneofs = { },
                OptionalRepeatedResourceNameOneofAsBookNameOneofs = { },
                OptionalRepeatedResourceNameCommon = { },
                OptionalRepeatedFixed32 = { },
                OptionalRepeatedFixed64 = { },
                OptionalMap = { },
                AnyValue = new Any(),
                StructValue = new Struct(),
                ValueValue = new Value(),
                ListValueValue = new ListValue(),
                TimeValue = new Timestamp(),
                DurationValue = new Duration(),
                FieldMaskValue = new FieldMask(),
                Int32Value = null,
                Uint32Value = null,
                Int64Value = null,
                Uint64Value = null,
                FloatValue = null,
                DoubleValue = null,
                StringValue = null,
                BoolValue = null,
                BytesValue = null,
                RepeatedAnyValue = { },
                RepeatedStructValue = { },
                RepeatedValueValue = { },
                RepeatedListValueValue = { },
                RepeatedTimeValue = { },
                RepeatedDurationValue = { },
                RepeatedFieldMaskValue = { },
                RepeatedInt32Value = { },
                RepeatedUint32Value = { },
                RepeatedInt64Value = { },
                RepeatedUint64Value = { },
                RepeatedFloatValue = { },
                RepeatedDoubleValue = { },
                RepeatedStringValue = { },
                RepeatedBoolValue = { },
                RepeatedBytesValue = { },
            };
            TestOptionalRequiredFlatteningParamsResponse expectedResponse = new TestOptionalRequiredFlatteningParamsResponse();
            mockGrpcClient.Setup(x => x.TestOptionalRequiredFlatteningParamsAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<TestOptionalRequiredFlatteningParamsResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            int requiredSingularInt32 = 72313594;
            long requiredSingularInt64 = 72313499L;
            float requiredSingularFloat = -7514705.0f;
            double requiredSingularDouble = 1.9111005E8;
            bool requiredSingularBool = true;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string requiredSingularString = "requiredSingularString-1949894503";
            ByteString requiredSingularBytes = ByteString.CopyFromUtf8("-29");
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookNameOneof requiredSingularResourceName = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            BookNameOneof requiredSingularResourceNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string requiredSingularResourceNameCommon = "requiredSingularResourceNameCommon-1126805002";
            int requiredSingularFixed32 = 720656715;
            long requiredSingularFixed64 = 720656810;
            IEnumerable<int> requiredRepeatedInt32 = new List<int>();
            IEnumerable<long> requiredRepeatedInt64 = new List<long>();
            IEnumerable<float> requiredRepeatedFloat = new List<float>();
            IEnumerable<double> requiredRepeatedDouble = new List<double>();
            IEnumerable<bool> requiredRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> requiredRepeatedString = new List<string>();
            IEnumerable<ByteString> requiredRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceName = new List<BookNameOneof>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<string> requiredRepeatedResourceNameCommon = new List<string>();
            IEnumerable<int> requiredRepeatedFixed32 = new List<int>();
            IEnumerable<long> requiredRepeatedFixed64 = new List<long>();
            IDictionary<int, string> requiredMap = new Dictionary<int, string>();
            Any requiredAnyValue = new Any();
            Struct requiredStructValue = new Struct();
            Value requiredValueValue = new Value();
            ListValue requiredListValueValue = new ListValue();
            Timestamp requiredTimeValue = new Timestamp();
            Duration requiredDurationValue = new Duration();
            FieldMask requiredFieldMaskValue = new FieldMask();
            int? requiredInt32Value = null;
            uint? requiredUint32Value = null;
            long? requiredInt64Value = null;
            ulong? requiredUint64Value = null;
            float? requiredFloatValue = null;
            double? requiredDoubleValue = null;
            string requiredStringValue = null;
            bool? requiredBoolValue = null;
            ByteString requiredBytesValue = null;
            IEnumerable<Any> requiredRepeatedAnyValue = new List<Any>();
            IEnumerable<Struct> requiredRepeatedStructValue = new List<Struct>();
            IEnumerable<Value> requiredRepeatedValueValue = new List<Value>();
            IEnumerable<ListValue> requiredRepeatedListValueValue = new List<ListValue>();
            IEnumerable<Timestamp> requiredRepeatedTimeValue = new List<Timestamp>();
            IEnumerable<Duration> requiredRepeatedDurationValue = new List<Duration>();
            IEnumerable<FieldMask> requiredRepeatedFieldMaskValue = new List<FieldMask>();
            IEnumerable<int?> requiredRepeatedInt32Value = new List<int?>();
            IEnumerable<uint?> requiredRepeatedUint32Value = new List<uint?>();
            IEnumerable<long?> requiredRepeatedInt64Value = new List<long?>();
            IEnumerable<ulong?> requiredRepeatedUint64Value = new List<ulong?>();
            IEnumerable<float?> requiredRepeatedFloatValue = new List<float?>();
            IEnumerable<double?> requiredRepeatedDoubleValue = new List<double?>();
            IEnumerable<string> requiredRepeatedStringValue = new List<string>();
            IEnumerable<bool?> requiredRepeatedBoolValue = new List<bool?>();
            IEnumerable<ByteString> requiredRepeatedBytesValue = new List<ByteString>();
            int optionalSingularInt32 = 1196565723;
            long optionalSingularInt64 = 1196565628L;
            float optionalSingularFloat = -1.19939918E8f;
            double optionalSingularDouble = 1.41902287E8;
            bool optionalSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum optionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string optionalSingularString = "optionalSingularString1852995162";
            ByteString optionalSingularBytes = ByteString.CopyFromUtf8("2");
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookNameOneof optionalSingularResourceName = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            BookNameOneof optionalSingularResourceNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string optionalSingularResourceNameCommon = "optionalSingularResourceNameCommon-108123657";
            int optionalSingularFixed32 = 1648847958;
            long optionalSingularFixed64 = 1648847863;
            IEnumerable<int> optionalRepeatedInt32 = new List<int>();
            IEnumerable<long> optionalRepeatedInt64 = new List<long>();
            IEnumerable<float> optionalRepeatedFloat = new List<float>();
            IEnumerable<double> optionalRepeatedDouble = new List<double>();
            IEnumerable<bool> optionalRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> optionalRepeatedString = new List<string>();
            IEnumerable<ByteString> optionalRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceName = new List<BookNameOneof>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<string> optionalRepeatedResourceNameCommon = new List<string>();
            IEnumerable<int> optionalRepeatedFixed32 = new List<int>();
            IEnumerable<long> optionalRepeatedFixed64 = new List<long>();
            IDictionary<int, string> optionalMap = new Dictionary<int, string>();
            Any anyValue = new Any();
            Struct structValue = new Struct();
            Value valueValue = new Value();
            ListValue listValueValue = new ListValue();
            Timestamp timeValue = new Timestamp();
            Duration durationValue = new Duration();
            FieldMask fieldMaskValue = new FieldMask();
            int? int32Value = null;
            uint? uint32Value = null;
            long? int64Value = null;
            ulong? uint64Value = null;
            float? floatValue = null;
            double? doubleValue = null;
            string stringValue = null;
            bool? boolValue = null;
            ByteString bytesValue = null;
            IEnumerable<Any> repeatedAnyValue = new List<Any>();
            IEnumerable<Struct> repeatedStructValue = new List<Struct>();
            IEnumerable<Value> repeatedValueValue = new List<Value>();
            IEnumerable<ListValue> repeatedListValueValue = new List<ListValue>();
            IEnumerable<Timestamp> repeatedTimeValue = new List<Timestamp>();
            IEnumerable<Duration> repeatedDurationValue = new List<Duration>();
            IEnumerable<FieldMask> repeatedFieldMaskValue = new List<FieldMask>();
            IEnumerable<int?> repeatedInt32Value = new List<int?>();
            IEnumerable<uint?> repeatedUint32Value = new List<uint?>();
            IEnumerable<long?> repeatedInt64Value = new List<long?>();
            IEnumerable<ulong?> repeatedUint64Value = new List<ulong?>();
            IEnumerable<float?> repeatedFloatValue = new List<float?>();
            IEnumerable<double?> repeatedDoubleValue = new List<double?>();
            IEnumerable<string> repeatedStringValue = new List<string>();
            IEnumerable<bool?> repeatedBoolValue = new List<bool?>();
            IEnumerable<ByteString> repeatedBytesValue = new List<ByteString>();
            TestOptionalRequiredFlatteningParamsResponse response = await client.TestOptionalRequiredFlatteningParamsAsync(requiredSingularInt32, requiredSingularInt64, requiredSingularFloat, requiredSingularDouble, requiredSingularBool, requiredSingularEnum, requiredSingularString, requiredSingularBytes, requiredSingularMessage, requiredSingularResourceName, requiredSingularResourceNameOneof, requiredSingularResourceNameCommon, requiredSingularFixed32, requiredSingularFixed64, requiredRepeatedInt32, requiredRepeatedInt64, requiredRepeatedFloat, requiredRepeatedDouble, requiredRepeatedBool, requiredRepeatedEnum, requiredRepeatedString, requiredRepeatedBytes, requiredRepeatedMessage, requiredRepeatedResourceName, requiredRepeatedResourceNameOneof, requiredRepeatedResourceNameCommon, requiredRepeatedFixed32, requiredRepeatedFixed64, requiredMap, requiredAnyValue, requiredStructValue, requiredValueValue, requiredListValueValue, requiredTimeValue, requiredDurationValue, requiredFieldMaskValue, requiredInt32Value, requiredUint32Value, requiredInt64Value, requiredUint64Value, requiredFloatValue, requiredDoubleValue, requiredStringValue, requiredBoolValue, requiredBytesValue, requiredRepeatedAnyValue, requiredRepeatedStructValue, requiredRepeatedValueValue, requiredRepeatedListValueValue, requiredRepeatedTimeValue, requiredRepeatedDurationValue, requiredRepeatedFieldMaskValue, requiredRepeatedInt32Value, requiredRepeatedUint32Value, requiredRepeatedInt64Value, requiredRepeatedUint64Value, requiredRepeatedFloatValue, requiredRepeatedDoubleValue, requiredRepeatedStringValue, requiredRepeatedBoolValue, requiredRepeatedBytesValue, optionalSingularInt32, optionalSingularInt64, optionalSingularFloat, optionalSingularDouble, optionalSingularBool, optionalSingularEnum, optionalSingularString, optionalSingularBytes, optionalSingularMessage, optionalSingularResourceName, optionalSingularResourceNameOneof, optionalSingularResourceNameCommon, optionalSingularFixed32, optionalSingularFixed64, optionalRepeatedInt32, optionalRepeatedInt64, optionalRepeatedFloat, optionalRepeatedDouble, optionalRepeatedBool, optionalRepeatedEnum, optionalRepeatedString, optionalRepeatedBytes, optionalRepeatedMessage, optionalRepeatedResourceName, optionalRepeatedResourceNameOneof, optionalRepeatedResourceNameCommon, optionalRepeatedFixed32, optionalRepeatedFixed64, optionalMap, anyValue, structValue, valueValue, listValueValue, timeValue, durationValue, fieldMaskValue, int32Value, uint32Value, int64Value, uint64Value, floatValue, doubleValue, stringValue, boolValue, bytesValue, repeatedAnyValue, repeatedStructValue, repeatedValueValue, repeatedListValueValue, repeatedTimeValue, repeatedDurationValue, repeatedFieldMaskValue, repeatedInt32Value, repeatedUint32Value, repeatedInt64Value, repeatedUint64Value, repeatedFloatValue, repeatedDoubleValue, repeatedStringValue, repeatedBoolValue, repeatedBytesValue);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void TestOptionalRequiredFlatteningParams3()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            TestOptionalRequiredFlatteningParamsRequest request = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 72313594,
                RequiredSingularInt64 = 72313499L,
                RequiredSingularFloat = -7514705.0f,
                RequiredSingularDouble = 1.9111005E8,
                RequiredSingularBool = true,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "requiredSingularString-1949894503",
                RequiredSingularBytes = ByteString.CopyFromUtf8("-29"),
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                RequiredSingularResourceNameCommon = "requiredSingularResourceNameCommon-1126805002",
                RequiredSingularFixed32 = 720656715,
                RequiredSingularFixed64 = 720656810,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNameOneofs = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedResourceNameCommon = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
                RequiredAnyValue = new Any(),
                RequiredStructValue = new Struct(),
                RequiredValueValue = new Value(),
                RequiredListValueValue = new ListValue(),
                RequiredTimeValue = new Timestamp(),
                RequiredDurationValue = new Duration(),
                RequiredFieldMaskValue = new FieldMask(),
                RequiredInt32Value = null,
                RequiredUint32Value = null,
                RequiredInt64Value = null,
                RequiredUint64Value = null,
                RequiredFloatValue = null,
                RequiredDoubleValue = null,
                RequiredStringValue = null,
                RequiredBoolValue = null,
                RequiredBytesValue = null,
                RequiredRepeatedAnyValue = { },
                RequiredRepeatedStructValue = { },
                RequiredRepeatedValueValue = { },
                RequiredRepeatedListValueValue = { },
                RequiredRepeatedTimeValue = { },
                RequiredRepeatedDurationValue = { },
                RequiredRepeatedFieldMaskValue = { },
                RequiredRepeatedInt32Value = { },
                RequiredRepeatedUint32Value = { },
                RequiredRepeatedInt64Value = { },
                RequiredRepeatedUint64Value = { },
                RequiredRepeatedFloatValue = { },
                RequiredRepeatedDoubleValue = { },
                RequiredRepeatedStringValue = { },
                RequiredRepeatedBoolValue = { },
                RequiredRepeatedBytesValue = { },
            };
            TestOptionalRequiredFlatteningParamsResponse expectedResponse = new TestOptionalRequiredFlatteningParamsResponse();
            mockGrpcClient.Setup(x => x.TestOptionalRequiredFlatteningParams(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            TestOptionalRequiredFlatteningParamsResponse response = client.TestOptionalRequiredFlatteningParams(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task TestOptionalRequiredFlatteningParamsAsync3()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            TestOptionalRequiredFlatteningParamsRequest request = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 72313594,
                RequiredSingularInt64 = 72313499L,
                RequiredSingularFloat = -7514705.0f,
                RequiredSingularDouble = 1.9111005E8,
                RequiredSingularBool = true,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "requiredSingularString-1949894503",
                RequiredSingularBytes = ByteString.CopyFromUtf8("-29"),
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                RequiredSingularResourceNameCommon = "requiredSingularResourceNameCommon-1126805002",
                RequiredSingularFixed32 = 720656715,
                RequiredSingularFixed64 = 720656810,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNameOneofs = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedResourceNameCommon = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
                RequiredAnyValue = new Any(),
                RequiredStructValue = new Struct(),
                RequiredValueValue = new Value(),
                RequiredListValueValue = new ListValue(),
                RequiredTimeValue = new Timestamp(),
                RequiredDurationValue = new Duration(),
                RequiredFieldMaskValue = new FieldMask(),
                RequiredInt32Value = null,
                RequiredUint32Value = null,
                RequiredInt64Value = null,
                RequiredUint64Value = null,
                RequiredFloatValue = null,
                RequiredDoubleValue = null,
                RequiredStringValue = null,
                RequiredBoolValue = null,
                RequiredBytesValue = null,
                RequiredRepeatedAnyValue = { },
                RequiredRepeatedStructValue = { },
                RequiredRepeatedValueValue = { },
                RequiredRepeatedListValueValue = { },
                RequiredRepeatedTimeValue = { },
                RequiredRepeatedDurationValue = { },
                RequiredRepeatedFieldMaskValue = { },
                RequiredRepeatedInt32Value = { },
                RequiredRepeatedUint32Value = { },
                RequiredRepeatedInt64Value = { },
                RequiredRepeatedUint64Value = { },
                RequiredRepeatedFloatValue = { },
                RequiredRepeatedDoubleValue = { },
                RequiredRepeatedStringValue = { },
                RequiredRepeatedBoolValue = { },
                RequiredRepeatedBytesValue = { },
            };
            TestOptionalRequiredFlatteningParamsResponse expectedResponse = new TestOptionalRequiredFlatteningParamsResponse();
            mockGrpcClient.Setup(x => x.TestOptionalRequiredFlatteningParamsAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<TestOptionalRequiredFlatteningParamsResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            TestOptionalRequiredFlatteningParamsResponse response = await client.TestOptionalRequiredFlatteningParamsAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void ListAggregatedShelves()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            ListAggregatedShelvesRequest expectedRequest = new ListAggregatedShelvesRequest();
            ListAggregatedShelvesResponse expectedResponse = new ListAggregatedShelvesResponse
            {
                NextPageToken = "nextPageToken-1530815211",
            };
            mockGrpcClient.Setup(x => x.ListAggregatedShelves(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);

            ListAggregatedShelvesResponse response = client.ListAggregatedShelves();
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task ListAggregatedShelvesAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            ListAggregatedShelvesRequest expectedRequest = new ListAggregatedShelvesRequest();
            ListAggregatedShelvesResponse expectedResponse = new ListAggregatedShelvesResponse
            {
                NextPageToken = "nextPageToken-1530815211",
            };
            mockGrpcClient.Setup(x => x.ListAggregatedShelvesAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<ListAggregatedShelvesResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);

            ListAggregatedShelvesResponse response = await client.ListAggregatedShelvesAsync();
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void ListAggregatedShelves2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            ListAggregatedShelvesRequest request = new ListAggregatedShelvesRequest();
            ListAggregatedShelvesResponse expectedResponse = new ListAggregatedShelvesResponse
            {
                NextPageToken = "nextPageToken-1530815211",
            };
            mockGrpcClient.Setup(x => x.ListAggregatedShelves(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ListAggregatedShelvesResponse response = client.ListAggregatedShelves(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task ListAggregatedShelvesAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            ListAggregatedShelvesRequest request = new ListAggregatedShelvesRequest();
            ListAggregatedShelvesResponse expectedResponse = new ListAggregatedShelvesResponse
            {
                NextPageToken = "nextPageToken-1530815211",
            };
            mockGrpcClient.Setup(x => x.ListAggregatedShelvesAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<ListAggregatedShelvesResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ListAggregatedShelvesResponse response = await client.ListAggregatedShelvesAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void CreateInventory()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateInventoryRequest expectedRequest = new CreateInventoryRequest
            {
                ParentAsPublisherName = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]"),
                Inventory = new Inventory(),
                AssetAsResourceName = new ArchiveName("[ARCHIVE]"),
                ParentAssetAsResourceName = new ArchiveName("[ARCHIVE]"),
                AssetsAsResourceNames = { },
            };
            Inventory expectedResponse = new Inventory
            {
                InventoryName = new InventoryName("[PROJECT]", "[LOCATION]", "[PUBLISHER]"),
            };
            mockGrpcClient.Setup(x => x.CreateInventory(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            PublisherName parent = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]");
            Inventory inventory = new Inventory();
            IResourceName asset = new ArchiveName("[ARCHIVE]");
            IResourceName parentAsset = new ArchiveName("[ARCHIVE]");
            IEnumerable<IResourceName> assets = new List<IResourceName>();
            Inventory response = client.CreateInventory(parent, inventory, asset, parentAsset, assets);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task CreateInventoryAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateInventoryRequest expectedRequest = new CreateInventoryRequest
            {
                ParentAsPublisherName = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]"),
                Inventory = new Inventory(),
                AssetAsResourceName = new ArchiveName("[ARCHIVE]"),
                ParentAssetAsResourceName = new ArchiveName("[ARCHIVE]"),
                AssetsAsResourceNames = { },
            };
            Inventory expectedResponse = new Inventory
            {
                InventoryName = new InventoryName("[PROJECT]", "[LOCATION]", "[PUBLISHER]"),
            };
            mockGrpcClient.Setup(x => x.CreateInventoryAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Inventory>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            PublisherName parent = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]");
            Inventory inventory = new Inventory();
            IResourceName asset = new ArchiveName("[ARCHIVE]");
            IResourceName parentAsset = new ArchiveName("[ARCHIVE]");
            IEnumerable<IResourceName> assets = new List<IResourceName>();
            Inventory response = await client.CreateInventoryAsync(parent, inventory, asset, parentAsset, assets);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void CreateInventory2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateInventoryRequest request = new CreateInventoryRequest
            {
                ParentAsPublisherName = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]"),
                AssetAsResourceName = new ArchiveName("[ARCHIVE]"),
                ParentAssetAsResourceName = new ArchiveName("[ARCHIVE]"),
                AssetsAsResourceNames = { },
            };
            Inventory expectedResponse = new Inventory
            {
                InventoryName = new InventoryName("[PROJECT]", "[LOCATION]", "[PUBLISHER]"),
            };
            mockGrpcClient.Setup(x => x.CreateInventory(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Inventory response = client.CreateInventory(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task CreateInventoryAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateInventoryRequest request = new CreateInventoryRequest
            {
                ParentAsPublisherName = new PublisherName("[PROJECT]", "[LOCATION]", "[PUBLISHER]"),
                AssetAsResourceName = new ArchiveName("[ARCHIVE]"),
                ParentAssetAsResourceName = new ArchiveName("[ARCHIVE]"),
                AssetsAsResourceNames = { },
            };
            Inventory expectedResponse = new Inventory
            {
                InventoryName = new InventoryName("[PROJECT]", "[LOCATION]", "[PUBLISHER]"),
            };
            mockGrpcClient.Setup(x => x.CreateInventoryAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Inventory>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Inventory response = await client.CreateInventoryAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void MoveBooks()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MoveBooksRequest expectedRequest = new MoveBooksRequest
            {
                SourceAsArchiveName = new ArchiveName("[ARCHIVE]"),
                DestinationAsArchiveName = new ArchiveName("[ARCHIVE]"),
                PublishersAsPublisherNames = { },
                ProjectAsProjectName = new ProjectName("[PROJECT]"),
            };
            MoveBooksResponse expectedResponse = new MoveBooksResponse
            {
                Success = false,
            };
            mockGrpcClient.Setup(x => x.MoveBooks(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ArchiveName source = new ArchiveName("[ARCHIVE]");
            ArchiveName destination = new ArchiveName("[ARCHIVE]");
            IEnumerable<PublisherName> publishers = new List<PublisherName>();
            ProjectName project = new ProjectName("[PROJECT]");
            MoveBooksResponse response = client.MoveBooks(source, destination, publishers, project);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task MoveBooksAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MoveBooksRequest expectedRequest = new MoveBooksRequest
            {
                SourceAsArchiveName = new ArchiveName("[ARCHIVE]"),
                DestinationAsArchiveName = new ArchiveName("[ARCHIVE]"),
                PublishersAsPublisherNames = { },
                ProjectAsProjectName = new ProjectName("[PROJECT]"),
            };
            MoveBooksResponse expectedResponse = new MoveBooksResponse
            {
                Success = false,
            };
            mockGrpcClient.Setup(x => x.MoveBooksAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<MoveBooksResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ArchiveName source = new ArchiveName("[ARCHIVE]");
            ArchiveName destination = new ArchiveName("[ARCHIVE]");
            IEnumerable<PublisherName> publishers = new List<PublisherName>();
            ProjectName project = new ProjectName("[PROJECT]");
            MoveBooksResponse response = await client.MoveBooksAsync(source, destination, publishers, project);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void MoveBooks2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MoveBooksRequest request = new MoveBooksRequest();
            MoveBooksResponse expectedResponse = new MoveBooksResponse
            {
                Success = false,
            };
            mockGrpcClient.Setup(x => x.MoveBooks(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            MoveBooksResponse response = client.MoveBooks(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task MoveBooksAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MoveBooksRequest request = new MoveBooksRequest();
            MoveBooksResponse expectedResponse = new MoveBooksResponse
            {
                Success = false,
            };
            mockGrpcClient.Setup(x => x.MoveBooksAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<MoveBooksResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            MoveBooksResponse response = await client.MoveBooksAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void ArchiveBooks()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            ArchiveBooksRequest expectedRequest = new ArchiveBooksRequest
            {
                SourceAsArchiveName = new ArchiveName("[ARCHIVE]"),
                ArchiveAsArchiveName = new ArchiveName("[ARCHIVE]"),
            };
            ArchiveBooksResponse expectedResponse = new ArchiveBooksResponse
            {
                Success = false,
            };
            mockGrpcClient.Setup(x => x.ArchiveBooks(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ArchiveName source = new ArchiveName("[ARCHIVE]");
            ArchiveName archive = new ArchiveName("[ARCHIVE]");
            ArchiveBooksResponse response = client.ArchiveBooks(source, archive);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task ArchiveBooksAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            ArchiveBooksRequest expectedRequest = new ArchiveBooksRequest
            {
                SourceAsArchiveName = new ArchiveName("[ARCHIVE]"),
                ArchiveAsArchiveName = new ArchiveName("[ARCHIVE]"),
            };
            ArchiveBooksResponse expectedResponse = new ArchiveBooksResponse
            {
                Success = false,
            };
            mockGrpcClient.Setup(x => x.ArchiveBooksAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<ArchiveBooksResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ArchiveName source = new ArchiveName("[ARCHIVE]");
            ArchiveName archive = new ArchiveName("[ARCHIVE]");
            ArchiveBooksResponse response = await client.ArchiveBooksAsync(source, archive);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void ArchiveBooks2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            ArchiveBooksRequest request = new ArchiveBooksRequest();
            ArchiveBooksResponse expectedResponse = new ArchiveBooksResponse
            {
                Success = false,
            };
            mockGrpcClient.Setup(x => x.ArchiveBooks(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ArchiveBooksResponse response = client.ArchiveBooks(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task ArchiveBooksAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            ArchiveBooksRequest request = new ArchiveBooksRequest();
            ArchiveBooksResponse expectedResponse = new ArchiveBooksResponse
            {
                Success = false,
            };
            mockGrpcClient.Setup(x => x.ArchiveBooksAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<ArchiveBooksResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ArchiveBooksResponse response = await client.ArchiveBooksAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void SaveBook()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            Book expectedRequest = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Rating = Book.Types.Rating.Good,
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.SaveBook(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string author = "author-1406328437";
            string title = "title110371416";
            Book.Types.Rating rating = Book.Types.Rating.Good;
            client.SaveBook(name, author, title, rating);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task SaveBookAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            Book expectedRequest = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Rating = Book.Types.Rating.Good,
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.SaveBookAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]"));
            string author = "author-1406328437";
            string title = "title110371416";
            Book.Types.Rating rating = Book.Types.Rating.Good;
            await client.SaveBookAsync(name, author, title, rating);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void SaveBook2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            Book request = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.SaveBook(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            client.SaveBook(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task SaveBookAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            Book request = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.SaveBookAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            await client.SaveBookAsync(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void PrivateListShelves()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            ListShelvesRequest expectedRequest = new ListShelvesRequest();
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.PrivateListShelves(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);

            Book response = client.PrivateListShelves();
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task PrivateListShelvesAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            ListShelvesRequest expectedRequest = new ListShelvesRequest();
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.PrivateListShelvesAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);

            Book response = await client.PrivateListShelvesAsync();
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void PrivateListShelves2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            ListShelvesRequest request = new ListShelvesRequest();
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.PrivateListShelves(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = client.PrivateListShelves(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task PrivateListShelvesAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            ListShelvesRequest request = new ListShelvesRequest();
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookFromArchiveName("[ARCHIVE]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
                ReaderAsReaderNameOneof = "reader-934979389",
            };
            mockGrpcClient.Setup(x => x.PrivateListShelvesAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = await client.PrivateListShelvesAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Tests/MyProtoClientTest.g.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

namespace Google.Example.Library.V1.Tests
{
    using Google.Api.Gax;
    using Google.Api.Gax.Grpc;
    using apis = Google.Example.Library.V1;
    using Google.Protobuf.WellKnownTypes;
    using Grpc.Core;
    using Moq;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Threading;
    using System.Threading.Tasks;
    using Xunit;

    /// <summary>Generated unit tests</summary>
    public class GeneratedMyProtoClientTest
    {
        [Fact]
        public void MyMethod()
        {
            Mock<MyProto.MyProtoClient> mockGrpcClient = new Mock<MyProto.MyProtoClient>(MockBehavior.Strict);
            MethodRequest request = new MethodRequest();
            MethodResponse expectedResponse = new MethodResponse
            {
                Myfield = "myfield1515208398",
            };
            mockGrpcClient.Setup(x => x.MyMethod(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            MyProtoClient client = new MyProtoClientImpl(mockGrpcClient.Object, null);
            MethodResponse response = client.MyMethod(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task MyMethodAsync()
        {
            Mock<MyProto.MyProtoClient> mockGrpcClient = new Mock<MyProto.MyProtoClient>(MockBehavior.Strict);
            MethodRequest request = new MethodRequest();
            MethodResponse expectedResponse = new MethodResponse
            {
                Myfield = "myfield1515208398",
            };
            mockGrpcClient.Setup(x => x.MyMethodAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<MethodResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            MyProtoClient client = new MyProtoClientImpl(mockGrpcClient.Object, null);
            MethodResponse response = await client.MyMethodAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetNamespace()
        {
            Mock<MyProto.MyProtoClient> mockGrpcClient = new Mock<MyProto.MyProtoClient>(MockBehavior.Strict);
            MethodRequest request = new MethodRequest();
            Namespace expectedResponse = new Namespace
            {
                Value = "value111972721",
            };
            mockGrpcClient.Setup(x => x.GetNamespace(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            MyProtoClient client = new MyProtoClientImpl(mockGrpcClient.Object, null);
            Namespace response = client.GetNamespace(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetNamespaceAsync()
        {
            Mock<MyProto.MyProtoClient> mockGrpcClient = new Mock<MyProto.MyProtoClient>(MockBehavior.Strict);
            MethodRequest request = new MethodRequest();
            Namespace expectedResponse = new Namespace
            {
                Value = "value111972721",
            };
            mockGrpcClient.Setup(x => x.GetNamespaceAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Namespace>(Task.FromResult(expectedResponse), null, null, null, null));
            MyProtoClient client = new MyProtoClientImpl(mockGrpcClient.Object, null);
            Namespace response = await client.GetNamespaceAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1/Google.Example.Library.V1.csproj ==============
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>

    <!-- TODO: Version defaults to 1.0.0, edit as required -->
    <Version>1.0.0</Version>

    <!-- TODO: NuGet packaging options -->
    <!--
      <Description>
        Google Example Library API
        A simple Google Example Library API.
      </Description>
      <PackageTags>PubSub;Google;Cloud</PackageTags>
      <Copyright>Copyright 2020 Google LLC</Copyright>
      <Authors>Google LLC</Authors>
      *** TODO: These Icon, License, Project, and repo settings *MUST* be checked and edited ***
      *** The values given are just examples ***
      <PackageIconUrl>TODO: https://cloud.google.com/images/gcp-icon-64x64.png</PackageIconUrl>
      <PackageLicenseUrl>TODO: https://www.apache.org/licenses/LICENSE-2.0</PackageLicenseUrl>
      <PackageProjectUrl>TODO: https://github.com/GoogleCloudPlatform/google-cloud-dotnet</PackageProjectUrl>
      <RepositoryType>TODO: git</RepositoryType>
      <RepositoryUrl>TODO: https://github.com/GoogleCloudPlatform/google-cloud-dotnet</RepositoryUrl>
    -->

    <!-- TODO: Configure package signing -->
    <!--
      <AssemblyOriginatorKeyFile>...</AssemblyOriginatorKeyFile>
      <SignAssembly>true</SignAssembly>
      <PublicSign Condition=" '$(OS)' != 'Windows_NT' ">true</PublicSign>
    -->

    <!-- These items should not require editing -->
    <TargetFrameworks>netstandard1.5;net45</TargetFrameworks>
    <TargetFrameworks Condition=" '$(OS)' != 'Windows_NT' ">netstandard1.5</TargetFrameworks>
    <LangVersion>latest</LangVersion>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <Deterministic>true</Deterministic>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>

  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Google.Api.Gax.Grpc" Version="2.1.0" />
    <PackageReference Include="Grpc.Core" Version="1.6.1" />
  </ItemGroup>

</Project>

============== file: Google.Example.Library.V1/Google.Example.Library.V1/LibraryServiceClient.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

using gax = Google.Api.Gax;
using gaxgrpc = Google.Api.Gax.Grpc;
using gctv = Google.Cloud.Tagger.V1;
using lro = Google.LongRunning;
using pb = Google.Protobuf;
using pbwkt = Google.Protobuf.WellKnownTypes;
using gtv = Google.Tagger.V1;
using grpccore = Grpc.Core;
using sys = System;
using sc = System.Collections;
using scg = System.Collections.Generic;
using sco = System.Collections.ObjectModel;
using linq = System.Linq;
using st = System.Threading;
using stt = System.Threading.Tasks;

namespace Google.Example.Library.V1
{
    /// <summary>
    /// Settings for a <see cref="LibraryServiceClient"/>.
    /// </summary>
    public sealed partial class LibraryServiceSettings : gaxgrpc::ServiceSettingsBase
    {
        /// <summary>
        /// Get a new instance of the default <see cref="LibraryServiceSettings"/>.
        /// </summary>
        /// <returns>
        /// A new instance of the default <see cref="LibraryServiceSettings"/>.
        /// </returns>
        public static LibraryServiceSettings GetDefault() => new LibraryServiceSettings();

        /// <summary>
        /// Constructs a new <see cref="LibraryServiceSettings"/> object with default settings.
        /// </summary>
        public LibraryServiceSettings() { }

        private LibraryServiceSettings(LibraryServiceSettings existing) : base(existing)
        {
            gax::GaxPreconditions.CheckNotNull(existing, nameof(existing));
            CreateShelfSettings = existing.CreateShelfSettings;
            GetShelfSettings = existing.GetShelfSettings;
            ListShelvesSettings = existing.ListShelvesSettings;
            DeleteShelfSettings = existing.DeleteShelfSettings;
            MergeShelvesSettings = existing.MergeShelvesSettings;
            CreateBookSettings = existing.CreateBookSettings;
            PublishSeriesSettings = existing.PublishSeriesSettings;
            GetBookSettings = existing.GetBookSettings;
            ListBooksSettings = existing.ListBooksSettings;
            DeleteBookSettings = existing.DeleteBookSettings;
            UpdateBookSettings = existing.UpdateBookSettings;
            MoveBookSettings = existing.MoveBookSettings;
            ListStringsSettings = existing.ListStringsSettings;
            AddCommentsSettings = existing.AddCommentsSettings;
            GetBookFromArchiveSettings = existing.GetBookFromArchiveSettings;
            GetBookFromAnywhereSettings = existing.GetBookFromAnywhereSettings;
            GetBookFromAbsolutelyAnywhereSettings = existing.GetBookFromAbsolutelyAnywhereSettings;
            UpdateBookIndexSettings = existing.UpdateBookIndexSettings;
            StreamShelvesSettings = existing.StreamShelvesSettings;
            StreamBooksSettings = existing.StreamBooksSettings;
            DiscussBookSettings = existing.DiscussBookSettings;
            DiscussBookStreamingSettings = existing.DiscussBookStreamingSettings;
            FindRelatedBooksSettings = existing.FindRelatedBooksSettings;
            AddLabelSettings = existing.AddLabelSettings;
            GetBigBookSettings = existing.GetBigBookSettings;
            GetBigBookOperationsSettings = existing.GetBigBookOperationsSettings?.Clone();
            GetBigNothingSettings = existing.GetBigNothingSettings;
            GetBigNothingOperationsSettings = existing.GetBigNothingOperationsSettings?.Clone();
            TestOptionalRequiredFlatteningParamsSettings = existing.TestOptionalRequiredFlatteningParamsSettings;
            ListAggregatedShelvesSettings = existing.ListAggregatedShelvesSettings;
            CreateInventorySettings = existing.CreateInventorySettings;
            MoveBooksSettings = existing.MoveBooksSettings;
            ArchiveBooksSettings = existing.ArchiveBooksSettings;
            LongRunningArchiveBooksSettings = existing.LongRunningArchiveBooksSettings;
            LongRunningArchiveBooksOperationsSettings = existing.LongRunningArchiveBooksOperationsSettings?.Clone();
            StreamingArchiveBooksSettings = existing.StreamingArchiveBooksSettings;
            StreamingArchiveBooksStreamingSettings = existing.StreamingArchiveBooksStreamingSettings;
            SaveBookSettings = existing.SaveBookSettings;
            PrivateListShelvesSettings = existing.PrivateListShelvesSettings;
            OnCopy(existing);
        }

        partial void OnCopy(LibraryServiceSettings existing);

        /// <summary>
        /// The filter specifying which RPC <see cref="grpccore::StatusCode"/>s are eligible for retry
        /// for "Idempotent" <see cref="LibraryServiceClient"/> RPC methods.
        /// </summary>
        /// <remarks>
        /// The eligible RPC <see cref="grpccore::StatusCode"/>s for retry for "Idempotent" RPC methods are:
        /// <list type="bullet">
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// </remarks>
        public static sys::Predicate<grpccore::RpcException> IdempotentRetryFilter { get; } =
            gaxgrpc::RetrySettings.FilterForStatusCodes(grpccore::StatusCode.DeadlineExceeded, grpccore::StatusCode.Unavailable);

        /// <summary>
        /// The filter specifying which RPC <see cref="grpccore::StatusCode"/>s are eligible for retry
        /// for "NonIdempotent" <see cref="LibraryServiceClient"/> RPC methods.
        /// </summary>
        /// <remarks>
        /// There are no RPC <see cref="grpccore::StatusCode"/>s eligible for retry for "NonIdempotent" RPC methods.
        /// </remarks>
        public static sys::Predicate<grpccore::RpcException> NonIdempotentRetryFilter { get; } =
            gaxgrpc::RetrySettings.FilterForStatusCodes();

        /// <summary>
        /// "Default" retry backoff for <see cref="LibraryServiceClient"/> RPC methods.
        /// </summary>
        /// <returns>
        /// The "Default" retry backoff for <see cref="LibraryServiceClient"/> RPC methods.
        /// </returns>
        /// <remarks>
        /// The "Default" retry backoff for <see cref="LibraryServiceClient"/> RPC methods is defined as:
        /// <list type="bullet">
        /// <item><description>Initial delay: 100 milliseconds</description></item>
        /// <item><description>Maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Delay multiplier: 1.2</description></item>
        /// </list>
        /// </remarks>
        public static gaxgrpc::BackoffSettings GetDefaultRetryBackoff() => new gaxgrpc::BackoffSettings(
            delay: sys::TimeSpan.FromMilliseconds(100),
            maxDelay: sys::TimeSpan.FromMilliseconds(1000),
            delayMultiplier: 1.2
        );

        /// <summary>
        /// "Default" timeout backoff for <see cref="LibraryServiceClient"/> RPC methods.
        /// </summary>
        /// <returns>
        /// The "Default" timeout backoff for <see cref="LibraryServiceClient"/> RPC methods.
        /// </returns>
        /// <remarks>
        /// The "Default" timeout backoff for <see cref="LibraryServiceClient"/> RPC methods is defined as:
        /// <list type="bullet">
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Maximum timeout: 3000 milliseconds</description></item>
        /// </list>
        /// </remarks>
        public static gaxgrpc::BackoffSettings GetDefaultTimeoutBackoff() => new gaxgrpc::BackoffSettings(
            delay: sys::TimeSpan.FromMilliseconds(300),
            maxDelay: sys::TimeSpan.FromMilliseconds(3000),
            delayMultiplier: 1.3
        );

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.CreateShelf</c> and <c>LibraryServiceClient.CreateShelfAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.CreateShelf</c> and
        /// <c>LibraryServiceClient.CreateShelfAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings CreateShelfSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetShelf</c> and <c>LibraryServiceClient.GetShelfAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetShelf</c> and
        /// <c>LibraryServiceClient.GetShelfAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetShelfSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.ListShelves</c> and <c>LibraryServiceClient.ListShelvesAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.ListShelves</c> and
        /// <c>LibraryServiceClient.ListShelvesAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings ListShelvesSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.DeleteShelf</c> and <c>LibraryServiceClient.DeleteShelfAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.DeleteShelf</c> and
        /// <c>LibraryServiceClient.DeleteShelfAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings DeleteShelfSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.MergeShelves</c> and <c>LibraryServiceClient.MergeShelvesAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.MergeShelves</c> and
        /// <c>LibraryServiceClient.MergeShelvesAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings MergeShelvesSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.CreateBook</c> and <c>LibraryServiceClient.CreateBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.CreateBook</c> and
        /// <c>LibraryServiceClient.CreateBookAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings CreateBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.PublishSeries</c> and <c>LibraryServiceClient.PublishSeriesAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.PublishSeries</c> and
        /// <c>LibraryServiceClient.PublishSeriesAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings PublishSeriesSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBook</c> and <c>LibraryServiceClient.GetBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBook</c> and
        /// <c>LibraryServiceClient.GetBookAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.ListBooks</c> and <c>LibraryServiceClient.ListBooksAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.ListBooks</c> and
        /// <c>LibraryServiceClient.ListBooksAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings ListBooksSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.DeleteBook</c> and <c>LibraryServiceClient.DeleteBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.DeleteBook</c> and
        /// <c>LibraryServiceClient.DeleteBookAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings DeleteBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.UpdateBook</c> and <c>LibraryServiceClient.UpdateBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.UpdateBook</c> and
        /// <c>LibraryServiceClient.UpdateBookAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings UpdateBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.MoveBook</c> and <c>LibraryServiceClient.MoveBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.MoveBook</c> and
        /// <c>LibraryServiceClient.MoveBookAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings MoveBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.ListStrings</c> and <c>LibraryServiceClient.ListStringsAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.ListStrings</c> and
        /// <c>LibraryServiceClient.ListStringsAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings ListStringsSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.AddComments</c> and <c>LibraryServiceClient.AddCommentsAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.AddComments</c> and
        /// <c>LibraryServiceClient.AddCommentsAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings AddCommentsSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBookFromArchive</c> and <c>LibraryServiceClient.GetBookFromArchiveAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBookFromArchive</c> and
        /// <c>LibraryServiceClient.GetBookFromArchiveAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetBookFromArchiveSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBookFromAnywhere</c> and <c>LibraryServiceClient.GetBookFromAnywhereAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBookFromAnywhere</c> and
        /// <c>LibraryServiceClient.GetBookFromAnywhereAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetBookFromAnywhereSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBookFromAbsolutelyAnywhere</c> and <c>LibraryServiceClient.GetBookFromAbsolutelyAnywhereAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBookFromAbsolutelyAnywhere</c> and
        /// <c>LibraryServiceClient.GetBookFromAbsolutelyAnywhereAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetBookFromAbsolutelyAnywhereSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.UpdateBookIndex</c> and <c>LibraryServiceClient.UpdateBookIndexAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.UpdateBookIndex</c> and
        /// <c>LibraryServiceClient.UpdateBookIndexAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings UpdateBookIndexSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for calls to <c>LibraryServiceClient.StreamShelves</c>.
        /// </summary>
        /// <remarks>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings StreamShelvesSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for calls to <c>LibraryServiceClient.StreamBooks</c>.
        /// </summary>
        /// <remarks>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings StreamBooksSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for calls to <c>LibraryServiceClient.DiscussBook</c>.
        /// </summary>
        /// <remarks>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings DiscussBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)));

        /// <summary>
        /// <see cref="gaxgrpc::BidirectionalStreamingSettings"/> for calls to
        /// <c>LibraryServiceClient.DiscussBook</c>.
        /// </summary>
        /// <remarks>
        /// The default local send queue size is 100.
        /// </remarks>
        public gaxgrpc::BidirectionalStreamingSettings DiscussBookStreamingSettings { get; set; } =
            new gaxgrpc::BidirectionalStreamingSettings(100);

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.FindRelatedBooks</c> and <c>LibraryServiceClient.FindRelatedBooksAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.FindRelatedBooks</c> and
        /// <c>LibraryServiceClient.FindRelatedBooksAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings FindRelatedBooksSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.AddLabel</c> and <c>LibraryServiceClient.AddLabelAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.AddLabel</c> and
        /// <c>LibraryServiceClient.AddLabelAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings AddLabelSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBigBook</c> and <c>LibraryServiceClient.GetBigBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBigBook</c> and
        /// <c>LibraryServiceClient.GetBigBookAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetBigBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// Long Running Operation settings for calls to <c>LibraryServiceClient.GetBigBook</c>.
        /// </summary>
        /// <remarks>
        /// Uses default <see cref="gax::PollSettings"/> of:
        /// <list type="bullet">
        /// <item><description>Initial delay: 3000 milliseconds</description></item>
        /// <item><description>Delay multiplier: 1.3</description></item>
        /// <item><description>Maximum delay: 30000 milliseconds</description></item>
        /// <item><description>Total timeout: 86400000 milliseconds</description></item>
        /// </list>
        /// </remarks>
        public lro::OperationsSettings GetBigBookOperationsSettings { get; set; } = new lro::OperationsSettings
        {
            DefaultPollSettings = new gax::PollSettings(
                gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(86400000L)),
                sys::TimeSpan.FromMilliseconds(3000L),
                1.3,
                sys::TimeSpan.FromMilliseconds(30000L))
        };

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBigNothing</c> and <c>LibraryServiceClient.GetBigNothingAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBigNothing</c> and
        /// <c>LibraryServiceClient.GetBigNothingAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetBigNothingSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// Long Running Operation settings for calls to <c>LibraryServiceClient.GetBigNothing</c>.
        /// </summary>
        /// <remarks>
        /// Uses default <see cref="gax::PollSettings"/> of:
        /// <list type="bullet">
        /// <item><description>Initial delay: 3000 milliseconds</description></item>
        /// <item><description>Delay multiplier: 1.3</description></item>
        /// <item><description>Maximum delay: 60000 milliseconds</description></item>
        /// <item><description>Total timeout: 600000 milliseconds</description></item>
        /// </list>
        /// </remarks>
        public lro::OperationsSettings GetBigNothingOperationsSettings { get; set; } = new lro::OperationsSettings
        {
            DefaultPollSettings = new gax::PollSettings(
                gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(600000L)),
                sys::TimeSpan.FromMilliseconds(3000L),
                1.3,
                sys::TimeSpan.FromMilliseconds(60000L))
        };

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.TestOptionalRequiredFlatteningParams</c> and <c>LibraryServiceClient.TestOptionalRequiredFlatteningParamsAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.TestOptionalRequiredFlatteningParams</c> and
        /// <c>LibraryServiceClient.TestOptionalRequiredFlatteningParamsAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings TestOptionalRequiredFlatteningParamsSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.ListAggregatedShelves</c> and <c>LibraryServiceClient.ListAggregatedShelvesAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.ListAggregatedShelves</c> and
        /// <c>LibraryServiceClient.ListAggregatedShelvesAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings ListAggregatedShelvesSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.CreateInventory</c> and <c>LibraryServiceClient.CreateInventoryAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.CreateInventory</c> and
        /// <c>LibraryServiceClient.CreateInventoryAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings CreateInventorySettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.MoveBooks</c> and <c>LibraryServiceClient.MoveBooksAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.MoveBooks</c> and
        /// <c>LibraryServiceClient.MoveBooksAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings MoveBooksSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.ArchiveBooks</c> and <c>LibraryServiceClient.ArchiveBooksAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.ArchiveBooks</c> and
        /// <c>LibraryServiceClient.ArchiveBooksAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings ArchiveBooksSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.LongRunningArchiveBooks</c> and <c>LibraryServiceClient.LongRunningArchiveBooksAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.LongRunningArchiveBooks</c> and
        /// <c>LibraryServiceClient.LongRunningArchiveBooksAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings LongRunningArchiveBooksSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// Long Running Operation settings for calls to <c>LibraryServiceClient.LongRunningArchiveBooks</c>.
        /// </summary>
        /// <remarks>
        /// Uses default <see cref="gax::PollSettings"/> of:
        /// <list type="bullet">
        /// <item><description>Initial delay: 500 milliseconds</description></item>
        /// <item><description>Delay multiplier: 1.5</description></item>
        /// <item><description>Maximum delay: 5000 milliseconds</description></item>
        /// <item><description>Total timeout: 300000 milliseconds</description></item>
        /// </list>
        /// </remarks>
        public lro::OperationsSettings LongRunningArchiveBooksOperationsSettings { get; set; } = new lro::OperationsSettings
        {
            DefaultPollSettings = new gax::PollSettings(
                gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(300000L)),
                sys::TimeSpan.FromMilliseconds(500L),
                1.5,
                sys::TimeSpan.FromMilliseconds(5000L))
        };

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for calls to <c>LibraryServiceClient.StreamingArchiveBooks</c>.
        /// </summary>
        /// <remarks>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings StreamingArchiveBooksSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)));

        /// <summary>
        /// <see cref="gaxgrpc::BidirectionalStreamingSettings"/> for calls to
        /// <c>LibraryServiceClient.StreamingArchiveBooks</c>.
        /// </summary>
        /// <remarks>
        /// The default local send queue size is 100.
        /// </remarks>
        public gaxgrpc::BidirectionalStreamingSettings StreamingArchiveBooksStreamingSettings { get; set; } =
            new gaxgrpc::BidirectionalStreamingSettings(100);

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.SaveBook</c> and <c>LibraryServiceClient.SaveBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.SaveBook</c> and
        /// <c>LibraryServiceClient.SaveBookAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings SaveBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.PrivateListShelves</c> and <c>LibraryServiceClient.PrivateListShelvesAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.PrivateListShelves</c> and
        /// <c>LibraryServiceClient.PrivateListShelvesAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings PrivateListShelvesSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// Creates a deep clone of this object, with all the same property values.
        /// </summary>
        /// <returns>A deep clone of this <see cref="LibraryServiceSettings"/> object.</returns>
        public LibraryServiceSettings Clone() => new LibraryServiceSettings(this);
    }

    /// <summary>
    /// Builder class for <see cref="LibraryServiceClient"/> to provide simple configuration of credentials, endpoint etc.
    /// </summary>
    public sealed partial class LibraryServiceClientBuilder : gaxgrpc::ClientBuilderBase<LibraryServiceClient>
    {
        /// <summary>
        /// The settings to use for RPCs, or null for the default settings.
        /// </summary>
        public LibraryServiceSettings Settings { get; set; }

        /// <inheritdoc/>
        public override LibraryServiceClient Build()
        {
            Validate();
            grpccore::CallInvoker callInvoker = CreateCallInvoker();
            return LibraryServiceClient.Create(callInvoker, Settings);
        }

        /// <inheritdoc />
        public override async stt::Task<LibraryServiceClient> BuildAsync(st::CancellationToken cancellationToken = default)
        {
            Validate();
            grpccore::CallInvoker callInvoker = await CreateCallInvokerAsync(cancellationToken).ConfigureAwait(false);
            return LibraryServiceClient.Create(callInvoker, Settings);
        }

        /// <inheritdoc />
        protected override gaxgrpc::ServiceEndpoint GetDefaultEndpoint() => LibraryServiceClient.DefaultEndpoint;

        /// <inheritdoc />
        protected override scg::IReadOnlyList<string> GetDefaultScopes() => LibraryServiceClient.DefaultScopes;

        /// <inheritdoc />
        protected override gaxgrpc::ChannelPool GetChannelPool() => LibraryServiceClient.ChannelPool;
    }

    /// <summary>
    /// LibraryService client wrapper, for convenient use.
    /// </summary>
    public abstract partial class LibraryServiceClient
    {
        /// <summary>
        /// The default endpoint for the LibraryService service, which is a host of "library-example.googleapis.com" and a port of 1234.
        /// </summary>
        public static gaxgrpc::ServiceEndpoint DefaultEndpoint { get; } = new gaxgrpc::ServiceEndpoint("library-example.googleapis.com", 1234);

        /// <summary>
        /// The default LibraryService scopes.
        /// </summary>
        /// <remarks>
        /// The default LibraryService scopes are:
        /// <list type="bullet">
        /// <item><description>"https://www.googleapis.com/auth/cloud-platform"</description></item>
        /// <item><description>"https://www.googleapis.com/auth/library"</description></item>
        /// </list>
        /// </remarks>
        public static scg::IReadOnlyList<string> DefaultScopes { get; } = new sco::ReadOnlyCollection<string>(new string[] {
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/library",
        });

        private static readonly gaxgrpc::ChannelPool s_channelPool = new gaxgrpc::ChannelPool(DefaultScopes);

        internal static gaxgrpc::ChannelPool ChannelPool => s_channelPool;

        /// <summary>
        /// Asynchronously creates a <see cref="LibraryServiceClient"/>, applying defaults for all unspecified settings,
        /// and creating a channel connecting to the given endpoint with application default credentials where
        /// necessary. See the example for how to use custom credentials.
        /// </summary>
        /// <example>
        /// This sample shows how to create a client using default credentials:
        /// <code>
        /// using Google.Example.Library.V1;
        /// ...
        /// // When running on Google Cloud Platform this will use the project Compute Credential.
        /// // Or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to the path of a JSON
        /// // credential file to use that credential.
        /// LibraryServiceClient client = await LibraryServiceClient.CreateAsync();
        /// </code>
        /// This sample shows how to create a client using credentials loaded from a JSON file:
        /// <code>
        /// using Google.Example.Library.V1;
        /// using Google.Apis.Auth.OAuth2;
        /// using Grpc.Auth;
        /// using Grpc.Core;
        /// ...
        /// GoogleCredential cred = GoogleCredential.FromFile("/path/to/credentials.json");
        /// Channel channel = new Channel(
        ///     LibraryServiceClient.DefaultEndpoint.Host, LibraryServiceClient.DefaultEndpoint.Port, cred.ToChannelCredentials());
        /// LibraryServiceClient client = LibraryServiceClient.Create(channel);
        /// ...
        /// // Shutdown the channel when it is no longer required.
        /// await channel.ShutdownAsync();
        /// </code>
        /// </example>
        /// <param name="endpoint">Optional <see cref="gaxgrpc::ServiceEndpoint"/>.</param>
        /// <param name="settings">Optional <see cref="LibraryServiceSettings"/>.</param>
        /// <returns>The task representing the created <see cref="LibraryServiceClient"/>.</returns>
        public static async stt::Task<LibraryServiceClient> CreateAsync(gaxgrpc::ServiceEndpoint endpoint = null, LibraryServiceSettings settings = null)
        {
            grpccore::Channel channel = await s_channelPool.GetChannelAsync(endpoint ?? DefaultEndpoint).ConfigureAwait(false);
            return Create(channel, settings);
        }

        /// <summary>
        /// Synchronously creates a <see cref="LibraryServiceClient"/>, applying defaults for all unspecified settings,
        /// and creating a channel connecting to the given endpoint with application default credentials where
        /// necessary. See the example for how to use custom credentials.
        /// </summary>
        /// <example>
        /// This sample shows how to create a client using default credentials:
        /// <code>
        /// using Google.Example.Library.V1;
        /// ...
        /// // When running on Google Cloud Platform this will use the project Compute Credential.
        /// // Or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to the path of a JSON
        /// // credential file to use that credential.
        /// LibraryServiceClient client = LibraryServiceClient.Create();
        /// </code>
        /// This sample shows how to create a client using credentials loaded from a JSON file:
        /// <code>
        /// using Google.Example.Library.V1;
        /// using Google.Apis.Auth.OAuth2;
        /// using Grpc.Auth;
        /// using Grpc.Core;
        /// ...
        /// GoogleCredential cred = GoogleCredential.FromFile("/path/to/credentials.json");
        /// Channel channel = new Channel(
        ///     LibraryServiceClient.DefaultEndpoint.Host, LibraryServiceClient.DefaultEndpoint.Port, cred.ToChannelCredentials());
        /// LibraryServiceClient client = LibraryServiceClient.Create(channel);
        /// ...
        /// // Shutdown the channel when it is no longer required.
        /// channel.ShutdownAsync().Wait();
        /// </code>
        /// </example>
        /// <param name="endpoint">Optional <see cref="gaxgrpc::ServiceEndpoint"/>.</param>
        /// <param name="settings">Optional <see cref="LibraryServiceSettings"/>.</param>
        /// <returns>The created <see cref="LibraryServiceClient"/>.</returns>
        public static LibraryServiceClient Create(gaxgrpc::ServiceEndpoint endpoint = null, LibraryServiceSettings settings = null)
        {
            grpccore::Channel channel = s_channelPool.GetChannel(endpoint ?? DefaultEndpoint);
            return Create(channel, settings);
        }

        /// <summary>
        /// Creates a <see cref="LibraryServiceClient"/> which uses the specified channel for remote operations.
        /// </summary>
        /// <param name="channel">The <see cref="grpccore::Channel"/> for remote operations. Must not be null.</param>
        /// <param name="settings">Optional <see cref="LibraryServiceSettings"/>.</param>
        /// <returns>The created <see cref="LibraryServiceClient"/>.</returns>
        public static LibraryServiceClient Create(grpccore::Channel channel, LibraryServiceSettings settings = null)
        {
            gax::GaxPreconditions.CheckNotNull(channel, nameof(channel));
            return Create(new grpccore::DefaultCallInvoker(channel), settings);
        }

        /// <summary>
        /// Creates a <see cref="LibraryServiceClient"/> which uses the specified call invoker for remote operations.
        /// </summary>
        /// <param name="callInvoker">The <see cref="grpccore::CallInvoker"/> for remote operations. Must not be null.</param>
        /// <param name="settings">Optional <see cref="LibraryServiceSettings"/>.</param>
        /// <returns>The created <see cref="LibraryServiceClient"/>.</returns>
        public static LibraryServiceClient Create(grpccore::CallInvoker callInvoker, LibraryServiceSettings settings = null)
        {
            gax::GaxPreconditions.CheckNotNull(callInvoker, nameof(callInvoker));
            grpccore::Interceptors.Interceptor interceptor = settings?.Interceptor;
            if (interceptor != null)
            {
                callInvoker = grpccore::Interceptors.CallInvokerExtensions.Intercept(callInvoker, interceptor);
            }
            LibraryService.LibraryServiceClient grpcClient = new LibraryService.LibraryServiceClient(callInvoker);
            return new LibraryServiceClientImpl(grpcClient, settings);
        }

        /// <summary>
        /// Shuts down any channels automatically created by <see cref="Create(gaxgrpc::ServiceEndpoint, LibraryServiceSettings)"/>
        /// and <see cref="CreateAsync(gaxgrpc::ServiceEndpoint, LibraryServiceSettings)"/>. Channels which weren't automatically
        /// created are not affected.
        /// </summary>
        /// <remarks>After calling this method, further calls to <see cref="Create(gaxgrpc::ServiceEndpoint, LibraryServiceSettings)"/>
        /// and <see cref="CreateAsync(gaxgrpc::ServiceEndpoint, LibraryServiceSettings)"/> will create new channels, which could
        /// in turn be shut down by another call to this method.</remarks>
        /// <returns>A task representing the asynchronous shutdown operation.</returns>
        public static stt::Task ShutdownDefaultChannelsAsync() => s_channelPool.ShutdownChannelsAsync();

        /// <summary>
        /// The underlying gRPC LibraryService client.
        /// </summary>
        public virtual LibraryService.LibraryServiceClient GrpcClient
        {
            get { throw new sys::NotImplementedException(); }
        }

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="shelf">
        /// The shelf to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> CreateShelfAsync(
            Shelf shelf,
            gaxgrpc::CallSettings callSettings = null) => CreateShelfAsync(
                new CreateShelfRequest
                {
                    Shelf = gax::GaxPreconditions.CheckNotNull(shelf, nameof(shelf)),
                },
                callSettings);

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="shelf">
        /// The shelf to create.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> CreateShelfAsync(
            Shelf shelf,
            st::CancellationToken cancellationToken) => CreateShelfAsync(
                shelf,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="shelf">
        /// The shelf to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf CreateShelf(
            Shelf shelf,
            gaxgrpc::CallSettings callSettings = null) => CreateShelf(
                new CreateShelfRequest
                {
                    Shelf = gax::GaxPreconditions.CheckNotNull(shelf, nameof(shelf)),
                },
                callSettings);

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> CreateShelfAsync(
            CreateShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> CreateShelfAsync(
            CreateShelfRequest request,
            st::CancellationToken cancellationToken) => CreateShelfAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf CreateShelf(
            CreateShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            ShelfName name,
            gaxgrpc::CallSettings callSettings = null) => GetShelfAsync(
                new GetShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            ShelfName name,
            st::CancellationToken cancellationToken) => GetShelfAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            ShelfName name,
            gaxgrpc::CallSettings callSettings = null) => GetShelf(
                new GetShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetShelfAsync(
                new GetShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            string name,
            st::CancellationToken cancellationToken) => GetShelfAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetShelf(
                new GetShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            ShelfName name,
            SomeMessage message,
            gaxgrpc::CallSettings callSettings = null) => GetShelfAsync(
                new GetShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Message = message, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            ShelfName name,
            SomeMessage message,
            st::CancellationToken cancellationToken) => GetShelfAsync(
                name,
                message,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            ShelfName name,
            SomeMessage message,
            gaxgrpc::CallSettings callSettings = null) => GetShelf(
                new GetShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Message = message, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            string name,
            SomeMessage message,
            gaxgrpc::CallSettings callSettings = null) => GetShelfAsync(
                new GetShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Message = message, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            string name,
            SomeMessage message,
            st::CancellationToken cancellationToken) => GetShelfAsync(
                name,
                message,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            string name,
            SomeMessage message,
            gaxgrpc::CallSettings callSettings = null) => GetShelf(
                new GetShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Message = message, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="stringBuilder">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            ShelfName name,
            SomeMessage message,
            StringBuilder stringBuilder,
            gaxgrpc::CallSettings callSettings = null) => GetShelfAsync(
                new GetShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Message = message, // Optional
                    StringBuilder = stringBuilder, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="stringBuilder">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            ShelfName name,
            SomeMessage message,
            StringBuilder stringBuilder,
            st::CancellationToken cancellationToken) => GetShelfAsync(
                name,
                message,
                stringBuilder,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="stringBuilder">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            ShelfName name,
            SomeMessage message,
            StringBuilder stringBuilder,
            gaxgrpc::CallSettings callSettings = null) => GetShelf(
                new GetShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Message = message, // Optional
                    StringBuilder = stringBuilder, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="stringBuilder">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            string name,
            SomeMessage message,
            StringBuilder stringBuilder,
            gaxgrpc::CallSettings callSettings = null) => GetShelfAsync(
                new GetShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Message = message, // Optional
                    StringBuilder = stringBuilder, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="stringBuilder">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            string name,
            SomeMessage message,
            StringBuilder stringBuilder,
            st::CancellationToken cancellationToken) => GetShelfAsync(
                name,
                message,
                stringBuilder,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="stringBuilder">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            string name,
            SomeMessage message,
            StringBuilder stringBuilder,
            gaxgrpc::CallSettings callSettings = null) => GetShelf(
                new GetShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Message = message, // Optional
                    StringBuilder = stringBuilder, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            GetShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            GetShelfRequest request,
            st::CancellationToken cancellationToken) => GetShelfAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            GetShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListShelvesResponse, Shelf> ListShelvesAsync(
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListShelvesAsync(
                new ListShelvesRequest
                {
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListShelvesResponse, Shelf> ListShelves(
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListShelves(
                new ListShelvesRequest
                {
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListShelvesResponse, Shelf> ListShelvesAsync(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListShelvesResponse, Shelf> ListShelves(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteShelfAsync(
            ShelfName name,
            gaxgrpc::CallSettings callSettings = null) => DeleteShelfAsync(
                new DeleteShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to delete.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteShelfAsync(
            ShelfName name,
            st::CancellationToken cancellationToken) => DeleteShelfAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void DeleteShelf(
            ShelfName name,
            gaxgrpc::CallSettings callSettings = null) => DeleteShelf(
                new DeleteShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteShelfAsync(
            string name,
            gaxgrpc::CallSettings callSettings = null) => DeleteShelfAsync(
                new DeleteShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to delete.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteShelfAsync(
            string name,
            st::CancellationToken cancellationToken) => DeleteShelfAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void DeleteShelf(
            string name,
            gaxgrpc::CallSettings callSettings = null) => DeleteShelf(
                new DeleteShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteShelfAsync(
            DeleteShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteShelfAsync(
            DeleteShelfRequest request,
            st::CancellationToken cancellationToken) => DeleteShelfAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void DeleteShelf(
            DeleteShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf we're adding books to.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the shelf we're removing books from and deleting.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> MergeShelvesAsync(
            ShelfName name,
            ShelfName otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MergeShelvesAsync(
                new MergeShelvesRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OtherShelfNameAsShelfName = gax::GaxPreconditions.CheckNotNull(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf we're adding books to.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the shelf we're removing books from and deleting.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> MergeShelvesAsync(
            ShelfName name,
            ShelfName otherShelfName,
            st::CancellationToken cancellationToken) => MergeShelvesAsync(
                name,
                otherShelfName,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf we're adding books to.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the shelf we're removing books from and deleting.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf MergeShelves(
            ShelfName name,
            ShelfName otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MergeShelves(
                new MergeShelvesRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OtherShelfNameAsShelfName = gax::GaxPreconditions.CheckNotNull(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf we're adding books to.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the shelf we're removing books from and deleting.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> MergeShelvesAsync(
            string name,
            string otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MergeShelvesAsync(
                new MergeShelvesRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    OtherShelfName = gax::GaxPreconditions.CheckNotNullOrEmpty(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf we're adding books to.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the shelf we're removing books from and deleting.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> MergeShelvesAsync(
            string name,
            string otherShelfName,
            st::CancellationToken cancellationToken) => MergeShelvesAsync(
                name,
                otherShelfName,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf we're adding books to.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the shelf we're removing books from and deleting.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf MergeShelves(
            string name,
            string otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MergeShelves(
                new MergeShelvesRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    OtherShelfName = gax::GaxPreconditions.CheckNotNullOrEmpty(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> MergeShelvesAsync(
            MergeShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> MergeShelvesAsync(
            MergeShelvesRequest request,
            st::CancellationToken cancellationToken) => MergeShelvesAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf MergeShelves(
            MergeShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf in which the book is created.
        /// </param>
        /// <param name="book">
        /// The book to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> CreateBookAsync(
            ShelfName name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => CreateBookAsync(
                new CreateBookRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf in which the book is created.
        /// </param>
        /// <param name="book">
        /// The book to create.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> CreateBookAsync(
            ShelfName name,
            Book book,
            st::CancellationToken cancellationToken) => CreateBookAsync(
                name,
                book,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf in which the book is created.
        /// </param>
        /// <param name="book">
        /// The book to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book CreateBook(
            ShelfName name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => CreateBook(
                new CreateBookRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf in which the book is created.
        /// </param>
        /// <param name="book">
        /// The book to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> CreateBookAsync(
            string name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => CreateBookAsync(
                new CreateBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf in which the book is created.
        /// </param>
        /// <param name="book">
        /// The book to create.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> CreateBookAsync(
            string name,
            Book book,
            st::CancellationToken cancellationToken) => CreateBookAsync(
                name,
                book,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf in which the book is created.
        /// </param>
        /// <param name="book">
        /// The book to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book CreateBook(
            string name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => CreateBook(
                new CreateBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> CreateBookAsync(
            CreateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> CreateBookAsync(
            CreateBookRequest request,
            st::CancellationToken cancellationToken) => CreateBookAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book CreateBook(
            CreateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="shelf">
        /// The shelf in which the series is created.
        /// </param>
        /// <param name="books">
        /// The books to publish in the series.
        /// </param>
        /// <param name="edition">
        /// The edition of the series
        /// </param>
        /// <param name="seriesUuid">
        /// Uniquely identifies the series to the publishing house.
        /// </param>
        /// <param name="publisher">
        /// The publisher of the series.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<PublishSeriesResponse> PublishSeriesAsync(
            Shelf shelf,
            scg::IEnumerable<Book> books,
            uint? edition,
            SeriesUuid seriesUuid,
            PublisherName publisher,
            gaxgrpc::CallSettings callSettings = null) => PublishSeriesAsync(
                new PublishSeriesRequest
                {
                    Shelf = gax::GaxPreconditions.CheckNotNull(shelf, nameof(shelf)),
                    Books = { gax::GaxPreconditions.CheckNotNull(books, nameof(books)) },
                    Edition = edition ?? 0, // Optional
                    SeriesUuid = gax::GaxPreconditions.CheckNotNull(seriesUuid, nameof(seriesUuid)),
                    PublisherAsPublisherName = publisher, // Optional
                },
                callSettings);

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="shelf">
        /// The shelf in which the series is created.
        /// </param>
        /// <param name="books">
        /// The books to publish in the series.
        /// </param>
        /// <param name="edition">
        /// The edition of the series
        /// </param>
        /// <param name="seriesUuid">
        /// Uniquely identifies the series to the publishing house.
        /// </param>
        /// <param name="publisher">
        /// The publisher of the series.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<PublishSeriesResponse> PublishSeriesAsync(
            Shelf shelf,
            scg::IEnumerable<Book> books,
            uint? edition,
            SeriesUuid seriesUuid,
            PublisherName publisher,
            st::CancellationToken cancellationToken) => PublishSeriesAsync(
                shelf,
                books,
                edition,
                seriesUuid,
                publisher,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="shelf">
        /// The shelf in which the series is created.
        /// </param>
        /// <param name="books">
        /// The books to publish in the series.
        /// </param>
        /// <param name="edition">
        /// The edition of the series
        /// </param>
        /// <param name="seriesUuid">
        /// Uniquely identifies the series to the publishing house.
        /// </param>
        /// <param name="publisher">
        /// The publisher of the series.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual PublishSeriesResponse PublishSeries(
            Shelf shelf,
            scg::IEnumerable<Book> books,
            uint? edition,
            SeriesUuid seriesUuid,
            PublisherName publisher,
            gaxgrpc::CallSettings callSettings = null) => PublishSeries(
                new PublishSeriesRequest
                {
                    Shelf = gax::GaxPreconditions.CheckNotNull(shelf, nameof(shelf)),
                    Books = { gax::GaxPreconditions.CheckNotNull(books, nameof(books)) },
                    Edition = edition ?? 0, // Optional
                    SeriesUuid = gax::GaxPreconditions.CheckNotNull(seriesUuid, nameof(seriesUuid)),
                    PublisherAsPublisherName = publisher, // Optional
                },
                callSettings);

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="shelf">
        /// The shelf in which the series is created.
        /// </param>
        /// <param name="books">
        /// The books to publish in the series.
        /// </param>
        /// <param name="edition">
        /// The edition of the series
        /// </param>
        /// <param name="seriesUuid">
        /// Uniquely identifies the series to the publishing house.
        /// </param>
        /// <param name="publisher">
        /// The publisher of the series.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<PublishSeriesResponse> PublishSeriesAsync(
            Shelf shelf,
            scg::IEnumerable<Book> books,
            uint? edition,
            SeriesUuid seriesUuid,
            string publisher,
            gaxgrpc::CallSettings callSettings = null) => PublishSeriesAsync(
                new PublishSeriesRequest
                {
                    Shelf = gax::GaxPreconditions.CheckNotNull(shelf, nameof(shelf)),
                    Books = { gax::GaxPreconditions.CheckNotNull(books, nameof(books)) },
                    Edition = edition ?? 0, // Optional
                    SeriesUuid = gax::GaxPreconditions.CheckNotNull(seriesUuid, nameof(seriesUuid)),
                    Publisher = publisher ?? "", // Optional
                },
                callSettings);

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="shelf">
        /// The shelf in which the series is created.
        /// </param>
        /// <param name="books">
        /// The books to publish in the series.
        /// </param>
        /// <param name="edition">
        /// The edition of the series
        /// </param>
        /// <param name="seriesUuid">
        /// Uniquely identifies the series to the publishing house.
        /// </param>
        /// <param name="publisher">
        /// The publisher of the series.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<PublishSeriesResponse> PublishSeriesAsync(
            Shelf shelf,
            scg::IEnumerable<Book> books,
            uint? edition,
            SeriesUuid seriesUuid,
            string publisher,
            st::CancellationToken cancellationToken) => PublishSeriesAsync(
                shelf,
                books,
                edition,
                seriesUuid,
                publisher,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="shelf">
        /// The shelf in which the series is created.
        /// </param>
        /// <param name="books">
        /// The books to publish in the series.
        /// </param>
        /// <param name="edition">
        /// The edition of the series
        /// </param>
        /// <param name="seriesUuid">
        /// Uniquely identifies the series to the publishing house.
        /// </param>
        /// <param name="publisher">
        /// The publisher of the series.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual PublishSeriesResponse PublishSeries(
            Shelf shelf,
            scg::IEnumerable<Book> books,
            uint? edition,
            SeriesUuid seriesUuid,
            string publisher,
            gaxgrpc::CallSettings callSettings = null) => PublishSeries(
                new PublishSeriesRequest
                {
                    Shelf = gax::GaxPreconditions.CheckNotNull(shelf, nameof(shelf)),
                    Books = { gax::GaxPreconditions.CheckNotNull(books, nameof(books)) },
                    Edition = edition ?? 0, // Optional
                    SeriesUuid = gax::GaxPreconditions.CheckNotNull(seriesUuid, nameof(seriesUuid)),
                    Publisher = publisher ?? "", // Optional
                },
                callSettings);

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<PublishSeriesResponse> PublishSeriesAsync(
            PublishSeriesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<PublishSeriesResponse> PublishSeriesAsync(
            PublishSeriesRequest request,
            st::CancellationToken cancellationToken) => PublishSeriesAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual PublishSeriesResponse PublishSeries(
            PublishSeriesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> GetBookAsync(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => GetBookAsync(
                new GetBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> GetBookAsync(
            BookNameOneof name,
            st::CancellationToken cancellationToken) => GetBookAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book GetBook(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => GetBook(
                new GetBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> GetBookAsync(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetBookAsync(
                new GetBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> GetBookAsync(
            string name,
            st::CancellationToken cancellationToken) => GetBookAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book GetBook(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetBook(
                new GetBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> GetBookAsync(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> GetBookAsync(
            GetBookRequest request,
            st::CancellationToken cancellationToken) => GetBookAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book GetBook(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf whose books we'd like to list.
        /// </param>
        /// <param name="filter">
        /// To test python built-in wrapping.
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListBooksResponse, Book> ListBooksAsync(
            ShelfName name,
            string filter,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListBooksAsync(
                new ListBooksRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Filter = filter ?? "", // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf whose books we'd like to list.
        /// </param>
        /// <param name="filter">
        /// To test python built-in wrapping.
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListBooksResponse, Book> ListBooks(
            ShelfName name,
            string filter,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListBooks(
                new ListBooksRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Filter = filter ?? "", // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf whose books we'd like to list.
        /// </param>
        /// <param name="filter">
        /// To test python built-in wrapping.
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListBooksResponse, Book> ListBooksAsync(
            string name,
            string filter,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListBooksAsync(
                new ListBooksRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Filter = filter ?? "", // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf whose books we'd like to list.
        /// </param>
        /// <param name="filter">
        /// To test python built-in wrapping.
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListBooksResponse, Book> ListBooks(
            string name,
            string filter,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListBooks(
                new ListBooksRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Filter = filter ?? "", // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListBooksResponse, Book> ListBooksAsync(
            ListBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListBooksResponse, Book> ListBooks(
            ListBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteBookAsync(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => DeleteBookAsync(
                new DeleteBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to delete.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteBookAsync(
            BookNameOneof name,
            st::CancellationToken cancellationToken) => DeleteBookAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void DeleteBook(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => DeleteBook(
                new DeleteBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteBookAsync(
            string name,
            gaxgrpc::CallSettings callSettings = null) => DeleteBookAsync(
                new DeleteBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to delete.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteBookAsync(
            string name,
            st::CancellationToken cancellationToken) => DeleteBookAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void DeleteBook(
            string name,
            gaxgrpc::CallSettings callSettings = null) => DeleteBook(
                new DeleteBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteBookAsync(
            DeleteBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteBookAsync(
            DeleteBookRequest request,
            st::CancellationToken cancellationToken) => DeleteBookAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void DeleteBook(
            DeleteBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            BookNameOneof name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookAsync(
                new UpdateBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            BookNameOneof name,
            Book book,
            st::CancellationToken cancellationToken) => UpdateBookAsync(
                name,
                book,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book UpdateBook(
            BookNameOneof name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => UpdateBook(
                new UpdateBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            string name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookAsync(
                new UpdateBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            string name,
            Book book,
            st::CancellationToken cancellationToken) => UpdateBookAsync(
                name,
                book,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book UpdateBook(
            string name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => UpdateBook(
                new UpdateBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="optionalFoo">
        /// An optional foo.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="updateMask">
        /// A field mask to apply, rendered as an HTTP parameter.
        /// </param>
        /// <param name="physicalMask">
        /// To test Python import clash resolution.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            BookNameOneof name,
            string optionalFoo,
            Book book,
            pbwkt::FieldMask updateMask,
            FieldMask physicalMask,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookAsync(
                new UpdateBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OptionalFoo = optionalFoo ?? "", // Optional
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                    UpdateMask = updateMask, // Optional
                    PhysicalMask = physicalMask, // Optional
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="optionalFoo">
        /// An optional foo.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="updateMask">
        /// A field mask to apply, rendered as an HTTP parameter.
        /// </param>
        /// <param name="physicalMask">
        /// To test Python import clash resolution.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            BookNameOneof name,
            string optionalFoo,
            Book book,
            pbwkt::FieldMask updateMask,
            FieldMask physicalMask,
            st::CancellationToken cancellationToken) => UpdateBookAsync(
                name,
                optionalFoo,
                book,
                updateMask,
                physicalMask,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="optionalFoo">
        /// An optional foo.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="updateMask">
        /// A field mask to apply, rendered as an HTTP parameter.
        /// </param>
        /// <param name="physicalMask">
        /// To test Python import clash resolution.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book UpdateBook(
            BookNameOneof name,
            string optionalFoo,
            Book book,
            pbwkt::FieldMask updateMask,
            FieldMask physicalMask,
            gaxgrpc::CallSettings callSettings = null) => UpdateBook(
                new UpdateBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OptionalFoo = optionalFoo ?? "", // Optional
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                    UpdateMask = updateMask, // Optional
                    PhysicalMask = physicalMask, // Optional
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="optionalFoo">
        /// An optional foo.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="updateMask">
        /// A field mask to apply, rendered as an HTTP parameter.
        /// </param>
        /// <param name="physicalMask">
        /// To test Python import clash resolution.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            string name,
            string optionalFoo,
            Book book,
            pbwkt::FieldMask updateMask,
            FieldMask physicalMask,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookAsync(
                new UpdateBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    OptionalFoo = optionalFoo ?? "", // Optional
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                    UpdateMask = updateMask, // Optional
                    PhysicalMask = physicalMask, // Optional
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="optionalFoo">
        /// An optional foo.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="updateMask">
        /// A field mask to apply, rendered as an HTTP parameter.
        /// </param>
        /// <param name="physicalMask">
        /// To test Python import clash resolution.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            string name,
            string optionalFoo,
            Book book,
            pbwkt::FieldMask updateMask,
            FieldMask physicalMask,
            st::CancellationToken cancellationToken) => UpdateBookAsync(
                name,
                optionalFoo,
                book,
                updateMask,
                physicalMask,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="optionalFoo">
        /// An optional foo.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="updateMask">
        /// A field mask to apply, rendered as an HTTP parameter.
        /// </param>
        /// <param name="physicalMask">
        /// To test Python import clash resolution.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book UpdateBook(
            string name,
            string optionalFoo,
            Book book,
            pbwkt::FieldMask updateMask,
            FieldMask physicalMask,
            gaxgrpc::CallSettings callSettings = null) => UpdateBook(
                new UpdateBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    OptionalFoo = optionalFoo ?? "", // Optional
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                    UpdateMask = updateMask, // Optional
                    PhysicalMask = physicalMask, // Optional
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            UpdateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            UpdateBookRequest request,
            st::CancellationToken cancellationToken) => UpdateBookAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book UpdateBook(
            UpdateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to move.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the destination shelf.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> MoveBookAsync(
            BookNameOneof name,
            ShelfName otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MoveBookAsync(
                new MoveBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OtherShelfNameAsShelfName = gax::GaxPreconditions.CheckNotNull(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to move.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the destination shelf.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> MoveBookAsync(
            BookNameOneof name,
            ShelfName otherShelfName,
            st::CancellationToken cancellationToken) => MoveBookAsync(
                name,
                otherShelfName,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to move.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the destination shelf.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book MoveBook(
            BookNameOneof name,
            ShelfName otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MoveBook(
                new MoveBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OtherShelfNameAsShelfName = gax::GaxPreconditions.CheckNotNull(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to move.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the destination shelf.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> MoveBookAsync(
            string name,
            string otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MoveBookAsync(
                new MoveBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    OtherShelfName = gax::GaxPreconditions.CheckNotNullOrEmpty(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to move.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the destination shelf.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> MoveBookAsync(
            string name,
            string otherShelfName,
            st::CancellationToken cancellationToken) => MoveBookAsync(
                name,
                otherShelfName,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to move.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the destination shelf.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book MoveBook(
            string name,
            string otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MoveBook(
                new MoveBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    OtherShelfName = gax::GaxPreconditions.CheckNotNullOrEmpty(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> MoveBookAsync(
            MoveBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> MoveBookAsync(
            MoveBookRequest request,
            st::CancellationToken cancellationToken) => MoveBookAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book MoveBook(
            MoveBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListStringsResponse, IResourceName> ListStringsAsync(
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListStringsAsync(
                new ListStringsRequest
                {
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListStringsResponse, IResourceName> ListStrings(
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListStrings(
                new ListStringsRequest
                {
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListStringsResponse, IResourceName> ListStringsAsync(
            IResourceName name,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListStringsAsync(
                new ListStringsRequest
                {
                    AsResourceName = name, // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListStringsResponse, IResourceName> ListStrings(
            IResourceName name,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListStrings(
                new ListStringsRequest
                {
                    AsResourceName = name, // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListStringsResponse, IResourceName> ListStringsAsync(
            string name,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListStringsAsync(
                new ListStringsRequest
                {
                    Name = name ?? "", // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListStringsResponse, IResourceName> ListStrings(
            string name,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListStrings(
                new ListStringsRequest
                {
                    Name = name ?? "", // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListStringsResponse, IResourceName> ListStringsAsync(
            ListStringsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListStringsResponse, IResourceName> ListStrings(
            ListStringsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="comments">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task AddCommentsAsync(
            BookNameOneof name,
            scg::IEnumerable<Comment> comments,
            gaxgrpc::CallSettings callSettings = null) => AddCommentsAsync(
                new AddCommentsRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Comments = { gax::GaxPreconditions.CheckNotNull(comments, nameof(comments)) },
                },
                callSettings);

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="comments">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task AddCommentsAsync(
            BookNameOneof name,
            scg::IEnumerable<Comment> comments,
            st::CancellationToken cancellationToken) => AddCommentsAsync(
                name,
                comments,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="comments">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void AddComments(
            BookNameOneof name,
            scg::IEnumerable<Comment> comments,
            gaxgrpc::CallSettings callSettings = null) => AddComments(
                new AddCommentsRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Comments = { gax::GaxPreconditions.CheckNotNull(comments, nameof(comments)) },
                },
                callSettings);

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="comments">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task AddCommentsAsync(
            string name,
            scg::IEnumerable<Comment> comments,
            gaxgrpc::CallSettings callSettings = null) => AddCommentsAsync(
                new AddCommentsRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Comments = { gax::GaxPreconditions.CheckNotNull(comments, nameof(comments)) },
                },
                callSettings);

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="comments">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task AddCommentsAsync(
            string name,
            scg::IEnumerable<Comment> comments,
            st::CancellationToken cancellationToken) => AddCommentsAsync(
                name,
                comments,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="comments">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void AddComments(
            string name,
            scg::IEnumerable<Comment> comments,
            gaxgrpc::CallSettings callSettings = null) => AddComments(
                new AddCommentsRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Comments = { gax::GaxPreconditions.CheckNotNull(comments, nameof(comments)) },
                },
                callSettings);

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task AddCommentsAsync(
            AddCommentsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task AddCommentsAsync(
            AddCommentsRequest request,
            st::CancellationToken cancellationToken) => AddCommentsAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void AddComments(
            AddCommentsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="parent">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromArchive> GetBookFromArchiveAsync(
            ArchivedBookName name,
            ProjectName parent,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromArchiveAsync(
                new GetBookFromArchiveRequest
                {
                    ArchivedBookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    ParentAsProjectName = gax::GaxPreconditions.CheckNotNull(parent, nameof(parent)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="parent">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromArchive> GetBookFromArchiveAsync(
            ArchivedBookName name,
            ProjectName parent,
            st::CancellationToken cancellationToken) => GetBookFromArchiveAsync(
                name,
                parent,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="parent">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromArchive GetBookFromArchive(
            ArchivedBookName name,
            ProjectName parent,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromArchive(
                new GetBookFromArchiveRequest
                {
                    ArchivedBookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    ParentAsProjectName = gax::GaxPreconditions.CheckNotNull(parent, nameof(parent)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="parent">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromArchive> GetBookFromArchiveAsync(
            string name,
            string parent,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromArchiveAsync(
                new GetBookFromArchiveRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Parent = gax::GaxPreconditions.CheckNotNullOrEmpty(parent, nameof(parent)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="parent">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromArchive> GetBookFromArchiveAsync(
            string name,
            string parent,
            st::CancellationToken cancellationToken) => GetBookFromArchiveAsync(
                name,
                parent,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="parent">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromArchive GetBookFromArchive(
            string name,
            string parent,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromArchive(
                new GetBookFromArchiveRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Parent = gax::GaxPreconditions.CheckNotNullOrEmpty(parent, nameof(parent)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromArchive> GetBookFromArchiveAsync(
            GetBookFromArchiveRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromArchive> GetBookFromArchiveAsync(
            GetBookFromArchiveRequest request,
            st::CancellationToken cancellationToken) => GetBookFromArchiveAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromArchive GetBookFromArchive(
            GetBookFromArchiveRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="altBookName">
        /// An alternate book name, used to test restricting flattened field to a
        /// single resource name type in a oneof.
        /// </param>
        /// <param name="place">
        ///
        /// </param>
        /// <param name="folder">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            BookNameOneof name,
            BookNameOneof altBookName,
            LocationName place,
            FolderName folder,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAnywhereAsync(
                new GetBookFromAnywhereRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    AltBookNameAsBookNameOneof = gax::GaxPreconditions.CheckNotNull(altBookName, nameof(altBookName)),
                    PlaceAsLocationName = gax::GaxPreconditions.CheckNotNull(place, nameof(place)),
                    FolderAsFolderName = gax::GaxPreconditions.CheckNotNull(folder, nameof(folder)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="altBookName">
        /// An alternate book name, used to test restricting flattened field to a
        /// single resource name type in a oneof.
        /// </param>
        /// <param name="place">
        ///
        /// </param>
        /// <param name="folder">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            BookNameOneof name,
            BookNameOneof altBookName,
            LocationName place,
            FolderName folder,
            st::CancellationToken cancellationToken) => GetBookFromAnywhereAsync(
                name,
                altBookName,
                place,
                folder,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="altBookName">
        /// An alternate book name, used to test restricting flattened field to a
        /// single resource name type in a oneof.
        /// </param>
        /// <param name="place">
        ///
        /// </param>
        /// <param name="folder">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAnywhere(
            BookNameOneof name,
            BookNameOneof altBookName,
            LocationName place,
            FolderName folder,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAnywhere(
                new GetBookFromAnywhereRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    AltBookNameAsBookNameOneof = gax::GaxPreconditions.CheckNotNull(altBookName, nameof(altBookName)),
                    PlaceAsLocationName = gax::GaxPreconditions.CheckNotNull(place, nameof(place)),
                    FolderAsFolderName = gax::GaxPreconditions.CheckNotNull(folder, nameof(folder)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="altBookName">
        /// An alternate book name, used to test restricting flattened field to a
        /// single resource name type in a oneof.
        /// </param>
        /// <param name="place">
        ///
        /// </param>
        /// <param name="folder">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            string name,
            string altBookName,
            string place,
            string folder,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAnywhereAsync(
                new GetBookFromAnywhereRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    AltBookName = gax::GaxPreconditions.CheckNotNullOrEmpty(altBookName, nameof(altBookName)),
                    Place = gax::GaxPreconditions.CheckNotNullOrEmpty(place, nameof(place)),
                    Folder = gax::GaxPreconditions.CheckNotNullOrEmpty(folder, nameof(folder)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="altBookName">
        /// An alternate book name, used to test restricting flattened field to a
        /// single resource name type in a oneof.
        /// </param>
        /// <param name="place">
        ///
        /// </param>
        /// <param name="folder">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            string name,
            string altBookName,
            string place,
            string folder,
            st::CancellationToken cancellationToken) => GetBookFromAnywhereAsync(
                name,
                altBookName,
                place,
                folder,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="altBookName">
        /// An alternate book name, used to test restricting flattened field to a
        /// single resource name type in a oneof.
        /// </param>
        /// <param name="place">
        ///
        /// </param>
        /// <param name="folder">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAnywhere(
            string name,
            string altBookName,
            string place,
            string folder,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAnywhere(
                new GetBookFromAnywhereRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    AltBookName = gax::GaxPreconditions.CheckNotNullOrEmpty(altBookName, nameof(altBookName)),
                    Place = gax::GaxPreconditions.CheckNotNullOrEmpty(place, nameof(place)),
                    Folder = gax::GaxPreconditions.CheckNotNullOrEmpty(folder, nameof(folder)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            GetBookFromAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            GetBookFromAnywhereRequest request,
            st::CancellationToken cancellationToken) => GetBookFromAnywhereAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAnywhere(
            GetBookFromAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAbsolutelyAnywhereAsync(
                new GetBookFromAbsolutelyAnywhereRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            BookNameOneof name,
            st::CancellationToken cancellationToken) => GetBookFromAbsolutelyAnywhereAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAbsolutelyAnywhere(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAbsolutelyAnywhere(
                new GetBookFromAbsolutelyAnywhereRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAbsolutelyAnywhereAsync(
                new GetBookFromAbsolutelyAnywhereRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            string name,
            st::CancellationToken cancellationToken) => GetBookFromAbsolutelyAnywhereAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAbsolutelyAnywhere(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAbsolutelyAnywhere(
                new GetBookFromAbsolutelyAnywhereRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            GetBookFromAbsolutelyAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            GetBookFromAbsolutelyAnywhereRequest request,
            st::CancellationToken cancellationToken) => GetBookFromAbsolutelyAnywhereAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAbsolutelyAnywhere(
            GetBookFromAbsolutelyAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="indexName">
        /// The name of the index for the book
        /// </param>
        /// <param name="indexMap">
        /// The index to update the book with
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task UpdateBookIndexAsync(
            BookNameOneof name,
            string indexName,
            scg::IDictionary<string, string> indexMap,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookIndexAsync(
                new UpdateBookIndexRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    IndexName = gax::GaxPreconditions.CheckNotNullOrEmpty(indexName, nameof(indexName)),
                    IndexMap = { gax::GaxPreconditions.CheckNotNull(indexMap, nameof(indexMap)) },
                },
                callSettings);

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="indexName">
        /// The name of the index for the book
        /// </param>
        /// <param name="indexMap">
        /// The index to update the book with
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task UpdateBookIndexAsync(
            BookNameOneof name,
            string indexName,
            scg::IDictionary<string, string> indexMap,
            st::CancellationToken cancellationToken) => UpdateBookIndexAsync(
                name,
                indexName,
                indexMap,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="indexName">
        /// The name of the index for the book
        /// </param>
        /// <param name="indexMap">
        /// The index to update the book with
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void UpdateBookIndex(
            BookNameOneof name,
            string indexName,
            scg::IDictionary<string, string> indexMap,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookIndex(
                new UpdateBookIndexRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    IndexName = gax::GaxPreconditions.CheckNotNullOrEmpty(indexName, nameof(indexName)),
                    IndexMap = { gax::GaxPreconditions.CheckNotNull(indexMap, nameof(indexMap)) },
                },
                callSettings);

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="indexName">
        /// The name of the index for the book
        /// </param>
        /// <param name="indexMap">
        /// The index to update the book with
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task UpdateBookIndexAsync(
            string name,
            string indexName,
            scg::IDictionary<string, string> indexMap,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookIndexAsync(
                new UpdateBookIndexRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    IndexName = gax::GaxPreconditions.CheckNotNullOrEmpty(indexName, nameof(indexName)),
                    IndexMap = { gax::GaxPreconditions.CheckNotNull(indexMap, nameof(indexMap)) },
                },
                callSettings);

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="indexName">
        /// The name of the index for the book
        /// </param>
        /// <param name="indexMap">
        /// The index to update the book with
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task UpdateBookIndexAsync(
            string name,
            string indexName,
            scg::IDictionary<string, string> indexMap,
            st::CancellationToken cancellationToken) => UpdateBookIndexAsync(
                name,
                indexName,
                indexMap,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="indexName">
        /// The name of the index for the book
        /// </param>
        /// <param name="indexMap">
        /// The index to update the book with
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void UpdateBookIndex(
            string name,
            string indexName,
            scg::IDictionary<string, string> indexMap,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookIndex(
                new UpdateBookIndexRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    IndexName = gax::GaxPreconditions.CheckNotNullOrEmpty(indexName, nameof(indexName)),
                    IndexMap = { gax::GaxPreconditions.CheckNotNull(indexMap, nameof(indexMap)) },
                },
                callSettings);

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task UpdateBookIndexAsync(
            UpdateBookIndexRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task UpdateBookIndexAsync(
            UpdateBookIndexRequest request,
            st::CancellationToken cancellationToken) => UpdateBookIndexAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void UpdateBookIndex(
            UpdateBookIndexRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Test server streaming
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The server stream.
        /// </returns>
        public virtual StreamShelvesStream StreamShelves(
            StreamShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Server streaming methods for <c>StreamShelves</c>.
        /// </summary>
        public abstract partial class StreamShelvesStream : gaxgrpc::ServerStreamingBase<StreamShelvesResponse>
        {
        }

        /// <summary>
        /// Test server streaming, non-paged responses.
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf whose books we'd like to list.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The server stream.
        /// </returns>
        public virtual StreamBooksStream StreamBooks(
            string name,
            gaxgrpc::CallSettings callSettings = null) => StreamBooks(
                new StreamBooksRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test server streaming, non-paged responses.
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The server stream.
        /// </returns>
        public virtual StreamBooksStream StreamBooks(
            StreamBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Server streaming methods for <c>StreamBooks</c>.
        /// </summary>
        public abstract partial class StreamBooksStream : gaxgrpc::ServerStreamingBase<Book>
        {
        }

        /// <summary>
        /// Test bidi-streaming.
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The client-server stream.
        /// </returns>
        *** ERROR: Cannot handle streaming type 'BidiStreaming' ***

        /// <summary>
        /// Test bidi-streaming.
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The client-server stream.
        /// </returns>
        *** ERROR: Cannot handle streaming type 'BidiStreaming' ***

        /// <summary>
        /// Test bidi-streaming.
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <param name="streamingSettings">
        /// If not null, applies streaming overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The client-server stream.
        /// </returns>
        public virtual DiscussBookStream DiscussBook(
            gaxgrpc::CallSettings callSettings = null,
            gaxgrpc::BidirectionalStreamingSettings streamingSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Bidirectional streaming methods for <c>DiscussBook</c>.
        /// </summary>
        public abstract partial class DiscussBookStream : gaxgrpc::BidirectionalStreamingBase<DiscussBookRequest, Comment>
        {
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="names">
        ///
        /// </param>
        /// <param name="shelves">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> FindRelatedBooksAsync(
            scg::IEnumerable<BookNameOneof> names,
            scg::IEnumerable<ShelfName> shelves,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => FindRelatedBooksAsync(
                new FindRelatedBooksRequest
                {
                    BookNameOneofs = { gax::GaxPreconditions.CheckNotNull(names, nameof(names)) },
                    ShelvesAsShelfNames = { gax::GaxPreconditions.CheckNotNull(shelves, nameof(shelves)) },
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="names">
        ///
        /// </param>
        /// <param name="shelves">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> FindRelatedBooks(
            scg::IEnumerable<BookNameOneof> names,
            scg::IEnumerable<ShelfName> shelves,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => FindRelatedBooks(
                new FindRelatedBooksRequest
                {
                    BookNameOneofs = { gax::GaxPreconditions.CheckNotNull(names, nameof(names)) },
                    ShelvesAsShelfNames = { gax::GaxPreconditions.CheckNotNull(shelves, nameof(shelves)) },
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="names">
        ///
        /// </param>
        /// <param name="shelves">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> FindRelatedBooksAsync(
            scg::IEnumerable<string> names,
            scg::IEnumerable<string> shelves,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => FindRelatedBooksAsync(
                new FindRelatedBooksRequest
                {
                    Names = { gax::GaxPreconditions.CheckNotNull(names, nameof(names)) },
                    Shelves = { gax::GaxPreconditions.CheckNotNull(shelves, nameof(shelves)) },
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="names">
        ///
        /// </param>
        /// <param name="shelves">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> FindRelatedBooks(
            scg::IEnumerable<string> names,
            scg::IEnumerable<string> shelves,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => FindRelatedBooks(
                new FindRelatedBooksRequest
                {
                    Names = { gax::GaxPreconditions.CheckNotNull(names, nameof(names)) },
                    Shelves = { gax::GaxPreconditions.CheckNotNull(shelves, nameof(shelves)) },
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> FindRelatedBooksAsync(
            FindRelatedBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> FindRelatedBooks(
            FindRelatedBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<gtv::AddLabelResponse> AddLabelAsync(
            gtv::AddLabelRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<gtv::AddLabelResponse> AddLabelAsync(
            gtv::AddLabelRequest request,
            st::CancellationToken cancellationToken) => AddLabelAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual gtv::AddLabelResponse AddLabel(
            gtv::AddLabelRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => GetBigBookAsync(
                new GetBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            BookNameOneof name,
            st::CancellationToken cancellationToken) => GetBigBookAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<Book, GetBigBookMetadata> GetBigBook(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => GetBigBook(
                new GetBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetBigBookAsync(
                new GetBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            string name,
            st::CancellationToken cancellationToken) => GetBigBookAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<Book, GetBigBookMetadata> GetBigBook(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetBigBook(
                new GetBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Asynchronously poll an operation once, using an <c>operationName</c> from a previous invocation of <c>GetBigBookAsync</c>.
        /// </summary>
        /// <param name="operationName">The name of a previously invoked operation. Must not be <c>null</c> or empty.</param>
        /// <param name="callSettings">If not null, applies overrides to this RPC call.</param>
        /// <returns>A task representing the result of polling the operation.</returns>
        public virtual stt::Task<lro::Operation<Book, GetBigBookMetadata>> PollOnceGetBigBookAsync(
            string operationName,
            gaxgrpc::CallSettings callSettings = null) => lro::Operation<Book, GetBigBookMetadata>.PollOnceFromNameAsync(
                gax::GaxPreconditions.CheckNotNullOrEmpty(operationName, nameof(operationName)),
                GetBigBookOperationsClient,
                callSettings);

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<Book, GetBigBookMetadata> GetBigBook(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// The long-running operations client for <c>GetBigBook</c>.
        /// </summary>
        public virtual lro::OperationsClient GetBigBookOperationsClient
        {
            get { throw new sys::NotImplementedException(); }
        }

        /// <summary>
        /// Poll an operation once, using an <c>operationName</c> from a previous invocation of <c>GetBigBook</c>.
        /// </summary>
        /// <param name="operationName">The name of a previously invoked operation. Must not be <c>null</c> or empty.</param>
        /// <param name="callSettings">If not null, applies overrides to this RPC call.</param>
        /// <returns>The result of polling the operation.</returns>
        public virtual lro::Operation<Book, GetBigBookMetadata> PollOnceGetBigBook(
            string operationName,
            gaxgrpc::CallSettings callSettings = null) => lro::Operation<Book, GetBigBookMetadata>.PollOnceFromName(
                gax::GaxPreconditions.CheckNotNullOrEmpty(operationName, nameof(operationName)),
                GetBigBookOperationsClient,
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<pbwkt::Empty, GetBigBookMetadata>> GetBigNothingAsync(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => GetBigNothingAsync(
                new GetBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<pbwkt::Empty, GetBigBookMetadata>> GetBigNothingAsync(
            BookNameOneof name,
            st::CancellationToken cancellationToken) => GetBigNothingAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<pbwkt::Empty, GetBigBookMetadata> GetBigNothing(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => GetBigNothing(
                new GetBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<pbwkt::Empty, GetBigBookMetadata>> GetBigNothingAsync(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetBigNothingAsync(
                new GetBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<pbwkt::Empty, GetBigBookMetadata>> GetBigNothingAsync(
            string name,
            st::CancellationToken cancellationToken) => GetBigNothingAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<pbwkt::Empty, GetBigBookMetadata> GetBigNothing(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetBigNothing(
                new GetBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<pbwkt::Empty, GetBigBookMetadata>> GetBigNothingAsync(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Asynchronously poll an operation once, using an <c>operationName</c> from a previous invocation of <c>GetBigNothingAsync</c>.
        /// </summary>
        /// <param name="operationName">The name of a previously invoked operation. Must not be <c>null</c> or empty.</param>
        /// <param name="callSettings">If not null, applies overrides to this RPC call.</param>
        /// <returns>A task representing the result of polling the operation.</returns>
        public virtual stt::Task<lro::Operation<pbwkt::Empty, GetBigBookMetadata>> PollOnceGetBigNothingAsync(
            string operationName,
            gaxgrpc::CallSettings callSettings = null) => lro::Operation<pbwkt::Empty, GetBigBookMetadata>.PollOnceFromNameAsync(
                gax::GaxPreconditions.CheckNotNullOrEmpty(operationName, nameof(operationName)),
                GetBigNothingOperationsClient,
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<pbwkt::Empty, GetBigBookMetadata> GetBigNothing(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// The long-running operations client for <c>GetBigNothing</c>.
        /// </summary>
        public virtual lro::OperationsClient GetBigNothingOperationsClient
        {
            get { throw new sys::NotImplementedException(); }
        }

        /// <summary>
        /// Poll an operation once, using an <c>operationName</c> from a previous invocation of <c>GetBigNothing</c>.
        /// </summary>
        /// <param name="operationName">The name of a previously invoked operation. Must not be <c>null</c> or empty.</param>
        /// <param name="callSettings">If not null, applies overrides to this RPC call.</param>
        /// <returns>The result of polling the operation.</returns>
        public virtual lro::Operation<pbwkt::Empty, GetBigBookMetadata> PollOnceGetBigNothing(
            string operationName,
            gaxgrpc::CallSettings callSettings = null) => lro::Operation<pbwkt::Empty, GetBigBookMetadata>.PollOnceFromName(
                gax::GaxPreconditions.CheckNotNullOrEmpty(operationName, nameof(operationName)),
                GetBigNothingOperationsClient,
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            gaxgrpc::CallSettings callSettings = null) => TestOptionalRequiredFlatteningParamsAsync(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            st::CancellationToken cancellationToken) => TestOptionalRequiredFlatteningParamsAsync(
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual TestOptionalRequiredFlatteningParamsResponse TestOptionalRequiredFlatteningParams(
            gaxgrpc::CallSettings callSettings = null) => TestOptionalRequiredFlatteningParams(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="requiredSingularInt32">
        ///
        /// </param>
        /// <param name="requiredSingularInt64">
        ///
        /// </param>
        /// <param name="requiredSingularFloat">
        ///
        /// </param>
        /// <param name="requiredSingularDouble">
        ///
        /// </param>
        /// <param name="requiredSingularBool">
        ///
        /// </param>
        /// <param name="requiredSingularEnum">
        ///
        /// </param>
        /// <param name="requiredSingularString">
        ///
        /// </param>
        /// <param name="requiredSingularBytes">
        ///
        /// </param>
        /// <param name="requiredSingularMessage">
        ///
        /// </param>
        /// <param name="requiredSingularResourceName">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredSingularFixed32">
        ///
        /// </param>
        /// <param name="requiredSingularFixed64">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloat">
        ///
        /// </param>
        /// <param name="requiredRepeatedDouble">
        ///
        /// </param>
        /// <param name="requiredRepeatedBool">
        ///
        /// </param>
        /// <param name="requiredRepeatedEnum">
        ///
        /// </param>
        /// <param name="requiredRepeatedString">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytes">
        ///
        /// </param>
        /// <param name="requiredRepeatedMessage">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceName">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed32">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed64">
        ///
        /// </param>
        /// <param name="requiredMap">
        ///
        /// </param>
        /// <param name="requiredAnyValue">
        ///
        /// </param>
        /// <param name="requiredStructValue">
        ///
        /// </param>
        /// <param name="requiredValueValue">
        ///
        /// </param>
        /// <param name="requiredListValueValue">
        ///
        /// </param>
        /// <param name="requiredTimeValue">
        ///
        /// </param>
        /// <param name="requiredDurationValue">
        ///
        /// </param>
        /// <param name="requiredFieldMaskValue">
        ///
        /// </param>
        /// <param name="requiredInt32Value">
        ///
        /// </param>
        /// <param name="requiredUint32Value">
        ///
        /// </param>
        /// <param name="requiredInt64Value">
        ///
        /// </param>
        /// <param name="requiredUint64Value">
        ///
        /// </param>
        /// <param name="requiredFloatValue">
        ///
        /// </param>
        /// <param name="requiredDoubleValue">
        ///
        /// </param>
        /// <param name="requiredStringValue">
        ///
        /// </param>
        /// <param name="requiredBoolValue">
        ///
        /// </param>
        /// <param name="requiredBytesValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedAnyValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedStructValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedValueValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedListValueValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedTimeValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedDurationValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedFieldMaskValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedUint32Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedUint64Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloatValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedDoubleValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedStringValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedBoolValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytesValue">
        ///
        /// </param>
        /// <param name="optionalSingularInt32">
        ///
        /// </param>
        /// <param name="optionalSingularInt64">
        ///
        /// </param>
        /// <param name="optionalSingularFloat">
        ///
        /// </param>
        /// <param name="optionalSingularDouble">
        ///
        /// </param>
        /// <param name="optionalSingularBool">
        ///
        /// </param>
        /// <param name="optionalSingularEnum">
        ///
        /// </param>
        /// <param name="optionalSingularString">
        ///
        /// </param>
        /// <param name="optionalSingularBytes">
        ///
        /// </param>
        /// <param name="optionalSingularMessage">
        ///
        /// </param>
        /// <param name="optionalSingularResourceName">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalSingularFixed32">
        ///
        /// </param>
        /// <param name="optionalSingularFixed64">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt32">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt64">
        ///
        /// </param>
        /// <param name="optionalRepeatedFloat">
        ///
        /// </param>
        /// <param name="optionalRepeatedDouble">
        ///
        /// </param>
        /// <param name="optionalRepeatedBool">
        ///
        /// </param>
        /// <param name="optionalRepeatedEnum">
        ///
        /// </param>
        /// <param name="optionalRepeatedString">
        ///
        /// </param>
        /// <param name="optionalRepeatedBytes">
        ///
        /// </param>
        /// <param name="optionalRepeatedMessage">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceName">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed32">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed64">
        ///
        /// </param>
        /// <param name="optionalMap">
        ///
        /// </param>
        /// <param name="anyValue">
        ///
        /// </param>
        /// <param name="structValue">
        ///
        /// </param>
        /// <param name="valueValue">
        ///
        /// </param>
        /// <param name="listValueValue">
        ///
        /// </param>
        /// <param name="timeValue">
        ///
        /// </param>
        /// <param name="durationValue">
        ///
        /// </param>
        /// <param name="fieldMaskValue">
        ///
        /// </param>
        /// <param name="int32Value">
        ///
        /// </param>
        /// <param name="uint32Value">
        ///
        /// </param>
        /// <param name="int64Value">
        ///
        /// </param>
        /// <param name="uint64Value">
        ///
        /// </param>
        /// <param name="floatValue">
        ///
        /// </param>
        /// <param name="doubleValue">
        ///
        /// </param>
        /// <param name="stringValue">
        ///
        /// </param>
        /// <param name="boolValue">
        ///
        /// </param>
        /// <param name="bytesValue">
        ///
        /// </param>
        /// <param name="repeatedAnyValue">
        ///
        /// </param>
        /// <param name="repeatedStructValue">
        ///
        /// </param>
        /// <param name="repeatedValueValue">
        ///
        /// </param>
        /// <param name="repeatedListValueValue">
        ///
        /// </param>
        /// <param name="repeatedTimeValue">
        ///
        /// </param>
        /// <param name="repeatedDurationValue">
        ///
        /// </param>
        /// <param name="repeatedFieldMaskValue">
        ///
        /// </param>
        /// <param name="repeatedInt32Value">
        ///
        /// </param>
        /// <param name="repeatedUint32Value">
        ///
        /// </param>
        /// <param name="repeatedInt64Value">
        ///
        /// </param>
        /// <param name="repeatedUint64Value">
        ///
        /// </param>
        /// <param name="repeatedFloatValue">
        ///
        /// </param>
        /// <param name="repeatedDoubleValue">
        ///
        /// </param>
        /// <param name="repeatedStringValue">
        ///
        /// </param>
        /// <param name="repeatedBoolValue">
        ///
        /// </param>
        /// <param name="repeatedBytesValue">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            int requiredSingularInt32,
            long requiredSingularInt64,
            float requiredSingularFloat,
            double requiredSingularDouble,
            bool requiredSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum,
            string requiredSingularString,
            pb::ByteString requiredSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage,
            BookNameOneof requiredSingularResourceName,
            BookNameOneof requiredSingularResourceNameOneof,
            string requiredSingularResourceNameCommon,
            int requiredSingularFixed32,
            long requiredSingularFixed64,
            scg::IEnumerable<int> requiredRepeatedInt32,
            scg::IEnumerable<long> requiredRepeatedInt64,
            scg::IEnumerable<float> requiredRepeatedFloat,
            scg::IEnumerable<double> requiredRepeatedDouble,
            scg::IEnumerable<bool> requiredRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum,
            scg::IEnumerable<string> requiredRepeatedString,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage,
            scg::IEnumerable<BookNameOneof> requiredRepeatedResourceName,
            scg::IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof,
            scg::IEnumerable<string> requiredRepeatedResourceNameCommon,
            scg::IEnumerable<int> requiredRepeatedFixed32,
            scg::IEnumerable<long> requiredRepeatedFixed64,
            scg::IDictionary<int, string> requiredMap,
            pbwkt::Any requiredAnyValue,
            pbwkt::Struct requiredStructValue,
            pbwkt::Value requiredValueValue,
            pbwkt::ListValue requiredListValueValue,
            pbwkt::Timestamp requiredTimeValue,
            pbwkt::Duration requiredDurationValue,
            pbwkt::FieldMask requiredFieldMaskValue,
            int? requiredInt32Value,
            uint? requiredUint32Value,
            long? requiredInt64Value,
            ulong? requiredUint64Value,
            float? requiredFloatValue,
            double? requiredDoubleValue,
            string requiredStringValue,
            bool? requiredBoolValue,
            pb::ByteString requiredBytesValue,
            scg::IEnumerable<pbwkt::Any> requiredRepeatedAnyValue,
            scg::IEnumerable<pbwkt::Struct> requiredRepeatedStructValue,
            scg::IEnumerable<pbwkt::Value> requiredRepeatedValueValue,
            scg::IEnumerable<pbwkt::ListValue> requiredRepeatedListValueValue,
            scg::IEnumerable<pbwkt::Timestamp> requiredRepeatedTimeValue,
            scg::IEnumerable<pbwkt::Duration> requiredRepeatedDurationValue,
            scg::IEnumerable<pbwkt::FieldMask> requiredRepeatedFieldMaskValue,
            scg::IEnumerable<int?> requiredRepeatedInt32Value,
            scg::IEnumerable<uint?> requiredRepeatedUint32Value,
            scg::IEnumerable<long?> requiredRepeatedInt64Value,
            scg::IEnumerable<ulong?> requiredRepeatedUint64Value,
            scg::IEnumerable<float?> requiredRepeatedFloatValue,
            scg::IEnumerable<double?> requiredRepeatedDoubleValue,
            scg::IEnumerable<string> requiredRepeatedStringValue,
            scg::IEnumerable<bool?> requiredRepeatedBoolValue,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytesValue,
            int? optionalSingularInt32,
            long? optionalSingularInt64,
            float? optionalSingularFloat,
            double? optionalSingularDouble,
            bool? optionalSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum? optionalSingularEnum,
            string optionalSingularString,
            pb::ByteString optionalSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage,
            BookNameOneof optionalSingularResourceName,
            BookNameOneof optionalSingularResourceNameOneof,
            string optionalSingularResourceNameCommon,
            int? optionalSingularFixed32,
            long? optionalSingularFixed64,
            scg::IEnumerable<int> optionalRepeatedInt32,
            scg::IEnumerable<long> optionalRepeatedInt64,
            scg::IEnumerable<float> optionalRepeatedFloat,
            scg::IEnumerable<double> optionalRepeatedDouble,
            scg::IEnumerable<bool> optionalRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum,
            scg::IEnumerable<string> optionalRepeatedString,
            scg::IEnumerable<pb::ByteString> optionalRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage,
            scg::IEnumerable<BookNameOneof> optionalRepeatedResourceName,
            scg::IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof,
            scg::IEnumerable<string> optionalRepeatedResourceNameCommon,
            scg::IEnumerable<int> optionalRepeatedFixed32,
            scg::IEnumerable<long> optionalRepeatedFixed64,
            scg::IDictionary<int, string> optionalMap,
            pbwkt::Any anyValue,
            pbwkt::Struct structValue,
            pbwkt::Value valueValue,
            pbwkt::ListValue listValueValue,
            pbwkt::Timestamp timeValue,
            pbwkt::Duration durationValue,
            pbwkt::FieldMask fieldMaskValue,
            int? int32Value,
            uint? uint32Value,
            long? int64Value,
            ulong? uint64Value,
            float? floatValue,
            double? doubleValue,
            string stringValue,
            bool? boolValue,
            pb::ByteString bytesValue,
            scg::IEnumerable<pbwkt::Any> repeatedAnyValue,
            scg::IEnumerable<pbwkt::Struct> repeatedStructValue,
            scg::IEnumerable<pbwkt::Value> repeatedValueValue,
            scg::IEnumerable<pbwkt::ListValue> repeatedListValueValue,
            scg::IEnumerable<pbwkt::Timestamp> repeatedTimeValue,
            scg::IEnumerable<pbwkt::Duration> repeatedDurationValue,
            scg::IEnumerable<pbwkt::FieldMask> repeatedFieldMaskValue,
            scg::IEnumerable<int?> repeatedInt32Value,
            scg::IEnumerable<uint?> repeatedUint32Value,
            scg::IEnumerable<long?> repeatedInt64Value,
            scg::IEnumerable<ulong?> repeatedUint64Value,
            scg::IEnumerable<float?> repeatedFloatValue,
            scg::IEnumerable<double?> repeatedDoubleValue,
            scg::IEnumerable<string> repeatedStringValue,
            scg::IEnumerable<bool?> repeatedBoolValue,
            scg::IEnumerable<pb::ByteString> repeatedBytesValue,
            gaxgrpc::CallSettings callSettings = null) => TestOptionalRequiredFlatteningParamsAsync(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                    RequiredSingularInt32 = requiredSingularInt32,
                    RequiredSingularInt64 = requiredSingularInt64,
                    RequiredSingularFloat = requiredSingularFloat,
                    RequiredSingularDouble = requiredSingularDouble,
                    RequiredSingularBool = requiredSingularBool,
                    RequiredSingularEnum = requiredSingularEnum,
                    RequiredSingularString = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularString, nameof(requiredSingularString)),
                    RequiredSingularBytes = gax::GaxPreconditions.CheckNotNull(requiredSingularBytes, nameof(requiredSingularBytes)),
                    RequiredSingularMessage = gax::GaxPreconditions.CheckNotNull(requiredSingularMessage, nameof(requiredSingularMessage)),
                    RequiredSingularResourceNameAsBookNameOneof = gax::GaxPreconditions.CheckNotNull(requiredSingularResourceName, nameof(requiredSingularResourceName)),
                    RequiredSingularResourceNameOneofAsBookNameOneof = gax::GaxPreconditions.CheckNotNull(requiredSingularResourceNameOneof, nameof(requiredSingularResourceNameOneof)),
                    RequiredSingularResourceNameCommon = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularResourceNameCommon, nameof(requiredSingularResourceNameCommon)),
                    RequiredSingularFixed32 = requiredSingularFixed32,
                    RequiredSingularFixed64 = requiredSingularFixed64,
                    RequiredRepeatedInt32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt32, nameof(requiredRepeatedInt32)) },
                    RequiredRepeatedInt64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt64, nameof(requiredRepeatedInt64)) },
                    RequiredRepeatedFloat = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFloat, nameof(requiredRepeatedFloat)) },
                    RequiredRepeatedDouble = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedDouble, nameof(requiredRepeatedDouble)) },
                    RequiredRepeatedBool = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBool, nameof(requiredRepeatedBool)) },
                    RequiredRepeatedEnum = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedEnum, nameof(requiredRepeatedEnum)) },
                    RequiredRepeatedString = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedString, nameof(requiredRepeatedString)) },
                    RequiredRepeatedBytes = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBytes, nameof(requiredRepeatedBytes)) },
                    RequiredRepeatedMessage = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedMessage, nameof(requiredRepeatedMessage)) },
                    RequiredRepeatedResourceNameAsBookNameOneofs = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceName, nameof(requiredRepeatedResourceName)) },
                    RequiredRepeatedResourceNameOneofAsBookNameOneofs = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameOneof, nameof(requiredRepeatedResourceNameOneof)) },
                    RequiredRepeatedResourceNameCommon = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameCommon, nameof(requiredRepeatedResourceNameCommon)) },
                    RequiredRepeatedFixed32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed32, nameof(requiredRepeatedFixed32)) },
                    RequiredRepeatedFixed64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed64, nameof(requiredRepeatedFixed64)) },
                    RequiredMap = { gax::GaxPreconditions.CheckNotNull(requiredMap, nameof(requiredMap)) },
                    RequiredAnyValue = gax::GaxPreconditions.CheckNotNull(requiredAnyValue, nameof(requiredAnyValue)),
                    RequiredStructValue = gax::GaxPreconditions.CheckNotNull(requiredStructValue, nameof(requiredStructValue)),
                    RequiredValueValue = gax::GaxPreconditions.CheckNotNull(requiredValueValue, nameof(requiredValueValue)),
                    RequiredListValueValue = gax::GaxPreconditions.CheckNotNull(requiredListValueValue, nameof(requiredListValueValue)),
                    RequiredTimeValue = gax::GaxPreconditions.CheckNotNull(requiredTimeValue, nameof(requiredTimeValue)),
                    RequiredDurationValue = gax::GaxPreconditions.CheckNotNull(requiredDurationValue, nameof(requiredDurationValue)),
                    RequiredFieldMaskValue = gax::GaxPreconditions.CheckNotNull(requiredFieldMaskValue, nameof(requiredFieldMaskValue)),
                    RequiredInt32Value = requiredInt32Value ?? throw new sys::ArgumentNullException(nameof(requiredInt32Value)),
                    RequiredUint32Value = requiredUint32Value ?? throw new sys::ArgumentNullException(nameof(requiredUint32Value)),
                    RequiredInt64Value = requiredInt64Value ?? throw new sys::ArgumentNullException(nameof(requiredInt64Value)),
                    RequiredUint64Value = requiredUint64Value ?? throw new sys::ArgumentNullException(nameof(requiredUint64Value)),
                    RequiredFloatValue = requiredFloatValue ?? throw new sys::ArgumentNullException(nameof(requiredFloatValue)),
                    RequiredDoubleValue = requiredDoubleValue ?? throw new sys::ArgumentNullException(nameof(requiredDoubleValue)),
                    RequiredStringValue = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredStringValue, nameof(requiredStringValue)),
                    RequiredBoolValue = requiredBoolValue ?? throw new sys::ArgumentNullException(nameof(requiredBoolValue)),
                    RequiredBytesValue = gax::GaxPreconditions.CheckNotNull(requiredBytesValue, nameof(requiredBytesValue)),
                    RequiredRepeatedAnyValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedAnyValue, nameof(requiredRepeatedAnyValue)) },
                    RequiredRepeatedStructValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedStructValue, nameof(requiredRepeatedStructValue)) },
                    RequiredRepeatedValueValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedValueValue, nameof(requiredRepeatedValueValue)) },
                    RequiredRepeatedListValueValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedListValueValue, nameof(requiredRepeatedListValueValue)) },
                    RequiredRepeatedTimeValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedTimeValue, nameof(requiredRepeatedTimeValue)) },
                    RequiredRepeatedDurationValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedDurationValue, nameof(requiredRepeatedDurationValue)) },
                    RequiredRepeatedFieldMaskValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFieldMaskValue, nameof(requiredRepeatedFieldMaskValue)) },
                    RequiredRepeatedInt32Value = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt32Value, nameof(requiredRepeatedInt32Value)) },
                    RequiredRepeatedUint32Value = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedUint32Value, nameof(requiredRepeatedUint32Value)) },
                    RequiredRepeatedInt64Value = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt64Value, nameof(requiredRepeatedInt64Value)) },
                    RequiredRepeatedUint64Value = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedUint64Value, nameof(requiredRepeatedUint64Value)) },
                    RequiredRepeatedFloatValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFloatValue, nameof(requiredRepeatedFloatValue)) },
                    RequiredRepeatedDoubleValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedDoubleValue, nameof(requiredRepeatedDoubleValue)) },
                    RequiredRepeatedStringValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedStringValue, nameof(requiredRepeatedStringValue)) },
                    RequiredRepeatedBoolValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBoolValue, nameof(requiredRepeatedBoolValue)) },
                    RequiredRepeatedBytesValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBytesValue, nameof(requiredRepeatedBytesValue)) },
                    OptionalSingularInt32 = optionalSingularInt32 ?? 0, // Optional
                    OptionalSingularInt64 = optionalSingularInt64 ?? 0L, // Optional
                    OptionalSingularFloat = optionalSingularFloat ?? 0.0f, // Optional
                    OptionalSingularDouble = optionalSingularDouble ?? 0.0, // Optional
                    OptionalSingularBool = optionalSingularBool ?? false, // Optional
                    OptionalSingularEnum = optionalSingularEnum ?? TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero, // Optional
                    OptionalSingularString = optionalSingularString ?? "", // Optional
                    OptionalSingularBytes = optionalSingularBytes ?? pb::ByteString.Empty, // Optional
                    OptionalSingularMessage = optionalSingularMessage, // Optional
                    OptionalSingularResourceNameAsBookNameOneof = optionalSingularResourceName, // Optional
                    OptionalSingularResourceNameOneofAsBookNameOneof = optionalSingularResourceNameOneof, // Optional
                    OptionalSingularResourceNameCommon = optionalSingularResourceNameCommon ?? "", // Optional
                    OptionalSingularFixed32 = optionalSingularFixed32 ?? 0, // Optional
                    OptionalSingularFixed64 = optionalSingularFixed64 ?? 0L, // Optional
                    OptionalRepeatedInt32 = { optionalRepeatedInt32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedInt64 = { optionalRepeatedInt64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalRepeatedFloat = { optionalRepeatedFloat ?? linq::Enumerable.Empty<float>() }, // Optional
                    OptionalRepeatedDouble = { optionalRepeatedDouble ?? linq::Enumerable.Empty<double>() }, // Optional
                    OptionalRepeatedBool = { optionalRepeatedBool ?? linq::Enumerable.Empty<bool>() }, // Optional
                    OptionalRepeatedEnum = { optionalRepeatedEnum ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>() }, // Optional
                    OptionalRepeatedString = { optionalRepeatedString ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedBytes = { optionalRepeatedBytes ?? linq::Enumerable.Empty<pb::ByteString>() }, // Optional
                    OptionalRepeatedMessage = { optionalRepeatedMessage ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>() }, // Optional
                    OptionalRepeatedResourceNameAsBookNameOneofs = { optionalRepeatedResourceName ?? linq::Enumerable.Empty<BookNameOneof>() }, // Optional
                    OptionalRepeatedResourceNameOneofAsBookNameOneofs = { optionalRepeatedResourceNameOneof ?? linq::Enumerable.Empty<BookNameOneof>() }, // Optional
                    OptionalRepeatedResourceNameCommon = { optionalRepeatedResourceNameCommon ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedFixed32 = { optionalRepeatedFixed32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedFixed64 = { optionalRepeatedFixed64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalMap = { optionalMap ?? gax::EmptyDictionary<int, string>.Instance }, // Optional
                    AnyValue = anyValue, // Optional
                    StructValue = structValue, // Optional
                    ValueValue = valueValue, // Optional
                    ListValueValue = listValueValue, // Optional
                    TimeValue = timeValue, // Optional
                    DurationValue = durationValue, // Optional
                    FieldMaskValue = fieldMaskValue, // Optional
                    Int32Value = int32Value, // Optional
                    Uint32Value = uint32Value, // Optional
                    Int64Value = int64Value, // Optional
                    Uint64Value = uint64Value, // Optional
                    FloatValue = floatValue, // Optional
                    DoubleValue = doubleValue, // Optional
                    StringValue = stringValue, // Optional
                    BoolValue = boolValue, // Optional
                    BytesValue = bytesValue, // Optional
                    RepeatedAnyValue = { repeatedAnyValue ?? linq::Enumerable.Empty<pbwkt::Any>() }, // Optional
                    RepeatedStructValue = { repeatedStructValue ?? linq::Enumerable.Empty<pbwkt::Struct>() }, // Optional
                    RepeatedValueValue = { repeatedValueValue ?? linq::Enumerable.Empty<pbwkt::Value>() }, // Optional
                    RepeatedListValueValue = { repeatedListValueValue ?? linq::Enumerable.Empty<pbwkt::ListValue>() }, // Optional
                    RepeatedTimeValue = { repeatedTimeValue ?? linq::Enumerable.Empty<pbwkt::Timestamp>() }, // Optional
                    RepeatedDurationValue = { repeatedDurationValue ?? linq::Enumerable.Empty<pbwkt::Duration>() }, // Optional
                    RepeatedFieldMaskValue = { repeatedFieldMaskValue ?? linq::Enumerable.Empty<pbwkt::FieldMask>() }, // Optional
                    RepeatedInt32Value = { repeatedInt32Value ?? linq::Enumerable.Empty<int?>() }, // Optional
                    RepeatedUint32Value = { repeatedUint32Value ?? linq::Enumerable.Empty<uint?>() }, // Optional
                    RepeatedInt64Value = { repeatedInt64Value ?? linq::Enumerable.Empty<long?>() }, // Optional
                    RepeatedUint64Value = { repeatedUint64Value ?? linq::Enumerable.Empty<ulong?>() }, // Optional
                    RepeatedFloatValue = { repeatedFloatValue ?? linq::Enumerable.Empty<float?>() }, // Optional
                    RepeatedDoubleValue = { repeatedDoubleValue ?? linq::Enumerable.Empty<double?>() }, // Optional
                    RepeatedStringValue = { repeatedStringValue ?? linq::Enumerable.Empty<string>() }, // Optional
                    RepeatedBoolValue = { repeatedBoolValue ?? linq::Enumerable.Empty<bool?>() }, // Optional
                    RepeatedBytesValue = { repeatedBytesValue ?? linq::Enumerable.Empty<pb::ByteString>() }, // Optional
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="requiredSingularInt32">
        ///
        /// </param>
        /// <param name="requiredSingularInt64">
        ///
        /// </param>
        /// <param name="requiredSingularFloat">
        ///
        /// </param>
        /// <param name="requiredSingularDouble">
        ///
        /// </param>
        /// <param name="requiredSingularBool">
        ///
        /// </param>
        /// <param name="requiredSingularEnum">
        ///
        /// </param>
        /// <param name="requiredSingularString">
        ///
        /// </param>
        /// <param name="requiredSingularBytes">
        ///
        /// </param>
        /// <param name="requiredSingularMessage">
        ///
        /// </param>
        /// <param name="requiredSingularResourceName">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredSingularFixed32">
        ///
        /// </param>
        /// <param name="requiredSingularFixed64">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloat">
        ///
        /// </param>
        /// <param name="requiredRepeatedDouble">
        ///
        /// </param>
        /// <param name="requiredRepeatedBool">
        ///
        /// </param>
        /// <param name="requiredRepeatedEnum">
        ///
        /// </param>
        /// <param name="requiredRepeatedString">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytes">
        ///
        /// </param>
        /// <param name="requiredRepeatedMessage">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceName">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed32">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed64">
        ///
        /// </param>
        /// <param name="requiredMap">
        ///
        /// </param>
        /// <param name="requiredAnyValue">
        ///
        /// </param>
        /// <param name="requiredStructValue">
        ///
        /// </param>
        /// <param name="requiredValueValue">
        ///
        /// </param>
        /// <param name="requiredListValueValue">
        ///
        /// </param>
        /// <param name="requiredTimeValue">
        ///
        /// </param>
        /// <param name="requiredDurationValue">
        ///
        /// </param>
        /// <param name="requiredFieldMaskValue">
        ///
        /// </param>
        /// <param name="requiredInt32Value">
        ///
        /// </param>
        /// <param name="requiredUint32Value">
        ///
        /// </param>
        /// <param name="requiredInt64Value">
        ///
        /// </param>
        /// <param name="requiredUint64Value">
        ///
        /// </param>
        /// <param name="requiredFloatValue">
        ///
        /// </param>
        /// <param name="requiredDoubleValue">
        ///
        /// </param>
        /// <param name="requiredStringValue">
        ///
        /// </param>
        /// <param name="requiredBoolValue">
        ///
        /// </param>
        /// <param name="requiredBytesValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedAnyValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedStructValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedValueValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedListValueValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedTimeValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedDurationValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedFieldMaskValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedUint32Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedUint64Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloatValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedDoubleValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedStringValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedBoolValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytesValue">
        ///
        /// </param>
        /// <param name="optionalSingularInt32">
        ///
        /// </param>
        /// <param name="optionalSingularInt64">
        ///
        /// </param>
        /// <param name="optionalSingularFloat">
        ///
        /// </param>
        /// <param name="optionalSingularDouble">
        ///
        /// </param>
        /// <param name="optionalSingularBool">
        ///
        /// </param>
        /// <param name="optionalSingularEnum">
        ///
        /// </param>
        /// <param name="optionalSingularString">
        ///
        /// </param>
        /// <param name="optionalSingularBytes">
        ///
        /// </param>
        /// <param name="optionalSingularMessage">
        ///
        /// </param>
        /// <param name="optionalSingularResourceName">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalSingularFixed32">
        ///
        /// </param>
        /// <param name="optionalSingularFixed64">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt32">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt64">
        ///
        /// </param>
        /// <param name="optionalRepeatedFloat">
        ///
        /// </param>
        /// <param name="optionalRepeatedDouble">
        ///
        /// </param>
        /// <param name="optionalRepeatedBool">
        ///
        /// </param>
        /// <param name="optionalRepeatedEnum">
        ///
        /// </param>
        /// <param name="optionalRepeatedString">
        ///
        /// </param>
        /// <param name="optionalRepeatedBytes">
        ///
        /// </param>
        /// <param name="optionalRepeatedMessage">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceName">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed32">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed64">
        ///
        /// </param>
        /// <param name="optionalMap">
        ///
        /// </param>
        /// <param name="anyValue">
        ///
        /// </param>
        /// <param name="structValue">
        ///
        /// </param>
        /// <param name="valueValue">
        ///
        /// </param>
        /// <param name="listValueValue">
        ///
        /// </param>
        /// <param name="timeValue">
        ///
        /// </param>
        /// <param name="durationValue">
        ///
        /// </param>
        /// <param name="fieldMaskValue">
        ///
        /// </param>
        /// <param name="int32Value">
        ///
        /// </param>
        /// <param name="uint32Value">
        ///
        /// </param>
        /// <param name="int64Value">
        ///
        /// </param>
        /// <param name="uint64Value">
        ///
        /// </param>
        /// <param name="floatValue">
        ///
        /// </param>
        /// <param name="doubleValue">
        ///
        /// </param>
        /// <param name="stringValue">
        ///
        /// </param>
        /// <param name="boolValue">
        ///
        /// </param>
        /// <param name="bytesValue">
        ///
        /// </param>
        /// <param name="repeatedAnyValue">
        ///
        /// </param>
        /// <param name="repeatedStructValue">
        ///
        /// </param>
        /// <param name="repeatedValueValue">
        ///
        /// </param>
        /// <param name="repeatedListValueValue">
        ///
        /// </param>
        /// <param name="repeatedTimeValue">
        ///
        /// </param>
        /// <param name="repeatedDurationValue">
        ///
        /// </param>
        /// <param name="repeatedFieldMaskValue">
        ///
        /// </param>
        /// <param name="repeatedInt32Value">
        ///
        /// </param>
        /// <param name="repeatedUint32Value">
        ///
        /// </param>
        /// <param name="repeatedInt64Value">
        ///
        /// </param>
        /// <param name="repeatedUint64Value">
        ///
        /// </param>
        /// <param name="repeatedFloatValue">
        ///
        /// </param>
        /// <param name="repeatedDoubleValue">
        ///
        /// </param>
        /// <param name="repeatedStringValue">
        ///
        /// </param>
        /// <param name="repeatedBoolValue">
        ///
        /// </param>
        /// <param name="repeatedBytesValue">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            int requiredSingularInt32,
            long requiredSingularInt64,
            float requiredSingularFloat,
            double requiredSingularDouble,
            bool requiredSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum,
            string requiredSingularString,
            pb::ByteString requiredSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage,
            BookNameOneof requiredSingularResourceName,
            BookNameOneof requiredSingularResourceNameOneof,
            string requiredSingularResourceNameCommon,
            int requiredSingularFixed32,
            long requiredSingularFixed64,
            scg::IEnumerable<int> requiredRepeatedInt32,
            scg::IEnumerable<long> requiredRepeatedInt64,
            scg::IEnumerable<float> requiredRepeatedFloat,
            scg::IEnumerable<double> requiredRepeatedDouble,
            scg::IEnumerable<bool> requiredRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum,
            scg::IEnumerable<string> requiredRepeatedString,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage,
            scg::IEnumerable<BookNameOneof> requiredRepeatedResourceName,
            scg::IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof,
            scg::IEnumerable<string> requiredRepeatedResourceNameCommon,
            scg::IEnumerable<int> requiredRepeatedFixed32,
            scg::IEnumerable<long> requiredRepeatedFixed64,
            scg::IDictionary<int, string> requiredMap,
            pbwkt::Any requiredAnyValue,
            pbwkt::Struct requiredStructValue,
            pbwkt::Value requiredValueValue,
            pbwkt::ListValue requiredListValueValue,
            pbwkt::Timestamp requiredTimeValue,
            pbwkt::Duration requiredDurationValue,
            pbwkt::FieldMask requiredFieldMaskValue,
            int? requiredInt32Value,
            uint? requiredUint32Value,
            long? requiredInt64Value,
            ulong? requiredUint64Value,
            float? requiredFloatValue,
            double? requiredDoubleValue,
            string requiredStringValue,
            bool? requiredBoolValue,
            pb::ByteString requiredBytesValue,
            scg::IEnumerable<pbwkt::Any> requiredRepeatedAnyValue,
            scg::IEnumerable<pbwkt::Struct> requiredRepeatedStructValue,
            scg::IEnumerable<pbwkt::Value> requiredRepeatedValueValue,
            scg::IEnumerable<pbwkt::ListValue> requiredRepeatedListValueValue,
            scg::IEnumerable<pbwkt::Timestamp> requiredRepeatedTimeValue,
            scg::IEnumerable<pbwkt::Duration> requiredRepeatedDurationValue,
            scg::IEnumerable<pbwkt::FieldMask> requiredRepeatedFieldMaskValue,
            scg::IEnumerable<int?> requiredRepeatedInt32Value,
            scg::IEnumerable<uint?> requiredRepeatedUint32Value,
            scg::IEnumerable<long?> requiredRepeatedInt64Value,
            scg::IEnumerable<ulong?> requiredRepeatedUint64Value,
            scg::IEnumerable<float?> requiredRepeatedFloatValue,
            scg::IEnumerable<double?> requiredRepeatedDoubleValue,
            scg::IEnumerable<string> requiredRepeatedStringValue,
            scg::IEnumerable<bool?> requiredRepeatedBoolValue,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytesValue,
            int? optionalSingularInt32,
            long? optionalSingularInt64,
            float? optionalSingularFloat,
            double? optionalSingularDouble,
            bool? optionalSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum? optionalSingularEnum,
            string optionalSingularString,
            pb::ByteString optionalSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage,
            BookNameOneof optionalSingularResourceName,
            BookNameOneof optionalSingularResourceNameOneof,
            string optionalSingularResourceNameCommon,
            int? optionalSingularFixed32,
            long? optionalSingularFixed64,
            scg::IEnumerable<int> optionalRepeatedInt32,
            scg::IEnumerable<long> optionalRepeatedInt64,
            scg::IEnumerable<float> optionalRepeatedFloat,
            scg::IEnumerable<double> optionalRepeatedDouble,
            scg::IEnumerable<bool> optionalRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum,
            scg::IEnumerable<string> optionalRepeatedString,
            scg::IEnumerable<pb::ByteString> optionalRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage,
            scg::IEnumerable<BookNameOneof> optionalRepeatedResourceName,
            scg::IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof,
            scg::IEnumerable<string> optionalRepeatedResourceNameCommon,
            scg::IEnumerable<int> optionalRepeatedFixed32,
            scg::IEnumerable<long> optionalRepeatedFixed64,
            scg::IDictionary<int, string> optionalMap,
            pbwkt::Any anyValue,
            pbwkt::Struct structValue,
            pbwkt::Value valueValue,
            pbwkt::ListValue listValueValue,
            pbwkt::Timestamp timeValue,
            pbwkt::Duration durationValue,
            pbwkt::FieldMask fieldMaskValue,
            int? int32Value,
            uint? uint32Value,
            long? int64Value,
            ulong? uint64Value,
            float? floatValue,
            double? doubleValue,
            string stringValue,
            bool? boolValue,
            pb::ByteString bytesValue,
            scg::IEnumerable<pbwkt::Any> repeatedAnyValue,
            scg::IEnumerable<pbwkt::Struct> repeatedStructValue,
            scg::IEnumerable<pbwkt::Value> repeatedValueValue,
            scg::IEnumerable<pbwkt::ListValue> repeatedListValueValue,
            scg::IEnumerable<pbwkt::Timestamp> repeatedTimeValue,
            scg::IEnumerable<pbwkt::Duration> repeatedDurationValue,
            scg::IEnumerable<pbwkt::FieldMask> repeatedFieldMaskValue,
            scg::IEnumerable<int?> repeatedInt32Value,
            scg::IEnumerable<uint?> repeatedUint32Value,
            scg::IEnumerable<long?> repeatedInt64Value,
            scg::IEnumerable<ulong?> repeatedUint64Value,
            scg::IEnumerable<float?> repeatedFloatValue,
            scg::IEnumerable<double?> repeatedDoubleValue,
            scg::IEnumerable<string> repeatedStringValue,
            scg::IEnumerable<bool?> repeatedBoolValue,
            scg::IEnumerable<pb::ByteString> repeatedBytesValue,
            st::CancellationToken cancellationToken) => TestOptionalRequiredFlatteningParamsAsync(
                requiredSingularInt32,
                requiredSingularInt64,
                requiredSingularFloat,
                requiredSingularDouble,
                requiredSingularBool,
                requiredSingularEnum,
                requiredSingularString,
                requiredSingularBytes,
                requiredSingularMessage,
                requiredSingularResourceName,
                requiredSingularResourceNameOneof,
                requiredSingularResourceNameCommon,
                requiredSingularFixed32,
                requiredSingularFixed64,
                requiredRepeatedInt32,
                requiredRepeatedInt64,
                requiredRepeatedFloat,
                requiredRepeatedDouble,
                requiredRepeatedBool,
                requiredRepeatedEnum,
                requiredRepeatedString,
                requiredRepeatedBytes,
                requiredRepeatedMessage,
                requiredRepeatedResourceName,
                requiredRepeatedResourceNameOneof,
                requiredRepeatedResourceNameCommon,
                requiredRepeatedFixed32,
                requiredRepeatedFixed64,
                requiredMap,
                requiredAnyValue,
                requiredStructValue,
                requiredValueValue,
                requiredListValueValue,
                requiredTimeValue,
                requiredDurationValue,
                requiredFieldMaskValue,
                requiredInt32Value,
                requiredUint32Value,
                requiredInt64Value,
                requiredUint64Value,
                requiredFloatValue,
                requiredDoubleValue,
                requiredStringValue,
                requiredBoolValue,
                requiredBytesValue,
                requiredRepeatedAnyValue,
                requiredRepeatedStructValue,
                requiredRepeatedValueValue,
                requiredRepeatedListValueValue,
                requiredRepeatedTimeValue,
                requiredRepeatedDurationValue,
                requiredRepeatedFieldMaskValue,
                requiredRepeatedInt32Value,
                requiredRepeatedUint32Value,
                requiredRepeatedInt64Value,
                requiredRepeatedUint64Value,
                requiredRepeatedFloatValue,
                requiredRepeatedDoubleValue,
                requiredRepeatedStringValue,
                requiredRepeatedBoolValue,
                requiredRepeatedBytesValue,
                optionalSingularInt32,
                optionalSingularInt64,
                optionalSingularFloat,
                optionalSingularDouble,
                optionalSingularBool,
                optionalSingularEnum,
                optionalSingularString,
                optionalSingularBytes,
                optionalSingularMessage,
                optionalSingularResourceName,
                optionalSingularResourceNameOneof,
                optionalSingularResourceNameCommon,
                optionalSingularFixed32,
                optionalSingularFixed64,
                optionalRepeatedInt32,
                optionalRepeatedInt64,
                optionalRepeatedFloat,
                optionalRepeatedDouble,
                optionalRepeatedBool,
                optionalRepeatedEnum,
                optionalRepeatedString,
                optionalRepeatedBytes,
                optionalRepeatedMessage,
                optionalRepeatedResourceName,
                optionalRepeatedResourceNameOneof,
                optionalRepeatedResourceNameCommon,
                optionalRepeatedFixed32,
                optionalRepeatedFixed64,
                optionalMap,
                anyValue,
                structValue,
                valueValue,
                listValueValue,
                timeValue,
                durationValue,
                fieldMaskValue,
                int32Value,
                uint32Value,
                int64Value,
                uint64Value,
                floatValue,
                doubleValue,
                stringValue,
                boolValue,
                bytesValue,
                repeatedAnyValue,
                repeatedStructValue,
                repeatedValueValue,
                repeatedListValueValue,
                repeatedTimeValue,
                repeatedDurationValue,
                repeatedFieldMaskValue,
                repeatedInt32Value,
                repeatedUint32Value,
                repeatedInt64Value,
                repeatedUint64Value,
                repeatedFloatValue,
                repeatedDoubleValue,
                repeatedStringValue,
                repeatedBoolValue,
                repeatedBytesValue,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="requiredSingularInt32">
        ///
        /// </param>
        /// <param name="requiredSingularInt64">
        ///
        /// </param>
        /// <param name="requiredSingularFloat">
        ///
        /// </param>
        /// <param name="requiredSingularDouble">
        ///
        /// </param>
        /// <param name="requiredSingularBool">
        ///
        /// </param>
        /// <param name="requiredSingularEnum">
        ///
        /// </param>
        /// <param name="requiredSingularString">
        ///
        /// </param>
        /// <param name="requiredSingularBytes">
        ///
        /// </param>
        /// <param name="requiredSingularMessage">
        ///
        /// </param>
        /// <param name="requiredSingularResourceName">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredSingularFixed32">
        ///
        /// </param>
        /// <param name="requiredSingularFixed64">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloat">
        ///
        /// </param>
        /// <param name="requiredRepeatedDouble">
        ///
        /// </param>
        /// <param name="requiredRepeatedBool">
        ///
        /// </param>
        /// <param name="requiredRepeatedEnum">
        ///
        /// </param>
        /// <param name="requiredRepeatedString">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytes">
        ///
        /// </param>
        /// <param name="requiredRepeatedMessage">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceName">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed32">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed64">
        ///
        /// </param>
        /// <param name="requiredMap">
        ///
        /// </param>
        /// <param name="requiredAnyValue">
        ///
        /// </param>
        /// <param name="requiredStructValue">
        ///
        /// </param>
        /// <param name="requiredValueValue">
        ///
        /// </param>
        /// <param name="requiredListValueValue">
        ///
        /// </param>
        /// <param name="requiredTimeValue">
        ///
        /// </param>
        /// <param name="requiredDurationValue">
        ///
        /// </param>
        /// <param name="requiredFieldMaskValue">
        ///
        /// </param>
        /// <param name="requiredInt32Value">
        ///
        /// </param>
        /// <param name="requiredUint32Value">
        ///
        /// </param>
        /// <param name="requiredInt64Value">
        ///
        /// </param>
        /// <param name="requiredUint64Value">
        ///
        /// </param>
        /// <param name="requiredFloatValue">
        ///
        /// </param>
        /// <param name="requiredDoubleValue">
        ///
        /// </param>
        /// <param name="requiredStringValue">
        ///
        /// </param>
        /// <param name="requiredBoolValue">
        ///
        /// </param>
        /// <param name="requiredBytesValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedAnyValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedStructValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedValueValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedListValueValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedTimeValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedDurationValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedFieldMaskValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedUint32Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedUint64Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloatValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedDoubleValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedStringValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedBoolValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytesValue">
        ///
        /// </param>
        /// <param name="optionalSingularInt32">
        ///
        /// </param>
        /// <param name="optionalSingularInt64">
        ///
        /// </param>
        /// <param name="optionalSingularFloat">
        ///
        /// </param>
        /// <param name="optionalSingularDouble">
        ///
        /// </param>
        /// <param name="optionalSingularBool">
        ///
        /// </param>
        /// <param name="optionalSingularEnum">
        ///
        /// </param>
        /// <param name="optionalSingularString">
        ///
        /// </param>
        /// <param name="optionalSingularBytes">
        ///
        /// </param>
        /// <param name="optionalSingularMessage">
        ///
        /// </param>
        /// <param name="optionalSingularResourceName">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalSingularFixed32">
        ///
        /// </param>
        /// <param name="optionalSingularFixed64">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt32">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt64">
        ///
        /// </param>
        /// <param name="optionalRepeatedFloat">
        ///
        /// </param>
        /// <param name="optionalRepeatedDouble">
        ///
        /// </param>
        /// <param name="optionalRepeatedBool">
        ///
        /// </param>
        /// <param name="optionalRepeatedEnum">
        ///
        /// </param>
        /// <param name="optionalRepeatedString">
        ///
        /// </param>
        /// <param name="optionalRepeatedBytes">
        ///
        /// </param>
        /// <param name="optionalRepeatedMessage">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceName">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed32">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed64">
        ///
        /// </param>
        /// <param name="optionalMap">
        ///
        /// </param>
        /// <param name="anyValue">
        ///
        /// </param>
        /// <param name="structValue">
        ///
        /// </param>
        /// <param name="valueValue">
        ///
        /// </param>
        /// <param name="listValueValue">
        ///
        /// </param>
        /// <param name="timeValue">
        ///
        /// </param>
        /// <param name="durationValue">
        ///
        /// </param>
        /// <param name="fieldMaskValue">
        ///
        /// </param>
        /// <param name="int32Value">
        ///
        /// </param>
        /// <param name="uint32Value">
        ///
        /// </param>
        /// <param name="int64Value">
        ///
        /// </param>
        /// <param name="uint64Value">
        ///
        /// </param>
        /// <param name="floatValue">
        ///
        /// </param>
        /// <param name="doubleValue">
        ///
        /// </param>
        /// <param name="stringValue">
        ///
        /// </param>
        /// <param name="boolValue">
        ///
        /// </param>
        /// <param name="bytesValue">
        ///
        /// </param>
        /// <param name="repeatedAnyValue">
        ///
        /// </param>
        /// <param name="repeatedStructValue">
        ///
        /// </param>
        /// <param name="repeatedValueValue">
        ///
        /// </param>
        /// <param name="repeatedListValueValue">
        ///
        /// </param>
        /// <param name="repeatedTimeValue">
        ///
        /// </param>
        /// <param name="repeatedDurationValue">
        ///
        /// </param>
        /// <param name="repeatedFieldMaskValue">
        ///
        /// </param>
        /// <param name="repeatedInt32Value">
        ///
        /// </param>
        /// <param name="repeatedUint32Value">
        ///
        /// </param>
        /// <param name="repeatedInt64Value">
        ///
        /// </param>
        /// <param name="repeatedUint64Value">
        ///
        /// </param>
        /// <param name="repeatedFloatValue">
        ///
        /// </param>
        /// <param name="repeatedDoubleValue">
        ///
        /// </param>
        /// <param name="repeatedStringValue">
        ///
        /// </param>
        /// <param name="repeatedBoolValue">
        ///
        /// </param>
        /// <param name="repeatedBytesValue">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual TestOptionalRequiredFlatteningParamsResponse TestOptionalRequiredFlatteningParams(
            int requiredSingularInt32,
            long requiredSingularInt64,
            float requiredSingularFloat,
            double requiredSingularDouble,
            bool requiredSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum,
            string requiredSingularString,
            pb::ByteString requiredSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage,
            BookNameOneof requiredSingularResourceName,
            BookNameOneof requiredSingularResourceNameOneof,
            string requiredSingularResourceNameCommon,
            int requiredSingularFixed32,
            long requiredSingularFixed64,
            scg::IEnumerable<int> requiredRepeatedInt32,
            scg::IEnumerable<long> requiredRepeatedInt64,
            scg::IEnumerable<float> requiredRepeatedFloat,
            scg::IEnumerable<double> requiredRepeatedDouble,
            scg::IEnumerable<bool> requiredRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum,
            scg::IEnumerable<string> requiredRepeatedString,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage,
            scg::IEnumerable<BookNameOneof> requiredRepeatedResourceName,
            scg::IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof,
            scg::IEnumerable<string> requiredRepeatedResourceNameCommon,
            scg::IEnumerable<int> requiredRepeatedFixed32,
            scg::IEnumerable<long> requiredRepeatedFixed64,
            scg::IDictionary<int, string> requiredMap,
            pbwkt::Any requiredAnyValue,
            pbwkt::Struct requiredStructValue,
            pbwkt::Value requiredValueValue,
            pbwkt::ListValue requiredListValueValue,
            pbwkt::Timestamp requiredTimeValue,
            pbwkt::Duration requiredDurationValue,
            pbwkt::FieldMask requiredFieldMaskValue,
            int? requiredInt32Value,
            uint? requiredUint32Value,
            long? requiredInt64Value,
            ulong? requiredUint64Value,
            float? requiredFloatValue,
            double? requiredDoubleValue,
            string requiredStringValue,
            bool? requiredBoolValue,
            pb::ByteString requiredBytesValue,
            scg::IEnumerable<pbwkt::Any> requiredRepeatedAnyValue,
            scg::IEnumerable<pbwkt::Struct> requiredRepeatedStructValue,
            scg::IEnumerable<pbwkt::Value> requiredRepeatedValueValue,
            scg::IEnumerable<pbwkt::ListValue> requiredRepeatedListValueValue,
            scg::IEnumerable<pbwkt::Timestamp> requiredRepeatedTimeValue,
            scg::IEnumerable<pbwkt::Duration> requiredRepeatedDurationValue,
            scg::IEnumerable<pbwkt::FieldMask> requiredRepeatedFieldMaskValue,
            scg::IEnumerable<int?> requiredRepeatedInt32Value,
            scg::IEnumerable<uint?> requiredRepeatedUint32Value,
            scg::IEnumerable<long?> requiredRepeatedInt64Value,
            scg::IEnumerable<ulong?> requiredRepeatedUint64Value,
            scg::IEnumerable<float?> requiredRepeatedFloatValue,
            scg::IEnumerable<double?> requiredRepeatedDoubleValue,
            scg::IEnumerable<string> requiredRepeatedStringValue,
            scg::IEnumerable<bool?> requiredRepeatedBoolValue,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytesValue,
            int? optionalSingularInt32,
            long? optionalSingularInt64,
            float? optionalSingularFloat,
            double? optionalSingularDouble,
            bool? optionalSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum? optionalSingularEnum,
            string optionalSingularString,
            pb::ByteString optionalSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage,
            BookNameOneof optionalSingularResourceName,
            BookNameOneof optionalSingularResourceNameOneof,
            string optionalSingularResourceNameCommon,
            int? optionalSingularFixed32,
            long? optionalSingularFixed64,
            scg::IEnumerable<int> optionalRepeatedInt32,
            scg::IEnumerable<long> optionalRepeatedInt64,
            scg::IEnumerable<float> optionalRepeatedFloat,
            scg::IEnumerable<double> optionalRepeatedDouble,
            scg::IEnumerable<bool> optionalRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum,
            scg::IEnumerable<string> optionalRepeatedString,
            scg::IEnumerable<pb::ByteString> optionalRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage,
            scg::IEnumerable<BookNameOneof> optionalRepeatedResourceName,
            scg::IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof,
            scg::IEnumerable<string> optionalRepeatedResourceNameCommon,
            scg::IEnumerable<int> optionalRepeatedFixed32,
            scg::IEnumerable<long> optionalRepeatedFixed64,
            scg::IDictionary<int, string> optionalMap,
            pbwkt::Any anyValue,
            pbwkt::Struct structValue,
            pbwkt::Value valueValue,
            pbwkt::ListValue listValueValue,
            pbwkt::Timestamp timeValue,
            pbwkt::Duration durationValue,
            pbwkt::FieldMask fieldMaskValue,
            int? int32Value,
            uint? uint32Value,
            long? int64Value,
            ulong? uint64Value,
            float? floatValue,
            double? doubleValue,
            string stringValue,
            bool? boolValue,
            pb::ByteString bytesValue,
            scg::IEnumerable<pbwkt::Any> repeatedAnyValue,
            scg::IEnumerable<pbwkt::Struct> repeatedStructValue,
            scg::IEnumerable<pbwkt::Value> repeatedValueValue,
            scg::IEnumerable<pbwkt::ListValue> repeatedListValueValue,
            scg::IEnumerable<pbwkt::Timestamp> repeatedTimeValue,
            scg::IEnumerable<pbwkt::Duration> repeatedDurationValue,
            scg::IEnumerable<pbwkt::FieldMask> repeatedFieldMaskValue,
            scg::IEnumerable<int?> repeatedInt32Value,
            scg::IEnumerable<uint?> repeatedUint32Value,
            scg::IEnumerable<long?> repeatedInt64Value,
            scg::IEnumerable<ulong?> repeatedUint64Value,
            scg::IEnumerable<float?> repeatedFloatValue,
            scg::IEnumerable<double?> repeatedDoubleValue,
            scg::IEnumerable<string> repeatedStringValue,
            scg::IEnumerable<bool?> repeatedBoolValue,
            scg::IEnumerable<pb::ByteString> repeatedBytesValue,
            gaxgrpc::CallSettings callSettings = null) => TestOptionalRequiredFlatteningParams(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                    RequiredSingularInt32 = requiredSingularInt32,
                    RequiredSingularInt64 = requiredSingularInt64,
                    RequiredSingularFloat = requiredSingularFloat,
                    RequiredSingularDouble = requiredSingularDouble,
                    RequiredSingularBool = requiredSingularBool,
                    RequiredSingularEnum = requiredSingularEnum,
                    RequiredSingularString = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularString, nameof(requiredSingularString)),
                    RequiredSingularBytes = gax::GaxPreconditions.CheckNotNull(requiredSingularBytes, nameof(requiredSingularBytes)),
                    RequiredSingularMessage = gax::GaxPreconditions.CheckNotNull(requiredSingularMessage, nameof(requiredSingularMessage)),
                    RequiredSingularResourceNameAsBookNameOneof = gax::GaxPreconditions.CheckNotNull(requiredSingularResourceName, nameof(requiredSingularResourceName)),
                    RequiredSingularResourceNameOneofAsBookNameOneof = gax::GaxPreconditions.CheckNotNull(requiredSingularResourceNameOneof, nameof(requiredSingularResourceNameOneof)),
                    RequiredSingularResourceNameCommon = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularResourceNameCommon, nameof(requiredSingularResourceNameCommon)),
                    RequiredSingularFixed32 = requiredSingularFixed32,
                    RequiredSingularFixed64 = requiredSingularFixed64,
                    RequiredRepeatedInt32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt32, nameof(requiredRepeatedInt32)) },
                    RequiredRepeatedInt64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt64, nameof(requiredRepeatedInt64)) },
                    RequiredRepeatedFloat = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFloat, nameof(requiredRepeatedFloat)) },
                    RequiredRepeatedDouble = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedDouble, nameof(requiredRepeatedDouble)) },
                    RequiredRepeatedBool = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBool, nameof(requiredRepeatedBool)) },
                    RequiredRepeatedEnum = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedEnum, nameof(requiredRepeatedEnum)) },
                    RequiredRepeatedString = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedString, nameof(requiredRepeatedString)) },
                    RequiredRepeatedBytes = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBytes, nameof(requiredRepeatedBytes)) },
                    RequiredRepeatedMessage = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedMessage, nameof(requiredRepeatedMessage)) },
                    RequiredRepeatedResourceNameAsBookNameOneofs = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceName, nameof(requiredRepeatedResourceName)) },
                    RequiredRepeatedResourceNameOneofAsBookNameOneofs = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameOneof, nameof(requiredRepeatedResourceNameOneof)) },
                    RequiredRepeatedResourceNameCommon = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameCommon, nameof(requiredRepeatedResourceNameCommon)) },
                    RequiredRepeatedFixed32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed32, nameof(requiredRepeatedFixed32)) },
                    RequiredRepeatedFixed64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed64, nameof(requiredRepeatedFixed64)) },
                    RequiredMap = { gax::GaxPreconditions.CheckNotNull(requiredMap, nameof(requiredMap)) },
                    RequiredAnyValue = gax::GaxPreconditions.CheckNotNull(requiredAnyValue, nameof(requiredAnyValue)),
                    RequiredStructValue = gax::GaxPreconditions.CheckNotNull(requiredStructValue, nameof(requiredStructValue)),
                    RequiredValueValue = gax::GaxPreconditions.CheckNotNull(requiredValueValue, nameof(requiredValueValue)),
                    RequiredListValueValue = gax::GaxPreconditions.CheckNotNull(requiredListValueValue, nameof(requiredListValueValue)),
                    RequiredTimeValue = gax::GaxPreconditions.CheckNotNull(requiredTimeValue, nameof(requiredTimeValue)),
                    RequiredDurationValue = gax::GaxPreconditions.CheckNotNull(requiredDurationValue, nameof(requiredDurationValue)),
                    RequiredFieldMaskValue = gax::GaxPreconditions.CheckNotNull(requiredFieldMaskValue, nameof(requiredFieldMaskValue)),
                    RequiredInt32Value = requiredInt32Value ?? throw new sys::ArgumentNullException(nameof(requiredInt32Value)),
                    RequiredUint32Value = requiredUint32Value ?? throw new sys::ArgumentNullException(nameof(requiredUint32Value)),
                    RequiredInt64Value = requiredInt64Value ?? throw new sys::ArgumentNullException(nameof(requiredInt64Value)),
                    RequiredUint64Value = requiredUint64Value ?? throw new sys::ArgumentNullException(nameof(requiredUint64Value)),
                    RequiredFloatValue = requiredFloatValue ?? throw new sys::ArgumentNullException(nameof(requiredFloatValue)),
                    RequiredDoubleValue = requiredDoubleValue ?? throw new sys::ArgumentNullException(nameof(requiredDoubleValue)),
                    RequiredStringValue = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredStringValue, nameof(requiredStringValue)),
                    RequiredBoolValue = requiredBoolValue ?? throw new sys::ArgumentNullException(nameof(requiredBoolValue)),
                    RequiredBytesValue = gax::GaxPreconditions.CheckNotNull(requiredBytesValue, nameof(requiredBytesValue)),
                    RequiredRepeatedAnyValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedAnyValue, nameof(requiredRepeatedAnyValue)) },
                    RequiredRepeatedStructValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedStructValue, nameof(requiredRepeatedStructValue)) },
                    RequiredRepeatedValueValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedValueValue, nameof(requiredRepeatedValueValue)) },
                    RequiredRepeatedListValueValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedListValueValue, nameof(requiredRepeatedListValueValue)) },
                    RequiredRepeatedTimeValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedTimeValue, nameof(requiredRepeatedTimeValue)) },
                    RequiredRepeatedDurationValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedDurationValue, nameof(requiredRepeatedDurationValue)) },
                    RequiredRepeatedFieldMaskValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFieldMaskValue, nameof(requiredRepeatedFieldMaskValue)) },
                    RequiredRepeatedInt32Value = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt32Value, nameof(requiredRepeatedInt32Value)) },
                    RequiredRepeatedUint32Value = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedUint32Value, nameof(requiredRepeatedUint32Value)) },
                    RequiredRepeatedInt64Value = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt64Value, nameof(requiredRepeatedInt64Value)) },
                    RequiredRepeatedUint64Value = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedUint64Value, nameof(requiredRepeatedUint64Value)) },
                    RequiredRepeatedFloatValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFloatValue, nameof(requiredRepeatedFloatValue)) },
                    RequiredRepeatedDoubleValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedDoubleValue, nameof(requiredRepeatedDoubleValue)) },
                    RequiredRepeatedStringValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedStringValue, nameof(requiredRepeatedStringValue)) },
                    RequiredRepeatedBoolValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBoolValue, nameof(requiredRepeatedBoolValue)) },
                    RequiredRepeatedBytesValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBytesValue, nameof(requiredRepeatedBytesValue)) },
                    OptionalSingularInt32 = optionalSingularInt32 ?? 0, // Optional
                    OptionalSingularInt64 = optionalSingularInt64 ?? 0L, // Optional
                    OptionalSingularFloat = optionalSingularFloat ?? 0.0f, // Optional
                    OptionalSingularDouble = optionalSingularDouble ?? 0.0, // Optional
                    OptionalSingularBool = optionalSingularBool ?? false, // Optional
                    OptionalSingularEnum = optionalSingularEnum ?? TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero, // Optional
                    OptionalSingularString = optionalSingularString ?? "", // Optional
                    OptionalSingularBytes = optionalSingularBytes ?? pb::ByteString.Empty, // Optional
                    OptionalSingularMessage = optionalSingularMessage, // Optional
                    OptionalSingularResourceNameAsBookNameOneof = optionalSingularResourceName, // Optional
                    OptionalSingularResourceNameOneofAsBookNameOneof = optionalSingularResourceNameOneof, // Optional
                    OptionalSingularResourceNameCommon = optionalSingularResourceNameCommon ?? "", // Optional
                    OptionalSingularFixed32 = optionalSingularFixed32 ?? 0, // Optional
                    OptionalSingularFixed64 = optionalSingularFixed64 ?? 0L, // Optional
                    OptionalRepeatedInt32 = { optionalRepeatedInt32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedInt64 = { optionalRepeatedInt64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalRepeatedFloat = { optionalRepeatedFloat ?? linq::Enumerable.Empty<float>() }, // Optional
                    OptionalRepeatedDouble = { optionalRepeatedDouble ?? linq::Enumerable.Empty<double>() }, // Optional
                    OptionalRepeatedBool = { optionalRepeatedBool ?? linq::Enumerable.Empty<bool>() }, // Optional
                    OptionalRepeatedEnum = { optionalRepeatedEnum ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>() }, // Optional
                    OptionalRepeatedString = { optionalRepeatedString ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedBytes = { optionalRepeatedBytes ?? linq::Enumerable.Empty<pb::ByteString>() }, // Optional
                    OptionalRepeatedMessage = { optionalRepeatedMessage ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>() }, // Optional
                    OptionalRepeatedResourceNameAsBookNameOneofs = { optionalRepeatedResourceName ?? linq::Enumerable.Empty<BookNameOneof>() }, // Optional
                    OptionalRepeatedResourceNameOneofAsBookNameOneofs = { optionalRepeatedResourceNameOneof ?? linq::Enumerable.Empty<BookNameOneof>() }, // Optional
                    OptionalRepeatedResourceNameCommon = { optionalRepeatedResourceNameCommon ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedFixed32 = { optionalRepeatedFixed32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedFixed64 = { optionalRepeatedFixed64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalMap = { optionalMap ?? gax::EmptyDictionary<int, string>.Instance }, // Optional
                    AnyValue = anyValue, // Optional
                    StructValue = structValue, // Optional
                    ValueValue = valueValue, // Optional
                    ListValueValue = listValueValue, // Optional
                    TimeValue = timeValue, // Optional
                    DurationValue = durationValue, // Optional
                    FieldMaskValue = fieldMaskValue, // Optional
                    Int32Value = int32Value, // Optional
                    Uint32Value = uint32Value, // Optional
                    Int64Value = int64Value, // Optional
                    Uint64Value = uint64Value, // Optional
                    FloatValue = floatValue, // Optional
                    DoubleValue = doubleValue, // Optional
                    StringValue = stringValue, // Optional
                    BoolValue = boolValue, // Optional
                    BytesValue = bytesValue, // Optional
                    RepeatedAnyValue = { repeatedAnyValue ?? linq::Enumerable.Empty<pbwkt::Any>() }, // Optional
                    RepeatedStructValue = { repeatedStructValue ?? linq::Enumerable.Empty<pbwkt::Struct>() }, // Optional
                    RepeatedValueValue = { repeatedValueValue ?? linq::Enumerable.Empty<pbwkt::Value>() }, // Optional
                    RepeatedListValueValue = { repeatedListValueValue ?? linq::Enumerable.Empty<pbwkt::ListValue>() }, // Optional
                    RepeatedTimeValue = { repeatedTimeValue ?? linq::Enumerable.Empty<pbwkt::Timestamp>() }, // Optional
                    RepeatedDurationValue = { repeatedDurationValue ?? linq::Enumerable.Empty<pbwkt::Duration>() }, // Optional
                    RepeatedFieldMaskValue = { repeatedFieldMaskValue ?? linq::Enumerable.Empty<pbwkt::FieldMask>() }, // Optional
                    RepeatedInt32Value = { repeatedInt32Value ?? linq::Enumerable.Empty<int?>() }, // Optional
                    RepeatedUint32Value = { repeatedUint32Value ?? linq::Enumerable.Empty<uint?>() }, // Optional
                    RepeatedInt64Value = { repeatedInt64Value ?? linq::Enumerable.Empty<long?>() }, // Optional
                    RepeatedUint64Value = { repeatedUint64Value ?? linq::Enumerable.Empty<ulong?>() }, // Optional
                    RepeatedFloatValue = { repeatedFloatValue ?? linq::Enumerable.Empty<float?>() }, // Optional
                    RepeatedDoubleValue = { repeatedDoubleValue ?? linq::Enumerable.Empty<double?>() }, // Optional
                    RepeatedStringValue = { repeatedStringValue ?? linq::Enumerable.Empty<string>() }, // Optional
                    RepeatedBoolValue = { repeatedBoolValue ?? linq::Enumerable.Empty<bool?>() }, // Optional
                    RepeatedBytesValue = { repeatedBytesValue ?? linq::Enumerable.Empty<pb::ByteString>() }, // Optional
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="requiredSingularInt32">
        ///
        /// </param>
        /// <param name="requiredSingularInt64">
        ///
        /// </param>
        /// <param name="requiredSingularFloat">
        ///
        /// </param>
        /// <param name="requiredSingularDouble">
        ///
        /// </param>
        /// <param name="requiredSingularBool">
        ///
        /// </param>
        /// <param name="requiredSingularEnum">
        ///
        /// </param>
        /// <param name="requiredSingularString">
        ///
        /// </param>
        /// <param name="requiredSingularBytes">
        ///
        /// </param>
        /// <param name="requiredSingularMessage">
        ///
        /// </param>
        /// <param name="requiredSingularResourceName">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredSingularFixed32">
        ///
        /// </param>
        /// <param name="requiredSingularFixed64">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloat">
        ///
        /// </param>
        /// <param name="requiredRepeatedDouble">
        ///
        /// </param>
        /// <param name="requiredRepeatedBool">
        ///
        /// </param>
        /// <param name="requiredRepeatedEnum">
        ///
        /// </param>
        /// <param name="requiredRepeatedString">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytes">
        ///
        /// </param>
        /// <param name="requiredRepeatedMessage">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceName">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed32">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed64">
        ///
        /// </param>
        /// <param name="requiredMap">
        ///
        /// </param>
        /// <param name="requiredAnyValue">
        ///
        /// </param>
        /// <param name="requiredStructValue">
        ///
        /// </param>
        /// <param name="requiredValueValue">
        ///
        /// </param>
        /// <param name="requiredListValueValue">
        ///
        /// </param>
        /// <param name="requiredTimeValue">
        ///
        /// </param>
        /// <param name="requiredDurationValue">
        ///
        /// </param>
        /// <param name="requiredFieldMaskValue">
        ///
        /// </param>
        /// <param name="requiredInt32Value">
        ///
        /// </param>
        /// <param name="requiredUint32Value">
        ///
        /// </param>
        /// <param name="requiredInt64Value">
        ///
        /// </param>
        /// <param name="requiredUint64Value">
        ///
        /// </param>
        /// <param name="requiredFloatValue">
        ///
        /// </param>
        /// <param name="requiredDoubleValue">
        ///
        /// </param>
        /// <param name="requiredStringValue">
        ///
        /// </param>
        /// <param name="requiredBoolValue">
        ///
        /// </param>
        /// <param name="requiredBytesValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedAnyValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedStructValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedValueValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedListValueValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedTimeValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedDurationValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedFieldMaskValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedUint32Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedUint64Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloatValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedDoubleValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedStringValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedBoolValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytesValue">
        ///
        /// </param>
        /// <param name="optionalSingularInt32">
        ///
        /// </param>
        /// <param name="optionalSingularInt64">
        ///
        /// </param>
        /// <param name="optionalSingularFloat">
        ///
        /// </param>
        /// <param name="optionalSingularDouble">
        ///
        /// </param>
        /// <param name="optionalSingularBool">
        ///
        /// </param>
        /// <param name="optionalSingularEnum">
        ///
        /// </param>
        /// <param name="optionalSingularString">
        ///
        /// </param>
        /// <param name="optionalSingularBytes">
        ///
        /// </param>
        /// <param name="optionalSingularMessage">
        ///
        /// </param>
        /// <param name="optionalSingularResourceName">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalSingularFixed32">
        ///
        /// </param>
        /// <param name="optionalSingularFixed64">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt32">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt64">
        ///
        /// </param>
        /// <param name="optionalRepeatedFloat">
        ///
        /// </param>
        /// <param name="optionalRepeatedDouble">
        ///
        /// </param>
        /// <param name="optionalRepeatedBool">
        ///
        /// </param>
        /// <param name="optionalRepeatedEnum">
        ///
        /// </param>
        /// <param name="optionalRepeatedString">
        ///
        /// </param>
        /// <param name="optionalRepeatedBytes">
        ///
        /// </param>
        /// <param name="optionalRepeatedMessage">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceName">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed32">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed64">
        ///
        /// </param>
        /// <param name="optionalMap">
        ///
        /// </param>
        /// <param name="anyValue">
        ///
        /// </param>
        /// <param name="structValue">
        ///
        /// </param>
        /// <param name="valueValue">
        ///
        /// </param>
        /// <param name="listValueValue">
        ///
        /// </param>
        /// <param name="timeValue">
        ///
        /// </param>
        /// <param name="durationValue">
        ///
        /// </param>
        /// <param name="fieldMaskValue">
        ///
        /// </param>
        /// <param name="int32Value">
        ///
        /// </param>
        /// <param name="uint32Value">
        ///
        /// </param>
        /// <param name="int64Value">
        ///
        /// </param>
        /// <param name="uint64Value">
        ///
        /// </param>
        /// <param name="floatValue">
        ///
        /// </param>
        /// <param name="doubleValue">
        ///
        /// </param>
        /// <param name="stringValue">
        ///
        /// </param>
        /// <param name="boolValue">
        ///
        /// </param>
        /// <param name="bytesValue">
        ///
        /// </param>
        /// <param name="repeatedAnyValue">
        ///
        /// </param>
        /// <param name="repeatedStructValue">
        ///
        /// </param>
        /// <param name="repeatedValueValue">
        ///
        /// </param>
        /// <param name="repeatedListValueValue">
        ///
        /// </param>
        /// <param name="repeatedTimeValue">
        ///
        /// </param>
        /// <param name="repeatedDurationValue">
        ///
        /// </param>
        /// <param name="repeatedFieldMaskValue">
        ///
        /// </param>
        /// <param name="repeatedInt32Value">
        ///
        /// </param>
        /// <param name="repeatedUint32Value">
        ///
        /// </param>
        /// <param name="repeatedInt64Value">
        ///
        /// </param>
        /// <param name="repeatedUint64Value">
        ///
        /// </param>
        /// <param name="repeatedFloatValue">
        ///
        /// </param>
        /// <param name="repeatedDoubleValue">
        ///
        /// </param>
        /// <param name="repeatedStringValue">
        ///
        /// </param>
        /// <param name="repeatedBoolValue">
        ///
        /// </param>
        /// <param name="repeatedBytesValue">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            int requiredSingularInt32,
            long requiredSingularInt64,
            float requiredSingularFloat,
            double requiredSingularDouble,
            bool requiredSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum,
            string requiredSingularString,
            pb::ByteString requiredSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage,
            string requiredSingularResourceName,
            string requiredSingularResourceNameOneof,
            string requiredSingularResourceNameCommon,
            int requiredSingularFixed32,
            long requiredSingularFixed64,
            scg::IEnumerable<int> requiredRepeatedInt32,
            scg::IEnumerable<long> requiredRepeatedInt64,
            scg::IEnumerable<float> requiredRepeatedFloat,
            scg::IEnumerable<double> requiredRepeatedDouble,
            scg::IEnumerable<bool> requiredRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum,
            scg::IEnumerable<string> requiredRepeatedString,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage,
            scg::IEnumerable<string> requiredRepeatedResourceName,
            scg::IEnumerable<string> requiredRepeatedResourceNameOneof,
            scg::IEnumerable<string> requiredRepeatedResourceNameCommon,
            scg::IEnumerable<int> requiredRepeatedFixed32,
            scg::IEnumerable<long> requiredRepeatedFixed64,
            scg::IDictionary<int, string> requiredMap,
            pbwkt::Any requiredAnyValue,
            pbwkt::Struct requiredStructValue,
            pbwkt::Value requiredValueValue,
            pbwkt::ListValue requiredListValueValue,
            pbwkt::Timestamp requiredTimeValue,
            pbwkt::Duration requiredDurationValue,
            pbwkt::FieldMask requiredFieldMaskValue,
            int? requiredInt32Value,
            uint? requiredUint32Value,
            long? requiredInt64Value,
            ulong? requiredUint64Value,
            float? requiredFloatValue,
            double? requiredDoubleValue,
            string requiredStringValue,
            bool? requiredBoolValue,
            pb::ByteString requiredBytesValue,
            scg::IEnumerable<pbwkt::Any> requiredRepeatedAnyValue,
            scg::IEnumerable<pbwkt::Struct> requiredRepeatedStructValue,
            scg::IEnumerable<pbwkt::Value> requiredRepeatedValueValue,
            scg::IEnumerable<pbwkt::ListValue> requiredRepeatedListValueValue,
            scg::IEnumerable<pbwkt::Timestamp> requiredRepeatedTimeValue,
            scg::IEnumerable<pbwkt::Duration> requiredRepeatedDurationValue,
            scg::IEnumerable<pbwkt::FieldMask> requiredRepeatedFieldMaskValue,
            scg::IEnumerable<int?> requiredRepeatedInt32Value,
            scg::IEnumerable<uint?> requiredRepeatedUint32Value,
            scg::IEnumerable<long?> requiredRepeatedInt64Value,
            scg::IEnumerable<ulong?> requiredRepeatedUint64Value,
            scg::IEnumerable<float?> requiredRepeatedFloatValue,
            scg::IEnumerable<double?> requiredRepeatedDoubleValue,
            scg::IEnumerable<string> requiredRepeatedStringValue,
            scg::IEnumerable<bool?> requiredRepeatedBoolValue,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytesValue,
            int? optionalSingularInt32,
            long? optionalSingularInt64,
            float? optionalSingularFloat,
            double? optionalSingularDouble,
            bool? optionalSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum? optionalSingularEnum,
            string optionalSingularString,
            pb::ByteString optionalSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage,
            string optionalSingularResourceName,
            string optionalSingularResourceNameOneof,
            string optionalSingularResourceNameCommon,
            int? optionalSingularFixed32,
            long? optionalSingularFixed64,
            scg::IEnumerable<int> optionalRepeatedInt32,
            scg::IEnumerable<long> optionalRepeatedInt64,
            scg::IEnumerable<float> optionalRepeatedFloat,
            scg::IEnumerable<double> optionalRepeatedDouble,
            scg::IEnumerable<bool> optionalRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum,
            scg::IEnumerable<string> optionalRepeatedString,
            scg::IEnumerable<pb::ByteString> optionalRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage,
            scg::IEnumerable<string> optionalRepeatedResourceName,
            scg::IEnumerable<string> optionalRepeatedResourceNameOneof,
            scg::IEnumerable<string> optionalRepeatedResourceNameCommon,
            scg::IEnumerable<int> optionalRepeatedFixed32,
            scg::IEnumerable<long> optionalRepeatedFixed64,
            scg::IDictionary<int, string> optionalMap,
            pbwkt::Any anyValue,
            pbwkt::Struct structValue,
            pbwkt::Value valueValue,
            pbwkt::ListValue listValueValue,
            pbwkt::Timestamp timeValue,
            pbwkt::Duration durationValue,
            pbwkt::FieldMask fieldMaskValue,
            int? int32Value,
            uint? uint32Value,
            long? int64Value,
            ulong? uint64Value,
            float? floatValue,
            double? doubleValue,
            string stringValue,
            bool? boolValue,
            pb::ByteString bytesValue,
            scg::IEnumerable<pbwkt::Any> repeatedAnyValue,
            scg::IEnumerable<pbwkt::Struct> repeatedStructValue,
            scg::IEnumerable<pbwkt::Value> repeatedValueValue,
            scg::IEnumerable<pbwkt::ListValue> repeatedListValueValue,
            scg::IEnumerable<pbwkt::Timestamp> repeatedTimeValue,
            scg::IEnumerable<pbwkt::Duration> repeatedDurationValue,
            scg::IEnumerable<pbwkt::FieldMask> repeatedFieldMaskValue,
            scg::IEnumerable<int?> repeatedInt32Value,
            scg::IEnumerable<uint?> repeatedUint32Value,
            scg::IEnumerable<long?> repeatedInt64Value,
            scg::IEnumerable<ulong?> repeatedUint64Value,
            scg::IEnumerable<float?> repeatedFloatValue,
            scg::IEnumerable<double?> repeatedDoubleValue,
            scg::IEnumerable<string> repeatedStringValue,
            scg::IEnumerable<bool?> repeatedBoolValue,
            scg::IEnumerable<pb::ByteString> repeatedBytesValue,
            gaxgrpc::CallSettings callSettings = null) => TestOptionalRequiredFlatteningParamsAsync(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                    RequiredSingularInt32 = requiredSingularInt32,
                    RequiredSingularInt64 = requiredSingularInt64,
                    RequiredSingularFloat = requiredSingularFloat,
                    RequiredSingularDouble = requiredSingularDouble,
                    RequiredSingularBool = requiredSingularBool,
                    RequiredSingularEnum = requiredSingularEnum,
                    RequiredSingularString = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularString, nameof(requiredSingularString)),
                    RequiredSingularBytes = gax::GaxPreconditions.CheckNotNull(requiredSingularBytes, nameof(requiredSingularBytes)),
                    RequiredSingularMessage = gax::GaxPreconditions.CheckNotNull(requiredSingularMessage, nameof(requiredSingularMessage)),
                    RequiredSingularResourceName = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularResourceName, nameof(requiredSingularResourceName)),
                    RequiredSingularResourceNameOneof = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularResourceNameOneof, nameof(requiredSingularResourceNameOneof)),
                    RequiredSingularResourceNameCommon = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularResourceNameCommon, nameof(requiredSingularResourceNameCommon)),
                    RequiredSingularFixed32 = requiredSingularFixed32,
                    RequiredSingularFixed64 = requiredSingularFixed64,
                    RequiredRepeatedInt32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt32, nameof(requiredRepeatedInt32)) },
                    RequiredRepeatedInt64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt64, nameof(requiredRepeatedInt64)) },
                    RequiredRepeatedFloat = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFloat, nameof(requiredRepeatedFloat)) },
                    RequiredRepeatedDouble = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedDouble, nameof(requiredRepeatedDouble)) },
                    RequiredRepeatedBool = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBool, nameof(requiredRepeatedBool)) },
                    RequiredRepeatedEnum = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedEnum, nameof(requiredRepeatedEnum)) },
                    RequiredRepeatedString = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedString, nameof(requiredRepeatedString)) },
                    RequiredRepeatedBytes = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBytes, nameof(requiredRepeatedBytes)) },
                    RequiredRepeatedMessage = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedMessage, nameof(requiredRepeatedMessage)) },
                    RequiredRepeatedResourceName = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceName, nameof(requiredRepeatedResourceName)) },
                    RequiredRepeatedResourceNameOneof = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameOneof, nameof(requiredRepeatedResourceNameOneof)) },
                    RequiredRepeatedResourceNameCommon = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameCommon, nameof(requiredRepeatedResourceNameCommon)) },
                    RequiredRepeatedFixed32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed32, nameof(requiredRepeatedFixed32)) },
                    RequiredRepeatedFixed64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed64, nameof(requiredRepeatedFixed64)) },
                    RequiredMap = { gax::GaxPreconditions.CheckNotNull(requiredMap, nameof(requiredMap)) },
                    RequiredAnyValue = gax::GaxPreconditions.CheckNotNull(requiredAnyValue, nameof(requiredAnyValue)),
                    RequiredStructValue = gax::GaxPreconditions.CheckNotNull(requiredStructValue, nameof(requiredStructValue)),
                    RequiredValueValue = gax::GaxPreconditions.CheckNotNull(requiredValueValue, nameof(requiredValueValue)),
                    RequiredListValueValue = gax::GaxPreconditions.CheckNotNull(requiredListValueValue, nameof(requiredListValueValue)),
                    RequiredTimeValue = gax::GaxPreconditions.CheckNotNull(requiredTimeValue, nameof(requiredTimeValue)),
                    RequiredDurationValue = gax::GaxPreconditions.CheckNotNull(requiredDurationValue, nameof(requiredDurationValue)),
                    RequiredFieldMaskValue = gax::GaxPreconditions.CheckNotNull(requiredFieldMaskValue, nameof(requiredFieldMaskValue)),
                    RequiredInt32Value = requiredInt32Value ?? throw new sys::ArgumentNullException(nameof(requiredInt32Value)),
                    RequiredUint32Value = requiredUint32Value ?? throw new sys::ArgumentNullException(nameof(requiredUint32Value)),
                    RequiredInt64Value = requiredInt64Value ?? throw new sys::ArgumentNullException(nameof(requiredInt64Value)),
                    RequiredUint64Value = requiredUint64Value ?? throw new sys::ArgumentNullException(nameof(requiredUint64Value)),
                    RequiredFloatValue = requiredFloatValue ?? throw new sys::ArgumentNullException(nameof(requiredFloatValue)),
                    RequiredDoubleValue = requiredDoubleValue ?? throw new sys::ArgumentNullException(nameof(requiredDoubleValue)),
                    RequiredStringValue = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredStringValue, nameof(requiredStringValue)),
                    RequiredBoolValue = requiredBoolValue ?? throw new sys::ArgumentNullException(nameof(requiredBoolValue)),
                    RequiredBytesValue = gax::GaxPreconditions.CheckNotNull(requiredBytesValue, nameof(requiredBytesValue)),
                    RequiredRepeatedAnyValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedAnyValue, nameof(requiredRepeatedAnyValue)) },
                    RequiredRepeatedStructValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedStructValue, nameof(requiredRepeatedStructValue)) },
                    RequiredRepeatedValueValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedValueValue, nameof(requiredRepeatedValueValue)) },
                    RequiredRepeatedListValueValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedListValueValue, nameof(requiredRepeatedListValueValue)) },
                    RequiredRepeatedTimeValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedTimeValue, nameof(requiredRepeatedTimeValue)) },
                    RequiredRepeatedDurationValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedDurationValue, nameof(requiredRepeatedDurationValue)) },
                    RequiredRepeatedFieldMaskValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFieldMaskValue, nameof(requiredRepeatedFieldMaskValue)) },
                    RequiredRepeatedInt32Value = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt32Value, nameof(requiredRepeatedInt32Value)) },
                    RequiredRepeatedUint32Value = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedUint32Value, nameof(requiredRepeatedUint32Value)) },
                    RequiredRepeatedInt64Value = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt64Value, nameof(requiredRepeatedInt64Value)) },
                    RequiredRepeatedUint64Value = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedUint64Value, nameof(requiredRepeatedUint64Value)) },
                    RequiredRepeatedFloatValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFloatValue, nameof(requiredRepeatedFloatValue)) },
                    RequiredRepeatedDoubleValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedDoubleValue, nameof(requiredRepeatedDoubleValue)) },
                    RequiredRepeatedStringValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedStringValue, nameof(requiredRepeatedStringValue)) },
                    RequiredRepeatedBoolValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBoolValue, nameof(requiredRepeatedBoolValue)) },
                    RequiredRepeatedBytesValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBytesValue, nameof(requiredRepeatedBytesValue)) },
                    OptionalSingularInt32 = optionalSingularInt32 ?? 0, // Optional
                    OptionalSingularInt64 = optionalSingularInt64 ?? 0L, // Optional
                    OptionalSingularFloat = optionalSingularFloat ?? 0.0f, // Optional
                    OptionalSingularDouble = optionalSingularDouble ?? 0.0, // Optional
                    OptionalSingularBool = optionalSingularBool ?? false, // Optional
                    OptionalSingularEnum = optionalSingularEnum ?? TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero, // Optional
                    OptionalSingularString = optionalSingularString ?? "", // Optional
                    OptionalSingularBytes = optionalSingularBytes ?? pb::ByteString.Empty, // Optional
                    OptionalSingularMessage = optionalSingularMessage, // Optional
                    OptionalSingularResourceName = optionalSingularResourceName ?? "", // Optional
                    OptionalSingularResourceNameOneof = optionalSingularResourceNameOneof ?? "", // Optional
                    OptionalSingularResourceNameCommon = optionalSingularResourceNameCommon ?? "", // Optional
                    OptionalSingularFixed32 = optionalSingularFixed32 ?? 0, // Optional
                    OptionalSingularFixed64 = optionalSingularFixed64 ?? 0L, // Optional
                    OptionalRepeatedInt32 = { optionalRepeatedInt32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedInt64 = { optionalRepeatedInt64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalRepeatedFloat = { optionalRepeatedFloat ?? linq::Enumerable.Empty<float>() }, // Optional
                    OptionalRepeatedDouble = { optionalRepeatedDouble ?? linq::Enumerable.Empty<double>() }, // Optional
                    OptionalRepeatedBool = { optionalRepeatedBool ?? linq::Enumerable.Empty<bool>() }, // Optional
                    OptionalRepeatedEnum = { optionalRepeatedEnum ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>() }, // Optional
                    OptionalRepeatedString = { optionalRepeatedString ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedBytes = { optionalRepeatedBytes ?? linq::Enumerable.Empty<pb::ByteString>() }, // Optional
                    OptionalRepeatedMessage = { optionalRepeatedMessage ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>() }, // Optional
                    OptionalRepeatedResourceName = { optionalRepeatedResourceName ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedResourceNameOneof = { optionalRepeatedResourceNameOneof ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedResourceNameCommon = { optionalRepeatedResourceNameCommon ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedFixed32 = { optionalRepeatedFixed32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedFixed64 = { optionalRepeatedFixed64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalMap = { optionalMap ?? gax::EmptyDictionary<int, string>.Instance }, // Optional
                    AnyValue = anyValue, // Optional
                    StructValue = structValue, // Optional
                    ValueValue = valueValue, // Optional
                    ListValueValue = listValueValue, // Optional
                    TimeValue = timeValue, // Optional
                    DurationValue = durationValue, // Optional
                    FieldMaskValue = fieldMaskValue, // Optional
                    Int32Value = int32Value, // Optional
                    Uint32Value = uint32Value, // Optional
                    Int64Value = int64Value, // Optional
                    Uint64Value = uint64Value, // Optional
                    FloatValue = floatValue, // Optional
                    DoubleValue = doubleValue, // Optional
                    StringValue = stringValue, // Optional
                    BoolValue = boolValue, // Optional
                    BytesValue = bytesValue, // Optional
                    RepeatedAnyValue = { repeatedAnyValue ?? linq::Enumerable.Empty<pbwkt::Any>() }, // Optional
                    RepeatedStructValue = { repeatedStructValue ?? linq::Enumerable.Empty<pbwkt::Struct>() }, // Optional
                    RepeatedValueValue = { repeatedValueValue ?? linq::Enumerable.Empty<pbwkt::Value>() }, // Optional
                    RepeatedListValueValue = { repeatedListValueValue ?? linq::Enumerable.Empty<pbwkt::ListValue>() }, // Optional
                    RepeatedTimeValue = { repeatedTimeValue ?? linq::Enumerable.Empty<pbwkt::Timestamp>() }, // Optional
                    RepeatedDurationValue = { repeatedDurationValue ?? linq::Enumerable.Empty<pbwkt::Duration>() }, // Optional
                    RepeatedFieldMaskValue = { repeatedFieldMaskValue ?? linq::Enumerable.Empty<pbwkt::FieldMask>() }, // Optional
                    RepeatedInt32Value = { repeatedInt32Value ?? linq::Enumerable.Empty<int?>() }, // Optional
                    RepeatedUint32Value = { repeatedUint32Value ?? linq::Enumerable.Empty<uint?>() }, // Optional
                    RepeatedInt64Value = { repeatedInt64Value ?? linq::Enumerable.Empty<long?>() }, // Optional
                    RepeatedUint64Value = { repeatedUint64Value ?? linq::Enumerable.Empty<ulong?>() }, // Optional
                    RepeatedFloatValue = { repeatedFloatValue ?? linq::Enumerable.Empty<float?>() }, // Optional
                    RepeatedDoubleValue = { repeatedDoubleValue ?? linq::Enumerable.Empty<double?>() }, // Optional
                    RepeatedStringValue = { repeatedStringValue ?? linq::Enumerable.Empty<string>() }, // Optional
                    RepeatedBoolValue = { repeatedBoolValue ?? linq::Enumerable.Empty<bool?>() }, // Optional
                    RepeatedBytesValue = { repeatedBytesValue ?? linq::Enumerable.Empty<pb::ByteString>() }, // Optional
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="requiredSingularInt32">
        ///
        /// </param>
        /// <param name="requiredSingularInt64">
        ///
        /// </param>
        /// <param name="requiredSingularFloat">
        ///
        /// </param>
        /// <param name="requiredSingularDouble">
        ///
        /// </param>
        /// <param name="requiredSingularBool">
        ///
        /// </param>
        /// <param name="requiredSingularEnum">
        ///
        /// </param>
        /// <param name="requiredSingularString">
        ///
        /// </param>
        /// <param name="requiredSingularBytes">
        ///
        /// </param>
        /// <param name="requiredSingularMessage">
        ///
        /// </param>
        /// <param name="requiredSingularResourceName">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredSingularFixed32">
        ///
        /// </param>
        /// <param name="requiredSingularFixed64">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloat">
        ///
        /// </param>
        /// <param name="requiredRepeatedDouble">
        ///
        /// </param>
        /// <param name="requiredRepeatedBool">
        ///
        /// </param>
        /// <param name="requiredRepeatedEnum">
        ///
        /// </param>
        /// <param name="requiredRepeatedString">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytes">
        ///
        /// </param>
        /// <param name="requiredRepeatedMessage">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceName">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed32">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed64">
        ///
        /// </param>
        /// <param name="requiredMap">
        ///
        /// </param>
        /// <param name="requiredAnyValue">
        ///
        /// </param>
        /// <param name="requiredStructValue">
        ///
        /// </param>
        /// <param name="requiredValueValue">
        ///
        /// </param>
        /// <param name="requiredListValueValue">
        ///
        /// </param>
        /// <param name="requiredTimeValue">
        ///
        /// </param>
        /// <param name="requiredDurationValue">
        ///
        /// </param>
        /// <param name="requiredFieldMaskValue">
        ///
        /// </param>
        /// <param name="requiredInt32Value">
        ///
        /// </param>
        /// <param name="requiredUint32Value">
        ///
        /// </param>
        /// <param name="requiredInt64Value">
        ///
        /// </param>
        /// <param name="requiredUint64Value">
        ///
        /// </param>
        /// <param name="requiredFloatValue">
        ///
        /// </param>
        /// <param name="requiredDoubleValue">
        ///
        /// </param>
        /// <param name="requiredStringValue">
        ///
        /// </param>
        /// <param name="requiredBoolValue">
        ///
        /// </param>
        /// <param name="requiredBytesValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedAnyValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedStructValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedValueValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedListValueValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedTimeValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedDurationValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedFieldMaskValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedUint32Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedUint64Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloatValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedDoubleValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedStringValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedBoolValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytesValue">
        ///
        /// </param>
        /// <param name="optionalSingularInt32">
        ///
        /// </param>
        /// <param name="optionalSingularInt64">
        ///
        /// </param>
        /// <param name="optionalSingularFloat">
        ///
        /// </param>
        /// <param name="optionalSingularDouble">
        ///
        /// </param>
        /// <param name="optionalSingularBool">
        ///
        /// </param>
        /// <param name="optionalSingularEnum">
        ///
        /// </param>
        /// <param name="optionalSingularString">
        ///
        /// </param>
        /// <param name="optionalSingularBytes">
        ///
        /// </param>
        /// <param name="optionalSingularMessage">
        ///
        /// </param>
        /// <param name="optionalSingularResourceName">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalSingularFixed32">
        ///
        /// </param>
        /// <param name="optionalSingularFixed64">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt32">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt64">
        ///
        /// </param>
        /// <param name="optionalRepeatedFloat">
        ///
        /// </param>
        /// <param name="optionalRepeatedDouble">
        ///
        /// </param>
        /// <param name="optionalRepeatedBool">
        ///
        /// </param>
        /// <param name="optionalRepeatedEnum">
        ///
        /// </param>
        /// <param name="optionalRepeatedString">
        ///
        /// </param>
        /// <param name="optionalRepeatedBytes">
        ///
        /// </param>
        /// <param name="optionalRepeatedMessage">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceName">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed32">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed64">
        ///
        /// </param>
        /// <param name="optionalMap">
        ///
        /// </param>
        /// <param name="anyValue">
        ///
        /// </param>
        /// <param name="structValue">
        ///
        /// </param>
        /// <param name="valueValue">
        ///
        /// </param>
        /// <param name="listValueValue">
        ///
        /// </param>
        /// <param name="timeValue">
        ///
        /// </param>
        /// <param name="durationValue">
        ///
        /// </param>
        /// <param name="fieldMaskValue">
        ///
        /// </param>
        /// <param name="int32Value">
        ///
        /// </param>
        /// <param name="uint32Value">
        ///
        /// </param>
        /// <param name="int64Value">
        ///
        /// </param>
        /// <param name="uint64Value">
        ///
        /// </param>
        /// <param name="floatValue">
        ///
        /// </param>
        /// <param name="doubleValue">
        ///
        /// </param>
        /// <param name="stringValue">
        ///
        /// </param>
        /// <param name="boolValue">
        ///
        /// </param>
        /// <param name="bytesValue">
        ///
        /// </param>
        /// <param name="repeatedAnyValue">
        ///
        /// </param>
        /// <param name="repeatedStructValue">
        ///
        /// </param>
        /// <param name="repeatedValueValue">
        ///
        /// </param>
        /// <param name="repeatedListValueValue">
        ///
        /// </param>
        /// <param name="repeatedTimeValue">
        ///
        /// </param>
        /// <param name="repeatedDurationValue">
        ///
        /// </param>
        /// <param name="repeatedFieldMaskValue">
        ///
        /// </param>
        /// <param name="repeatedInt32Value">
        ///
        /// </param>
        /// <param name="repeatedUint32Value">
        ///
        /// </param>
        /// <param name="repeatedInt64Value">
        ///
        /// </param>
        /// <param name="repeatedUint64Value">
        ///
        /// </param>
        /// <param name="repeatedFloatValue">
        ///
        /// </param>
        /// <param name="repeatedDoubleValue">
        ///
        /// </param>
        /// <param name="repeatedStringValue">
        ///
        /// </param>
        /// <param name="repeatedBoolValue">
        ///
        /// </param>
        /// <param name="repeatedBytesValue">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            int requiredSingularInt32,
            long requiredSingularInt64,
            float requiredSingularFloat,
            double requiredSingularDouble,
            bool requiredSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum,
            string requiredSingularString,
            pb::ByteString requiredSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage,
            string requiredSingularResourceName,
            string requiredSingularResourceNameOneof,
            string requiredSingularResourceNameCommon,
            int requiredSingularFixed32,
            long requiredSingularFixed64,
            scg::IEnumerable<int> requiredRepeatedInt32,
            scg::IEnumerable<long> requiredRepeatedInt64,
            scg::IEnumerable<float> requiredRepeatedFloat,
            scg::IEnumerable<double> requiredRepeatedDouble,
            scg::IEnumerable<bool> requiredRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum,
            scg::IEnumerable<string> requiredRepeatedString,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage,
            scg::IEnumerable<string> requiredRepeatedResourceName,
            scg::IEnumerable<string> requiredRepeatedResourceNameOneof,
            scg::IEnumerable<string> requiredRepeatedResourceNameCommon,
            scg::IEnumerable<int> requiredRepeatedFixed32,
            scg::IEnumerable<long> requiredRepeatedFixed64,
            scg::IDictionary<int, string> requiredMap,
            pbwkt::Any requiredAnyValue,
            pbwkt::Struct requiredStructValue,
            pbwkt::Value requiredValueValue,
            pbwkt::ListValue requiredListValueValue,
            pbwkt::Timestamp requiredTimeValue,
            pbwkt::Duration requiredDurationValue,
            pbwkt::FieldMask requiredFieldMaskValue,
            int? requiredInt32Value,
            uint? requiredUint32Value,
            long? requiredInt64Value,
            ulong? requiredUint64Value,
            float? requiredFloatValue,
            double? requiredDoubleValue,
            string requiredStringValue,
            bool? requiredBoolValue,
            pb::ByteString requiredBytesValue,
            scg::IEnumerable<pbwkt::Any> requiredRepeatedAnyValue,
            scg::IEnumerable<pbwkt::Struct> requiredRepeatedStructValue,
            scg::IEnumerable<pbwkt::Value> requiredRepeatedValueValue,
            scg::IEnumerable<pbwkt::ListValue> requiredRepeatedListValueValue,
            scg::IEnumerable<pbwkt::Timestamp> requiredRepeatedTimeValue,
            scg::IEnumerable<pbwkt::Duration> requiredRepeatedDurationValue,
            scg::IEnumerable<pbwkt::FieldMask> requiredRepeatedFieldMaskValue,
            scg::IEnumerable<int?> requiredRepeatedInt32Value,
            scg::IEnumerable<uint?> requiredRepeatedUint32Value,
            scg::IEnumerable<long?> requiredRepeatedInt64Value,
            scg::IEnumerable<ulong?> requiredRepeatedUint64Value,
            scg::IEnumerable<float?> requiredRepeatedFloatValue,
            scg::IEnumerable<double?> requiredRepeatedDoubleValue,
            scg::IEnumerable<string> requiredRepeatedStringValue,
            scg::IEnumerable<bool?> requiredRepeatedBoolValue,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytesValue,
            int? optionalSingularInt32,
            long? optionalSingularInt64,
            float? optionalSingularFloat,
            double? optionalSingularDouble,
            bool? optionalSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum? optionalSingularEnum,
            string optionalSingularString,
            pb::ByteString optionalSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage,
            string optionalSingularResourceName,
            string optionalSingularResourceNameOneof,
            string optionalSingularResourceNameCommon,
            int? optionalSingularFixed32,
            long? optionalSingularFixed64,
            scg::IEnumerable<int> optionalRepeatedInt32,
            scg::IEnumerable<long> optionalRepeatedInt64,
            scg::IEnumerable<float> optionalRepeatedFloat,
            scg::IEnumerable<double> optionalRepeatedDouble,
            scg::IEnumerable<bool> optionalRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum,
            scg::IEnumerable<string> optionalRepeatedString,
            scg::IEnumerable<pb::ByteString> optionalRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage,
            scg::IEnumerable<string> optionalRepeatedResourceName,
            scg::IEnumerable<string> optionalRepeatedResourceNameOneof,
            scg::IEnumerable<string> optionalRepeatedResourceNameCommon,
            scg::IEnumerable<int> optionalRepeatedFixed32,
            scg::IEnumerable<long> optionalRepeatedFixed64,
            scg::IDictionary<int, string> optionalMap,
            pbwkt::Any anyValue,
            pbwkt::Struct structValue,
            pbwkt::Value valueValue,
            pbwkt::ListValue listValueValue,
            pbwkt::Timestamp timeValue,
            pbwkt::Duration durationValue,
            pbwkt::FieldMask fieldMaskValue,
            int? int32Value,
            uint? uint32Value,
            long? int64Value,
            ulong? uint64Value,
            float? floatValue,
            double? doubleValue,
            string stringValue,
            bool? boolValue,
            pb::ByteString bytesValue,
            scg::IEnumerable<pbwkt::Any> repeatedAnyValue,
            scg::IEnumerable<pbwkt::Struct> repeatedStructValue,
            scg::IEnumerable<pbwkt::Value> repeatedValueValue,
            scg::IEnumerable<pbwkt::ListValue> repeatedListValueValue,
            scg::IEnumerable<pbwkt::Timestamp> repeatedTimeValue,
            scg::IEnumerable<pbwkt::Duration> repeatedDurationValue,
            scg::IEnumerable<pbwkt::FieldMask> repeatedFieldMaskValue,
            scg::IEnumerable<int?> repeatedInt32Value,
            scg::IEnumerable<uint?> repeatedUint32Value,
            scg::IEnumerable<long?> repeatedInt64Value,
            scg::IEnumerable<ulong?> repeatedUint64Value,
            scg::IEnumerable<float?> repeatedFloatValue,
            scg::IEnumerable<double?> repeatedDoubleValue,
            scg::IEnumerable<string> repeatedStringValue,
            scg::IEnumerable<bool?> repeatedBoolValue,
            scg::IEnumerable<pb::ByteString> repeatedBytesValue,
            st::CancellationToken cancellationToken) => TestOptionalRequiredFlatteningParamsAsync(
                requiredSingularInt32,
                requiredSingularInt64,
                requiredSingularFloat,
                requiredSingularDouble,
                requiredSingularBool,
                requiredSingularEnum,
                requiredSingularString,
                requiredSingularBytes,
                requiredSingularMessage,
                requiredSingularResourceName,
                requiredSingularResourceNameOneof,
                requiredSingularResourceNameCommon,
                requiredSingularFixed32,
                requiredSingularFixed64,
                requiredRepeatedInt32,
                requiredRepeatedInt64,
                requiredRepeatedFloat,
                requiredRepeatedDouble,
                requiredRepeatedBool,
                requiredRepeatedEnum,
                requiredRepeatedString,
                requiredRepeatedBytes,
                requiredRepeatedMessage,
                requiredRepeatedResourceName,
                requiredRepeatedResourceNameOneof,
                requiredRepeatedResourceNameCommon,
                requiredRepeatedFixed32,
                requiredRepeatedFixed64,
                requiredMap,
                requiredAnyValue,
                requiredStructValue,
                requiredValueValue,
                requiredListValueValue,
                requiredTimeValue,
                requiredDurationValue,
                requiredFieldMaskValue,
                requiredInt32Value,
                requiredUint32Value,
                requiredInt64Value,
                requiredUint64Value,
                requiredFloatValue,
                requiredDoubleValue,
                requiredStringValue,
                requiredBoolValue,
                requiredBytesValue,
                requiredRepeatedAnyValue,
                requiredRepeatedStructValue,
                requiredRepeatedValueValue,
                requiredRepeatedListValueValue,
                requiredRepeatedTimeValue,
                requiredRepeatedDurationValue,
                requiredRepeatedFieldMaskValue,
                requiredRepeatedInt32Value,
                requiredRepeatedUint32Value,
                requiredRepeatedInt64Value,
                requiredRepeatedUint64Value,
                requiredRepeatedFloatValue,
                requiredRepeatedDoubleValue,
                requiredRepeatedStringValue,
                requiredRepeatedBoolValue,
                requiredRepeatedBytesValue,
                optionalSingularInt32,
                optionalSingularInt64,
                optionalSingularFloat,
                optionalSingularDouble,
                optionalSingularBool,
                optionalSingularEnum,
                optionalSingularString,
                optionalSingularBytes,
                optionalSingularMessage,
                optionalSingularResourceName,
                optionalSingularResourceNameOneof,
                optionalSingularResourceNameCommon,
                optionalSingularFixed32,
                optionalSingularFixed64,
                optionalRepeatedInt32,
                optionalRepeatedInt64,
                optionalRepeatedFloat,
                optionalRepeatedDouble,
                optionalRepeatedBool,
                optionalRepeatedEnum,
                optionalRepeatedString,
                optionalRepeatedBytes,
                optionalRepeatedMessage,
                optionalRepeatedResourceName,
                optionalRepeatedResourceNameOneof,
                optionalRepeatedResourceNameCommon,
                optionalRepeatedFixed32,
                optionalRepeatedFixed64,
                optionalMap,
                anyValue,
                structValue,
                valueValue,
                listValueValue,
                timeValue,
                durationValue,
                fieldMaskValue,
                int32Value,
                uint32Value,
                int64Value,
                uint64Value,
                floatValue,
                doubleValue,
                stringValue,
                boolValue,
                bytesValue,
                repeatedAnyValue,
                repeatedStructValue,
                repeatedValueValue,
                repeatedListValueValue,
                repeatedTimeValue,
                repeatedDurationValue,
                repeatedFieldMaskValue,
                repeatedInt32Value,
                repeatedUint32Value,
                repeatedInt64Value,
                repeatedUint64Value,
                repeatedFloatValue,
                repeatedDoubleValue,
                repeatedStringValue,
                repeatedBoolValue,
                repeatedBytesValue,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="requiredSingularInt32">
        ///
        /// </param>
        /// <param name="requiredSingularInt64">
        ///
        /// </param>
        /// <param name="requiredSingularFloat">
        ///
        /// </param>
        /// <param name="requiredSingularDouble">
        ///
        /// </param>
        /// <param name="requiredSingularBool">
        ///
        /// </param>
        /// <param name="requiredSingularEnum">
        ///
        /// </param>
        /// <param name="requiredSingularString">
        ///
        /// </param>
        /// <param name="requiredSingularBytes">
        ///
        /// </param>
        /// <param name="requiredSingularMessage">
        ///
        /// </param>
        /// <param name="requiredSingularResourceName">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredSingularFixed32">
        ///
        /// </param>
        /// <param name="requiredSingularFixed64">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloat">
        ///
        /// </param>
        /// <param name="requiredRepeatedDouble">
        ///
        /// </param>
        /// <param name="requiredRepeatedBool">
        ///
        /// </param>
        /// <param name="requiredRepeatedEnum">
        ///
        /// </param>
        /// <param name="requiredRepeatedString">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytes">
        ///
        /// </param>
        /// <param name="requiredRepeatedMessage">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceName">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed32">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed64">
        ///
        /// </param>
        /// <param name="requiredMap">
        ///
        /// </param>
        /// <param name="requiredAnyValue">
        ///
        /// </param>
        /// <param name="requiredStructValue">
        ///
        /// </param>
        /// <param name="requiredValueValue">
        ///
        /// </param>
        /// <param name="requiredListValueValue">
        ///
        /// </param>
        /// <param name="requiredTimeValue">
        ///
        /// </param>
        /// <param name="requiredDurationValue">
        ///
        /// </param>
        /// <param name="requiredFieldMaskValue">
        ///
        /// </param>
        /// <param name="requiredInt32Value">
        ///
        /// </param>
        /// <param name="requiredUint32Value">
        ///
        /// </param>
        /// <param name="requiredInt64Value">
        ///
        /// </param>
        /// <param name="requiredUint64Value">
        ///
        /// </param>
        /// <param name="requiredFloatValue">
        ///
        /// </param>
        /// <param name="requiredDoubleValue">
        ///
        /// </param>
        /// <param name="requiredStringValue">
        ///
        /// </param>
        /// <param name="requiredBoolValue">
        ///
        /// </param>
        /// <param name="requiredBytesValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedAnyValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedStructValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedValueValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedListValueValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedTimeValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedDurationValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedFieldMaskValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedUint32Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedUint64Value">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloatValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedDoubleValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedStringValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedBoolValue">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytesValue">
        ///
        /// </param>
        /// <param name="optionalSingularInt32">
        ///
        /// </param>
        /// <param name="optionalSingularInt64">
        ///
        /// </param>
        /// <param name="optionalSingularFloat">
        ///
        /// </param>
        /// <param name="optionalSingularDouble">
        ///
        /// </param>
        /// <param name="optionalSingularBool">
        ///
        /// </param>
        /// <param name="optionalSingularEnum">
        ///
        /// </param>
        /// <param name="optionalSingularString">
        ///
        /// </param>
        /// <param name="optionalSingularBytes">
        ///
        /// </param>
        /// <param name="optionalSingularMessage">
        ///
        /// </param>
        /// <param name="optionalSingularResourceName">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalSingularFixed32">
        ///
        /// </param>
        /// <param name="optionalSingularFixed64">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt32">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt64">
        ///
        /// </param>
        /// <param name="optionalRepeatedFloat">
        ///
        /// </param>
        /// <param name="optionalRepeatedDouble">
        ///
        /// </param>
        /// <param name="optionalRepeatedBool">
        ///
        /// </param>
        /// <param name="optionalRepeatedEnum">
        ///
        /// </param>
        /// <param name="optionalRepeatedString">
        ///
        /// </param>
        /// <param name="optionalRepeatedBytes">
        ///
        /// </param>
        /// <param name="optionalRepeatedMessage">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceName">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed32">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed64">
        ///
        /// </param>
        /// <param name="optionalMap">
        ///
        /// </param>
        /// <param name="anyValue">
        ///
        /// </param>
        /// <param name="structValue">
        ///
        /// </param>
        /// <param name="valueValue">
        ///
        /// </param>
        /// <param name="listValueValue">
        ///
        /// </param>
        /// <param name="timeValue">
        ///
        /// </param>
        /// <param name="durationValue">
        ///
        /// </param>
        /// <param name="fieldMaskValue">
        ///
        /// </param>
        /// <param name="int32Value">
        ///
        /// </param>
        /// <param name="uint32Value">
        ///
        /// </param>
        /// <param name="int64Value">
        ///
        /// </param>
        /// <param name="uint64Value">
        ///
        /// </param>
        /// <param name="floatValue">
        ///
        /// </param>
        /// <param name="doubleValue">
        ///
        /// </param>
        /// <param name="stringValue">
        ///
        /// </param>
        /// <param name="boolValue">
        ///
        /// </param>
        /// <param name="bytesValue">
        ///
        /// </param>
        /// <param name="repeatedAnyValue">
        ///
        /// </param>
        /// <param name="repeatedStructValue">
        ///
        /// </param>
        /// <param name="repeatedValueValue">
        ///
        /// </param>
        /// <param name="repeatedListValueValue">
        ///
        /// </param>
        /// <param name="repeatedTimeValue">
        ///
        /// </param>
        /// <param name="repeatedDurationValue">
        ///
        /// </param>
        /// <param name="repeatedFieldMaskValue">
        ///
        /// </param>
        /// <param name="repeatedInt32Value">
        ///
        /// </param>
        /// <param name="repeatedUint32Value">
        ///
        /// </param>
        /// <param name="repeatedInt64Value">
        ///
        /// </param>
        /// <param name="repeatedUint64Value">
        ///
        /// </param>
        /// <param name="repeatedFloatValue">
        ///
        /// </param>
        /// <param name="repeatedDoubleValue">
        ///
        /// </param>
        /// <param name="repeatedStringValue">
        ///
        /// </param>
        /// <param name="repeatedBoolValue">
        ///
        /// </param>
        /// <param name="repeatedBytesValue">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual TestOptionalRequiredFlatteningParamsResponse TestOptionalRequiredFlatteningParams(
            int requiredSingularInt32,
            long requiredSingularInt64,
            float requiredSingularFloat,
            double requiredSingularDouble,
            bool requiredSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum,
            string requiredSingularString,
            pb::ByteString requiredSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage,
            string requiredSingularResourceName,
            string requiredSingularResourceNameOneof,
            string requiredSingularResourceNameCommon,
            int requiredSingularFixed32,
            long requiredSingularFixed64,
            scg::IEnumerable<int> requiredRepeatedInt32,
            scg::IEnumerable<long> requiredRepeatedInt64,
            scg::IEnumerable<float> requiredRepeatedFloat,
            scg::IEnumerable<double> requiredRepeatedDouble,
            scg::IEnumerable<bool> requiredRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum,
            scg::IEnumerable<string> requiredRepeatedString,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage,
            scg::IEnumerable<string> requiredRepeatedResourceName,
            scg::IEnumerable<string> requiredRepeatedResourceNameOneof,
            scg::IEnumerable<string> requiredRepeatedResourceNameCommon,
            scg::IEnumerable<int> requiredRepeatedFixed32,
            scg::IEnumerable<long> requiredRepeatedFixed64,
            scg::IDictionary<int, string> requiredMap,
            pbwkt::Any requiredAnyValue,
            pbwkt::Struct requiredStructValue,
            pbwkt::Value requiredValueValue,
            pbwkt::ListValue requiredListValueValue,
            pbwkt::Timestamp requiredTimeValue,
            pbwkt::Duration requiredDurationValue,
            pbwkt::FieldMask requiredFieldMaskValue,
            int? requiredInt32Value,
            uint? requiredUint32Value,
            long? requiredInt64Value,
            ulong? requiredUint64Value,
            float? requiredFloatValue,
            double? requiredDoubleValue,
            string requiredStringValue,
            bool? requiredBoolValue,
            pb::ByteString requiredBytesValue,
            scg::IEnumerable<pbwkt::Any> requiredRepeatedAnyValue,
            scg::IEnumerable<pbwkt::Struct> requiredRepeatedStructValue,
            scg::IEnumerable<pbwkt::Value> requiredRepeatedValueValue,
            scg::IEnumerable<pbwkt::ListValue> requiredRepeatedListValueValue,
            scg::IEnumerable<pbwkt::Timestamp> requiredRepeatedTimeValue,
            scg::IEnumerable<pbwkt::Duration> requiredRepeatedDurationValue,
            scg::IEnumerable<pbwkt::FieldMask> requiredRepeatedFieldMaskValue,
            scg::IEnumerable<int?> requiredRepeatedInt32Value,
            scg::IEnumerable<uint?> requiredRepeatedUint32Value,
            scg::IEnumerable<long?> requiredRepeatedInt64Value,
            scg::IEnumerable<ulong?> requiredRepeatedUint64Value,
            scg::IEnumerable<float?> requiredRepeatedFloatValue,
            scg::IEnumerable<double?> requiredRepeatedDoubleValue,
            scg::IEnumerable<string> requiredRepeatedStringValue,
            scg::IEnumerable<bool?> requiredRepeatedBoolValue,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytesValue,
            int? optionalSingularInt32,
            long? optionalSingularInt64,
            float? optionalSingularFloat,
            double? optionalSingularDouble,
            bool? optionalSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum? optionalSingularEnum,
            string optionalSingularString,
            pb::ByteString optionalSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage,
            string optionalSingularResourceName,
            string optionalSingularResourceNameOneof,
            string optionalSingularResourceNameCommon,
            int? optionalSingularFixed32,
            long? optionalSingularFixed64,
            scg::IEnumerable<int> optionalRepeatedInt32,
            scg::IEnumerable<long> optionalRepeatedInt64,
            scg::IEnumerable<float> optionalRepeatedFloat,
            scg::IEnumerable<double> optionalRepeatedDouble,
            scg::IEnumerable<bool> optionalRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum,
            scg::IEnumerable<string> optionalRepeatedString,
            scg::IEnumerable<pb::ByteString> optionalRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage,
            scg::IEnumerable<string> optionalRepeatedResourceName,
            scg::IEnumerable<string> optionalRepeatedResourceNameOneof,
            scg::IEnumerable<string> optionalRepeatedResourceNameCommon,
            scg::IEnumerable<int> optionalRepeatedFixed32,
            scg::IEnumerable<long> optionalRepeatedFixed64,
            scg::IDictionary<int, string> optionalMap,
            pbwkt::Any anyValue,
            pbwkt::Struct structValue,
            pbwkt::Value valueValue,
            pbwkt::ListValue listValueValue,
            pbwkt::Timestamp timeValue,
            pbwkt::Duration durationValue,
            pbwkt::FieldMask fieldMaskValue,
            int? int32Value,
            uint? uint32Value,
            long? int64Value,
            ulong? uint64Value,
            float? floatValue,
            double? doubleValue,
            string stringValue,
            bool? boolValue,
            pb::ByteString bytesValue,
            scg::IEnumerable<pbwkt::Any> repeatedAnyValue,
            scg::IEnumerable<pbwkt::Struct> repeatedStructValue,
            scg::IEnumerable<pbwkt::Value> repeatedValueValue,
            scg::IEnumerable<pbwkt::ListValue> repeatedListValueValue,
            scg::IEnumerable<pbwkt::Timestamp> repeatedTimeValue,
            scg::IEnumerable<pbwkt::Duration> repeatedDurationValue,
            scg::IEnumerable<pbwkt::FieldMask> repeatedFieldMaskValue,
            scg::IEnumerable<int?> repeatedInt32Value,
            scg::IEnumerable<uint?> repeatedUint32Value,
            scg::IEnumerable<long?> repeatedInt64Value,
            scg::IEnumerable<ulong?> repeatedUint64Value,
            scg::IEnumerable<float?> repeatedFloatValue,
            scg::IEnumerable<double?> repeatedDoubleValue,
            scg::IEnumerable<string> repeatedStringValue,
            scg::IEnumerable<bool?> repeatedBoolValue,
            scg::IEnumerable<pb::ByteString> repeatedBytesValue,
            gaxgrpc::CallSettings callSettings = null) => TestOptionalRequiredFlatteningParams(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                    RequiredSingularInt32 = requiredSingularInt32,
                    RequiredSingularInt64 = requiredSingularInt64,
                    RequiredSingularFloat = requiredSingularFloat,
                    RequiredSingularDouble = requiredSingularDouble,
                    RequiredSingularBool = requiredSingularBool,
                    RequiredSingularEnum = requiredSingularEnum,
                    RequiredSingularString = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularString, nameof(requiredSingularString)),
                    RequiredSingularBytes = gax::GaxPreconditions.CheckNotNull(requiredSingularBytes, nameof(requiredSingularBytes)),
                    RequiredSingularMessage = gax::GaxPreconditions.CheckNotNull(requiredSingularMessage, nameof(requiredSingularMessage)),
                    RequiredSingularResourceName = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularResourceName, nameof(requiredSingularResourceName)),
                    RequiredSingularResourceNameOneof = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularResourceNameOneof, nameof(requiredSingularResourceNameOneof)),
                    RequiredSingularResourceNameCommon = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularResourceNameCommon, nameof(requiredSingularResourceNameCommon)),
                    RequiredSingularFixed32 = requiredSingularFixed32,
                    RequiredSingularFixed64 = requiredSingularFixed64,
                    RequiredRepeatedInt32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt32, nameof(requiredRepeatedInt32)) },
                    RequiredRepeatedInt64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt64, nameof(requiredRepeatedInt64)) },
                    RequiredRepeatedFloat = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFloat, nameof(requiredRepeatedFloat)) },
                    RequiredRepeatedDouble = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedDouble, nameof(requiredRepeatedDouble)) },
                    RequiredRepeatedBool = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBool, nameof(requiredRepeatedBool)) },
                    RequiredRepeatedEnum = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedEnum, nameof(requiredRepeatedEnum)) },
                    RequiredRepeatedString = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedString, nameof(requiredRepeatedString)) },
                    RequiredRepeatedBytes = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBytes, nameof(requiredRepeatedBytes)) },
                    RequiredRepeatedMessage = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedMessage, nameof(requiredRepeatedMessage)) },
                    RequiredRepeatedResourceName = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceName, nameof(requiredRepeatedResourceName)) },
                    RequiredRepeatedResourceNameOneof = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameOneof, nameof(requiredRepeatedResourceNameOneof)) },
                    RequiredRepeatedResourceNameCommon = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameCommon, nameof(requiredRepeatedResourceNameCommon)) },
                    RequiredRepeatedFixed32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed32, nameof(requiredRepeatedFixed32)) },
                    RequiredRepeatedFixed64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed64, nameof(requiredRepeatedFixed64)) },
                    RequiredMap = { gax::GaxPreconditions.CheckNotNull(requiredMap, nameof(requiredMap)) },
                    RequiredAnyValue = gax::GaxPreconditions.CheckNotNull(requiredAnyValue, nameof(requiredAnyValue)),
                    RequiredStructValue = gax::GaxPreconditions.CheckNotNull(requiredStructValue, nameof(requiredStructValue)),
                    RequiredValueValue = gax::GaxPreconditions.CheckNotNull(requiredValueValue, nameof(requiredValueValue)),
                    RequiredListValueValue = gax::GaxPreconditions.CheckNotNull(requiredListValueValue, nameof(requiredListValueValue)),
                    RequiredTimeValue = gax::GaxPreconditions.CheckNotNull(requiredTimeValue, nameof(requiredTimeValue)),
                    RequiredDurationValue = gax::GaxPreconditions.CheckNotNull(requiredDurationValue, nameof(requiredDurationValue)),
                    RequiredFieldMaskValue = gax::GaxPreconditions.CheckNotNull(requiredFieldMaskValue, nameof(requiredFieldMaskValue)),
                    RequiredInt32Value = requiredInt32Value ?? throw new sys::ArgumentNullException(nameof(requiredInt32Value)),
                    RequiredUint32Value = requiredUint32Value ?? throw new sys::ArgumentNullException(nameof(requiredUint32Value)),
                    RequiredInt64Value = requiredInt64Value ?? throw new sys::ArgumentNullException(nameof(requiredInt64Value)),
                    RequiredUint64Value = requiredUint64Value ?? throw new sys::ArgumentNullException(nameof(requiredUint64Value)),
                    RequiredFloatValue = requiredFloatValue ?? throw new sys::ArgumentNullException(nameof(requiredFloatValue)),
                    RequiredDoubleValue = requiredDoubleValue ?? throw new sys::ArgumentNullException(nameof(requiredDoubleValue)),
                    RequiredStringValue = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredStringValue, nameof(requiredStringValue)),
                    RequiredBoolValue = requiredBoolValue ?? throw new sys::ArgumentNullException(nameof(requiredBoolValue)),
                    RequiredBytesValue = gax::GaxPreconditions.CheckNotNull(requiredBytesValue, nameof(requiredBytesValue)),
                    RequiredRepeatedAnyValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedAnyValue, nameof(requiredRepeatedAnyValue)) },
                    RequiredRepeatedStructValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedStructValue, nameof(requiredRepeatedStructValue)) },
                    RequiredRepeatedValueValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedValueValue, nameof(requiredRepeatedValueValue)) },
                    RequiredRepeatedListValueValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedListValueValue, nameof(requiredRepeatedListValueValue)) },
                    RequiredRepeatedTimeValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedTimeValue, nameof(requiredRepeatedTimeValue)) },
                    RequiredRepeatedDurationValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedDurationValue, nameof(requiredRepeatedDurationValue)) },
                    RequiredRepeatedFieldMaskValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFieldMaskValue, nameof(requiredRepeatedFieldMaskValue)) },
                    RequiredRepeatedInt32Value = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt32Value, nameof(requiredRepeatedInt32Value)) },
                    RequiredRepeatedUint32Value = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedUint32Value, nameof(requiredRepeatedUint32Value)) },
                    RequiredRepeatedInt64Value = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt64Value, nameof(requiredRepeatedInt64Value)) },
                    RequiredRepeatedUint64Value = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedUint64Value, nameof(requiredRepeatedUint64Value)) },
                    RequiredRepeatedFloatValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFloatValue, nameof(requiredRepeatedFloatValue)) },
                    RequiredRepeatedDoubleValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedDoubleValue, nameof(requiredRepeatedDoubleValue)) },
                    RequiredRepeatedStringValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedStringValue, nameof(requiredRepeatedStringValue)) },
                    RequiredRepeatedBoolValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBoolValue, nameof(requiredRepeatedBoolValue)) },
                    RequiredRepeatedBytesValue = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBytesValue, nameof(requiredRepeatedBytesValue)) },
                    OptionalSingularInt32 = optionalSingularInt32 ?? 0, // Optional
                    OptionalSingularInt64 = optionalSingularInt64 ?? 0L, // Optional
                    OptionalSingularFloat = optionalSingularFloat ?? 0.0f, // Optional
                    OptionalSingularDouble = optionalSingularDouble ?? 0.0, // Optional
                    OptionalSingularBool = optionalSingularBool ?? false, // Optional
                    OptionalSingularEnum = optionalSingularEnum ?? TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero, // Optional
                    OptionalSingularString = optionalSingularString ?? "", // Optional
                    OptionalSingularBytes = optionalSingularBytes ?? pb::ByteString.Empty, // Optional
                    OptionalSingularMessage = optionalSingularMessage, // Optional
                    OptionalSingularResourceName = optionalSingularResourceName ?? "", // Optional
                    OptionalSingularResourceNameOneof = optionalSingularResourceNameOneof ?? "", // Optional
                    OptionalSingularResourceNameCommon = optionalSingularResourceNameCommon ?? "", // Optional
                    OptionalSingularFixed32 = optionalSingularFixed32 ?? 0, // Optional
                    OptionalSingularFixed64 = optionalSingularFixed64 ?? 0L, // Optional
                    OptionalRepeatedInt32 = { optionalRepeatedInt32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedInt64 = { optionalRepeatedInt64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalRepeatedFloat = { optionalRepeatedFloat ?? linq::Enumerable.Empty<float>() }, // Optional
                    OptionalRepeatedDouble = { optionalRepeatedDouble ?? linq::Enumerable.Empty<double>() }, // Optional
                    OptionalRepeatedBool = { optionalRepeatedBool ?? linq::Enumerable.Empty<bool>() }, // Optional
                    OptionalRepeatedEnum = { optionalRepeatedEnum ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>() }, // Optional
                    OptionalRepeatedString = { optionalRepeatedString ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedBytes = { optionalRepeatedBytes ?? linq::Enumerable.Empty<pb::ByteString>() }, // Optional
                    OptionalRepeatedMessage = { optionalRepeatedMessage ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>() }, // Optional
                    OptionalRepeatedResourceName = { optionalRepeatedResourceName ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedResourceNameOneof = { optionalRepeatedResourceNameOneof ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedResourceNameCommon = { optionalRepeatedResourceNameCommon ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedFixed32 = { optionalRepeatedFixed32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedFixed64 = { optionalRepeatedFixed64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalMap = { optionalMap ?? gax::EmptyDictionary<int, string>.Instance }, // Optional
                    AnyValue = anyValue, // Optional
                    StructValue = structValue, // Optional
                    ValueValue = valueValue, // Optional
                    ListValueValue = listValueValue, // Optional
                    TimeValue = timeValue, // Optional
                    DurationValue = durationValue, // Optional
                    FieldMaskValue = fieldMaskValue, // Optional
                    Int32Value = int32Value, // Optional
                    Uint32Value = uint32Value, // Optional
                    Int64Value = int64Value, // Optional
                    Uint64Value = uint64Value, // Optional
                    FloatValue = floatValue, // Optional
                    DoubleValue = doubleValue, // Optional
                    StringValue = stringValue, // Optional
                    BoolValue = boolValue, // Optional
                    BytesValue = bytesValue, // Optional
                    RepeatedAnyValue = { repeatedAnyValue ?? linq::Enumerable.Empty<pbwkt::Any>() }, // Optional
                    RepeatedStructValue = { repeatedStructValue ?? linq::Enumerable.Empty<pbwkt::Struct>() }, // Optional
                    RepeatedValueValue = { repeatedValueValue ?? linq::Enumerable.Empty<pbwkt::Value>() }, // Optional
                    RepeatedListValueValue = { repeatedListValueValue ?? linq::Enumerable.Empty<pbwkt::ListValue>() }, // Optional
                    RepeatedTimeValue = { repeatedTimeValue ?? linq::Enumerable.Empty<pbwkt::Timestamp>() }, // Optional
                    RepeatedDurationValue = { repeatedDurationValue ?? linq::Enumerable.Empty<pbwkt::Duration>() }, // Optional
                    RepeatedFieldMaskValue = { repeatedFieldMaskValue ?? linq::Enumerable.Empty<pbwkt::FieldMask>() }, // Optional
                    RepeatedInt32Value = { repeatedInt32Value ?? linq::Enumerable.Empty<int?>() }, // Optional
                    RepeatedUint32Value = { repeatedUint32Value ?? linq::Enumerable.Empty<uint?>() }, // Optional
                    RepeatedInt64Value = { repeatedInt64Value ?? linq::Enumerable.Empty<long?>() }, // Optional
                    RepeatedUint64Value = { repeatedUint64Value ?? linq::Enumerable.Empty<ulong?>() }, // Optional
                    RepeatedFloatValue = { repeatedFloatValue ?? linq::Enumerable.Empty<float?>() }, // Optional
                    RepeatedDoubleValue = { repeatedDoubleValue ?? linq::Enumerable.Empty<double?>() }, // Optional
                    RepeatedStringValue = { repeatedStringValue ?? linq::Enumerable.Empty<string>() }, // Optional
                    RepeatedBoolValue = { repeatedBoolValue ?? linq::Enumerable.Empty<bool?>() }, // Optional
                    RepeatedBytesValue = { repeatedBytesValue ?? linq::Enumerable.Empty<pb::ByteString>() }, // Optional
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            TestOptionalRequiredFlatteningParamsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            TestOptionalRequiredFlatteningParamsRequest request,
            st::CancellationToken cancellationToken) => TestOptionalRequiredFlatteningParamsAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual TestOptionalRequiredFlatteningParamsResponse TestOptionalRequiredFlatteningParams(
            TestOptionalRequiredFlatteningParamsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<ListAggregatedShelvesResponse> ListAggregatedShelvesAsync(
            gaxgrpc::CallSettings callSettings = null) => ListAggregatedShelvesAsync(
                new ListAggregatedShelvesRequest
                {
                },
                callSettings);

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<ListAggregatedShelvesResponse> ListAggregatedShelvesAsync(
            st::CancellationToken cancellationToken) => ListAggregatedShelvesAsync(
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual ListAggregatedShelvesResponse ListAggregatedShelves(
            gaxgrpc::CallSettings callSettings = null) => ListAggregatedShelves(
                new ListAggregatedShelvesRequest
                {
                },
                callSettings);

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<ListAggregatedShelvesResponse> ListAggregatedShelvesAsync(
            ListAggregatedShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<ListAggregatedShelvesResponse> ListAggregatedShelvesAsync(
            ListAggregatedShelvesRequest request,
            st::CancellationToken cancellationToken) => ListAggregatedShelvesAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual ListAggregatedShelvesResponse ListAggregatedShelves(
            ListAggregatedShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Creates an inventory. Tests singleton resources.
        /// </summary>
        /// <param name="parent">
        ///
        /// </param>
        /// <param name="inventory">
        ///
        /// </param>
        /// <param name="asset">
        ///
        /// </param>
        /// <param name="parentAsset">
        ///
        /// </param>
        /// <param name="assets">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Inventory> CreateInventoryAsync(
            PublisherName parent,
            Inventory inventory,
            IResourceName asset,
            IResourceName parentAsset,
            scg::IEnumerable<IResourceName> assets,
            gaxgrpc::CallSettings callSettings = null) => CreateInventoryAsync(
                new CreateInventoryRequest
                {
                    ParentAsPublisherName = gax::GaxPreconditions.CheckNotNull(parent, nameof(parent)),
                    Inventory = inventory, // Optional
                    AssetAsResourceName = gax::GaxPreconditions.CheckNotNull(asset, nameof(asset)),
                    ParentAssetAsResourceName = gax::GaxPreconditions.CheckNotNull(parentAsset, nameof(parentAsset)),
                    AssetsAsResourceNames = { gax::GaxPreconditions.CheckNotNull(assets, nameof(assets)) },
                },
                callSettings);

        /// <summary>
        /// Creates an inventory. Tests singleton resources.
        /// </summary>
        /// <param name="parent">
        ///
        /// </param>
        /// <param name="inventory">
        ///
        /// </param>
        /// <param name="asset">
        ///
        /// </param>
        /// <param name="parentAsset">
        ///
        /// </param>
        /// <param name="assets">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Inventory> CreateInventoryAsync(
            PublisherName parent,
            Inventory inventory,
            IResourceName asset,
            IResourceName parentAsset,
            scg::IEnumerable<IResourceName> assets,
            st::CancellationToken cancellationToken) => CreateInventoryAsync(
                parent,
                inventory,
                asset,
                parentAsset,
                assets,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates an inventory. Tests singleton resources.
        /// </summary>
        /// <param name="parent">
        ///
        /// </param>
        /// <param name="inventory">
        ///
        /// </param>
        /// <param name="asset">
        ///
        /// </param>
        /// <param name="parentAsset">
        ///
        /// </param>
        /// <param name="assets">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Inventory CreateInventory(
            PublisherName parent,
            Inventory inventory,
            IResourceName asset,
            IResourceName parentAsset,
            scg::IEnumerable<IResourceName> assets,
            gaxgrpc::CallSettings callSettings = null) => CreateInventory(
                new CreateInventoryRequest
                {
                    ParentAsPublisherName = gax::GaxPreconditions.CheckNotNull(parent, nameof(parent)),
                    Inventory = inventory, // Optional
                    AssetAsResourceName = gax::GaxPreconditions.CheckNotNull(asset, nameof(asset)),
                    ParentAssetAsResourceName = gax::GaxPreconditions.CheckNotNull(parentAsset, nameof(parentAsset)),
                    AssetsAsResourceNames = { gax::GaxPreconditions.CheckNotNull(assets, nameof(assets)) },
                },
                callSettings);

        /// <summary>
        /// Creates an inventory. Tests singleton resources.
        /// </summary>
        /// <param name="parent">
        ///
        /// </param>
        /// <param name="inventory">
        ///
        /// </param>
        /// <param name="asset">
        ///
        /// </param>
        /// <param name="parentAsset">
        ///
        /// </param>
        /// <param name="assets">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Inventory> CreateInventoryAsync(
            string parent,
            Inventory inventory,
            string asset,
            string parentAsset,
            scg::IEnumerable<string> assets,
            gaxgrpc::CallSettings callSettings = null) => CreateInventoryAsync(
                new CreateInventoryRequest
                {
                    Parent = gax::GaxPreconditions.CheckNotNullOrEmpty(parent, nameof(parent)),
                    Inventory = inventory, // Optional
                    Asset = gax::GaxPreconditions.CheckNotNullOrEmpty(asset, nameof(asset)),
                    ParentAsset = gax::GaxPreconditions.CheckNotNullOrEmpty(parentAsset, nameof(parentAsset)),
                    Assets = { gax::GaxPreconditions.CheckNotNull(assets, nameof(assets)) },
                },
                callSettings);

        /// <summary>
        /// Creates an inventory. Tests singleton resources.
        /// </summary>
        /// <param name="parent">
        ///
        /// </param>
        /// <param name="inventory">
        ///
        /// </param>
        /// <param name="asset">
        ///
        /// </param>
        /// <param name="parentAsset">
        ///
        /// </param>
        /// <param name="assets">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Inventory> CreateInventoryAsync(
            string parent,
            Inventory inventory,
            string asset,
            string parentAsset,
            scg::IEnumerable<string> assets,
            st::CancellationToken cancellationToken) => CreateInventoryAsync(
                parent,
                inventory,
                asset,
                parentAsset,
                assets,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates an inventory. Tests singleton resources.
        /// </summary>
        /// <param name="parent">
        ///
        /// </param>
        /// <param name="inventory">
        ///
        /// </param>
        /// <param name="asset">
        ///
        /// </param>
        /// <param name="parentAsset">
        ///
        /// </param>
        /// <param name="assets">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Inventory CreateInventory(
            string parent,
            Inventory inventory,
            string asset,
            string parentAsset,
            scg::IEnumerable<string> assets,
            gaxgrpc::CallSettings callSettings = null) => CreateInventory(
                new CreateInventoryRequest
                {
                    Parent = gax::GaxPreconditions.CheckNotNullOrEmpty(parent, nameof(parent)),
                    Inventory = inventory, // Optional
                    Asset = gax::GaxPreconditions.CheckNotNullOrEmpty(asset, nameof(asset)),
                    ParentAsset = gax::GaxPreconditions.CheckNotNullOrEmpty(parentAsset, nameof(parentAsset)),
                    Assets = { gax::GaxPreconditions.CheckNotNull(assets, nameof(assets)) },
                },
                callSettings);

        /// <summary>
        /// Creates an inventory. Tests singleton resources.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Inventory> CreateInventoryAsync(
            CreateInventoryRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Creates an inventory. Tests singleton resources.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Inventory> CreateInventoryAsync(
            CreateInventoryRequest request,
            st::CancellationToken cancellationToken) => CreateInventoryAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates an inventory. Tests singleton resources.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Inventory CreateInventory(
            CreateInventoryRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ArchiveName source,
            ArchiveName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooksAsync(
                new MoveBooksRequest
                {
                    SourceAsArchiveName = source, // Optional
                    DestinationAsArchiveName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ArchiveName source,
            ArchiveName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            st::CancellationToken cancellationToken) => MoveBooksAsync(
                source,
                destination,
                publishers,
                project,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MoveBooksResponse MoveBooks(
            ArchiveName source,
            ArchiveName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooks(
                new MoveBooksRequest
                {
                    SourceAsArchiveName = source, // Optional
                    DestinationAsArchiveName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ArchiveName source,
            InventoryName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooksAsync(
                new MoveBooksRequest
                {
                    SourceAsArchiveName = source, // Optional
                    DestinationAsInventoryName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ArchiveName source,
            InventoryName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            st::CancellationToken cancellationToken) => MoveBooksAsync(
                source,
                destination,
                publishers,
                project,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MoveBooksResponse MoveBooks(
            ArchiveName source,
            InventoryName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooks(
                new MoveBooksRequest
                {
                    SourceAsArchiveName = source, // Optional
                    DestinationAsInventoryName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ArchiveName source,
            ShelfName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooksAsync(
                new MoveBooksRequest
                {
                    SourceAsArchiveName = source, // Optional
                    DestinationAsShelfName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ArchiveName source,
            ShelfName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            st::CancellationToken cancellationToken) => MoveBooksAsync(
                source,
                destination,
                publishers,
                project,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MoveBooksResponse MoveBooks(
            ArchiveName source,
            ShelfName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooks(
                new MoveBooksRequest
                {
                    SourceAsArchiveName = source, // Optional
                    DestinationAsShelfName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ArchiveName source,
            ProjectName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooksAsync(
                new MoveBooksRequest
                {
                    SourceAsArchiveName = source, // Optional
                    DestinationAsProjectName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ArchiveName source,
            ProjectName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            st::CancellationToken cancellationToken) => MoveBooksAsync(
                source,
                destination,
                publishers,
                project,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MoveBooksResponse MoveBooks(
            ArchiveName source,
            ProjectName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooks(
                new MoveBooksRequest
                {
                    SourceAsArchiveName = source, // Optional
                    DestinationAsProjectName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            InventoryName source,
            ArchiveName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooksAsync(
                new MoveBooksRequest
                {
                    SourceAsInventoryName = source, // Optional
                    DestinationAsArchiveName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            InventoryName source,
            ArchiveName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            st::CancellationToken cancellationToken) => MoveBooksAsync(
                source,
                destination,
                publishers,
                project,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MoveBooksResponse MoveBooks(
            InventoryName source,
            ArchiveName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooks(
                new MoveBooksRequest
                {
                    SourceAsInventoryName = source, // Optional
                    DestinationAsArchiveName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            InventoryName source,
            InventoryName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooksAsync(
                new MoveBooksRequest
                {
                    SourceAsInventoryName = source, // Optional
                    DestinationAsInventoryName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            InventoryName source,
            InventoryName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            st::CancellationToken cancellationToken) => MoveBooksAsync(
                source,
                destination,
                publishers,
                project,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MoveBooksResponse MoveBooks(
            InventoryName source,
            InventoryName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooks(
                new MoveBooksRequest
                {
                    SourceAsInventoryName = source, // Optional
                    DestinationAsInventoryName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            InventoryName source,
            ShelfName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooksAsync(
                new MoveBooksRequest
                {
                    SourceAsInventoryName = source, // Optional
                    DestinationAsShelfName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            InventoryName source,
            ShelfName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            st::CancellationToken cancellationToken) => MoveBooksAsync(
                source,
                destination,
                publishers,
                project,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MoveBooksResponse MoveBooks(
            InventoryName source,
            ShelfName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooks(
                new MoveBooksRequest
                {
                    SourceAsInventoryName = source, // Optional
                    DestinationAsShelfName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            InventoryName source,
            ProjectName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooksAsync(
                new MoveBooksRequest
                {
                    SourceAsInventoryName = source, // Optional
                    DestinationAsProjectName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            InventoryName source,
            ProjectName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            st::CancellationToken cancellationToken) => MoveBooksAsync(
                source,
                destination,
                publishers,
                project,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MoveBooksResponse MoveBooks(
            InventoryName source,
            ProjectName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooks(
                new MoveBooksRequest
                {
                    SourceAsInventoryName = source, // Optional
                    DestinationAsProjectName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ShelfName source,
            ArchiveName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooksAsync(
                new MoveBooksRequest
                {
                    SourceAsShelfName = source, // Optional
                    DestinationAsArchiveName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ShelfName source,
            ArchiveName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            st::CancellationToken cancellationToken) => MoveBooksAsync(
                source,
                destination,
                publishers,
                project,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MoveBooksResponse MoveBooks(
            ShelfName source,
            ArchiveName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooks(
                new MoveBooksRequest
                {
                    SourceAsShelfName = source, // Optional
                    DestinationAsArchiveName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ShelfName source,
            InventoryName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooksAsync(
                new MoveBooksRequest
                {
                    SourceAsShelfName = source, // Optional
                    DestinationAsInventoryName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ShelfName source,
            InventoryName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            st::CancellationToken cancellationToken) => MoveBooksAsync(
                source,
                destination,
                publishers,
                project,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MoveBooksResponse MoveBooks(
            ShelfName source,
            InventoryName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooks(
                new MoveBooksRequest
                {
                    SourceAsShelfName = source, // Optional
                    DestinationAsInventoryName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ShelfName source,
            ShelfName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooksAsync(
                new MoveBooksRequest
                {
                    SourceAsShelfName = source, // Optional
                    DestinationAsShelfName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ShelfName source,
            ShelfName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            st::CancellationToken cancellationToken) => MoveBooksAsync(
                source,
                destination,
                publishers,
                project,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MoveBooksResponse MoveBooks(
            ShelfName source,
            ShelfName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooks(
                new MoveBooksRequest
                {
                    SourceAsShelfName = source, // Optional
                    DestinationAsShelfName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ShelfName source,
            ProjectName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooksAsync(
                new MoveBooksRequest
                {
                    SourceAsShelfName = source, // Optional
                    DestinationAsProjectName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ShelfName source,
            ProjectName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            st::CancellationToken cancellationToken) => MoveBooksAsync(
                source,
                destination,
                publishers,
                project,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MoveBooksResponse MoveBooks(
            ShelfName source,
            ProjectName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooks(
                new MoveBooksRequest
                {
                    SourceAsShelfName = source, // Optional
                    DestinationAsProjectName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ProjectName source,
            ArchiveName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooksAsync(
                new MoveBooksRequest
                {
                    SourceAsProjectName = source, // Optional
                    DestinationAsArchiveName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ProjectName source,
            ArchiveName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            st::CancellationToken cancellationToken) => MoveBooksAsync(
                source,
                destination,
                publishers,
                project,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MoveBooksResponse MoveBooks(
            ProjectName source,
            ArchiveName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooks(
                new MoveBooksRequest
                {
                    SourceAsProjectName = source, // Optional
                    DestinationAsArchiveName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ProjectName source,
            InventoryName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooksAsync(
                new MoveBooksRequest
                {
                    SourceAsProjectName = source, // Optional
                    DestinationAsInventoryName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ProjectName source,
            InventoryName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            st::CancellationToken cancellationToken) => MoveBooksAsync(
                source,
                destination,
                publishers,
                project,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MoveBooksResponse MoveBooks(
            ProjectName source,
            InventoryName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooks(
                new MoveBooksRequest
                {
                    SourceAsProjectName = source, // Optional
                    DestinationAsInventoryName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ProjectName source,
            ShelfName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooksAsync(
                new MoveBooksRequest
                {
                    SourceAsProjectName = source, // Optional
                    DestinationAsShelfName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ProjectName source,
            ShelfName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            st::CancellationToken cancellationToken) => MoveBooksAsync(
                source,
                destination,
                publishers,
                project,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MoveBooksResponse MoveBooks(
            ProjectName source,
            ShelfName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooks(
                new MoveBooksRequest
                {
                    SourceAsProjectName = source, // Optional
                    DestinationAsShelfName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ProjectName source,
            ProjectName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooksAsync(
                new MoveBooksRequest
                {
                    SourceAsProjectName = source, // Optional
                    DestinationAsProjectName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            ProjectName source,
            ProjectName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            st::CancellationToken cancellationToken) => MoveBooksAsync(
                source,
                destination,
                publishers,
                project,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MoveBooksResponse MoveBooks(
            ProjectName source,
            ProjectName destination,
            scg::IEnumerable<PublisherName> publishers,
            ProjectName project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooks(
                new MoveBooksRequest
                {
                    SourceAsProjectName = source, // Optional
                    DestinationAsProjectName = destination, // Optional
                    PublishersAsPublisherNames = { publishers ?? linq::Enumerable.Empty<PublisherName>() }, // Optional
                    ProjectAsProjectName = project, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            string source,
            string destination,
            scg::IEnumerable<string> publishers,
            string project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooksAsync(
                new MoveBooksRequest
                {
                    Source = source ?? "", // Optional
                    Destination = destination ?? "", // Optional
                    Publishers = { publishers ?? linq::Enumerable.Empty<string>() }, // Optional
                    Project = project ?? "", // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            string source,
            string destination,
            scg::IEnumerable<string> publishers,
            string project,
            st::CancellationToken cancellationToken) => MoveBooksAsync(
                source,
                destination,
                publishers,
                project,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="destination">
        ///
        /// </param>
        /// <param name="publishers">
        ///
        /// </param>
        /// <param name="project">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MoveBooksResponse MoveBooks(
            string source,
            string destination,
            scg::IEnumerable<string> publishers,
            string project,
            gaxgrpc::CallSettings callSettings = null) => MoveBooks(
                new MoveBooksRequest
                {
                    Source = source ?? "", // Optional
                    Destination = destination ?? "", // Optional
                    Publishers = { publishers ?? linq::Enumerable.Empty<string>() }, // Optional
                    Project = project ?? "", // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            MoveBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MoveBooksResponse> MoveBooksAsync(
            MoveBooksRequest request,
            st::CancellationToken cancellationToken) => MoveBooksAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MoveBooksResponse MoveBooks(
            MoveBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<ArchiveBooksResponse> ArchiveBooksAsync(
            ArchiveName source,
            ArchiveName archive,
            gaxgrpc::CallSettings callSettings = null) => ArchiveBooksAsync(
                new ArchiveBooksRequest
                {
                    SourceAsArchiveName = source, // Optional
                    ArchiveAsArchiveName = archive, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<ArchiveBooksResponse> ArchiveBooksAsync(
            ArchiveName source,
            ArchiveName archive,
            st::CancellationToken cancellationToken) => ArchiveBooksAsync(
                source,
                archive,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual ArchiveBooksResponse ArchiveBooks(
            ArchiveName source,
            ArchiveName archive,
            gaxgrpc::CallSettings callSettings = null) => ArchiveBooks(
                new ArchiveBooksRequest
                {
                    SourceAsArchiveName = source, // Optional
                    ArchiveAsArchiveName = archive, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<ArchiveBooksResponse> ArchiveBooksAsync(
            InventoryName source,
            ArchiveName archive,
            gaxgrpc::CallSettings callSettings = null) => ArchiveBooksAsync(
                new ArchiveBooksRequest
                {
                    SourceAsInventoryName = source, // Optional
                    ArchiveAsArchiveName = archive, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<ArchiveBooksResponse> ArchiveBooksAsync(
            InventoryName source,
            ArchiveName archive,
            st::CancellationToken cancellationToken) => ArchiveBooksAsync(
                source,
                archive,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual ArchiveBooksResponse ArchiveBooks(
            InventoryName source,
            ArchiveName archive,
            gaxgrpc::CallSettings callSettings = null) => ArchiveBooks(
                new ArchiveBooksRequest
                {
                    SourceAsInventoryName = source, // Optional
                    ArchiveAsArchiveName = archive, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<ArchiveBooksResponse> ArchiveBooksAsync(
            ShelfName source,
            ArchiveName archive,
            gaxgrpc::CallSettings callSettings = null) => ArchiveBooksAsync(
                new ArchiveBooksRequest
                {
                    SourceAsShelfName = source, // Optional
                    ArchiveAsArchiveName = archive, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<ArchiveBooksResponse> ArchiveBooksAsync(
            ShelfName source,
            ArchiveName archive,
            st::CancellationToken cancellationToken) => ArchiveBooksAsync(
                source,
                archive,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual ArchiveBooksResponse ArchiveBooks(
            ShelfName source,
            ArchiveName archive,
            gaxgrpc::CallSettings callSettings = null) => ArchiveBooks(
                new ArchiveBooksRequest
                {
                    SourceAsShelfName = source, // Optional
                    ArchiveAsArchiveName = archive, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<ArchiveBooksResponse> ArchiveBooksAsync(
            ProjectName source,
            ArchiveName archive,
            gaxgrpc::CallSettings callSettings = null) => ArchiveBooksAsync(
                new ArchiveBooksRequest
                {
                    SourceAsProjectName = source, // Optional
                    ArchiveAsArchiveName = archive, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<ArchiveBooksResponse> ArchiveBooksAsync(
            ProjectName source,
            ArchiveName archive,
            st::CancellationToken cancellationToken) => ArchiveBooksAsync(
                source,
                archive,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual ArchiveBooksResponse ArchiveBooks(
            ProjectName source,
            ArchiveName archive,
            gaxgrpc::CallSettings callSettings = null) => ArchiveBooks(
                new ArchiveBooksRequest
                {
                    SourceAsProjectName = source, // Optional
                    ArchiveAsArchiveName = archive, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<ArchiveBooksResponse> ArchiveBooksAsync(
            string source,
            string archive,
            gaxgrpc::CallSettings callSettings = null) => ArchiveBooksAsync(
                new ArchiveBooksRequest
                {
                    Source = source ?? "", // Optional
                    Archive = archive ?? "", // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<ArchiveBooksResponse> ArchiveBooksAsync(
            string source,
            string archive,
            st::CancellationToken cancellationToken) => ArchiveBooksAsync(
                source,
                archive,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual ArchiveBooksResponse ArchiveBooks(
            string source,
            string archive,
            gaxgrpc::CallSettings callSettings = null) => ArchiveBooks(
                new ArchiveBooksRequest
                {
                    Source = source ?? "", // Optional
                    Archive = archive ?? "", // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<ArchiveBooksResponse> ArchiveBooksAsync(
            ArchiveBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<ArchiveBooksResponse> ArchiveBooksAsync(
            ArchiveBooksRequest request,
            st::CancellationToken cancellationToken) => ArchiveBooksAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual ArchiveBooksResponse ArchiveBooks(
            ArchiveBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata>> LongRunningArchiveBooksAsync(
            ArchiveName source,
            ArchiveName archive,
            gaxgrpc::CallSettings callSettings = null) => LongRunningArchiveBooksAsync(
                new ArchiveBooksRequest
                {
                    SourceAsArchiveName = source, // Optional
                    ArchiveAsArchiveName = archive, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata>> LongRunningArchiveBooksAsync(
            ArchiveName source,
            ArchiveName archive,
            st::CancellationToken cancellationToken) => LongRunningArchiveBooksAsync(
                source,
                archive,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata> LongRunningArchiveBooks(
            ArchiveName source,
            ArchiveName archive,
            gaxgrpc::CallSettings callSettings = null) => LongRunningArchiveBooks(
                new ArchiveBooksRequest
                {
                    SourceAsArchiveName = source, // Optional
                    ArchiveAsArchiveName = archive, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata>> LongRunningArchiveBooksAsync(
            InventoryName source,
            ArchiveName archive,
            gaxgrpc::CallSettings callSettings = null) => LongRunningArchiveBooksAsync(
                new ArchiveBooksRequest
                {
                    SourceAsInventoryName = source, // Optional
                    ArchiveAsArchiveName = archive, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata>> LongRunningArchiveBooksAsync(
            InventoryName source,
            ArchiveName archive,
            st::CancellationToken cancellationToken) => LongRunningArchiveBooksAsync(
                source,
                archive,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata> LongRunningArchiveBooks(
            InventoryName source,
            ArchiveName archive,
            gaxgrpc::CallSettings callSettings = null) => LongRunningArchiveBooks(
                new ArchiveBooksRequest
                {
                    SourceAsInventoryName = source, // Optional
                    ArchiveAsArchiveName = archive, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata>> LongRunningArchiveBooksAsync(
            ShelfName source,
            ArchiveName archive,
            gaxgrpc::CallSettings callSettings = null) => LongRunningArchiveBooksAsync(
                new ArchiveBooksRequest
                {
                    SourceAsShelfName = source, // Optional
                    ArchiveAsArchiveName = archive, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata>> LongRunningArchiveBooksAsync(
            ShelfName source,
            ArchiveName archive,
            st::CancellationToken cancellationToken) => LongRunningArchiveBooksAsync(
                source,
                archive,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata> LongRunningArchiveBooks(
            ShelfName source,
            ArchiveName archive,
            gaxgrpc::CallSettings callSettings = null) => LongRunningArchiveBooks(
                new ArchiveBooksRequest
                {
                    SourceAsShelfName = source, // Optional
                    ArchiveAsArchiveName = archive, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata>> LongRunningArchiveBooksAsync(
            ProjectName source,
            ArchiveName archive,
            gaxgrpc::CallSettings callSettings = null) => LongRunningArchiveBooksAsync(
                new ArchiveBooksRequest
                {
                    SourceAsProjectName = source, // Optional
                    ArchiveAsArchiveName = archive, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata>> LongRunningArchiveBooksAsync(
            ProjectName source,
            ArchiveName archive,
            st::CancellationToken cancellationToken) => LongRunningArchiveBooksAsync(
                source,
                archive,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata> LongRunningArchiveBooks(
            ProjectName source,
            ArchiveName archive,
            gaxgrpc::CallSettings callSettings = null) => LongRunningArchiveBooks(
                new ArchiveBooksRequest
                {
                    SourceAsProjectName = source, // Optional
                    ArchiveAsArchiveName = archive, // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata>> LongRunningArchiveBooksAsync(
            string source,
            string archive,
            gaxgrpc::CallSettings callSettings = null) => LongRunningArchiveBooksAsync(
                new ArchiveBooksRequest
                {
                    Source = source ?? "", // Optional
                    Archive = archive ?? "", // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata>> LongRunningArchiveBooksAsync(
            string source,
            string archive,
            st::CancellationToken cancellationToken) => LongRunningArchiveBooksAsync(
                source,
                archive,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="source">
        ///
        /// </param>
        /// <param name="archive">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata> LongRunningArchiveBooks(
            string source,
            string archive,
            gaxgrpc::CallSettings callSettings = null) => LongRunningArchiveBooks(
                new ArchiveBooksRequest
                {
                    Source = source ?? "", // Optional
                    Archive = archive ?? "", // Optional
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata>> LongRunningArchiveBooksAsync(
            ArchiveBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Asynchronously poll an operation once, using an <c>operationName</c> from a previous invocation of <c>LongRunningArchiveBooksAsync</c>.
        /// </summary>
        /// <param name="operationName">The name of a previously invoked operation. Must not be <c>null</c> or empty.</param>
        /// <param name="callSettings">If not null, applies overrides to this RPC call.</param>
        /// <returns>A task representing the result of polling the operation.</returns>
        public virtual stt::Task<lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata>> PollOnceLongRunningArchiveBooksAsync(
            string operationName,
            gaxgrpc::CallSettings callSettings = null) => lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata>.PollOnceFromNameAsync(
                gax::GaxPreconditions.CheckNotNullOrEmpty(operationName, nameof(operationName)),
                LongRunningArchiveBooksOperationsClient,
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata> LongRunningArchiveBooks(
            ArchiveBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// The long-running operations client for <c>LongRunningArchiveBooks</c>.
        /// </summary>
        public virtual lro::OperationsClient LongRunningArchiveBooksOperationsClient
        {
            get { throw new sys::NotImplementedException(); }
        }

        /// <summary>
        /// Poll an operation once, using an <c>operationName</c> from a previous invocation of <c>LongRunningArchiveBooks</c>.
        /// </summary>
        /// <param name="operationName">The name of a previously invoked operation. Must not be <c>null</c> or empty.</param>
        /// <param name="callSettings">If not null, applies overrides to this RPC call.</param>
        /// <returns>The result of polling the operation.</returns>
        public virtual lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata> PollOnceLongRunningArchiveBooks(
            string operationName,
            gaxgrpc::CallSettings callSettings = null) => lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata>.PollOnceFromName(
                gax::GaxPreconditions.CheckNotNullOrEmpty(operationName, nameof(operationName)),
                LongRunningArchiveBooksOperationsClient,
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The client-server stream.
        /// </returns>
        *** ERROR: Cannot handle streaming type 'BidiStreaming' ***

        /// <summary>
        ///
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The client-server stream.
        /// </returns>
        *** ERROR: Cannot handle streaming type 'BidiStreaming' ***

        /// <summary>
        ///
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The client-server stream.
        /// </returns>
        *** ERROR: Cannot handle streaming type 'BidiStreaming' ***

        /// <summary>
        ///
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The client-server stream.
        /// </returns>
        *** ERROR: Cannot handle streaming type 'BidiStreaming' ***

        /// <summary>
        ///
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The client-server stream.
        /// </returns>
        *** ERROR: Cannot handle streaming type 'BidiStreaming' ***

        /// <summary>
        ///
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <param name="streamingSettings">
        /// If not null, applies streaming overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The client-server stream.
        /// </returns>
        public virtual StreamingArchiveBooksStream StreamingArchiveBooks(
            gaxgrpc::CallSettings callSettings = null,
            gaxgrpc::BidirectionalStreamingSettings streamingSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Bidirectional streaming methods for <c>StreamingArchiveBooks</c>.
        /// </summary>
        public abstract partial class StreamingArchiveBooksStream : gaxgrpc::BidirectionalStreamingBase<ArchiveBooksRequest, ArchiveBooksResponse>
        {
        }

        /// <summary>
        /// Test using resource messages as request objects. Only used by PubSub (CreateSubscription) for historical reasons.
        /// New APIs should always create a separate message for a request.
        /// </summary>
        /// <param name="name">
        /// The resource name of the book.
        /// Book names have the form `bookShelves/{shelf_id}/books/{book_id}`.
        /// Message field comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </param>
        /// <param name="author">
        /// The name of the book author.
        /// </param>
        /// <param name="title">
        /// The title of the book.
        /// </param>
        /// <param name="rating">
        /// For testing enums.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task SaveBookAsync(
            BookNameOneof name,
            string author,
            string title,
            Book.Types.Rating? rating,
            gaxgrpc::CallSettings callSettings = null) => SaveBookAsync(
                new Book
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Author = author ?? "", // Optional
                    Title = title ?? "", // Optional
                    Rating = rating ?? Book.Types.Rating.Good, // Optional
                },
                callSettings);

        /// <summary>
        /// Test using resource messages as request objects. Only used by PubSub (CreateSubscription) for historical reasons.
        /// New APIs should always create a separate message for a request.
        /// </summary>
        /// <param name="name">
        /// The resource name of the book.
        /// Book names have the form `bookShelves/{shelf_id}/books/{book_id}`.
        /// Message field comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </param>
        /// <param name="author">
        /// The name of the book author.
        /// </param>
        /// <param name="title">
        /// The title of the book.
        /// </param>
        /// <param name="rating">
        /// For testing enums.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task SaveBookAsync(
            BookNameOneof name,
            string author,
            string title,
            Book.Types.Rating? rating,
            st::CancellationToken cancellationToken) => SaveBookAsync(
                name,
                author,
                title,
                rating,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test using resource messages as request objects. Only used by PubSub (CreateSubscription) for historical reasons.
        /// New APIs should always create a separate message for a request.
        /// </summary>
        /// <param name="name">
        /// The resource name of the book.
        /// Book names have the form `bookShelves/{shelf_id}/books/{book_id}`.
        /// Message field comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </param>
        /// <param name="author">
        /// The name of the book author.
        /// </param>
        /// <param name="title">
        /// The title of the book.
        /// </param>
        /// <param name="rating">
        /// For testing enums.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void SaveBook(
            BookNameOneof name,
            string author,
            string title,
            Book.Types.Rating? rating,
            gaxgrpc::CallSettings callSettings = null) => SaveBook(
                new Book
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Author = author ?? "", // Optional
                    Title = title ?? "", // Optional
                    Rating = rating ?? Book.Types.Rating.Good, // Optional
                },
                callSettings);

        /// <summary>
        /// Test using resource messages as request objects. Only used by PubSub (CreateSubscription) for historical reasons.
        /// New APIs should always create a separate message for a request.
        /// </summary>
        /// <param name="name">
        /// The resource name of the book.
        /// Book names have the form `bookShelves/{shelf_id}/books/{book_id}`.
        /// Message field comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </param>
        /// <param name="author">
        /// The name of the book author.
        /// </param>
        /// <param name="title">
        /// The title of the book.
        /// </param>
        /// <param name="rating">
        /// For testing enums.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task SaveBookAsync(
            string name,
            string author,
            string title,
            Book.Types.Rating? rating,
            gaxgrpc::CallSettings callSettings = null) => SaveBookAsync(
                new Book
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Author = author ?? "", // Optional
                    Title = title ?? "", // Optional
                    Rating = rating ?? Book.Types.Rating.Good, // Optional
                },
                callSettings);

        /// <summary>
        /// Test using resource messages as request objects. Only used by PubSub (CreateSubscription) for historical reasons.
        /// New APIs should always create a separate message for a request.
        /// </summary>
        /// <param name="name">
        /// The resource name of the book.
        /// Book names have the form `bookShelves/{shelf_id}/books/{book_id}`.
        /// Message field comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </param>
        /// <param name="author">
        /// The name of the book author.
        /// </param>
        /// <param name="title">
        /// The title of the book.
        /// </param>
        /// <param name="rating">
        /// For testing enums.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task SaveBookAsync(
            string name,
            string author,
            string title,
            Book.Types.Rating? rating,
            st::CancellationToken cancellationToken) => SaveBookAsync(
                name,
                author,
                title,
                rating,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test using resource messages as request objects. Only used by PubSub (CreateSubscription) for historical reasons.
        /// New APIs should always create a separate message for a request.
        /// </summary>
        /// <param name="name">
        /// The resource name of the book.
        /// Book names have the form `bookShelves/{shelf_id}/books/{book_id}`.
        /// Message field comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </param>
        /// <param name="author">
        /// The name of the book author.
        /// </param>
        /// <param name="title">
        /// The title of the book.
        /// </param>
        /// <param name="rating">
        /// For testing enums.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void SaveBook(
            string name,
            string author,
            string title,
            Book.Types.Rating? rating,
            gaxgrpc::CallSettings callSettings = null) => SaveBook(
                new Book
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Author = author ?? "", // Optional
                    Title = title ?? "", // Optional
                    Rating = rating ?? Book.Types.Rating.Good, // Optional
                },
                callSettings);

        /// <summary>
        /// Test using resource messages as request objects. Only used by PubSub (CreateSubscription) for historical reasons.
        /// New APIs should always create a separate message for a request.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task SaveBookAsync(
            Book request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Test using resource messages as request objects. Only used by PubSub (CreateSubscription) for historical reasons.
        /// New APIs should always create a separate message for a request.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task SaveBookAsync(
            Book request,
            st::CancellationToken cancellationToken) => SaveBookAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test using resource messages as request objects. Only used by PubSub (CreateSubscription) for historical reasons.
        /// New APIs should always create a separate message for a request.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void SaveBook(
            Book request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// This method is not exposed in the GAPIC config. It should be generated.
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> PrivateListShelvesAsync(
            gaxgrpc::CallSettings callSettings = null) => PrivateListShelvesAsync(
                new ListShelvesRequest
                {
                },
                callSettings);

        /// <summary>
        /// This method is not exposed in the GAPIC config. It should be generated.
        /// </summary>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> PrivateListShelvesAsync(
            st::CancellationToken cancellationToken) => PrivateListShelvesAsync(
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// This method is not exposed in the GAPIC config. It should be generated.
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book PrivateListShelves(
            gaxgrpc::CallSettings callSettings = null) => PrivateListShelves(
                new ListShelvesRequest
                {
                },
                callSettings);

        /// <summary>
        /// This method is not exposed in the GAPIC config. It should be generated.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> PrivateListShelvesAsync(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// This method is not exposed in the GAPIC config. It should be generated.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> PrivateListShelvesAsync(
            ListShelvesRequest request,
            st::CancellationToken cancellationToken) => PrivateListShelvesAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// This method is not exposed in the GAPIC config. It should be generated.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book PrivateListShelves(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

    }

    /// <summary>
    /// LibraryService client wrapper implementation, for convenient use.
    /// </summary>
    public sealed partial class LibraryServiceClientImpl : LibraryServiceClient
    {
        private readonly gaxgrpc::ApiCall<CreateShelfRequest, Shelf> _callCreateShelf;
        private readonly gaxgrpc::ApiCall<GetShelfRequest, Shelf> _callGetShelf;
        private readonly gaxgrpc::ApiCall<ListShelvesRequest, ListShelvesResponse> _callListShelves;
        private readonly gaxgrpc::ApiCall<DeleteShelfRequest, pbwkt::Empty> _callDeleteShelf;
        private readonly gaxgrpc::ApiCall<MergeShelvesRequest, Shelf> _callMergeShelves;
        private readonly gaxgrpc::ApiCall<CreateBookRequest, Book> _callCreateBook;
        private readonly gaxgrpc::ApiCall<PublishSeriesRequest, PublishSeriesResponse> _callPublishSeries;
        private readonly gaxgrpc::ApiCall<GetBookRequest, Book> _callGetBook;
        private readonly gaxgrpc::ApiCall<ListBooksRequest, ListBooksResponse> _callListBooks;
        private readonly gaxgrpc::ApiCall<DeleteBookRequest, pbwkt::Empty> _callDeleteBook;
        private readonly gaxgrpc::ApiCall<UpdateBookRequest, Book> _callUpdateBook;
        private readonly gaxgrpc::ApiCall<MoveBookRequest, Book> _callMoveBook;
        private readonly gaxgrpc::ApiCall<ListStringsRequest, ListStringsResponse> _callListStrings;
        private readonly gaxgrpc::ApiCall<AddCommentsRequest, pbwkt::Empty> _callAddComments;
        private readonly gaxgrpc::ApiCall<GetBookFromArchiveRequest, BookFromArchive> _callGetBookFromArchive;
        private readonly gaxgrpc::ApiCall<GetBookFromAnywhereRequest, BookFromAnywhere> _callGetBookFromAnywhere;
        private readonly gaxgrpc::ApiCall<GetBookFromAbsolutelyAnywhereRequest, BookFromAnywhere> _callGetBookFromAbsolutelyAnywhere;
        private readonly gaxgrpc::ApiCall<UpdateBookIndexRequest, pbwkt::Empty> _callUpdateBookIndex;
        private readonly gaxgrpc::ApiServerStreamingCall<StreamShelvesRequest, StreamShelvesResponse> _callStreamShelves;
        private readonly gaxgrpc::ApiServerStreamingCall<StreamBooksRequest, Book> _callStreamBooks;
        private readonly gaxgrpc::ApiBidirectionalStreamingCall<DiscussBookRequest, Comment> _callDiscussBook;
        private readonly gaxgrpc::ApiCall<FindRelatedBooksRequest, FindRelatedBooksResponse> _callFindRelatedBooks;
        private readonly gaxgrpc::ApiCall<gtv::AddLabelRequest, gtv::AddLabelResponse> _callAddLabel;
        private readonly gaxgrpc::ApiCall<GetBookRequest, lro::Operation> _callGetBigBook;
        private readonly gaxgrpc::ApiCall<GetBookRequest, lro::Operation> _callGetBigNothing;
        private readonly gaxgrpc::ApiCall<TestOptionalRequiredFlatteningParamsRequest, TestOptionalRequiredFlatteningParamsResponse> _callTestOptionalRequiredFlatteningParams;
        private readonly gaxgrpc::ApiCall<ListAggregatedShelvesRequest, ListAggregatedShelvesResponse> _callListAggregatedShelves;
        private readonly gaxgrpc::ApiCall<CreateInventoryRequest, Inventory> _callCreateInventory;
        private readonly gaxgrpc::ApiCall<MoveBooksRequest, MoveBooksResponse> _callMoveBooks;
        private readonly gaxgrpc::ApiCall<ArchiveBooksRequest, ArchiveBooksResponse> _callArchiveBooks;
        private readonly gaxgrpc::ApiCall<ArchiveBooksRequest, lro::Operation> _callLongRunningArchiveBooks;
        private readonly gaxgrpc::ApiBidirectionalStreamingCall<ArchiveBooksRequest, ArchiveBooksResponse> _callStreamingArchiveBooks;
        private readonly gaxgrpc::ApiCall<Book, pbwkt::Empty> _callSaveBook;
        private readonly gaxgrpc::ApiCall<ListShelvesRequest, Book> _callPrivateListShelves;

        /// <summary>
        /// Constructs a client wrapper for the LibraryService service, with the specified gRPC client and settings.
        /// </summary>
        /// <param name="grpcClient">The underlying gRPC client.</param>
        /// <param name="settings">The base <see cref="LibraryServiceSettings"/> used within this client </param>
        public LibraryServiceClientImpl(LibraryService.LibraryServiceClient grpcClient, LibraryServiceSettings settings)
        {
            GrpcClient = grpcClient;
            LibraryServiceSettings effectiveSettings = settings ?? LibraryServiceSettings.GetDefault();
            gaxgrpc::ClientHelper clientHelper = new gaxgrpc::ClientHelper(effectiveSettings);
            gctv::Labeler.LabelerClient grpcLabelerClient = grpcClient.CreateLabelerClient();
            GetBigBookOperationsClient = new lro::OperationsClientImpl(
                grpcClient.CreateOperationsClient(), effectiveSettings.GetBigBookOperationsSettings);
            GetBigNothingOperationsClient = new lro::OperationsClientImpl(
                grpcClient.CreateOperationsClient(), effectiveSettings.GetBigNothingOperationsSettings);
            LongRunningArchiveBooksOperationsClient = new lro::OperationsClientImpl(
                grpcClient.CreateOperationsClient(), effectiveSettings.LongRunningArchiveBooksOperationsSettings);
            _callCreateShelf = clientHelper.BuildApiCall<CreateShelfRequest, Shelf>(
                GrpcClient.CreateShelfAsync, GrpcClient.CreateShelf, effectiveSettings.CreateShelfSettings);
            _callGetShelf = clientHelper.BuildApiCall<GetShelfRequest, Shelf>(
                GrpcClient.GetShelfAsync, GrpcClient.GetShelf, effectiveSettings.GetShelfSettings)
                .WithGoogleRequestParam("name", request => request.Name);
            _callListShelves = clientHelper.BuildApiCall<ListShelvesRequest, ListShelvesResponse>(
                GrpcClient.ListShelvesAsync, GrpcClient.ListShelves, effectiveSettings.ListShelvesSettings);
            _callDeleteShelf = clientHelper.BuildApiCall<DeleteShelfRequest, pbwkt::Empty>(
                GrpcClient.DeleteShelfAsync, GrpcClient.DeleteShelf, effectiveSettings.DeleteShelfSettings)
                .WithGoogleRequestParam("name", request => request.Name);
            _callMergeShelves = clientHelper.BuildApiCall<MergeShelvesRequest, Shelf>(
                GrpcClient.MergeShelvesAsync, GrpcClient.MergeShelves, effectiveSettings.MergeShelvesSettings)
                .WithGoogleRequestParam("name", request => request.Name);
            _callCreateBook = clientHelper.BuildApiCall<CreateBookRequest, Book>(
                GrpcClient.CreateBookAsync, GrpcClient.CreateBook, effectiveSettings.CreateBookSettings)
                .WithGoogleRequestParam("name", request => request.Name);
            _callPublishSeries = clientHelper.BuildApiCall<PublishSeriesRequest, PublishSeriesResponse>(
                GrpcClient.PublishSeriesAsync, GrpcClient.PublishSeries, effectiveSettings.PublishSeriesSettings)
                .WithGoogleRequestParam("shelf.name", request => request.Shelf?.Name);
            _callGetBook = clientHelper.BuildApiCall<GetBookRequest, Book>(
                GrpcClient.GetBookAsync, GrpcClient.GetBook, effectiveSettings.GetBookSettings)
                .WithGoogleRequestParam("name", request => request.Name);
            _callListBooks = clientHelper.BuildApiCall<ListBooksRequest, ListBooksResponse>(
                GrpcClient.ListBooksAsync, GrpcClient.ListBooks, effectiveSettings.ListBooksSettings)
                .WithGoogleRequestParam("name", request => request.Name);
            _callDeleteBook = clientHelper.BuildApiCall<DeleteBookRequest, pbwkt::Empty>(
                GrpcClient.DeleteBookAsync, GrpcClient.DeleteBook, effectiveSettings.DeleteBookSettings)
                .WithGoogleRequestParam("name", request => request.Name);
            _callUpdateBook = clientHelper.BuildApiCall<UpdateBookRequest, Book>(
                GrpcClient.UpdateBookAsync, GrpcClient.UpdateBook, effectiveSettings.UpdateBookSettings)
                .WithGoogleRequestParam("name", request => request.Name);
            _callMoveBook = clientHelper.BuildApiCall<MoveBookRequest, Book>(
                GrpcClient.MoveBookAsync, GrpcClient.MoveBook, effectiveSettings.MoveBookSettings)
                .WithGoogleRequestParam("name", request => request.Name);
            _callListStrings = clientHelper.BuildApiCall<ListStringsRequest, ListStringsResponse>(
                GrpcClient.ListStringsAsync, GrpcClient.ListStrings, effectiveSettings.ListStringsSettings);
            _callAddComments = clientHelper.BuildApiCall<AddCommentsRequest, pbwkt::Empty>(
                GrpcClient.AddCommentsAsync, GrpcClient.AddComments, effectiveSettings.AddCommentsSettings)
                .WithGoogleRequestParam("name", request => request.Name);
            _callGetBookFromArchive = clientHelper.BuildApiCall<GetBookFromArchiveRequest, BookFromArchive>(
                GrpcClient.GetBookFromArchiveAsync, GrpcClient.GetBookFromArchive, effectiveSettings.GetBookFromArchiveSettings)
                .WithGoogleRequestParam("name", request => request.Name);
            _callGetBookFromAnywhere = clientHelper.BuildApiCall<GetBookFromAnywhereRequest, BookFromAnywhere>(
                GrpcClient.GetBookFromAnywhereAsync, GrpcClient.GetBookFromAnywhere, effectiveSettings.GetBookFromAnywhereSettings)
                .WithGoogleRequestParam("name", request => request.Name);
            _callGetBookFromAbsolutelyAnywhere = clientHelper.BuildApiCall<GetBookFromAbsolutelyAnywhereRequest, BookFromAnywhere>(
                GrpcClient.GetBookFromAbsolutelyAnywhereAsync, GrpcClient.GetBookFromAbsolutelyAnywhere, effectiveSettings.GetBookFromAbsolutelyAnywhereSettings)
                .WithGoogleRequestParam("name", request => request.Name)
                .WithGoogleRequestParam("alt_book_name", request => request.AltBookName);
            _callUpdateBookIndex = clientHelper.BuildApiCall<UpdateBookIndexRequest, pbwkt::Empty>(
                GrpcClient.UpdateBookIndexAsync, GrpcClient.UpdateBookIndex, effectiveSettings.UpdateBookIndexSettings)
                .WithGoogleRequestParam("name", request => request.Name);
            _callStreamShelves = clientHelper.BuildApiCall<StreamShelvesRequest, StreamShelvesResponse>(
                GrpcClient.StreamShelves, effectiveSettings.StreamShelvesSettings);
            _callStreamBooks = clientHelper.BuildApiCall<StreamBooksRequest, Book>(
                GrpcClient.StreamBooks, effectiveSettings.StreamBooksSettings);
            _callDiscussBook = clientHelper.BuildApiCall<DiscussBookRequest, Comment>(
                GrpcClient.DiscussBook, effectiveSettings.DiscussBookSettings, effectiveSettings.DiscussBookStreamingSettings);
            _callFindRelatedBooks = clientHelper.BuildApiCall<FindRelatedBooksRequest, FindRelatedBooksResponse>(
                GrpcClient.FindRelatedBooksAsync, GrpcClient.FindRelatedBooks, effectiveSettings.FindRelatedBooksSettings);
            _callAddLabel = clientHelper.BuildApiCall<gtv::AddLabelRequest, gtv::AddLabelResponse>(
                grpcLabelerClient.AddLabelAsync, grpcLabelerClient.AddLabel, effectiveSettings.AddLabelSettings)
                .WithGoogleRequestParam("resource", request => request.Resource);
            _callGetBigBook = clientHelper.BuildApiCall<GetBookRequest, lro::Operation>(
                GrpcClient.GetBigBookAsync, GrpcClient.GetBigBook, effectiveSettings.GetBigBookSettings)
                .WithGoogleRequestParam("name", request => request.Name);
            _callGetBigNothing = clientHelper.BuildApiCall<GetBookRequest, lro::Operation>(
                GrpcClient.GetBigNothingAsync, GrpcClient.GetBigNothing, effectiveSettings.GetBigNothingSettings)
                .WithGoogleRequestParam("name", request => request.Name);
            _callTestOptionalRequiredFlatteningParams = clientHelper.BuildApiCall<TestOptionalRequiredFlatteningParamsRequest, TestOptionalRequiredFlatteningParamsResponse>(
                GrpcClient.TestOptionalRequiredFlatteningParamsAsync, GrpcClient.TestOptionalRequiredFlatteningParams, effectiveSettings.TestOptionalRequiredFlatteningParamsSettings);
            _callListAggregatedShelves = clientHelper.BuildApiCall<ListAggregatedShelvesRequest, ListAggregatedShelvesResponse>(
                GrpcClient.ListAggregatedShelvesAsync, GrpcClient.ListAggregatedShelves, effectiveSettings.ListAggregatedShelvesSettings);
            _callCreateInventory = clientHelper.BuildApiCall<CreateInventoryRequest, Inventory>(
                GrpcClient.CreateInventoryAsync, GrpcClient.CreateInventory, effectiveSettings.CreateInventorySettings)
                .WithGoogleRequestParam("parent", request => request.Parent);
            _callMoveBooks = clientHelper.BuildApiCall<MoveBooksRequest, MoveBooksResponse>(
                GrpcClient.MoveBooksAsync, GrpcClient.MoveBooks, effectiveSettings.MoveBooksSettings)
                .WithGoogleRequestParam("source", request => request.Source);
            _callArchiveBooks = clientHelper.BuildApiCall<ArchiveBooksRequest, ArchiveBooksResponse>(
                GrpcClient.ArchiveBooksAsync, GrpcClient.ArchiveBooks, effectiveSettings.ArchiveBooksSettings)
                .WithGoogleRequestParam("source", request => request.Source);
            _callLongRunningArchiveBooks = clientHelper.BuildApiCall<ArchiveBooksRequest, lro::Operation>(
                GrpcClient.LongRunningArchiveBooksAsync, GrpcClient.LongRunningArchiveBooks, effectiveSettings.LongRunningArchiveBooksSettings)
                .WithGoogleRequestParam("source", request => request.Source);
            _callStreamingArchiveBooks = clientHelper.BuildApiCall<ArchiveBooksRequest, ArchiveBooksResponse>(
                GrpcClient.StreamingArchiveBooks, effectiveSettings.StreamingArchiveBooksSettings, effectiveSettings.StreamingArchiveBooksStreamingSettings);
            _callSaveBook = clientHelper.BuildApiCall<Book, pbwkt::Empty>(
                GrpcClient.SaveBookAsync, GrpcClient.SaveBook, effectiveSettings.SaveBookSettings);
            _callPrivateListShelves = clientHelper.BuildApiCall<ListShelvesRequest, Book>(
                GrpcClient.PrivateListShelvesAsync, GrpcClient.PrivateListShelves, effectiveSettings.PrivateListShelvesSettings);
            Modify_ApiCall(ref _callCreateShelf);
            Modify_CreateShelfApiCall(ref _callCreateShelf);
            Modify_ApiCall(ref _callGetShelf);
            Modify_GetShelfApiCall(ref _callGetShelf);
            Modify_ApiCall(ref _callListShelves);
            Modify_ListShelvesApiCall(ref _callListShelves);
            Modify_ApiCall(ref _callDeleteShelf);
            Modify_DeleteShelfApiCall(ref _callDeleteShelf);
            Modify_ApiCall(ref _callMergeShelves);
            Modify_MergeShelvesApiCall(ref _callMergeShelves);
            Modify_ApiCall(ref _callCreateBook);
            Modify_CreateBookApiCall(ref _callCreateBook);
            Modify_ApiCall(ref _callPublishSeries);
            Modify_PublishSeriesApiCall(ref _callPublishSeries);
            Modify_ApiCall(ref _callGetBook);
            Modify_GetBookApiCall(ref _callGetBook);
            Modify_ApiCall(ref _callListBooks);
            Modify_ListBooksApiCall(ref _callListBooks);
            Modify_ApiCall(ref _callDeleteBook);
            Modify_DeleteBookApiCall(ref _callDeleteBook);
            Modify_ApiCall(ref _callUpdateBook);
            Modify_UpdateBookApiCall(ref _callUpdateBook);
            Modify_ApiCall(ref _callMoveBook);
            Modify_MoveBookApiCall(ref _callMoveBook);
            Modify_ApiCall(ref _callListStrings);
            Modify_ListStringsApiCall(ref _callListStrings);
            Modify_ApiCall(ref _callAddComments);
            Modify_AddCommentsApiCall(ref _callAddComments);
            Modify_ApiCall(ref _callGetBookFromArchive);
            Modify_GetBookFromArchiveApiCall(ref _callGetBookFromArchive);
            Modify_ApiCall(ref _callGetBookFromAnywhere);
            Modify_GetBookFromAnywhereApiCall(ref _callGetBookFromAnywhere);
            Modify_ApiCall(ref _callGetBookFromAbsolutelyAnywhere);
            Modify_GetBookFromAbsolutelyAnywhereApiCall(ref _callGetBookFromAbsolutelyAnywhere);
            Modify_ApiCall(ref _callUpdateBookIndex);
            Modify_UpdateBookIndexApiCall(ref _callUpdateBookIndex);
            Modify_ApiCall(ref _callStreamShelves);
            Modify_StreamShelvesApiCall(ref _callStreamShelves);
            Modify_ApiCall(ref _callStreamBooks);
            Modify_StreamBooksApiCall(ref _callStreamBooks);
            Modify_ApiCall(ref _callDiscussBook);
            Modify_DiscussBookApiCall(ref _callDiscussBook);
            Modify_ApiCall(ref _callFindRelatedBooks);
            Modify_FindRelatedBooksApiCall(ref _callFindRelatedBooks);
            Modify_ApiCall(ref _callAddLabel);
            Modify_AddLabelApiCall(ref _callAddLabel);
            Modify_ApiCall(ref _callGetBigBook);
            Modify_GetBigBookApiCall(ref _callGetBigBook);
            Modify_ApiCall(ref _callGetBigNothing);
            Modify_GetBigNothingApiCall(ref _callGetBigNothing);
            Modify_ApiCall(ref _callTestOptionalRequiredFlatteningParams);
            Modify_TestOptionalRequiredFlatteningParamsApiCall(ref _callTestOptionalRequiredFlatteningParams);
            Modify_ApiCall(ref _callListAggregatedShelves);
            Modify_ListAggregatedShelvesApiCall(ref _callListAggregatedShelves);
            Modify_ApiCall(ref _callCreateInventory);
            Modify_CreateInventoryApiCall(ref _callCreateInventory);
            Modify_ApiCall(ref _callMoveBooks);
            Modify_MoveBooksApiCall(ref _callMoveBooks);
            Modify_ApiCall(ref _callArchiveBooks);
            Modify_ArchiveBooksApiCall(ref _callArchiveBooks);
            Modify_ApiCall(ref _callLongRunningArchiveBooks);
            Modify_LongRunningArchiveBooksApiCall(ref _callLongRunningArchiveBooks);
            Modify_ApiCall(ref _callStreamingArchiveBooks);
            Modify_StreamingArchiveBooksApiCall(ref _callStreamingArchiveBooks);
            Modify_ApiCall(ref _callSaveBook);
            Modify_SaveBookApiCall(ref _callSaveBook);
            Modify_ApiCall(ref _callPrivateListShelves);
            Modify_PrivateListShelvesApiCall(ref _callPrivateListShelves);
            OnConstruction(grpcClient, effectiveSettings, clientHelper);
        }

        // Partial methods are named to (mostly) ensure there cannot be conflicts with RPC method names.

        // Partial methods called for every ApiCall on construction.
        // Allows modification of all the underlying ApiCall objects.
        partial void Modify_ApiCall<TRequest, TResponse>(ref gaxgrpc::ApiCall<TRequest, TResponse> call)
            where TRequest : class, pb::IMessage<TRequest>
            where TResponse : class, pb::IMessage<TResponse>;
        partial void Modify_ApiCall<TRequest, TResponse>(ref gaxgrpc::ApiServerStreamingCall<TRequest, TResponse> call)
            where TRequest : class, pb::IMessage<TRequest>
            where TResponse : class, pb::IMessage<TResponse>;
        partial void Modify_ApiCall<TRequest, TResponse>(ref gaxgrpc::ApiBidirectionalStreamingCall<TRequest, TResponse> call)
            where TRequest : class, pb::IMessage<TRequest>
            where TResponse : class, pb::IMessage<TResponse>;

        // Partial methods called for each ApiCall on construction.
        // Allows per-RPC-method modification of the underlying ApiCall object.
        partial void Modify_CreateShelfApiCall(ref gaxgrpc::ApiCall<CreateShelfRequest, Shelf> call);
        partial void Modify_GetShelfApiCall(ref gaxgrpc::ApiCall<GetShelfRequest, Shelf> call);
        partial void Modify_ListShelvesApiCall(ref gaxgrpc::ApiCall<ListShelvesRequest, ListShelvesResponse> call);
        partial void Modify_DeleteShelfApiCall(ref gaxgrpc::ApiCall<DeleteShelfRequest, pbwkt::Empty> call);
        partial void Modify_MergeShelvesApiCall(ref gaxgrpc::ApiCall<MergeShelvesRequest, Shelf> call);
        partial void Modify_CreateBookApiCall(ref gaxgrpc::ApiCall<CreateBookRequest, Book> call);
        partial void Modify_PublishSeriesApiCall(ref gaxgrpc::ApiCall<PublishSeriesRequest, PublishSeriesResponse> call);
        partial void Modify_GetBookApiCall(ref gaxgrpc::ApiCall<GetBookRequest, Book> call);
        partial void Modify_ListBooksApiCall(ref gaxgrpc::ApiCall<ListBooksRequest, ListBooksResponse> call);
        partial void Modify_DeleteBookApiCall(ref gaxgrpc::ApiCall<DeleteBookRequest, pbwkt::Empty> call);
        partial void Modify_UpdateBookApiCall(ref gaxgrpc::ApiCall<UpdateBookRequest, Book> call);
        partial void Modify_MoveBookApiCall(ref gaxgrpc::ApiCall<MoveBookRequest, Book> call);
        partial void Modify_ListStringsApiCall(ref gaxgrpc::ApiCall<ListStringsRequest, ListStringsResponse> call);
        partial void Modify_AddCommentsApiCall(ref gaxgrpc::ApiCall<AddCommentsRequest, pbwkt::Empty> call);
        partial void Modify_GetBookFromArchiveApiCall(ref gaxgrpc::ApiCall<GetBookFromArchiveRequest, BookFromArchive> call);
        partial void Modify_GetBookFromAnywhereApiCall(ref gaxgrpc::ApiCall<GetBookFromAnywhereRequest, BookFromAnywhere> call);
        partial void Modify_GetBookFromAbsolutelyAnywhereApiCall(ref gaxgrpc::ApiCall<GetBookFromAbsolutelyAnywhereRequest, BookFromAnywhere> call);
        partial void Modify_UpdateBookIndexApiCall(ref gaxgrpc::ApiCall<UpdateBookIndexRequest, pbwkt::Empty> call);
        partial void Modify_StreamShelvesApiCall(ref gaxgrpc::ApiServerStreamingCall<StreamShelvesRequest, StreamShelvesResponse> call);
        partial void Modify_StreamBooksApiCall(ref gaxgrpc::ApiServerStreamingCall<StreamBooksRequest, Book> call);
        partial void Modify_DiscussBookApiCall(ref gaxgrpc::ApiBidirectionalStreamingCall<DiscussBookRequest, Comment> call);
        partial void Modify_FindRelatedBooksApiCall(ref gaxgrpc::ApiCall<FindRelatedBooksRequest, FindRelatedBooksResponse> call);
        partial void Modify_AddLabelApiCall(ref gaxgrpc::ApiCall<gtv::AddLabelRequest, gtv::AddLabelResponse> call);
        partial void Modify_GetBigBookApiCall(ref gaxgrpc::ApiCall<GetBookRequest, lro::Operation> call);
        partial void Modify_GetBigNothingApiCall(ref gaxgrpc::ApiCall<GetBookRequest, lro::Operation> call);
        partial void Modify_TestOptionalRequiredFlatteningParamsApiCall(ref gaxgrpc::ApiCall<TestOptionalRequiredFlatteningParamsRequest, TestOptionalRequiredFlatteningParamsResponse> call);
        partial void Modify_ListAggregatedShelvesApiCall(ref gaxgrpc::ApiCall<ListAggregatedShelvesRequest, ListAggregatedShelvesResponse> call);
        partial void Modify_CreateInventoryApiCall(ref gaxgrpc::ApiCall<CreateInventoryRequest, Inventory> call);
        partial void Modify_MoveBooksApiCall(ref gaxgrpc::ApiCall<MoveBooksRequest, MoveBooksResponse> call);
        partial void Modify_ArchiveBooksApiCall(ref gaxgrpc::ApiCall<ArchiveBooksRequest, ArchiveBooksResponse> call);
        partial void Modify_LongRunningArchiveBooksApiCall(ref gaxgrpc::ApiCall<ArchiveBooksRequest, lro::Operation> call);
        partial void Modify_StreamingArchiveBooksApiCall(ref gaxgrpc::ApiBidirectionalStreamingCall<ArchiveBooksRequest, ArchiveBooksResponse> call);
        partial void Modify_SaveBookApiCall(ref gaxgrpc::ApiCall<Book, pbwkt::Empty> call);
        partial void Modify_PrivateListShelvesApiCall(ref gaxgrpc::ApiCall<ListShelvesRequest, Book> call);
        partial void OnConstruction(LibraryService.LibraryServiceClient grpcClient, LibraryServiceSettings effectiveSettings, gaxgrpc::ClientHelper clientHelper);

        /// <summary>
        /// The underlying gRPC LibraryService client.
        /// </summary>
        public override LibraryService.LibraryServiceClient GrpcClient { get; }

        // Partial methods called on each request.
        // Allows per-RPC-call modification to the request and CallSettings objects,
        // before the underlying RPC is performed.
        partial void Modify_CreateShelfRequest(ref CreateShelfRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_GetShelfRequest(ref GetShelfRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_ListShelvesRequest(ref ListShelvesRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_DeleteShelfRequest(ref DeleteShelfRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_MergeShelvesRequest(ref MergeShelvesRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_CreateBookRequest(ref CreateBookRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_PublishSeriesRequest(ref PublishSeriesRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_GetBookRequest(ref GetBookRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_ListBooksRequest(ref ListBooksRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_DeleteBookRequest(ref DeleteBookRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_UpdateBookRequest(ref UpdateBookRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_MoveBookRequest(ref MoveBookRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_ListStringsRequest(ref ListStringsRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_AddCommentsRequest(ref AddCommentsRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_GetBookFromArchiveRequest(ref GetBookFromArchiveRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_GetBookFromAnywhereRequest(ref GetBookFromAnywhereRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_GetBookFromAbsolutelyAnywhereRequest(ref GetBookFromAbsolutelyAnywhereRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_UpdateBookIndexRequest(ref UpdateBookIndexRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_StreamShelvesRequest(ref StreamShelvesRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_StreamBooksRequest(ref StreamBooksRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_DiscussBookRequestCallSettings(ref gaxgrpc::CallSettings settings);
        partial void Modify_DiscussBookRequestRequest(ref DiscussBookRequest request);
        partial void Modify_FindRelatedBooksRequest(ref FindRelatedBooksRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_AddLabelRequest(ref gtv::AddLabelRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_TestOptionalRequiredFlatteningParamsRequest(ref TestOptionalRequiredFlatteningParamsRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_ListAggregatedShelvesRequest(ref ListAggregatedShelvesRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_CreateInventoryRequest(ref CreateInventoryRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_MoveBooksRequest(ref MoveBooksRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_ArchiveBooksRequest(ref ArchiveBooksRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_Book(ref Book request, ref gaxgrpc::CallSettings settings);

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Shelf> CreateShelfAsync(
            CreateShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_CreateShelfRequest(ref request, ref callSettings);
            return _callCreateShelf.Async(request, callSettings);
        }

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Shelf CreateShelf(
            CreateShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_CreateShelfRequest(ref request, ref callSettings);
            return _callCreateShelf.Sync(request, callSettings);
        }

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Shelf> GetShelfAsync(
            GetShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetShelfRequest(ref request, ref callSettings);
            return _callGetShelf.Async(request, callSettings);
        }

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Shelf GetShelf(
            GetShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetShelfRequest(ref request, ref callSettings);
            return _callGetShelf.Sync(request, callSettings);
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public override gax::PagedAsyncEnumerable<ListShelvesResponse, Shelf> ListShelvesAsync(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListShelvesRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedAsyncEnumerable<ListShelvesRequest, ListShelvesResponse, Shelf>(_callListShelves, request, callSettings);
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public override gax::PagedEnumerable<ListShelvesResponse, Shelf> ListShelves(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListShelvesRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedEnumerable<ListShelvesRequest, ListShelvesResponse, Shelf>(_callListShelves, request, callSettings);
        }

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public override stt::Task DeleteShelfAsync(
            DeleteShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_DeleteShelfRequest(ref request, ref callSettings);
            return _callDeleteShelf.Async(request, callSettings);
        }

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public override void DeleteShelf(
            DeleteShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_DeleteShelfRequest(ref request, ref callSettings);
            _callDeleteShelf.Sync(request, callSettings);
        }

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Shelf> MergeShelvesAsync(
            MergeShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MergeShelvesRequest(ref request, ref callSettings);
            return _callMergeShelves.Async(request, callSettings);
        }

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Shelf MergeShelves(
            MergeShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MergeShelvesRequest(ref request, ref callSettings);
            return _callMergeShelves.Sync(request, callSettings);
        }

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Book> CreateBookAsync(
            CreateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_CreateBookRequest(ref request, ref callSettings);
            return _callCreateBook.Async(request, callSettings);
        }

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Book CreateBook(
            CreateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_CreateBookRequest(ref request, ref callSettings);
            return _callCreateBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<PublishSeriesResponse> PublishSeriesAsync(
            PublishSeriesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_PublishSeriesRequest(ref request, ref callSettings);
            return _callPublishSeries.Async(request, callSettings);
        }

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override PublishSeriesResponse PublishSeries(
            PublishSeriesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_PublishSeriesRequest(ref request, ref callSettings);
            return _callPublishSeries.Sync(request, callSettings);
        }

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Book> GetBookAsync(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return _callGetBook.Async(request, callSettings);
        }

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Book GetBook(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return _callGetBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Book"/> resources.
        /// </returns>
        public override gax::PagedAsyncEnumerable<ListBooksResponse, Book> ListBooksAsync(
            ListBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListBooksRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedAsyncEnumerable<ListBooksRequest, ListBooksResponse, Book>(_callListBooks, request, callSettings);
        }

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Book"/> resources.
        /// </returns>
        public override gax::PagedEnumerable<ListBooksResponse, Book> ListBooks(
            ListBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListBooksRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedEnumerable<ListBooksRequest, ListBooksResponse, Book>(_callListBooks, request, callSettings);
        }

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public override stt::Task DeleteBookAsync(
            DeleteBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_DeleteBookRequest(ref request, ref callSettings);
            return _callDeleteBook.Async(request, callSettings);
        }

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public override void DeleteBook(
            DeleteBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_DeleteBookRequest(ref request, ref callSettings);
            _callDeleteBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Book> UpdateBookAsync(
            UpdateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_UpdateBookRequest(ref request, ref callSettings);
            return _callUpdateBook.Async(request, callSettings);
        }

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Book UpdateBook(
            UpdateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_UpdateBookRequest(ref request, ref callSettings);
            return _callUpdateBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Book> MoveBookAsync(
            MoveBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MoveBookRequest(ref request, ref callSettings);
            return _callMoveBook.Async(request, callSettings);
        }

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Book MoveBook(
            MoveBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MoveBookRequest(ref request, ref callSettings);
            return _callMoveBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public override gax::PagedAsyncEnumerable<ListStringsResponse, IResourceName> ListStringsAsync(
            ListStringsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListStringsRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedAsyncEnumerable<ListStringsRequest, ListStringsResponse, IResourceName>(_callListStrings, request, callSettings);
        }

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public override gax::PagedEnumerable<ListStringsResponse, IResourceName> ListStrings(
            ListStringsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListStringsRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedEnumerable<ListStringsRequest, ListStringsResponse, IResourceName>(_callListStrings, request, callSettings);
        }

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public override stt::Task AddCommentsAsync(
            AddCommentsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_AddCommentsRequest(ref request, ref callSettings);
            return _callAddComments.Async(request, callSettings);
        }

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public override void AddComments(
            AddCommentsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_AddCommentsRequest(ref request, ref callSettings);
            _callAddComments.Sync(request, callSettings);
        }

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<BookFromArchive> GetBookFromArchiveAsync(
            GetBookFromArchiveRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookFromArchiveRequest(ref request, ref callSettings);
            return _callGetBookFromArchive.Async(request, callSettings);
        }

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override BookFromArchive GetBookFromArchive(
            GetBookFromArchiveRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookFromArchiveRequest(ref request, ref callSettings);
            return _callGetBookFromArchive.Sync(request, callSettings);
        }

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            GetBookFromAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookFromAnywhereRequest(ref request, ref callSettings);
            return _callGetBookFromAnywhere.Async(request, callSettings);
        }

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override BookFromAnywhere GetBookFromAnywhere(
            GetBookFromAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookFromAnywhereRequest(ref request, ref callSettings);
            return _callGetBookFromAnywhere.Sync(request, callSettings);
        }

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            GetBookFromAbsolutelyAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookFromAbsolutelyAnywhereRequest(ref request, ref callSettings);
            return _callGetBookFromAbsolutelyAnywhere.Async(request, callSettings);
        }

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override BookFromAnywhere GetBookFromAbsolutelyAnywhere(
            GetBookFromAbsolutelyAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookFromAbsolutelyAnywhereRequest(ref request, ref callSettings);
            return _callGetBookFromAbsolutelyAnywhere.Sync(request, callSettings);
        }

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public override stt::Task UpdateBookIndexAsync(
            UpdateBookIndexRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_UpdateBookIndexRequest(ref request, ref callSettings);
            return _callUpdateBookIndex.Async(request, callSettings);
        }

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public override void UpdateBookIndex(
            UpdateBookIndexRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_UpdateBookIndexRequest(ref request, ref callSettings);
            _callUpdateBookIndex.Sync(request, callSettings);
        }

        /// <summary>
        /// Test server streaming
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The server stream.
        /// </returns>
        public override StreamShelvesStream StreamShelves(
            StreamShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_StreamShelvesRequest(ref request, ref callSettings);
            return new StreamShelvesStreamImpl(_callStreamShelves.Call(request, callSettings));
        }

        internal sealed partial class StreamShelvesStreamImpl : StreamShelvesStream
        {
            /// <summary>
            /// Construct the server-streaming method for <c>StreamShelves</c>.
            /// </summary>
            /// <param name="call">The underlying gRPC server-streaming call.</param>
            internal StreamShelvesStreamImpl(grpccore::AsyncServerStreamingCall<StreamShelvesResponse> call)
            {
                GrpcCall = call;
            }

            /// <inheritdoc/>
            public override grpccore::AsyncServerStreamingCall<StreamShelvesResponse> GrpcCall { get; }

            /// <inheritdoc/>
            public override scg::IAsyncEnumerator<StreamShelvesResponse> ResponseStream => GrpcCall.ResponseStream;
        }

        /// <summary>
        /// Test server streaming, non-paged responses.
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The server stream.
        /// </returns>
        public override StreamBooksStream StreamBooks(
            StreamBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_StreamBooksRequest(ref request, ref callSettings);
            return new StreamBooksStreamImpl(_callStreamBooks.Call(request, callSettings));
        }

        internal sealed partial class StreamBooksStreamImpl : StreamBooksStream
        {
            /// <summary>
            /// Construct the server-streaming method for <c>StreamBooks</c>.
            /// </summary>
            /// <param name="call">The underlying gRPC server-streaming call.</param>
            internal StreamBooksStreamImpl(grpccore::AsyncServerStreamingCall<Book> call)
            {
                GrpcCall = call;
            }

            /// <inheritdoc/>
            public override grpccore::AsyncServerStreamingCall<Book> GrpcCall { get; }

            /// <inheritdoc/>
            public override scg::IAsyncEnumerator<Book> ResponseStream => GrpcCall.ResponseStream;
        }

        /// <summary>
        /// Test bidi-streaming.
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <param name="streamingSettings">
        /// If not null, applies streaming overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The client-server stream.
        /// </returns>
        public override DiscussBookStream DiscussBook(
            gaxgrpc::CallSettings callSettings = null,
            gaxgrpc::BidirectionalStreamingSettings streamingSettings = null)
        {
            Modify_DiscussBookRequestCallSettings(ref callSettings);
            gaxgrpc::BidirectionalStreamingSettings effectiveStreamingSettings =
                streamingSettings ?? _callDiscussBook.StreamingSettings;
            grpccore::AsyncDuplexStreamingCall<DiscussBookRequest, Comment> call =
                _callDiscussBook.Call(callSettings);
            gaxgrpc::BufferedClientStreamWriter<DiscussBookRequest> writeBuffer =
                new gaxgrpc::BufferedClientStreamWriter<DiscussBookRequest>(
                    call.RequestStream, effectiveStreamingSettings.BufferedClientWriterCapacity);
            return new DiscussBookStreamImpl(this, call, writeBuffer);
        }

        internal sealed partial class DiscussBookStreamImpl : DiscussBookStream
        {
            /// <summary>
            /// Construct the bidirectional streaming method for <c>DiscussBook</c>.
            /// </summary>
            /// <param name="service">The service containing this streaming method.</param>
            /// <param name="call">The underlying gRPC duplex streaming call.</param>
            /// <param name="writeBuffer">The <see cref="gaxgrpc::BufferedClientStreamWriter{DiscussBookRequest}"/>
            /// instance associated with this streaming call.</param>
            public DiscussBookStreamImpl(
                LibraryServiceClientImpl service,
                grpccore::AsyncDuplexStreamingCall<DiscussBookRequest, Comment> call,
                gaxgrpc::BufferedClientStreamWriter<DiscussBookRequest> writeBuffer)
            {
                _service = service;
                GrpcCall = call;
                _writeBuffer = writeBuffer;
            }

            private LibraryServiceClientImpl _service;
            private gaxgrpc::BufferedClientStreamWriter<DiscussBookRequest> _writeBuffer;

            private DiscussBookRequest ModifyRequest(DiscussBookRequest request)
            {
                _service.Modify_DiscussBookRequestRequest(ref request);
                return request;
            }

            /// <inheritdoc/>
            public override grpccore::AsyncDuplexStreamingCall<DiscussBookRequest, Comment> GrpcCall { get; }

            /// <inheritdoc/>
            public override stt::Task TryWriteAsync(DiscussBookRequest message) =>
                _writeBuffer.TryWriteAsync(ModifyRequest(message));

            /// <inheritdoc/>
            public override stt::Task WriteAsync(DiscussBookRequest message) =>
                _writeBuffer.WriteAsync(ModifyRequest(message));

            /// <inheritdoc/>
            public override stt::Task TryWriteAsync(DiscussBookRequest message, grpccore::WriteOptions options) =>
                _writeBuffer.TryWriteAsync(ModifyRequest(message), options);

            /// <inheritdoc/>
            public override stt::Task WriteAsync(DiscussBookRequest message, grpccore::WriteOptions options) =>
                _writeBuffer.WriteAsync(ModifyRequest(message), options);

            /// <inheritdoc/>
            public override stt::Task TryWriteCompleteAsync() =>
                _writeBuffer.TryWriteCompleteAsync();

            /// <inheritdoc/>
            public override stt::Task WriteCompleteAsync() =>
                _writeBuffer.WriteCompleteAsync();

            /// <inheritdoc/>
            public override scg::IAsyncEnumerator<Comment> ResponseStream =>
                GrpcCall.ResponseStream;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public override gax::PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> FindRelatedBooksAsync(
            FindRelatedBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_FindRelatedBooksRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedAsyncEnumerable<FindRelatedBooksRequest, FindRelatedBooksResponse, BookNameOneof>(_callFindRelatedBooks, request, callSettings);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public override gax::PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> FindRelatedBooks(
            FindRelatedBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_FindRelatedBooksRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedEnumerable<FindRelatedBooksRequest, FindRelatedBooksResponse, BookNameOneof>(_callFindRelatedBooks, request, callSettings);
        }

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<gtv::AddLabelResponse> AddLabelAsync(
            gtv::AddLabelRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_AddLabelRequest(ref request, ref callSettings);
            return _callAddLabel.Async(request, callSettings);
        }

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override gtv::AddLabelResponse AddLabel(
            gtv::AddLabelRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_AddLabelRequest(ref request, ref callSettings);
            return _callAddLabel.Sync(request, callSettings);
        }

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override async stt::Task<lro::Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return new lro::Operation<Book, GetBigBookMetadata>(
                await _callGetBigBook.Async(request, callSettings).ConfigureAwait(false), GetBigBookOperationsClient);
        }

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override lro::Operation<Book, GetBigBookMetadata> GetBigBook(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return new lro::Operation<Book, GetBigBookMetadata>(
                _callGetBigBook.Sync(request, callSettings), GetBigBookOperationsClient);
        }

        /// <summary>
        /// The long-running operations client for <c>GetBigBook</c>.
        /// </summary>
        public override lro::OperationsClient GetBigBookOperationsClient { get; }

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override async stt::Task<lro::Operation<pbwkt::Empty, GetBigBookMetadata>> GetBigNothingAsync(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return new lro::Operation<pbwkt::Empty, GetBigBookMetadata>(
                await _callGetBigNothing.Async(request, callSettings).ConfigureAwait(false), GetBigNothingOperationsClient);
        }

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override lro::Operation<pbwkt::Empty, GetBigBookMetadata> GetBigNothing(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return new lro::Operation<pbwkt::Empty, GetBigBookMetadata>(
                _callGetBigNothing.Sync(request, callSettings), GetBigNothingOperationsClient);
        }

        /// <summary>
        /// The long-running operations client for <c>GetBigNothing</c>.
        /// </summary>
        public override lro::OperationsClient GetBigNothingOperationsClient { get; }

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            TestOptionalRequiredFlatteningParamsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_TestOptionalRequiredFlatteningParamsRequest(ref request, ref callSettings);
            return _callTestOptionalRequiredFlatteningParams.Async(request, callSettings);
        }

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override TestOptionalRequiredFlatteningParamsResponse TestOptionalRequiredFlatteningParams(
            TestOptionalRequiredFlatteningParamsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_TestOptionalRequiredFlatteningParamsRequest(ref request, ref callSettings);
            return _callTestOptionalRequiredFlatteningParams.Sync(request, callSettings);
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<ListAggregatedShelvesResponse> ListAggregatedShelvesAsync(
            ListAggregatedShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListAggregatedShelvesRequest(ref request, ref callSettings);
            return _callListAggregatedShelves.Async(request, callSettings);
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override ListAggregatedShelvesResponse ListAggregatedShelves(
            ListAggregatedShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListAggregatedShelvesRequest(ref request, ref callSettings);
            return _callListAggregatedShelves.Sync(request, callSettings);
        }

        /// <summary>
        /// Creates an inventory. Tests singleton resources.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Inventory> CreateInventoryAsync(
            CreateInventoryRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_CreateInventoryRequest(ref request, ref callSettings);
            return _callCreateInventory.Async(request, callSettings);
        }

        /// <summary>
        /// Creates an inventory. Tests singleton resources.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Inventory CreateInventory(
            CreateInventoryRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_CreateInventoryRequest(ref request, ref callSettings);
            return _callCreateInventory.Sync(request, callSettings);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<MoveBooksResponse> MoveBooksAsync(
            MoveBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MoveBooksRequest(ref request, ref callSettings);
            return _callMoveBooks.Async(request, callSettings);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override MoveBooksResponse MoveBooks(
            MoveBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MoveBooksRequest(ref request, ref callSettings);
            return _callMoveBooks.Sync(request, callSettings);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<ArchiveBooksResponse> ArchiveBooksAsync(
            ArchiveBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ArchiveBooksRequest(ref request, ref callSettings);
            return _callArchiveBooks.Async(request, callSettings);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override ArchiveBooksResponse ArchiveBooks(
            ArchiveBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ArchiveBooksRequest(ref request, ref callSettings);
            return _callArchiveBooks.Sync(request, callSettings);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override async stt::Task<lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata>> LongRunningArchiveBooksAsync(
            ArchiveBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ArchiveBooksRequest(ref request, ref callSettings);
            return new lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata>(
                await _callLongRunningArchiveBooks.Async(request, callSettings).ConfigureAwait(false), LongRunningArchiveBooksOperationsClient);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata> LongRunningArchiveBooks(
            ArchiveBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ArchiveBooksRequest(ref request, ref callSettings);
            return new lro::Operation<ArchiveBooksResponse, ArchiveBooksMetadata>(
                _callLongRunningArchiveBooks.Sync(request, callSettings), LongRunningArchiveBooksOperationsClient);
        }

        /// <summary>
        /// The long-running operations client for <c>LongRunningArchiveBooks</c>.
        /// </summary>
        public override lro::OperationsClient LongRunningArchiveBooksOperationsClient { get; }

        /// <summary>
        ///
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <param name="streamingSettings">
        /// If not null, applies streaming overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The client-server stream.
        /// </returns>
        public override StreamingArchiveBooksStream StreamingArchiveBooks(
            gaxgrpc::CallSettings callSettings = null,
            gaxgrpc::BidirectionalStreamingSettings streamingSettings = null)
        {
            Modify_ArchiveBooksRequestCallSettings(ref callSettings);
            gaxgrpc::BidirectionalStreamingSettings effectiveStreamingSettings =
                streamingSettings ?? _callStreamingArchiveBooks.StreamingSettings;
            grpccore::AsyncDuplexStreamingCall<ArchiveBooksRequest, ArchiveBooksResponse> call =
                _callStreamingArchiveBooks.Call(callSettings);
            gaxgrpc::BufferedClientStreamWriter<ArchiveBooksRequest> writeBuffer =
                new gaxgrpc::BufferedClientStreamWriter<ArchiveBooksRequest>(
                    call.RequestStream, effectiveStreamingSettings.BufferedClientWriterCapacity);
            return new StreamingArchiveBooksStreamImpl(this, call, writeBuffer);
        }

        internal sealed partial class StreamingArchiveBooksStreamImpl : StreamingArchiveBooksStream
        {
            /// <summary>
            /// Construct the bidirectional streaming method for <c>StreamingArchiveBooks</c>.
            /// </summary>
            /// <param name="service">The service containing this streaming method.</param>
            /// <param name="call">The underlying gRPC duplex streaming call.</param>
            /// <param name="writeBuffer">The <see cref="gaxgrpc::BufferedClientStreamWriter{ArchiveBooksRequest}"/>
            /// instance associated with this streaming call.</param>
            public StreamingArchiveBooksStreamImpl(
                LibraryServiceClientImpl service,
                grpccore::AsyncDuplexStreamingCall<ArchiveBooksRequest, ArchiveBooksResponse> call,
                gaxgrpc::BufferedClientStreamWriter<ArchiveBooksRequest> writeBuffer)
            {
                _service = service;
                GrpcCall = call;
                _writeBuffer = writeBuffer;
            }

            private LibraryServiceClientImpl _service;
            private gaxgrpc::BufferedClientStreamWriter<ArchiveBooksRequest> _writeBuffer;

            private ArchiveBooksRequest ModifyRequest(ArchiveBooksRequest request)
            {
                _service.Modify_ArchiveBooksRequestRequest(ref request);
                return request;
            }

            /// <inheritdoc/>
            public override grpccore::AsyncDuplexStreamingCall<ArchiveBooksRequest, ArchiveBooksResponse> GrpcCall { get; }

            /// <inheritdoc/>
            public override stt::Task TryWriteAsync(ArchiveBooksRequest message) =>
                _writeBuffer.TryWriteAsync(ModifyRequest(message));

            /// <inheritdoc/>
            public override stt::Task WriteAsync(ArchiveBooksRequest message) =>
                _writeBuffer.WriteAsync(ModifyRequest(message));

            /// <inheritdoc/>
            public override stt::Task TryWriteAsync(ArchiveBooksRequest message, grpccore::WriteOptions options) =>
                _writeBuffer.TryWriteAsync(ModifyRequest(message), options);

            /// <inheritdoc/>
            public override stt::Task WriteAsync(ArchiveBooksRequest message, grpccore::WriteOptions options) =>
                _writeBuffer.WriteAsync(ModifyRequest(message), options);

            /// <inheritdoc/>
            public override stt::Task TryWriteCompleteAsync() =>
                _writeBuffer.TryWriteCompleteAsync();

            /// <inheritdoc/>
            public override stt::Task WriteCompleteAsync() =>
                _writeBuffer.WriteCompleteAsync();

            /// <inheritdoc/>
            public override scg::IAsyncEnumerator<ArchiveBooksResponse> ResponseStream =>
                GrpcCall.ResponseStream;
        }

        /// <summary>
        /// Test using resource messages as request objects. Only used by PubSub (CreateSubscription) for historical reasons.
        /// New APIs should always create a separate message for a request.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public override stt::Task SaveBookAsync(
            Book request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_Book(ref request, ref callSettings);
            return _callSaveBook.Async(request, callSettings);
        }

        /// <summary>
        /// Test using resource messages as request objects. Only used by PubSub (CreateSubscription) for historical reasons.
        /// New APIs should always create a separate message for a request.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public override void SaveBook(
            Book request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_Book(ref request, ref callSettings);
            _callSaveBook.Sync(request, callSettings);
        }

        /// <summary>
        /// This method is not exposed in the GAPIC config. It should be generated.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Book> PrivateListShelvesAsync(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListShelvesRequest(ref request, ref callSettings);
            return _callPrivateListShelves.Async(request, callSettings);
        }

        /// <summary>
        /// This method is not exposed in the GAPIC config. It should be generated.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Book PrivateListShelves(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListShelvesRequest(ref request, ref callSettings);
            return _callPrivateListShelves.Sync(request, callSettings);
        }

    }

    // Partial classes to enable page-streaming

    public partial class ListShelvesRequest : gaxgrpc::IPageRequest { }
    public partial class ListShelvesResponse : gaxgrpc::IPageResponse<Shelf>
    {
        /// <summary>
        /// Returns an enumerator that iterates through the resources in this response.
        /// </summary>
        public scg::IEnumerator<Shelf> GetEnumerator() => Shelves.GetEnumerator();

        /// <inheritdoc/>
        sc::IEnumerator sc::IEnumerable.GetEnumerator() => GetEnumerator();
    }

    public partial class ListBooksRequest : gaxgrpc::IPageRequest { }
    public partial class ListBooksResponse : gaxgrpc::IPageResponse<Book>
    {
        /// <summary>
        /// Returns an enumerator that iterates through the resources in this response.
        /// </summary>
        public scg::IEnumerator<Book> GetEnumerator() => Books.GetEnumerator();

        /// <inheritdoc/>
        sc::IEnumerator sc::IEnumerable.GetEnumerator() => GetEnumerator();
    }

    public partial class ListStringsRequest : gaxgrpc::IPageRequest { }
    public partial class ListStringsResponse : gaxgrpc::IPageResponse<IResourceName>
    {
        /// <summary>
        /// Returns an enumerator that iterates through the resources in this response.
        /// </summary>
        public scg::IEnumerator<IResourceName> GetEnumerator() => StringsAsResourceNames.GetEnumerator();

        /// <inheritdoc/>
        sc::IEnumerator sc::IEnumerable.GetEnumerator() => GetEnumerator();
    }

    public partial class FindRelatedBooksRequest : gaxgrpc::IPageRequest { }
    public partial class FindRelatedBooksResponse : gaxgrpc::IPageResponse<BookNameOneof>
    {
        /// <summary>
        /// Returns an enumerator that iterates through the resources in this response.
        /// </summary>
        public scg::IEnumerator<BookNameOneof> GetEnumerator() => BookNameOneofs.GetEnumerator();

        /// <inheritdoc/>
        sc::IEnumerator sc::IEnumerable.GetEnumerator() => GetEnumerator();
    }

    // Partial Grpc class to enable LRO client creation
    public static partial class LibraryService
    {
        public partial class LibraryServiceClient
        {
            /// <summary>
            /// Creates a new instance of <see cref="lro::Operations.OperationsClient"/> using the same call invoker as this client.
            /// </summary>
            /// <returns>A new Operations client for the same target as this client.</returns>
            public virtual lro::Operations.OperationsClient CreateOperationsClient() => new lro::Operations.OperationsClient(CallInvoker);
        }
    }

    // Partial Grpc class to enable gctv::Labeler.LabelerClient client creation
    public static partial class LibraryService
    {
        public partial class LibraryServiceClient
        {
            /// <summary>
            /// Creates a new instance of <see cref="gctv::Labeler.LabelerClient"/> using the same call invoker as this client.
            /// </summary>
            /// <returns>A new gctv::Labeler.LabelerClient for the same target as this client.</returns>
            public virtual gctv::Labeler.LabelerClient CreateLabelerClient() => new gctv::Labeler.LabelerClient(CallInvoker);
        }
    }


}

============== file: Google.Example.Library.V1/Google.Example.Library.V1/MyProtoClient.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

using gax = Google.Api.Gax;
using gaxgrpc = Google.Api.Gax.Grpc;
using pb = Google.Protobuf;
using pbwkt = Google.Protobuf.WellKnownTypes;
using grpccore = Grpc.Core;
using sys = System;
using sc = System.Collections;
using scg = System.Collections.Generic;
using sco = System.Collections.ObjectModel;
using st = System.Threading;
using stt = System.Threading.Tasks;

namespace Google.Example.Library.V1
{
    /// <summary>
    /// Settings for a <see cref="MyProtoClient"/>.
    /// </summary>
    public sealed partial class MyProtoSettings : gaxgrpc::ServiceSettingsBase
    {
        /// <summary>
        /// Get a new instance of the default <see cref="MyProtoSettings"/>.
        /// </summary>
        /// <returns>
        /// A new instance of the default <see cref="MyProtoSettings"/>.
        /// </returns>
        public static MyProtoSettings GetDefault() => new MyProtoSettings();

        /// <summary>
        /// Constructs a new <see cref="MyProtoSettings"/> object with default settings.
        /// </summary>
        public MyProtoSettings() { }

        private MyProtoSettings(MyProtoSettings existing) : base(existing)
        {
            gax::GaxPreconditions.CheckNotNull(existing, nameof(existing));
            MyMethodSettings = existing.MyMethodSettings;
            GetNamespaceSettings = existing.GetNamespaceSettings;
            OnCopy(existing);
        }

        partial void OnCopy(MyProtoSettings existing);

        /// <summary>
        /// The filter specifying which RPC <see cref="grpccore::StatusCode"/>s are eligible for retry
        /// for "Idempotent" <see cref="MyProtoClient"/> RPC methods.
        /// </summary>
        /// <remarks>
        /// The eligible RPC <see cref="grpccore::StatusCode"/>s for retry for "Idempotent" RPC methods are:
        /// <list type="bullet">
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// </remarks>
        public static sys::Predicate<grpccore::RpcException> IdempotentRetryFilter { get; } =
            gaxgrpc::RetrySettings.FilterForStatusCodes(grpccore::StatusCode.DeadlineExceeded, grpccore::StatusCode.Unavailable);

        /// <summary>
        /// The filter specifying which RPC <see cref="grpccore::StatusCode"/>s are eligible for retry
        /// for "NonIdempotent" <see cref="MyProtoClient"/> RPC methods.
        /// </summary>
        /// <remarks>
        /// There are no RPC <see cref="grpccore::StatusCode"/>s eligible for retry for "NonIdempotent" RPC methods.
        /// </remarks>
        public static sys::Predicate<grpccore::RpcException> NonIdempotentRetryFilter { get; } =
            gaxgrpc::RetrySettings.FilterForStatusCodes();

        /// <summary>
        /// "Default" retry backoff for <see cref="MyProtoClient"/> RPC methods.
        /// </summary>
        /// <returns>
        /// The "Default" retry backoff for <see cref="MyProtoClient"/> RPC methods.
        /// </returns>
        /// <remarks>
        /// The "Default" retry backoff for <see cref="MyProtoClient"/> RPC methods is defined as:
        /// <list type="bullet">
        /// <item><description>Initial delay: 100 milliseconds</description></item>
        /// <item><description>Maximum delay: 60000 milliseconds</description></item>
        /// <item><description>Delay multiplier: 1.3</description></item>
        /// </list>
        /// </remarks>
        public static gaxgrpc::BackoffSettings GetDefaultRetryBackoff() => new gaxgrpc::BackoffSettings(
            delay: sys::TimeSpan.FromMilliseconds(100),
            maxDelay: sys::TimeSpan.FromMilliseconds(60000),
            delayMultiplier: 1.3
        );

        /// <summary>
        /// "Default" timeout backoff for <see cref="MyProtoClient"/> RPC methods.
        /// </summary>
        /// <returns>
        /// The "Default" timeout backoff for <see cref="MyProtoClient"/> RPC methods.
        /// </returns>
        /// <remarks>
        /// The "Default" timeout backoff for <see cref="MyProtoClient"/> RPC methods is defined as:
        /// <list type="bullet">
        /// <item><description>Initial timeout: 20000 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.0</description></item>
        /// <item><description>Maximum timeout: 20000 milliseconds</description></item>
        /// </list>
        /// </remarks>
        public static gaxgrpc::BackoffSettings GetDefaultTimeoutBackoff() => new gaxgrpc::BackoffSettings(
            delay: sys::TimeSpan.FromMilliseconds(20000),
            maxDelay: sys::TimeSpan.FromMilliseconds(20000),
            delayMultiplier: 1.0
        );

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>MyProtoClient.MyMethod</c> and <c>MyProtoClient.MyMethodAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>MyProtoClient.MyMethod</c> and
        /// <c>MyProtoClient.MyMethodAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.3</description></item>
        /// <item><description>Retry maximum delay: 60000 milliseconds</description></item>
        /// <item><description>Initial timeout: 20000 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.0</description></item>
        /// <item><description>Timeout maximum delay: 20000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 600000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings MyMethodSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(600000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>MyProtoClient.GetNamespace</c> and <c>MyProtoClient.GetNamespaceAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>MyProtoClient.GetNamespace</c> and
        /// <c>MyProtoClient.GetNamespaceAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.3</description></item>
        /// <item><description>Retry maximum delay: 60000 milliseconds</description></item>
        /// <item><description>Initial timeout: 20000 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.0</description></item>
        /// <item><description>Timeout maximum delay: 20000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 600000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetNamespaceSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(600000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// Creates a deep clone of this object, with all the same property values.
        /// </summary>
        /// <returns>A deep clone of this <see cref="MyProtoSettings"/> object.</returns>
        public MyProtoSettings Clone() => new MyProtoSettings(this);
    }

    /// <summary>
    /// Builder class for <see cref="MyProtoClient"/> to provide simple configuration of credentials, endpoint etc.
    /// </summary>
    public sealed partial class MyProtoClientBuilder : gaxgrpc::ClientBuilderBase<MyProtoClient>
    {
        /// <summary>
        /// The settings to use for RPCs, or null for the default settings.
        /// </summary>
        public MyProtoSettings Settings { get; set; }

        /// <inheritdoc/>
        public override MyProtoClient Build()
        {
            Validate();
            grpccore::CallInvoker callInvoker = CreateCallInvoker();
            return MyProtoClient.Create(callInvoker, Settings);
        }

        /// <inheritdoc />
        public override async stt::Task<MyProtoClient> BuildAsync(st::CancellationToken cancellationToken = default)
        {
            Validate();
            grpccore::CallInvoker callInvoker = await CreateCallInvokerAsync(cancellationToken).ConfigureAwait(false);
            return MyProtoClient.Create(callInvoker, Settings);
        }

        /// <inheritdoc />
        protected override gaxgrpc::ServiceEndpoint GetDefaultEndpoint() => MyProtoClient.DefaultEndpoint;

        /// <inheritdoc />
        protected override scg::IReadOnlyList<string> GetDefaultScopes() => MyProtoClient.DefaultScopes;

        /// <inheritdoc />
        protected override gaxgrpc::ChannelPool GetChannelPool() => MyProtoClient.ChannelPool;
    }

    /// <summary>
    /// MyProto client wrapper, for convenient use.
    /// </summary>
    public abstract partial class MyProtoClient
    {
        /// <summary>
        /// The default endpoint for the MyProto service, which is a host of "library-example.googleapis.com" and a port of 1234.
        /// </summary>
        public static gaxgrpc::ServiceEndpoint DefaultEndpoint { get; } = new gaxgrpc::ServiceEndpoint("library-example.googleapis.com", 1234);

        /// <summary>
        /// The default MyProto scopes.
        /// </summary>
        /// <remarks>
        /// The default MyProto scopes are:
        /// <list type="bullet">
        /// <item><description>"https://www.googleapis.com/auth/cloud-platform"</description></item>
        /// <item><description>"https://www.googleapis.com/auth/library"</description></item>
        /// </list>
        /// </remarks>
        public static scg::IReadOnlyList<string> DefaultScopes { get; } = new sco::ReadOnlyCollection<string>(new string[] {
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/library",
        });

        private static readonly gaxgrpc::ChannelPool s_channelPool = new gaxgrpc::ChannelPool(DefaultScopes);

        internal static gaxgrpc::ChannelPool ChannelPool => s_channelPool;

        /// <summary>
        /// Asynchronously creates a <see cref="MyProtoClient"/>, applying defaults for all unspecified settings,
        /// and creating a channel connecting to the given endpoint with application default credentials where
        /// necessary. See the example for how to use custom credentials.
        /// </summary>
        /// <example>
        /// This sample shows how to create a client using default credentials:
        /// <code>
        /// using Google.Example.Library.V1;
        /// ...
        /// // When running on Google Cloud Platform this will use the project Compute Credential.
        /// // Or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to the path of a JSON
        /// // credential file to use that credential.
        /// MyProtoClient client = await MyProtoClient.CreateAsync();
        /// </code>
        /// This sample shows how to create a client using credentials loaded from a JSON file:
        /// <code>
        /// using Google.Example.Library.V1;
        /// using Google.Apis.Auth.OAuth2;
        /// using Grpc.Auth;
        /// using Grpc.Core;
        /// ...
        /// GoogleCredential cred = GoogleCredential.FromFile("/path/to/credentials.json");
        /// Channel channel = new Channel(
        ///     MyProtoClient.DefaultEndpoint.Host, MyProtoClient.DefaultEndpoint.Port, cred.ToChannelCredentials());
        /// MyProtoClient client = MyProtoClient.Create(channel);
        /// ...
        /// // Shutdown the channel when it is no longer required.
        /// await channel.ShutdownAsync();
        /// </code>
        /// </example>
        /// <param name="endpoint">Optional <see cref="gaxgrpc::ServiceEndpoint"/>.</param>
        /// <param name="settings">Optional <see cref="MyProtoSettings"/>.</param>
        /// <returns>The task representing the created <see cref="MyProtoClient"/>.</returns>
        public static async stt::Task<MyProtoClient> CreateAsync(gaxgrpc::ServiceEndpoint endpoint = null, MyProtoSettings settings = null)
        {
            grpccore::Channel channel = await s_channelPool.GetChannelAsync(endpoint ?? DefaultEndpoint).ConfigureAwait(false);
            return Create(channel, settings);
        }

        /// <summary>
        /// Synchronously creates a <see cref="MyProtoClient"/>, applying defaults for all unspecified settings,
        /// and creating a channel connecting to the given endpoint with application default credentials where
        /// necessary. See the example for how to use custom credentials.
        /// </summary>
        /// <example>
        /// This sample shows how to create a client using default credentials:
        /// <code>
        /// using Google.Example.Library.V1;
        /// ...
        /// // When running on Google Cloud Platform this will use the project Compute Credential.
        /// // Or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to the path of a JSON
        /// // credential file to use that credential.
        /// MyProtoClient client = MyProtoClient.Create();
        /// </code>
        /// This sample shows how to create a client using credentials loaded from a JSON file:
        /// <code>
        /// using Google.Example.Library.V1;
        /// using Google.Apis.Auth.OAuth2;
        /// using Grpc.Auth;
        /// using Grpc.Core;
        /// ...
        /// GoogleCredential cred = GoogleCredential.FromFile("/path/to/credentials.json");
        /// Channel channel = new Channel(
        ///     MyProtoClient.DefaultEndpoint.Host, MyProtoClient.DefaultEndpoint.Port, cred.ToChannelCredentials());
        /// MyProtoClient client = MyProtoClient.Create(channel);
        /// ...
        /// // Shutdown the channel when it is no longer required.
        /// channel.ShutdownAsync().Wait();
        /// </code>
        /// </example>
        /// <param name="endpoint">Optional <see cref="gaxgrpc::ServiceEndpoint"/>.</param>
        /// <param name="settings">Optional <see cref="MyProtoSettings"/>.</param>
        /// <returns>The created <see cref="MyProtoClient"/>.</returns>
        public static MyProtoClient Create(gaxgrpc::ServiceEndpoint endpoint = null, MyProtoSettings settings = null)
        {
            grpccore::Channel channel = s_channelPool.GetChannel(endpoint ?? DefaultEndpoint);
            return Create(channel, settings);
        }

        /// <summary>
        /// Creates a <see cref="MyProtoClient"/> which uses the specified channel for remote operations.
        /// </summary>
        /// <param name="channel">The <see cref="grpccore::Channel"/> for remote operations. Must not be null.</param>
        /// <param name="settings">Optional <see cref="MyProtoSettings"/>.</param>
        /// <returns>The created <see cref="MyProtoClient"/>.</returns>
        public static MyProtoClient Create(grpccore::Channel channel, MyProtoSettings settings = null)
        {
            gax::GaxPreconditions.CheckNotNull(channel, nameof(channel));
            return Create(new grpccore::DefaultCallInvoker(channel), settings);
        }

        /// <summary>
        /// Creates a <see cref="MyProtoClient"/> which uses the specified call invoker for remote operations.
        /// </summary>
        /// <param name="callInvoker">The <see cref="grpccore::CallInvoker"/> for remote operations. Must not be null.</param>
        /// <param name="settings">Optional <see cref="MyProtoSettings"/>.</param>
        /// <returns>The created <see cref="MyProtoClient"/>.</returns>
        public static MyProtoClient Create(grpccore::CallInvoker callInvoker, MyProtoSettings settings = null)
        {
            gax::GaxPreconditions.CheckNotNull(callInvoker, nameof(callInvoker));
            grpccore::Interceptors.Interceptor interceptor = settings?.Interceptor;
            if (interceptor != null)
            {
                callInvoker = grpccore::Interceptors.CallInvokerExtensions.Intercept(callInvoker, interceptor);
            }
            MyProto.MyProtoClient grpcClient = new MyProto.MyProtoClient(callInvoker);
            return new MyProtoClientImpl(grpcClient, settings);
        }

        /// <summary>
        /// Shuts down any channels automatically created by <see cref="Create(gaxgrpc::ServiceEndpoint, MyProtoSettings)"/>
        /// and <see cref="CreateAsync(gaxgrpc::ServiceEndpoint, MyProtoSettings)"/>. Channels which weren't automatically
        /// created are not affected.
        /// </summary>
        /// <remarks>After calling this method, further calls to <see cref="Create(gaxgrpc::ServiceEndpoint, MyProtoSettings)"/>
        /// and <see cref="CreateAsync(gaxgrpc::ServiceEndpoint, MyProtoSettings)"/> will create new channels, which could
        /// in turn be shut down by another call to this method.</remarks>
        /// <returns>A task representing the asynchronous shutdown operation.</returns>
        public static stt::Task ShutdownDefaultChannelsAsync() => s_channelPool.ShutdownChannelsAsync();

        /// <summary>
        /// The underlying gRPC MyProto client.
        /// </summary>
        public virtual MyProto.MyProtoClient GrpcClient
        {
            get { throw new sys::NotImplementedException(); }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MethodResponse> MyMethodAsync(
            MethodRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MethodResponse> MyMethodAsync(
            MethodRequest request,
            st::CancellationToken cancellationToken) => MyMethodAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MethodResponse MyMethod(
            MethodRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Define a service with a reserved name
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Namespace> GetNamespaceAsync(
            MethodRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Define a service with a reserved name
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Namespace> GetNamespaceAsync(
            MethodRequest request,
            st::CancellationToken cancellationToken) => GetNamespaceAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Define a service with a reserved name
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Namespace GetNamespace(
            MethodRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

    }

    /// <summary>
    /// MyProto client wrapper implementation, for convenient use.
    /// </summary>
    public sealed partial class MyProtoClientImpl : MyProtoClient
    {
        private readonly gaxgrpc::ApiCall<MethodRequest, MethodResponse> _callMyMethod;
        private readonly gaxgrpc::ApiCall<MethodRequest, Namespace> _callGetNamespace;

        /// <summary>
        /// Constructs a client wrapper for the MyProto service, with the specified gRPC client and settings.
        /// </summary>
        /// <param name="grpcClient">The underlying gRPC client.</param>
        /// <param name="settings">The base <see cref="MyProtoSettings"/> used within this client </param>
        public MyProtoClientImpl(MyProto.MyProtoClient grpcClient, MyProtoSettings settings)
        {
            GrpcClient = grpcClient;
            MyProtoSettings effectiveSettings = settings ?? MyProtoSettings.GetDefault();
            gaxgrpc::ClientHelper clientHelper = new gaxgrpc::ClientHelper(effectiveSettings);
            _callMyMethod = clientHelper.BuildApiCall<MethodRequest, MethodResponse>(
                GrpcClient.MyMethodAsync, GrpcClient.MyMethod, effectiveSettings.MyMethodSettings);
            _callGetNamespace = clientHelper.BuildApiCall<MethodRequest, Namespace>(
                GrpcClient.GetNamespaceAsync, GrpcClient.GetNamespace, effectiveSettings.GetNamespaceSettings);
            Modify_ApiCall(ref _callMyMethod);
            Modify_MyMethodApiCall(ref _callMyMethod);
            Modify_ApiCall(ref _callGetNamespace);
            Modify_GetNamespaceApiCall(ref _callGetNamespace);
            OnConstruction(grpcClient, effectiveSettings, clientHelper);
        }

        // Partial methods are named to (mostly) ensure there cannot be conflicts with RPC method names.

        // Partial methods called for every ApiCall on construction.
        // Allows modification of all the underlying ApiCall objects.
        partial void Modify_ApiCall<TRequest, TResponse>(ref gaxgrpc::ApiCall<TRequest, TResponse> call)
            where TRequest : class, pb::IMessage<TRequest>
            where TResponse : class, pb::IMessage<TResponse>;

        // Partial methods called for each ApiCall on construction.
        // Allows per-RPC-method modification of the underlying ApiCall object.
        partial void Modify_MyMethodApiCall(ref gaxgrpc::ApiCall<MethodRequest, MethodResponse> call);
        partial void Modify_GetNamespaceApiCall(ref gaxgrpc::ApiCall<MethodRequest, Namespace> call);
        partial void OnConstruction(MyProto.MyProtoClient grpcClient, MyProtoSettings effectiveSettings, gaxgrpc::ClientHelper clientHelper);

        /// <summary>
        /// The underlying gRPC MyProto client.
        /// </summary>
        public override MyProto.MyProtoClient GrpcClient { get; }

        // Partial methods called on each request.
        // Allows per-RPC-call modification to the request and CallSettings objects,
        // before the underlying RPC is performed.
        partial void Modify_MethodRequest(ref MethodRequest request, ref gaxgrpc::CallSettings settings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<MethodResponse> MyMethodAsync(
            MethodRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MethodRequest(ref request, ref callSettings);
            return _callMyMethod.Async(request, callSettings);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override MethodResponse MyMethod(
            MethodRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MethodRequest(ref request, ref callSettings);
            return _callMyMethod.Sync(request, callSettings);
        }

        /// <summary>
        /// Define a service with a reserved name
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Namespace> GetNamespaceAsync(
            MethodRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MethodRequest(ref request, ref callSettings);
            return _callGetNamespace.Async(request, callSettings);
        }

        /// <summary>
        /// Define a service with a reserved name
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Namespace GetNamespace(
            MethodRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MethodRequest(ref request, ref callSettings);
            return _callGetNamespace.Sync(request, callSettings);
        }

    }

    // Partial classes to enable page-streaming


}

============== file: Google.Example.Library.V1/Google.Example.Library.V1/ResourceNames.cs ==============
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

using gax = Google.Api.Gax;
using sys = System;
using scg = System.Collections.Generic;
using linq = System.Linq;

namespace Google.Example.Library.V1
{
    /// <summary>
    /// Resource name for the 'archive' resource.
    /// </summary>
    public sealed partial class ArchiveName : gax::IResourceName, sys::IEquatable<ArchiveName>
    {
        private static readonly gax::PathTemplate s_template = new gax::PathTemplate("archives/{archive}");

        /// <summary>
        /// Parses the given archive resource name in string form into a new
        /// <see cref="ArchiveName"/> instance.
        /// </summary>
        /// <param name="archiveName">The archive resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="ArchiveName"/> if successful.</returns>
        public static ArchiveName Parse(string archiveName)
        {
            gax::GaxPreconditions.CheckNotNull(archiveName, nameof(archiveName));
            gax::TemplatedResourceName resourceName = s_template.ParseName(archiveName);
            return new ArchiveName(resourceName[0]);
        }

        /// <summary>
        /// Tries to parse the given archive resource name in string form into a new
        /// <see cref="ArchiveName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="sys::ArgumentNullException"/> if <paramref name="archiveName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="archiveName">The archive resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="ArchiveName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed successfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string archiveName, out ArchiveName result)
        {
            gax::GaxPreconditions.CheckNotNull(archiveName, nameof(archiveName));
            gax::TemplatedResourceName resourceName;
            if (s_template.TryParseName(archiveName, out resourceName))
            {
                result = new ArchiveName(resourceName[0]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>Formats the IDs into the string representation of the <see cref="ArchiveName"/>.</summary>
        /// <param name="archiveId">The <c>archive</c> ID. Must not be <c>null</c>.</param>
        /// <returns>The string representation of the <see cref="ArchiveName"/>.</returns>
        public static string Format(string archiveId) =>
            s_template.Expand(gax::GaxPreconditions.CheckNotNull(archiveId, nameof(archiveId)));

        /// <summary>
        /// Constructs a new instance of the <see cref="ArchiveName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="archiveId">The archive ID. Must not be <c>null</c>.</param>
        public ArchiveName(string archiveId)
        {
            ArchiveId = gax::GaxPreconditions.CheckNotNull(archiveId, nameof(archiveId));
        }

        /// <summary>
        /// The archive ID. Never <c>null</c>.
        /// </summary>
        public string ArchiveId { get; }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ArchiveId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as ArchiveName);

        /// <inheritdoc />
        public bool Equals(ArchiveName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(ArchiveName a, ArchiveName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(ArchiveName a, ArchiveName b) => !(a == b);
    }

    /// <summary>
    /// Resource name for the 'archived_book' resource.
    /// </summary>
    public sealed partial class ArchivedBookName : gax::IResourceName, sys::IEquatable<ArchivedBookName>
    {
        private static readonly gax::PathTemplate s_template = new gax::PathTemplate("archives/{archive}/books/{book}");

        /// <summary>
        /// Parses the given archived_book resource name in string form into a new
        /// <see cref="ArchivedBookName"/> instance.
        /// </summary>
        /// <param name="archivedBookName">The archived_book resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="ArchivedBookName"/> if successful.</returns>
        public static ArchivedBookName Parse(string archivedBookName)
        {
            gax::GaxPreconditions.CheckNotNull(archivedBookName, nameof(archivedBookName));
            gax::TemplatedResourceName resourceName = s_template.ParseName(archivedBookName);
            return new ArchivedBookName(resourceName[0], resourceName[1]);
        }

        /// <summary>
        /// Tries to parse the given archived_book resource name in string form into a new
        /// <see cref="ArchivedBookName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="sys::ArgumentNullException"/> if <paramref name="archivedBookName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="archivedBookName">The archived_book resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="ArchivedBookName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed successfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string archivedBookName, out ArchivedBookName result)
        {
            gax::GaxPreconditions.CheckNotNull(archivedBookName, nameof(archivedBookName));
            gax::TemplatedResourceName resourceName;
            if (s_template.TryParseName(archivedBookName, out resourceName))
            {
                result = new ArchivedBookName(resourceName[0], resourceName[1]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>Formats the IDs into the string representation of the <see cref="ArchivedBookName"/>.</summary>
        /// <param name="archiveId">The <c>archive</c> ID. Must not be <c>null</c>.</param>
        /// <param name="bookId">The <c>book</c> ID. Must not be <c>null</c>.</param>
        /// <returns>The string representation of the <see cref="ArchivedBookName"/>.</returns>
        public static string Format(string archiveId, string bookId) =>
            s_template.Expand(gax::GaxPreconditions.CheckNotNull(archiveId, nameof(archiveId)), gax::GaxPreconditions.CheckNotNull(bookId, nameof(bookId)));

        /// <summary>
        /// Constructs a new instance of the <see cref="ArchivedBookName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="archiveId">The archive ID. Must not be <c>null</c>.</param>
        /// <param name="bookId">The book ID. Must not be <c>null</c>.</param>
        public ArchivedBookName(string archiveId, string bookId)
        {
            ArchiveId = gax::GaxPreconditions.CheckNotNull(archiveId, nameof(archiveId));
            BookId = gax::GaxPreconditions.CheckNotNull(bookId, nameof(bookId));
        }

        /// <summary>
        /// The archive ID. Never <c>null</c>.
        /// </summary>
        public string ArchiveId { get; }

        /// <summary>
        /// The book ID. Never <c>null</c>.
        /// </summary>
        public string BookId { get; }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ArchiveId, BookId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as ArchivedBookName);

        /// <inheritdoc />
        public bool Equals(ArchivedBookName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(ArchivedBookName a, ArchivedBookName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(ArchivedBookName a, ArchivedBookName b) => !(a == b);
    }

    /// <summary>
    /// Resource name for the 'book_from_archive' resource.
    /// </summary>
    public sealed partial class BookFromArchiveName : gax::IResourceName, sys::IEquatable<BookFromArchiveName>
    {
        private static readonly gax::PathTemplate s_template = new gax::PathTemplate("archives/{archive}/books/{book}");

        /// <summary>
        /// Parses the given book_from_archive resource name in string form into a new
        /// <see cref="BookFromArchiveName"/> instance.
        /// </summary>
        /// <param name="bookFromArchiveName">The book_from_archive resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="BookFromArchiveName"/> if successful.</returns>
        public static BookFromArchiveName Parse(string bookFromArchiveName)
        {
            gax::GaxPreconditions.CheckNotNull(bookFromArchiveName, nameof(bookFromArchiveName));
            gax::TemplatedResourceName resourceName = s_template.ParseName(bookFromArchiveName);
            return new BookFromArchiveName(resourceName[0], resourceName[1]);
        }

        /// <summary>
        /// Tries to parse the given book_from_archive resource name in string form into a new
        /// <see cref="BookFromArchiveName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="sys::ArgumentNullException"/> if <paramref name="bookFromArchiveName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="bookFromArchiveName">The book_from_archive resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="BookFromArchiveName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed successfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string bookFromArchiveName, out BookFromArchiveName result)
        {
            gax::GaxPreconditions.CheckNotNull(bookFromArchiveName, nameof(bookFromArchiveName));
            gax::TemplatedResourceName resourceName;
            if (s_template.TryParseName(bookFromArchiveName, out resourceName))
            {
                result = new BookFromArchiveName(resourceName[0], resourceName[1]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>Formats the IDs into the string representation of the <see cref="BookFromArchiveName"/>.</summary>
        /// <param name="archiveId">The <c>archive</c> ID. Must not be <c>null</c>.</param>
        /// <param name="bookId">The <c>book</c> ID. Must not be <c>null</c>.</param>
        /// <returns>The string representation of the <see cref="BookFromArchiveName"/>.</returns>
        public static string Format(string archiveId, string bookId) =>
            s_template.Expand(gax::GaxPreconditions.CheckNotNull(archiveId, nameof(archiveId)), gax::GaxPreconditions.CheckNotNull(bookId, nameof(bookId)));

        /// <summary>
        /// Constructs a new instance of the <see cref="BookFromArchiveName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="archiveId">The archive ID. Must not be <c>null</c>.</param>
        /// <param name="bookId">The book ID. Must not be <c>null</c>.</param>
        public BookFromArchiveName(string archiveId, string bookId)
        {
            ArchiveId = gax::GaxPreconditions.CheckNotNull(archiveId, nameof(archiveId));
            BookId = gax::GaxPreconditions.CheckNotNull(bookId, nameof(bookId));
        }

        /// <summary>
        /// The archive ID. Never <c>null</c>.
        /// </summary>
        public string ArchiveId { get; }

        /// <summary>
        /// The book ID. Never <c>null</c>.
        /// </summary>
        public string BookId { get; }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ArchiveId, BookId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as BookFromArchiveName);

        /// <inheritdoc />
        public bool Equals(BookFromArchiveName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(BookFromArchiveName a, BookFromArchiveName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(BookFromArchiveName a, BookFromArchiveName b) => !(a == b);
    }

    /// <summary>
    /// Resource name which will contain one of a choice of resource names.
    /// </summary>
    /// <remarks>
    /// This resource name will contain one of the following:
    /// <list type="bullet">
    /// <item><description>BookFromArchiveName: A resource of type 'book_from_archive'.</description></item>
    /// <item><description>ProjectBookName: A resource of type 'project_book'.</description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BookNameOneof : gax::IResourceName, sys::IEquatable<BookNameOneof>
    {
        /// <summary>
        /// The possible contents of <see cref="BookNameOneof"/>.
        /// </summary>
        public enum OneofType
        {
            /// <summary>
            /// A resource of an unknown type.
            /// </summary>
            Unknown = 0,

            /// <summary>
            /// A resource of type 'book_from_archive'.
            /// </summary>
            BookFromArchiveName = 1,

            /// <summary>
            /// A resource of type 'project_book'.
            /// </summary>
            ProjectBookName = 2,
        }

        /// <summary>
        /// Parses a resource name in string form into a new <see cref="BookNameOneof"/> instance.
        /// </summary>
        /// <remarks>
        /// To parse successfully the resource name must be one of the following:
        /// <list type="bullet">
        /// <item><description>BookFromArchiveName: A resource of type 'book_from_archive'.</description></item>
        /// <item><description>ProjectBookName: A resource of type 'project_book'.</description></item>
        /// </list>
        /// Or an <see cref="gax::UnknownResourceName"/> if <paramref name="allowUnknown"/> is <c>true</c>.
        /// </remarks>
        /// <param name="name">The resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="allowUnknown">If true, will successfully parse an unknown resource name
        /// into an <see cref="gax::UnknownResourceName"/>; otherwise will throw an
        /// <see cref="sys::ArgumentException"/> if an unknown resource name is given.</param>
        /// <returns>The parsed <see cref="BookNameOneof"/> if successful.</returns>
        public static BookNameOneof Parse(string name, bool allowUnknown)
        {
            BookNameOneof result;
            if (TryParse(name, allowUnknown, out result))
            {
                return result;
            }
            throw new sys::ArgumentException("Invalid name", nameof(name));
        }

        /// <summary>
        /// Tries to parse a resource name in string form into a new <see cref="BookNameOneof"/> instance.
        /// </summary>
        /// <remarks>
        /// To parse successfully the resource name must be one of the following:
        /// <list type="bullet">
        /// <item><description>BookFromArchiveName: A resource of type 'book_from_archive'.</description></item>
        /// <item><description>ProjectBookName: A resource of type 'project_book'.</description></item>
        /// </list>
        /// Or an <see cref="gax::UnknownResourceName"/> if <paramref name="allowUnknown"/> is <c>true</c>.
        /// </remarks>
        /// <param name="name">The resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="allowUnknown">If true, will successfully parse an unknown resource name
        /// into an <see cref="gax::UnknownResourceName"/>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="BookNameOneof"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed succssfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string name, bool allowUnknown, out BookNameOneof result)
        {
            gax::GaxPreconditions.CheckNotNull(name, nameof(name));
            BookFromArchiveName bookFromArchiveName;
            if (BookFromArchiveName.TryParse(name, out bookFromArchiveName))
            {
                result = new BookNameOneof(OneofType.BookFromArchiveName, bookFromArchiveName);
                return true;
            }
            ProjectBookName projectBookName;
            if (ProjectBookName.TryParse(name, out projectBookName))
            {
                result = new BookNameOneof(OneofType.ProjectBookName, projectBookName);
                return true;
            }
            if (allowUnknown)
            {
                gax::UnknownResourceName unknownResourceName;
                if (gax::UnknownResourceName.TryParse(name, out unknownResourceName))
                {
                    result = new BookNameOneof(OneofType.Unknown, unknownResourceName);
                    return true;
                }
            }
            result = null;
            return false;
        }

        /// <summary>
        /// Construct a new instance of <see cref="BookNameOneof"/> from the provided <see cref="BookFromArchiveName"/>
        /// </summary>
        /// <param name="bookFromArchiveName">The <see cref="BookFromArchiveName"/> to be contained within
        /// the returned <see cref="BookNameOneof"/>. Must not be <c>null</c>.</param>
        /// <returns>A new <see cref="BookNameOneof"/>, containing <paramref name="bookFromArchiveName"/>.</returns>
        public static BookNameOneof From(BookFromArchiveName bookFromArchiveName) => new BookNameOneof(OneofType.BookFromArchiveName, bookFromArchiveName);

        /// <summary>
        /// Construct a new instance of <see cref="BookNameOneof"/> from the provided <see cref="ProjectBookName"/>
        /// </summary>
        /// <param name="projectBookName">The <see cref="ProjectBookName"/> to be contained within
        /// the returned <see cref="BookNameOneof"/>. Must not be <c>null</c>.</param>
        /// <returns>A new <see cref="BookNameOneof"/>, containing <paramref name="projectBookName"/>.</returns>
        public static BookNameOneof From(ProjectBookName projectBookName) => new BookNameOneof(OneofType.ProjectBookName, projectBookName);

        private static bool IsValid(OneofType type, gax::IResourceName name)
        {
            switch (type)
            {
                case OneofType.Unknown: return true; // Anything goes with Unknown.
                case OneofType.BookFromArchiveName: return name is BookFromArchiveName;
                case OneofType.ProjectBookName: return name is ProjectBookName;
                default: return false;
            }
        }

        /// <summary>
        /// Constructs a new instance of the <see cref="BookNameOneof"/> resource name class
        /// from a suitable <see cref="gax::IResourceName"/> instance.
        /// </summary>
        public BookNameOneof(OneofType type, gax::IResourceName name)
        {
            Type = gax::GaxPreconditions.CheckEnumValue<OneofType>(type, nameof(type));
            Name = gax::GaxPreconditions.CheckNotNull(name, nameof(name));
            if (!IsValid(type, name))
            {
                throw new sys::ArgumentException($"Mismatched OneofType '{type}' and resource name '{name}'");
            }
        }

        /// <summary>
        /// The <see cref="OneofType"/> of the Name contained in this instance.
        /// </summary>
        public OneofType Type { get; }

        /// <summary>
        /// The <see cref="gax::IResourceName"/> contained in this instance.
        /// </summary>
        public gax::IResourceName Name { get; }

        private T CheckAndReturn<T>(OneofType type)
        {
            if (Type != type)
            {
                throw new sys::InvalidOperationException($"Requested type {type}, but this one-of contains type {Type}");
            }
            return (T)Name;
        }

        /// <summary>
        /// Get the contained <see cref="gax::IResourceName"/> as <see cref="BookFromArchiveName"/>.
        /// </summary>
        /// <remarks>
        /// An <see cref="sys::InvalidOperationException"/> will be thrown if this does not
        /// contain an instance of <see cref="BookFromArchiveName"/>.
        /// </remarks>
        public BookFromArchiveName BookFromArchiveName => CheckAndReturn<BookFromArchiveName>(OneofType.BookFromArchiveName);

        /// <summary>
        /// Get the contained <see cref="gax::IResourceName"/> as <see cref="ProjectBookName"/>.
        /// </summary>
        /// <remarks>
        /// An <see cref="sys::InvalidOperationException"/> will be thrown if this does not
        /// contain an instance of <see cref="ProjectBookName"/>.
        /// </remarks>
        public ProjectBookName ProjectBookName => CheckAndReturn<ProjectBookName>(OneofType.ProjectBookName);

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Oneof;

        /// <inheritdoc />
        public override string ToString() => Name.ToString();

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as BookNameOneof);

        /// <inheritdoc />
        public bool Equals(BookNameOneof other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(BookNameOneof a, BookNameOneof b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(BookNameOneof a, BookNameOneof b) => !(a == b);
    }

    /// <summary>
    /// Resource name for the 'folder' resource.
    /// </summary>
    public sealed partial class FolderName : gax::IResourceName, sys::IEquatable<FolderName>
    {
        private static readonly gax::PathTemplate s_template = new gax::PathTemplate("folders/{folder}");

        /// <summary>
        /// Parses the given folder resource name in string form into a new
        /// <see cref="FolderName"/> instance.
        /// </summary>
        /// <param name="folderName">The folder resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="FolderName"/> if successful.</returns>
        public static FolderName Parse(string folderName)
        {
            gax::GaxPreconditions.CheckNotNull(folderName, nameof(folderName));
            gax::TemplatedResourceName resourceName = s_template.ParseName(folderName);
            return new FolderName(resourceName[0]);
        }

        /// <summary>
        /// Tries to parse the given folder resource name in string form into a new
        /// <see cref="FolderName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="sys::ArgumentNullException"/> if <paramref name="folderName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="folderName">The folder resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="FolderName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed successfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string folderName, out FolderName result)
        {
            gax::GaxPreconditions.CheckNotNull(folderName, nameof(folderName));
            gax::TemplatedResourceName resourceName;
            if (s_template.TryParseName(folderName, out resourceName))
            {
                result = new FolderName(resourceName[0]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>Formats the IDs into the string representation of the <see cref="FolderName"/>.</summary>
        /// <param name="folderId">The <c>folder</c> ID. Must not be <c>null</c>.</param>
        /// <returns>The string representation of the <see cref="FolderName"/>.</returns>
        public static string Format(string folderId) =>
            s_template.Expand(gax::GaxPreconditions.CheckNotNull(folderId, nameof(folderId)));

        /// <summary>
        /// Constructs a new instance of the <see cref="FolderName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="folderId">The folder ID. Must not be <c>null</c>.</param>
        public FolderName(string folderId)
        {
            FolderId = gax::GaxPreconditions.CheckNotNull(folderId, nameof(folderId));
        }

        /// <summary>
        /// The folder ID. Never <c>null</c>.
        /// </summary>
        public string FolderId { get; }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(FolderId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as FolderName);

        /// <inheritdoc />
        public bool Equals(FolderName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(FolderName a, FolderName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(FolderName a, FolderName b) => !(a == b);
    }

    /// <summary>
    /// Resource name for the 'inventory' resource.
    /// </summary>
    public sealed partial class InventoryName : gax::IResourceName, sys::IEquatable<InventoryName>
    {
        private static readonly gax::PathTemplate s_template = new gax::PathTemplate("projects/{project}/locations/{location}/publishers/{publisher}/inventory");

        /// <summary>
        /// Parses the given inventory resource name in string form into a new
        /// <see cref="InventoryName"/> instance.
        /// </summary>
        /// <param name="inventoryName">The inventory resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="InventoryName"/> if successful.</returns>
        public static InventoryName Parse(string inventoryName)
        {
            gax::GaxPreconditions.CheckNotNull(inventoryName, nameof(inventoryName));
            gax::TemplatedResourceName resourceName = s_template.ParseName(inventoryName);
            return new InventoryName(resourceName[0], resourceName[1], resourceName[2]);
        }

        /// <summary>
        /// Tries to parse the given inventory resource name in string form into a new
        /// <see cref="InventoryName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="sys::ArgumentNullException"/> if <paramref name="inventoryName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="inventoryName">The inventory resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="InventoryName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed successfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string inventoryName, out InventoryName result)
        {
            gax::GaxPreconditions.CheckNotNull(inventoryName, nameof(inventoryName));
            gax::TemplatedResourceName resourceName;
            if (s_template.TryParseName(inventoryName, out resourceName))
            {
                result = new InventoryName(resourceName[0], resourceName[1], resourceName[2]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>Formats the IDs into the string representation of the <see cref="InventoryName"/>.</summary>
        /// <param name="projectId">The <c>project</c> ID. Must not be <c>null</c>.</param>
        /// <param name="locationId">The <c>location</c> ID. Must not be <c>null</c>.</param>
        /// <param name="publisherId">The <c>publisher</c> ID. Must not be <c>null</c>.</param>
        /// <returns>The string representation of the <see cref="InventoryName"/>.</returns>
        public static string Format(string projectId, string locationId, string publisherId) =>
            s_template.Expand(gax::GaxPreconditions.CheckNotNull(projectId, nameof(projectId)), gax::GaxPreconditions.CheckNotNull(locationId, nameof(locationId)), gax::GaxPreconditions.CheckNotNull(publisherId, nameof(publisherId)));

        /// <summary>
        /// Constructs a new instance of the <see cref="InventoryName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="projectId">The project ID. Must not be <c>null</c>.</param>
        /// <param name="locationId">The location ID. Must not be <c>null</c>.</param>
        /// <param name="publisherId">The publisher ID. Must not be <c>null</c>.</param>
        public InventoryName(string projectId, string locationId, string publisherId)
        {
            ProjectId = gax::GaxPreconditions.CheckNotNull(projectId, nameof(projectId));
            LocationId = gax::GaxPreconditions.CheckNotNull(locationId, nameof(locationId));
            PublisherId = gax::GaxPreconditions.CheckNotNull(publisherId, nameof(publisherId));
        }

        /// <summary>
        /// The project ID. Never <c>null</c>.
        /// </summary>
        public string ProjectId { get; }

        /// <summary>
        /// The location ID. Never <c>null</c>.
        /// </summary>
        public string LocationId { get; }

        /// <summary>
        /// The publisher ID. Never <c>null</c>.
        /// </summary>
        public string PublisherId { get; }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ProjectId, LocationId, PublisherId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as InventoryName);

        /// <inheritdoc />
        public bool Equals(InventoryName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(InventoryName a, InventoryName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(InventoryName a, InventoryName b) => !(a == b);
    }

    /// <summary>
    /// Resource name for the 'location' resource.
    /// </summary>
    public sealed partial class LocationName : gax::IResourceName, sys::IEquatable<LocationName>
    {
        private static readonly gax::PathTemplate s_template = new gax::PathTemplate("projects/{project}/locations/{location}");

        /// <summary>
        /// Parses the given location resource name in string form into a new
        /// <see cref="LocationName"/> instance.
        /// </summary>
        /// <param name="locationName">The location resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="LocationName"/> if successful.</returns>
        public static LocationName Parse(string locationName)
        {
            gax::GaxPreconditions.CheckNotNull(locationName, nameof(locationName));
            gax::TemplatedResourceName resourceName = s_template.ParseName(locationName);
            return new LocationName(resourceName[0], resourceName[1]);
        }

        /// <summary>
        /// Tries to parse the given location resource name in string form into a new
        /// <see cref="LocationName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="sys::ArgumentNullException"/> if <paramref name="locationName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="locationName">The location resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="LocationName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed successfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string locationName, out LocationName result)
        {
            gax::GaxPreconditions.CheckNotNull(locationName, nameof(locationName));
            gax::TemplatedResourceName resourceName;
            if (s_template.TryParseName(locationName, out resourceName))
            {
                result = new LocationName(resourceName[0], resourceName[1]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>Formats the IDs into the string representation of the <see cref="LocationName"/>.</summary>
        /// <param name="projectId">The <c>project</c> ID. Must not be <c>null</c>.</param>
        /// <param name="locationId">The <c>location</c> ID. Must not be <c>null</c>.</param>
        /// <returns>The string representation of the <see cref="LocationName"/>.</returns>
        public static string Format(string projectId, string locationId) =>
            s_template.Expand(gax::GaxPreconditions.CheckNotNull(projectId, nameof(projectId)), gax::GaxPreconditions.CheckNotNull(locationId, nameof(locationId)));

        /// <summary>
        /// Constructs a new instance of the <see cref="LocationName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="projectId">The project ID. Must not be <c>null</c>.</param>
        /// <param name="locationId">The location ID. Must not be <c>null</c>.</param>
        public LocationName(string projectId, string locationId)
        {
            ProjectId = gax::GaxPreconditions.CheckNotNull(projectId, nameof(projectId));
            LocationId = gax::GaxPreconditions.CheckNotNull(locationId, nameof(locationId));
        }

        /// <summary>
        /// The project ID. Never <c>null</c>.
        /// </summary>
        public string ProjectId { get; }

        /// <summary>
        /// The location ID. Never <c>null</c>.
        /// </summary>
        public string LocationId { get; }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ProjectId, LocationId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as LocationName);

        /// <inheritdoc />
        public bool Equals(LocationName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(LocationName a, LocationName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(LocationName a, LocationName b) => !(a == b);
    }

    /// <summary>
    /// Resource name for the 'project' resource.
    /// </summary>
    public sealed partial class ProjectName : gax::IResourceName, sys::IEquatable<ProjectName>
    {
        private static readonly gax::PathTemplate s_template = new gax::PathTemplate("projects/{project}");

        /// <summary>
        /// Parses the given project resource name in string form into a new
        /// <see cref="ProjectName"/> instance.
        /// </summary>
        /// <param name="projectName">The project resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="ProjectName"/> if successful.</returns>
        public static ProjectName Parse(string projectName)
        {
            gax::GaxPreconditions.CheckNotNull(projectName, nameof(projectName));
            gax::TemplatedResourceName resourceName = s_template.ParseName(projectName);
            return new ProjectName(resourceName[0]);
        }

        /// <summary>
        /// Tries to parse the given project resource name in string form into a new
        /// <see cref="ProjectName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="sys::ArgumentNullException"/> if <paramref name="projectName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="projectName">The project resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="ProjectName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed successfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string projectName, out ProjectName result)
        {
            gax::GaxPreconditions.CheckNotNull(projectName, nameof(projectName));
            gax::TemplatedResourceName resourceName;
            if (s_template.TryParseName(projectName, out resourceName))
            {
                result = new ProjectName(resourceName[0]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>Formats the IDs into the string representation of the <see cref="ProjectName"/>.</summary>
        /// <param name="projectId">The <c>project</c> ID. Must not be <c>null</c>.</param>
        /// <returns>The string representation of the <see cref="ProjectName"/>.</returns>
        public static string Format(string projectId) =>
            s_template.Expand(gax::GaxPreconditions.CheckNotNull(projectId, nameof(projectId)));

        /// <summary>
        /// Constructs a new instance of the <see cref="ProjectName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="projectId">The project ID. Must not be <c>null</c>.</param>
        public ProjectName(string projectId)
        {
            ProjectId = gax::GaxPreconditions.CheckNotNull(projectId, nameof(projectId));
        }

        /// <summary>
        /// The project ID. Never <c>null</c>.
        /// </summary>
        public string ProjectId { get; }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ProjectId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as ProjectName);

        /// <inheritdoc />
        public bool Equals(ProjectName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(ProjectName a, ProjectName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(ProjectName a, ProjectName b) => !(a == b);
    }

    /// <summary>
    /// Resource name for the 'project_book' resource.
    /// </summary>
    public sealed partial class ProjectBookName : gax::IResourceName, sys::IEquatable<ProjectBookName>
    {
        private static readonly gax::PathTemplate s_template = new gax::PathTemplate("projects/{project}/books/{book}");

        /// <summary>
        /// Parses the given project_book resource name in string form into a new
        /// <see cref="ProjectBookName"/> instance.
        /// </summary>
        /// <param name="projectBookName">The project_book resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="ProjectBookName"/> if successful.</returns>
        public static ProjectBookName Parse(string projectBookName)
        {
            gax::GaxPreconditions.CheckNotNull(projectBookName, nameof(projectBookName));
            gax::TemplatedResourceName resourceName = s_template.ParseName(projectBookName);
            return new ProjectBookName(resourceName[0], resourceName[1]);
        }

        /// <summary>
        /// Tries to parse the given project_book resource name in string form into a new
        /// <see cref="ProjectBookName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="sys::ArgumentNullException"/> if <paramref name="projectBookName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="projectBookName">The project_book resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="ProjectBookName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed successfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string projectBookName, out ProjectBookName result)
        {
            gax::GaxPreconditions.CheckNotNull(projectBookName, nameof(projectBookName));
            gax::TemplatedResourceName resourceName;
            if (s_template.TryParseName(projectBookName, out resourceName))
            {
                result = new ProjectBookName(resourceName[0], resourceName[1]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>Formats the IDs into the string representation of the <see cref="ProjectBookName"/>.</summary>
        /// <param name="projectId">The <c>project</c> ID. Must not be <c>null</c>.</param>
        /// <param name="bookId">The <c>book</c> ID. Must not be <c>null</c>.</param>
        /// <returns>The string representation of the <see cref="ProjectBookName"/>.</returns>
        public static string Format(string projectId, string bookId) =>
            s_template.Expand(gax::GaxPreconditions.CheckNotNull(projectId, nameof(projectId)), gax::GaxPreconditions.CheckNotNull(bookId, nameof(bookId)));

        /// <summary>
        /// Constructs a new instance of the <see cref="ProjectBookName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="projectId">The project ID. Must not be <c>null</c>.</param>
        /// <param name="bookId">The book ID. Must not be <c>null</c>.</param>
        public ProjectBookName(string projectId, string bookId)
        {
            ProjectId = gax::GaxPreconditions.CheckNotNull(projectId, nameof(projectId));
            BookId = gax::GaxPreconditions.CheckNotNull(bookId, nameof(bookId));
        }

        /// <summary>
        /// The project ID. Never <c>null</c>.
        /// </summary>
        public string ProjectId { get; }

        /// <summary>
        /// The book ID. Never <c>null</c>.
        /// </summary>
        public string BookId { get; }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ProjectId, BookId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as ProjectBookName);

        /// <inheritdoc />
        public bool Equals(ProjectBookName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(ProjectBookName a, ProjectBookName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(ProjectBookName a, ProjectBookName b) => !(a == b);
    }

    /// <summary>
    /// Resource name for the 'publisher' resource.
    /// </summary>
    public sealed partial class PublisherName : gax::IResourceName, sys::IEquatable<PublisherName>
    {
        private static readonly gax::PathTemplate s_template = new gax::PathTemplate("projects/{project}/locations/{location}/publishers/{publisher}");

        /// <summary>
        /// Parses the given publisher resource name in string form into a new
        /// <see cref="PublisherName"/> instance.
        /// </summary>
        /// <param name="publisherName">The publisher resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="PublisherName"/> if successful.</returns>
        public static PublisherName Parse(string publisherName)
        {
            gax::GaxPreconditions.CheckNotNull(publisherName, nameof(publisherName));
            gax::TemplatedResourceName resourceName = s_template.ParseName(publisherName);
            return new PublisherName(resourceName[0], resourceName[1], resourceName[2]);
        }

        /// <summary>
        /// Tries to parse the given publisher resource name in string form into a new
        /// <see cref="PublisherName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="sys::ArgumentNullException"/> if <paramref name="publisherName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="publisherName">The publisher resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="PublisherName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed successfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string publisherName, out PublisherName result)
        {
            gax::GaxPreconditions.CheckNotNull(publisherName, nameof(publisherName));
            gax::TemplatedResourceName resourceName;
            if (s_template.TryParseName(publisherName, out resourceName))
            {
                result = new PublisherName(resourceName[0], resourceName[1], resourceName[2]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>Formats the IDs into the string representation of the <see cref="PublisherName"/>.</summary>
        /// <param name="projectId">The <c>project</c> ID. Must not be <c>null</c>.</param>
        /// <param name="locationId">The <c>location</c> ID. Must not be <c>null</c>.</param>
        /// <param name="publisherId">The <c>publisher</c> ID. Must not be <c>null</c>.</param>
        /// <returns>The string representation of the <see cref="PublisherName"/>.</returns>
        public static string Format(string projectId, string locationId, string publisherId) =>
            s_template.Expand(gax::GaxPreconditions.CheckNotNull(projectId, nameof(projectId)), gax::GaxPreconditions.CheckNotNull(locationId, nameof(locationId)), gax::GaxPreconditions.CheckNotNull(publisherId, nameof(publisherId)));

        /// <summary>
        /// Constructs a new instance of the <see cref="PublisherName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="projectId">The project ID. Must not be <c>null</c>.</param>
        /// <param name="locationId">The location ID. Must not be <c>null</c>.</param>
        /// <param name="publisherId">The publisher ID. Must not be <c>null</c>.</param>
        public PublisherName(string projectId, string locationId, string publisherId)
        {
            ProjectId = gax::GaxPreconditions.CheckNotNull(projectId, nameof(projectId));
            LocationId = gax::GaxPreconditions.CheckNotNull(locationId, nameof(locationId));
            PublisherId = gax::GaxPreconditions.CheckNotNull(publisherId, nameof(publisherId));
        }

        /// <summary>
        /// The project ID. Never <c>null</c>.
        /// </summary>
        public string ProjectId { get; }

        /// <summary>
        /// The location ID. Never <c>null</c>.
        /// </summary>
        public string LocationId { get; }

        /// <summary>
        /// The publisher ID. Never <c>null</c>.
        /// </summary>
        public string PublisherId { get; }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ProjectId, LocationId, PublisherId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as PublisherName);

        /// <inheritdoc />
        public bool Equals(PublisherName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(PublisherName a, PublisherName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(PublisherName a, PublisherName b) => !(a == b);
    }

    /// <summary>
    /// Resource name which will contain one of a choice of resource names.
    /// </summary>
    /// <remarks>
    /// This resource name will contain one of the following:
    /// <list type="bullet">
    /// </list>
    /// </remarks>
    public sealed partial class ReaderNameOneof : gax::IResourceName, sys::IEquatable<ReaderNameOneof>
    {
        /// <summary>
        /// The possible contents of <see cref="ReaderNameOneof"/>.
        /// </summary>
        public enum OneofType
        {
            /// <summary>
            /// A resource of an unknown type.
            /// </summary>
            Unknown = 0,
        }

        /// <summary>
        /// Parses a resource name in string form into a new <see cref="ReaderNameOneof"/> instance.
        /// </summary>
        /// <remarks>
        /// To parse successfully the resource name must be one of the following:
        /// <list type="bullet">
        /// </list>
        /// Or an <see cref="gax::UnknownResourceName"/> if <paramref name="allowUnknown"/> is <c>true</c>.
        /// </remarks>
        /// <param name="name">The resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="allowUnknown">If true, will successfully parse an unknown resource name
        /// into an <see cref="gax::UnknownResourceName"/>; otherwise will throw an
        /// <see cref="sys::ArgumentException"/> if an unknown resource name is given.</param>
        /// <returns>The parsed <see cref="ReaderNameOneof"/> if successful.</returns>
        public static ReaderNameOneof Parse(string name, bool allowUnknown)
        {
            ReaderNameOneof result;
            if (TryParse(name, allowUnknown, out result))
            {
                return result;
            }
            throw new sys::ArgumentException("Invalid name", nameof(name));
        }

        /// <summary>
        /// Tries to parse a resource name in string form into a new <see cref="ReaderNameOneof"/> instance.
        /// </summary>
        /// <remarks>
        /// To parse successfully the resource name must be one of the following:
        /// <list type="bullet">
        /// </list>
        /// Or an <see cref="gax::UnknownResourceName"/> if <paramref name="allowUnknown"/> is <c>true</c>.
        /// </remarks>
        /// <param name="name">The resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="allowUnknown">If true, will successfully parse an unknown resource name
        /// into an <see cref="gax::UnknownResourceName"/>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="ReaderNameOneof"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed succssfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string name, bool allowUnknown, out ReaderNameOneof result)
        {
            gax::GaxPreconditions.CheckNotNull(name, nameof(name));
            if (allowUnknown)
            {
                gax::UnknownResourceName unknownResourceName;
                if (gax::UnknownResourceName.TryParse(name, out unknownResourceName))
                {
                    result = new ReaderNameOneof(OneofType.Unknown, unknownResourceName);
                    return true;
                }
            }
            result = null;
            return false;
        }

        private static bool IsValid(OneofType type, gax::IResourceName name)
        {
            switch (type)
            {
                case OneofType.Unknown: return true; // Anything goes with Unknown.
                default: return false;
            }
        }

        /// <summary>
        /// Constructs a new instance of the <see cref="ReaderNameOneof"/> resource name class
        /// from a suitable <see cref="gax::IResourceName"/> instance.
        /// </summary>
        public ReaderNameOneof(OneofType type, gax::IResourceName name)
        {
            Type = gax::GaxPreconditions.CheckEnumValue<OneofType>(type, nameof(type));
            Name = gax::GaxPreconditions.CheckNotNull(name, nameof(name));
            if (!IsValid(type, name))
            {
                throw new sys::ArgumentException($"Mismatched OneofType '{type}' and resource name '{name}'");
            }
        }

        /// <summary>
        /// The <see cref="OneofType"/> of the Name contained in this instance.
        /// </summary>
        public OneofType Type { get; }

        /// <summary>
        /// The <see cref="gax::IResourceName"/> contained in this instance.
        /// </summary>
        public gax::IResourceName Name { get; }

        private T CheckAndReturn<T>(OneofType type)
        {
            if (Type != type)
            {
                throw new sys::InvalidOperationException($"Requested type {type}, but this one-of contains type {Type}");
            }
            return (T)Name;
        }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Oneof;

        /// <inheritdoc />
        public override string ToString() => Name.ToString();

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as ReaderNameOneof);

        /// <inheritdoc />
        public bool Equals(ReaderNameOneof other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(ReaderNameOneof a, ReaderNameOneof b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(ReaderNameOneof a, ReaderNameOneof b) => !(a == b);
    }

    /// <summary>
    /// Resource name for the 'shelf' resource.
    /// </summary>
    public sealed partial class ShelfName : gax::IResourceName, sys::IEquatable<ShelfName>
    {
        private static readonly gax::PathTemplate s_template = new gax::PathTemplate("shelves/{shelf}");

        /// <summary>
        /// Parses the given shelf resource name in string form into a new
        /// <see cref="ShelfName"/> instance.
        /// </summary>
        /// <param name="shelfName">The shelf resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="ShelfName"/> if successful.</returns>
        public static ShelfName Parse(string shelfName)
        {
            gax::GaxPreconditions.CheckNotNull(shelfName, nameof(shelfName));
            gax::TemplatedResourceName resourceName = s_template.ParseName(shelfName);
            return new ShelfName(resourceName[0]);
        }

        /// <summary>
        /// Tries to parse the given shelf resource name in string form into a new
        /// <see cref="ShelfName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="sys::ArgumentNullException"/> if <paramref name="shelfName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="shelfName">The shelf resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="ShelfName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed successfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string shelfName, out ShelfName result)
        {
            gax::GaxPreconditions.CheckNotNull(shelfName, nameof(shelfName));
            gax::TemplatedResourceName resourceName;
            if (s_template.TryParseName(shelfName, out resourceName))
            {
                result = new ShelfName(resourceName[0]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>Formats the IDs into the string representation of the <see cref="ShelfName"/>.</summary>
        /// <param name="shelfId">The <c>shelf</c> ID. Must not be <c>null</c>.</param>
        /// <returns>The string representation of the <see cref="ShelfName"/>.</returns>
        public static string Format(string shelfId) =>
            s_template.Expand(gax::GaxPreconditions.CheckNotNull(shelfId, nameof(shelfId)));

        /// <summary>
        /// Constructs a new instance of the <see cref="ShelfName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="shelfId">The shelf ID. Must not be <c>null</c>.</param>
        public ShelfName(string shelfId)
        {
            ShelfId = gax::GaxPreconditions.CheckNotNull(shelfId, nameof(shelfId));
        }

        /// <summary>
        /// The shelf ID. Never <c>null</c>.
        /// </summary>
        public string ShelfId { get; }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ShelfId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as ShelfName);

        /// <inheritdoc />
        public bool Equals(ShelfName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(ShelfName a, ShelfName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(ShelfName a, ShelfName b) => !(a == b);
    }


    public partial class AddCommentsRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class ArchiveBooksRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ArchiveName"/>-typed view over the <see cref="Source"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ArchiveName SourceAsArchiveName
        {
            get { return string.IsNullOrEmpty(Source) ? null : Google.Example.Library.V1.ArchiveName.Parse(Source); }
            set { Source = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.ArchiveName"/>-typed view over the <see cref="Archive"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ArchiveName ArchiveAsArchiveName
        {
            get { return string.IsNullOrEmpty(Archive) ? null : Google.Example.Library.V1.ArchiveName.Parse(Archive); }
            set { Archive = value != null ? value.ToString() : ""; }
        }

    }

    public partial class Book
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.ReaderNameOneof"/>-typed view over the <see cref="Reader"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ReaderNameOneof ReaderAsReaderNameOneof
        {
            get { return string.IsNullOrEmpty(Reader) ? null : Google.Example.Library.V1.ReaderNameOneof.Parse(Reader, true); }
            set { Reader = value != null ? value.ToString() : ""; }
        }

    }

    public partial class BookFromAnywhere
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class BookFromArchive
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ArchivedBookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ArchivedBookName ArchivedBookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ArchivedBookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class CreateBookRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class CreateInventoryRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.PublisherName"/>-typed view over the <see cref="Parent"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.PublisherName ParentAsPublisherName
        {
            get { return string.IsNullOrEmpty(Parent) ? null : Google.Example.Library.V1.PublisherName.Parse(Parent); }
            set { Parent = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="gax::IResourceName"/>-typed view over the <see cref="Asset"/> resource name property.
        /// </summary>
        public gax::IResourceName AssetAsResourceName
        {
            get { return string.IsNullOrEmpty(Asset) ? null : gax::UnknownResourceName.Parse(Asset); }
            set { Asset = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="gax::IResourceName"/>-typed view over the <see cref="ParentAsset"/> resource name property.
        /// </summary>
        public gax::IResourceName ParentAssetAsResourceName
        {
            get { return string.IsNullOrEmpty(ParentAsset) ? null : gax::UnknownResourceName.Parse(ParentAsset); }
            set { ParentAsset = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="gax::ResourceNameList{gax::IResourceName}"/>-typed view over the <see cref="Assets"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<gax::IResourceName> AssetsAsResourceNames =>
            new gax::ResourceNameList<gax::IResourceName>(Assets,
                str => gax::UnknownResourceName.Parse(str));

    }

    public partial class DeleteBookRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class DeleteShelfRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class DiscussBookRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class FindRelatedBooksRequest
    {
        /// <summary>
        /// <see cref="gax::ResourceNameList{BookNameOneof}"/>-typed view over the <see cref="Names"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<BookNameOneof> BookNameOneofs =>
            new gax::ResourceNameList<BookNameOneof>(Names,
                str => BookNameOneof.Parse(str, true));

        /// <summary>
        /// <see cref="gax::ResourceNameList{ShelfName}"/>-typed view over the <see cref="Shelves"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<ShelfName> ShelvesAsShelfNames =>
            new gax::ResourceNameList<ShelfName>(Shelves,
                str => ShelfName.Parse(str));

    }

    public partial class FindRelatedBooksResponse
    {
        /// <summary>
        /// <see cref="gax::ResourceNameList{BookNameOneof}"/>-typed view over the <see cref="Names"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<BookNameOneof> BookNameOneofs =>
            new gax::ResourceNameList<BookNameOneof>(Names,
                str => BookNameOneof.Parse(str, true));

    }

    public partial class GetBookFromAbsolutelyAnywhereRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class GetBookFromAnywhereRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="AltBookName"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof AltBookNameAsBookNameOneof
        {
            get { return string.IsNullOrEmpty(AltBookName) ? null : Google.Example.Library.V1.BookNameOneof.Parse(AltBookName, true); }
            set { AltBookName = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.LocationName"/>-typed view over the <see cref="Place"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.LocationName PlaceAsLocationName
        {
            get { return string.IsNullOrEmpty(Place) ? null : Google.Example.Library.V1.LocationName.Parse(Place); }
            set { Place = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.FolderName"/>-typed view over the <see cref="Folder"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.FolderName FolderAsFolderName
        {
            get { return string.IsNullOrEmpty(Folder) ? null : Google.Example.Library.V1.FolderName.Parse(Folder); }
            set { Folder = value != null ? value.ToString() : ""; }
        }

    }

    public partial class GetBookFromArchiveRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ArchivedBookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ArchivedBookName ArchivedBookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ArchivedBookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.ProjectName"/>-typed view over the <see cref="Parent"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ProjectName ParentAsProjectName
        {
            get { return string.IsNullOrEmpty(Parent) ? null : Google.Example.Library.V1.ProjectName.Parse(Parent); }
            set { Parent = value != null ? value.ToString() : ""; }
        }

    }

    public partial class GetBookRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class GetShelfRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class Inventory
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.InventoryName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.InventoryName InventoryName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.InventoryName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class ListBooksRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class ListStringsRequest
    {
        /// <summary>
        /// <see cref="gax::IResourceName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public gax::IResourceName AsResourceName
        {
            get { return string.IsNullOrEmpty(Name) ? null : gax::UnknownResourceName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class ListStringsResponse
    {
        /// <summary>
        /// <see cref="gax::ResourceNameList{gax::IResourceName}"/>-typed view over the <see cref="Strings"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<gax::IResourceName> StringsAsResourceNames =>
            new gax::ResourceNameList<gax::IResourceName>(Strings,
                str => gax::UnknownResourceName.Parse(str));

    }

    public partial class MergeShelvesRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="OtherShelfName"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName OtherShelfNameAsShelfName
        {
            get { return string.IsNullOrEmpty(OtherShelfName) ? null : Google.Example.Library.V1.ShelfName.Parse(OtherShelfName); }
            set { OtherShelfName = value != null ? value.ToString() : ""; }
        }

    }

    public partial class MoveBookRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="OtherShelfName"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName OtherShelfNameAsShelfName
        {
            get { return string.IsNullOrEmpty(OtherShelfName) ? null : Google.Example.Library.V1.ShelfName.Parse(OtherShelfName); }
            set { OtherShelfName = value != null ? value.ToString() : ""; }
        }

    }

    public partial class MoveBooksRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ArchiveName"/>-typed view over the <see cref="Source"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ArchiveName SourceAsArchiveName
        {
            get { return string.IsNullOrEmpty(Source) ? null : Google.Example.Library.V1.ArchiveName.Parse(Source); }
            set { Source = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.ArchiveName"/>-typed view over the <see cref="Destination"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ArchiveName DestinationAsArchiveName
        {
            get { return string.IsNullOrEmpty(Destination) ? null : Google.Example.Library.V1.ArchiveName.Parse(Destination); }
            set { Destination = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="gax::ResourceNameList{PublisherName}"/>-typed view over the <see cref="Publishers"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<PublisherName> PublishersAsPublisherNames =>
            new gax::ResourceNameList<PublisherName>(Publishers,
                str => PublisherName.Parse(str));

        /// <summary>
        /// <see cref="Google.Example.Library.V1.ProjectName"/>-typed view over the <see cref="Project"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ProjectName ProjectAsProjectName
        {
            get { return string.IsNullOrEmpty(Project) ? null : Google.Example.Library.V1.ProjectName.Parse(Project); }
            set { Project = value != null ? value.ToString() : ""; }
        }

    }

    public partial class PublishSeriesRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.PublisherName"/>-typed view over the <see cref="Publisher"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.PublisherName PublisherAsPublisherName
        {
            get { return string.IsNullOrEmpty(Publisher) ? null : Google.Example.Library.V1.PublisherName.Parse(Publisher); }
            set { Publisher = value != null ? value.ToString() : ""; }
        }

    }

    public partial class Reader
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ReaderNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ReaderNameOneof ReaderNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ReaderNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class Shelf
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class StreamShelvesRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class TestOptionalRequiredFlatteningParamsRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="RequiredSingularResourceName"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof RequiredSingularResourceNameAsBookNameOneof
        {
            get { return string.IsNullOrEmpty(RequiredSingularResourceName) ? null : Google.Example.Library.V1.BookNameOneof.Parse(RequiredSingularResourceName, true); }
            set { RequiredSingularResourceName = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="RequiredSingularResourceNameOneof"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof RequiredSingularResourceNameOneofAsBookNameOneof
        {
            get { return string.IsNullOrEmpty(RequiredSingularResourceNameOneof) ? null : Google.Example.Library.V1.BookNameOneof.Parse(RequiredSingularResourceNameOneof, true); }
            set { RequiredSingularResourceNameOneof = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="gax::ResourceNameList{BookNameOneof}"/>-typed view over the <see cref="RequiredRepeatedResourceName"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<BookNameOneof> RequiredRepeatedResourceNameAsBookNameOneofs =>
            new gax::ResourceNameList<BookNameOneof>(RequiredRepeatedResourceName,
                str => BookNameOneof.Parse(str, true));

        /// <summary>
        /// <see cref="gax::ResourceNameList{BookNameOneof}"/>-typed view over the <see cref="RequiredRepeatedResourceNameOneof"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<BookNameOneof> RequiredRepeatedResourceNameOneofAsBookNameOneofs =>
            new gax::ResourceNameList<BookNameOneof>(RequiredRepeatedResourceNameOneof,
                str => BookNameOneof.Parse(str, true));

        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="OptionalSingularResourceName"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof OptionalSingularResourceNameAsBookNameOneof
        {
            get { return string.IsNullOrEmpty(OptionalSingularResourceName) ? null : Google.Example.Library.V1.BookNameOneof.Parse(OptionalSingularResourceName, true); }
            set { OptionalSingularResourceName = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="OptionalSingularResourceNameOneof"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof OptionalSingularResourceNameOneofAsBookNameOneof
        {
            get { return string.IsNullOrEmpty(OptionalSingularResourceNameOneof) ? null : Google.Example.Library.V1.BookNameOneof.Parse(OptionalSingularResourceNameOneof, true); }
            set { OptionalSingularResourceNameOneof = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="gax::ResourceNameList{BookNameOneof}"/>-typed view over the <see cref="OptionalRepeatedResourceName"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<BookNameOneof> OptionalRepeatedResourceNameAsBookNameOneofs =>
            new gax::ResourceNameList<BookNameOneof>(OptionalRepeatedResourceName,
                str => BookNameOneof.Parse(str, true));

        /// <summary>
        /// <see cref="gax::ResourceNameList{BookNameOneof}"/>-typed view over the <see cref="OptionalRepeatedResourceNameOneof"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<BookNameOneof> OptionalRepeatedResourceNameOneofAsBookNameOneofs =>
            new gax::ResourceNameList<BookNameOneof>(OptionalRepeatedResourceNameOneof,
                str => BookNameOneof.Parse(str, true));

    }

    public partial class UpdateBookIndexRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class UpdateBookRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

}
