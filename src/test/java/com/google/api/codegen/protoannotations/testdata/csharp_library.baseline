============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/DeleteShelfAsyncFlattenedAsyncEmptyResponseTypeWithResponseHandling.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedAsync", "empty_response_type_with_response_handling")

// [START sample]
// FIXME: import everything this sample needs
public class DeleteShelfAsyncFlattenedAsyncEmptyResponseTypeWithResponseHandling
{
    /// <summary>
    /// Test response handling for methods that return empty
    /// </summary>
    public static async Task SampleDeleteShelfAsync()
    {
        LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
        ShelfName name = new ShelfName("[SHELF_ID]");
        await libraryServiceClient.DeleteShelfAsync(name);
        // FIXME: inspect the results
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleDeleteShelfAsync().Wait();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/DeleteShelfAsyncFlattenedAsyncEmptyResponseTypeWithoutResponseHandling.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedAsync", "empty_response_type_without_response_handling")

// [START sample]
// FIXME: import everything this sample needs
public class DeleteShelfAsyncFlattenedAsyncEmptyResponseTypeWithoutResponseHandling
{
    /// <summary>
    /// Test default response handling is turned off for methods that return empty
    /// </summary>
    public static async Task SampleDeleteShelfAsync()
    {
        LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
        ShelfName name = new ShelfName("[SHELF_ID]");
        await libraryServiceClient.DeleteShelfAsync(name);
        // FIXME: inspect the results
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleDeleteShelfAsync().Wait();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/DeleteShelfAsyncRequestAsyncEmptyResponseTypeWithResponseHandling.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestAsync", "empty_response_type_with_response_handling")

// [START sample]
// FIXME: import everything this sample needs
public class DeleteShelfAsyncRequestAsyncEmptyResponseTypeWithResponseHandling
{
    /// <summary>
    /// Test response handling for methods that return empty
    /// </summary>
    public static async Task SampleDeleteShelfAsync()
    {
        LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
        DeleteShelfRequest request = new DeleteShelfRequest
        {
            ShelfName = new ShelfName("[SHELF_ID]"),
        };
        await libraryServiceClient.DeleteShelfAsync(request);
        // FIXME: inspect the results
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleDeleteShelfAsync().Wait();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/DeleteShelfAsyncRequestAsyncEmptyResponseTypeWithoutResponseHandling.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestAsync", "empty_response_type_without_response_handling")

// [START sample]
// FIXME: import everything this sample needs
public class DeleteShelfAsyncRequestAsyncEmptyResponseTypeWithoutResponseHandling
{
    /// <summary>
    /// Test default response handling is turned off for methods that return empty
    /// </summary>
    public static async Task SampleDeleteShelfAsync()
    {
        LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
        DeleteShelfRequest request = new DeleteShelfRequest
        {
            ShelfName = new ShelfName("[SHELF_ID]"),
        };
        await libraryServiceClient.DeleteShelfAsync(request);
        // FIXME: inspect the results
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleDeleteShelfAsync().Wait();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/DeleteShelfFlattenedEmptyResponseTypeWithResponseHandling.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Flattened", "empty_response_type_with_response_handling")

// [START sample]
// FIXME: import everything this sample needs
public class DeleteShelfFlattenedEmptyResponseTypeWithResponseHandling
{
    /// <summary>
    /// Test response handling for methods that return empty
    /// </summary>
    public static void SampleDeleteShelf()
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        ShelfName name = new ShelfName("[SHELF_ID]");
        libraryServiceClient.DeleteShelf(name);
        // FIXME: inspect the results
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleDeleteShelf();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/DeleteShelfFlattenedEmptyResponseTypeWithoutResponseHandling.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Flattened", "empty_response_type_without_response_handling")

// [START sample]
// FIXME: import everything this sample needs
public class DeleteShelfFlattenedEmptyResponseTypeWithoutResponseHandling
{
    /// <summary>
    /// Test default response handling is turned off for methods that return empty
    /// </summary>
    public static void SampleDeleteShelf()
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        ShelfName name = new ShelfName("[SHELF_ID]");
        libraryServiceClient.DeleteShelf(name);
        // FIXME: inspect the results
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleDeleteShelf();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/DeleteShelfRequestEmptyResponseTypeWithResponseHandling.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "empty_response_type_with_response_handling")

// [START sample]
// FIXME: import everything this sample needs
public class DeleteShelfRequestEmptyResponseTypeWithResponseHandling
{
    /// <summary>
    /// Test response handling for methods that return empty
    /// </summary>
    public static void SampleDeleteShelf()
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        DeleteShelfRequest request = new DeleteShelfRequest
        {
            ShelfName = new ShelfName("[SHELF_ID]"),
        };
        libraryServiceClient.DeleteShelf(request);
        // FIXME: inspect the results
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleDeleteShelf();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/DeleteShelfRequestEmptyResponseTypeWithoutResponseHandling.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "empty_response_type_without_response_handling")

// [START sample]
// FIXME: import everything this sample needs
public class DeleteShelfRequestEmptyResponseTypeWithoutResponseHandling
{
    /// <summary>
    /// Test default response handling is turned off for methods that return empty
    /// </summary>
    public static void SampleDeleteShelf()
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        DeleteShelfRequest request = new DeleteShelfRequest
        {
            ShelfName = new ShelfName("[SHELF_ID]"),
        };
        libraryServiceClient.DeleteShelf(request);
        // FIXME: inspect the results
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleDeleteShelf();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksAsyncFlattenedAsyncPagedAllOdyssey.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedAsyncPagedAll", "odyssey")

// [START sample]
// FIXME: import everything this sample needs
public class FindRelatedBooksAsyncFlattenedAsyncPagedAllOdyssey
{
    /// <summary>
    /// Testing calling forms
    /// </summary>
    public static async Task SampleFindRelatedBooksAsync()
    {
        LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
        IEnumerable<BookNameOneof> names = new[]
        {
            BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
        };
        IEnumerable<ShelfName> shelves = new[]
        {
            new ShelfName("[SHELF_ID]"),
        };
        PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> response = await libraryServiceClient.FindRelatedBooksAsync(names, shelves);
        // Iterate over pages (of server-defined size), performing one RPC per page
        await response.ForEachAsync((BookNameOneof item) =>
        {
            // FIXME: inspect the results
        });
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleFindRelatedBooksAsync().Wait();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksAsyncFlattenedAsyncPagedOdyssey.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedAsyncPaged", "odyssey")

// [START sample]
// FIXME: import everything this sample needs
public class FindRelatedBooksAsyncFlattenedAsyncPagedOdyssey
{
    /// <summary>
    /// Testing calling forms
    /// </summary>
    public static async Task SampleFindRelatedBooksAsync()
    {
        LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
        IEnumerable<BookNameOneof> names = new[]
        {
            BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
        };
        IEnumerable<ShelfName> shelves = new[]
        {
            new ShelfName("[SHELF_ID]"),
        };
        PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> response = await libraryServiceClient.FindRelatedBooksAsync(names, shelves);
        // Iterate over all response items, lazily performing RPCs as required
        await response.AsRawResponses().ForEachAsync((FindRelatedBooksResponse page) =>
        {
            foreach (BookNameOneof item in page)
            {
                // FIXME: inspect the results
            }
        });
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleFindRelatedBooksAsync().Wait();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksAsyncFlattenedAsyncPagedPageSizeOdyssey.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedAsyncPagedPageSize", "odyssey")

// [START sample]
// FIXME: import everything this sample needs
public class FindRelatedBooksAsyncFlattenedAsyncPagedPageSizeOdyssey
{
    /// <summary>
    /// Testing calling forms
    /// </summary>
    public static async Task SampleFindRelatedBooksAsync()
    {
        LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
        IEnumerable<BookNameOneof> names = new[]
        {
            BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
        };
        IEnumerable<ShelfName> shelves = new[]
        {
            new ShelfName("[SHELF_ID]"),
        };
        PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> response = await libraryServiceClient.FindRelatedBooksAsync(names, shelves);
        // Retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
        int pageSize = 10;
        Page<BookNameOneof> singlePage = await response.ReadPageAsync(pageSize);
        foreach (BookNameOneof item in response)
        {
            // FIXME: inspect the results
        }
        // Store the pageToken, for when the next page is required.
        string nextPageToken = singlePage.NextPageToken;
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleFindRelatedBooksAsync().Wait();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksAsyncRequestAsyncPagedAllOdyssey.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestAsyncPagedAll", "odyssey")

// [START sample]
// FIXME: import everything this sample needs
public class FindRelatedBooksAsyncRequestAsyncPagedAllOdyssey
{
    /// <summary>
    /// Testing calling forms
    /// </summary>
    public static async Task SampleFindRelatedBooksAsync()
    {
        LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
        FindRelatedBooksRequest request = new FindRelatedBooksRequest
        {
            BookNameOneofs =
            {
                BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            },
            ShelvesAsShelfNames =
            {
                new ShelfName("[SHELF_ID]"),
            },
        };
        PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> response = await libraryServiceClient.FindRelatedBooksAsync(request);
        // Iterate over pages (of server-defined size), performing one RPC per page
        await response.ForEachAsync((BookNameOneof item) =>
        {
            // FIXME: inspect the results
        });
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleFindRelatedBooksAsync().Wait();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksAsyncRequestAsyncPagedOdyssey.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestAsyncPaged", "odyssey")

// [START sample]
// FIXME: import everything this sample needs
public class FindRelatedBooksAsyncRequestAsyncPagedOdyssey
{
    /// <summary>
    /// Testing calling forms
    /// </summary>
    public static async Task SampleFindRelatedBooksAsync()
    {
        LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
        FindRelatedBooksRequest request = new FindRelatedBooksRequest
        {
            BookNameOneofs =
            {
                BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            },
            ShelvesAsShelfNames =
            {
                new ShelfName("[SHELF_ID]"),
            },
        };
        PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> response = await libraryServiceClient.FindRelatedBooksAsync(request);
        // Iterate over all response items, lazily performing RPCs as required
        await response.AsRawResponses().ForEachAsync((FindRelatedBooksResponse page) =>
        {
            foreach (BookNameOneof item in page)
            {
                // FIXME: inspect the results
            }
        });
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleFindRelatedBooksAsync().Wait();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksAsyncRequestAsyncPagedPageSizeOdyssey.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestAsyncPagedPageSize", "odyssey")

// [START sample]
// FIXME: import everything this sample needs
public class FindRelatedBooksAsyncRequestAsyncPagedPageSizeOdyssey
{
    /// <summary>
    /// Testing calling forms
    /// </summary>
    public static async Task SampleFindRelatedBooksAsync()
    {
        LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
        FindRelatedBooksRequest request = new FindRelatedBooksRequest
        {
            BookNameOneofs =
            {
                BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            },
            ShelvesAsShelfNames =
            {
                new ShelfName("[SHELF_ID]"),
            },
        };
        PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> response = await libraryServiceClient.FindRelatedBooksAsync(request);
        // Retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
        int pageSize = 10;
        Page<BookNameOneof> singlePage = await response.ReadPageAsync(pageSize);
        foreach (BookNameOneof item in response)
        {
            // FIXME: inspect the results
        }
        // Store the pageToken, for when the next page is required.
        string nextPageToken = singlePage.NextPageToken;
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleFindRelatedBooksAsync().Wait();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksFlattenedPagedAllOdyssey.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedPagedAll", "odyssey")

// [START sample]
// FIXME: import everything this sample needs
public class FindRelatedBooksFlattenedPagedAllOdyssey
{
    /// <summary>
    /// Testing calling forms
    /// </summary>
    public static void SampleFindRelatedBooks()
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        IEnumerable<BookNameOneof> names = new[]
        {
            BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
        };
        IEnumerable<ShelfName> shelves = new[]
        {
            new ShelfName("[SHELF_ID]"),
        };
        PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> response = libraryServiceClient.FindRelatedBooks(names, shelves);
        // Iterate over pages (of server-defined size), performing one RPC per page
        foreach (BookNameOneof item in response)
        {
            // FIXME: inspect the results
        }
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleFindRelatedBooks();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksFlattenedPagedOdyssey.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedPaged", "odyssey")

// [START sample]
// FIXME: import everything this sample needs
public class FindRelatedBooksFlattenedPagedOdyssey
{
    /// <summary>
    /// Testing calling forms
    /// </summary>
    public static void SampleFindRelatedBooks()
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        IEnumerable<BookNameOneof> names = new[]
        {
            BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
        };
        IEnumerable<ShelfName> shelves = new[]
        {
            new ShelfName("[SHELF_ID]"),
        };
        PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> response = libraryServiceClient.FindRelatedBooks(names, shelves);
        // Iterate over all response items, lazily performing RPCs as required
        foreach (FindRelatedBooksResponse page in response.asRawResponses())
        {
            foreach (BookNameOneof item in page)
            {
                // FIXME: inspect the results
            }
        }
        // FIXME: inspect the results
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleFindRelatedBooks();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksFlattenedPagedPageSizeOdyssey.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedPagedPageSize", "odyssey")

// [START sample]
// FIXME: import everything this sample needs
public class FindRelatedBooksFlattenedPagedPageSizeOdyssey
{
    /// <summary>
    /// Testing calling forms
    /// </summary>
    public static void SampleFindRelatedBooks()
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        IEnumerable<BookNameOneof> names = new[]
        {
            BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
        };
        IEnumerable<ShelfName> shelves = new[]
        {
            new ShelfName("[SHELF_ID]"),
        };
        PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> response = libraryServiceClient.FindRelatedBooks(names, shelves);
        // Retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
        int pageSize = 10;
        Page<BookNameOneof> singlePage = response.ReadPage(pageSize);
        foreach (BookNameOneof item in response)
        {
            // FIXME: inspect the results
        }
        // Store the pageToken, for when the next page is required.
        string nextPageToken = singlePage.NextPageToken;
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleFindRelatedBooks();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksRequestPagedAllOdyssey.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestPagedAll", "odyssey")

// [START sample]
// FIXME: import everything this sample needs
public class FindRelatedBooksRequestPagedAllOdyssey
{
    /// <summary>
    /// Testing calling forms
    /// </summary>
    public static void SampleFindRelatedBooks()
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        FindRelatedBooksRequest request = new FindRelatedBooksRequest
        {
            BookNameOneofs =
            {
                BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            },
            ShelvesAsShelfNames =
            {
                new ShelfName("[SHELF_ID]"),
            },
        };
        PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> response = libraryServiceClient.FindRelatedBooks(request);
        // Iterate over pages (of server-defined size), performing one RPC per page
        foreach (BookNameOneof item in response)
        {
            // FIXME: inspect the results
        }
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleFindRelatedBooks();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksRequestPagedOdyssey.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestPaged", "odyssey")

// [START sample]
// FIXME: import everything this sample needs
public class FindRelatedBooksRequestPagedOdyssey
{
    /// <summary>
    /// Testing calling forms
    /// </summary>
    public static void SampleFindRelatedBooks()
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        FindRelatedBooksRequest request = new FindRelatedBooksRequest
        {
            BookNameOneofs =
            {
                BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            },
            ShelvesAsShelfNames =
            {
                new ShelfName("[SHELF_ID]"),
            },
        };
        PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> response = libraryServiceClient.FindRelatedBooks(request);
        // Iterate over all response items, lazily performing RPCs as required
        foreach (FindRelatedBooksResponse page in response.asRawResponses())
        {
            foreach (BookNameOneof item in page)
            {
                // FIXME: inspect the results
            }
        }
        // FIXME: inspect the results
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleFindRelatedBooks();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/FindRelatedBooksRequestPagedPageSizeOdyssey.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestPagedPageSize", "odyssey")

// [START sample]
// FIXME: import everything this sample needs
public class FindRelatedBooksRequestPagedPageSizeOdyssey
{
    /// <summary>
    /// Testing calling forms
    /// </summary>
    public static void SampleFindRelatedBooks()
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        FindRelatedBooksRequest request = new FindRelatedBooksRequest
        {
            BookNameOneofs =
            {
                BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            },
            ShelvesAsShelfNames =
            {
                new ShelfName("[SHELF_ID]"),
            },
        };
        PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> response = libraryServiceClient.FindRelatedBooks(request);
        // Retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
        int pageSize = 10;
        Page<BookNameOneof> singlePage = response.ReadPage(pageSize);
        foreach (BookNameOneof item in response)
        {
            // FIXME: inspect the results
        }
        // Store the pageToken, for when the next page is required.
        string nextPageToken = singlePage.NextPageToken;
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleFindRelatedBooks();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBookAsyncFlattenedAsyncTestOnSuccessMap.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedAsync", "test_on_success_map")

// [START sample]
// FIXME: import everything this sample needs
public class GetBookAsyncFlattenedAsyncTestOnSuccessMap
{
    public static async Task SampleGetBookAsync()
    {
        LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
        BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
        Book response = await libraryServiceClient.GetBookAsync(name);
        // FIXME: inspect the results
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleGetBookAsync().Wait();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBookAsyncRequestAsyncTestOnSuccessMap.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestAsync", "test_on_success_map")

// [START sample]
// FIXME: import everything this sample needs
public class GetBookAsyncRequestAsyncTestOnSuccessMap
{
    public static async Task SampleGetBookAsync()
    {
        LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
        GetBookRequest request = new GetBookRequest
        {
            BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
        };
        Book response = await libraryServiceClient.GetBookAsync(request);
        // FIXME: inspect the results
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleGetBookAsync().Wait();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBookFlattenedTestOnSuccessMap.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Flattened", "test_on_success_map")

// [START sample]
// FIXME: import everything this sample needs
public class GetBookFlattenedTestOnSuccessMap
{
    public static void SampleGetBook()
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
        Book response = libraryServiceClient.GetBook(name);
        // FIXME: inspect the results
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleGetBook();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/GetBookRequestTestOnSuccessMap.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "test_on_success_map")

// [START sample]
// FIXME: import everything this sample needs
public class GetBookRequestTestOnSuccessMap
{
    public static void SampleGetBook()
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        GetBookRequest request = new GetBookRequest
        {
            BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
        };
        Book response = libraryServiceClient.GetBook(request);
        // FIXME: inspect the results
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SampleGetBook();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesAsyncFlattenedAsyncPiVersion.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedAsync", "pi_version")

// [START canonical]
// FIXME: import everything this sample needs
public class PublishSeriesAsyncFlattenedAsyncPiVersion
{
    /// <summary>
    /// Testing &lt;@calling forms&gt;
    /// </summary>
    /// <param name="shelfName">The name of the shelf where books are published to.</param>
    /// <param name="edition">The edition of the series.</param>
    public static async Task SamplePublishSeriesAsync(string shelfName, uint edition)
    {
        LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
        // string shelfName = "Math"
        // uint edition = 123
        Shelf shelf = new Shelf
        {
            Name = "Math",
        };
        IEnumerable<Book> books = new List<Book>();
        uint edition = 123;
        SeriesUuid seriesUuid = new SeriesUuid
        {
            SeriesString = "xyz3141592654",
        };
        PublishSeriesResponse response = await libraryServiceClient.PublishSeriesAsync(shelf, books, edition, seriesUuid);
        // FIXME: inspect the results
    }
    // [END canonical]

    public static void Main(string[] args)
    {
        new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
            .WithParsed<Options>(opts =>
                SamplePublishSeriesAsync(opts.ShelfName, opts.Edition).Wait());
    }

    public class Options
    {
        [Option("shelf_name", Default = "Math")]
        public string ShelfName { get; set; }

        [Option("edition", Default = 123)]
        public uint Edition { get; set; }
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesAsyncFlattenedAsyncSecondEdition.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("FlattenedAsync", "second_edition")

// [START canonical]
// FIXME: import everything this sample needs
public class PublishSeriesAsyncFlattenedAsyncSecondEdition
{
    /// <summary>
    /// Testing calling forms
    /// </summary>
    public static async Task SamplePublishSeriesAsync()
    {
        LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
        Shelf shelf = new Shelf();
        IEnumerable<Book> books = new List<Book>();
        uint edition = 2;
        SeriesUuid seriesUuid = new SeriesUuid();
        PublishSeriesResponse response = await libraryServiceClient.PublishSeriesAsync(shelf, books, edition, seriesUuid);
        // FIXME: inspect the results
    }
    // [END canonical]

    public static void Main(string[] args)
    {
        SamplePublishSeriesAsync().Wait();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesAsyncRequestAsyncPiVersion.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestAsync", "pi_version")

// [START canonical]
// FIXME: import everything this sample needs
public class PublishSeriesAsyncRequestAsyncPiVersion
{
    /// <summary>
    /// Testing &lt;@calling forms&gt;
    /// </summary>
    /// <param name="shelfName">The name of the shelf where books are published to.</param>
    /// <param name="edition">The edition of the series.</param>
    public static async Task SamplePublishSeriesAsync(string shelfName, uint edition)
    {
        LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
        // string shelfName = "Math"
        // uint edition = 123
        PublishSeriesRequest request = new PublishSeriesRequest
        {
            Shelf = new Shelf
            {
                Name = "Math",
            },
            Books = { },
            SeriesUuid = new SeriesUuid
            {
                SeriesString = "xyz3141592654",
            },
            Edition = 123,
        };
        PublishSeriesResponse response = await libraryServiceClient.PublishSeriesAsync(request);
        // FIXME: inspect the results
    }
    // [END canonical]

    public static void Main(string[] args)
    {
        new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
            .WithParsed<Options>(opts =>
                SamplePublishSeriesAsync(opts.ShelfName, opts.Edition).Wait());
    }

    public class Options
    {
        [Option("shelf_name", Default = "Math")]
        public string ShelfName { get; set; }

        [Option("edition", Default = 123)]
        public uint Edition { get; set; }
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesAsyncRequestAsyncSecondEdition.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestAsync", "second_edition")

// [START canonical]
// FIXME: import everything this sample needs
public class PublishSeriesAsyncRequestAsyncSecondEdition
{
    /// <summary>
    /// Testing calling forms
    /// </summary>
    public static async Task SamplePublishSeriesAsync()
    {
        LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
        PublishSeriesRequest request = new PublishSeriesRequest
        {
            Shelf = new Shelf(),
            Books = { },
            SeriesUuid = new SeriesUuid(),
            Edition = 2,
        };
        PublishSeriesResponse response = await libraryServiceClient.PublishSeriesAsync(request);
        // FIXME: inspect the results
    }
    // [END canonical]

    public static void Main(string[] args)
    {
        SamplePublishSeriesAsync().Wait();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesFlattenedPiVersion.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Flattened", "pi_version")

// [START canonical]
// FIXME: import everything this sample needs
public class PublishSeriesFlattenedPiVersion
{
    /// <summary>
    /// Testing &lt;@calling forms&gt;
    /// </summary>
    /// <param name="shelfName">The name of the shelf where books are published to.</param>
    /// <param name="edition">The edition of the series.</param>
    public static void SamplePublishSeries(string shelfName, uint edition)
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        // string shelfName = "Math"
        // uint edition = 123
        Shelf shelf = new Shelf
        {
            Name = "Math",
        };
        IEnumerable<Book> books = new List<Book>();
        uint edition = 123;
        SeriesUuid seriesUuid = new SeriesUuid
        {
            SeriesString = "xyz3141592654",
        };
        PublishSeriesResponse response = libraryServiceClient.PublishSeries(shelf, books, edition, seriesUuid);
        // FIXME: inspect the results
    }
    // [END canonical]

    public static void Main(string[] args)
    {
        new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
            .WithParsed<Options>(opts =>
                SamplePublishSeries(opts.ShelfName, opts.Edition));
    }

    public class Options
    {
        [Option("shelf_name", Default = "Math")]
        public string ShelfName { get; set; }

        [Option("edition", Default = 123)]
        public uint Edition { get; set; }
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesFlattenedSecondEdition.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Flattened", "second_edition")

// [START canonical]
// FIXME: import everything this sample needs
public class PublishSeriesFlattenedSecondEdition
{
    /// <summary>
    /// Testing calling forms
    /// </summary>
    public static void SamplePublishSeries()
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        Shelf shelf = new Shelf();
        IEnumerable<Book> books = new List<Book>();
        uint edition = 2;
        SeriesUuid seriesUuid = new SeriesUuid();
        PublishSeriesResponse response = libraryServiceClient.PublishSeries(shelf, books, edition, seriesUuid);
        // FIXME: inspect the results
    }
    // [END canonical]

    public static void Main(string[] args)
    {
        SamplePublishSeries();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesRequestPiVersion.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "pi_version")

// [START canonical]
// FIXME: import everything this sample needs
public class PublishSeriesRequestPiVersion
{
    /// <summary>
    /// Testing &lt;@calling forms&gt;
    /// </summary>
    /// <param name="shelfName">The name of the shelf where books are published to.</param>
    /// <param name="edition">The edition of the series.</param>
    public static void SamplePublishSeries(string shelfName, uint edition)
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        // string shelfName = "Math"
        // uint edition = 123
        PublishSeriesRequest request = new PublishSeriesRequest
        {
            Shelf = new Shelf
            {
                Name = "Math",
            },
            Books = { },
            SeriesUuid = new SeriesUuid
            {
                SeriesString = "xyz3141592654",
            },
            Edition = 123,
        };
        PublishSeriesResponse response = libraryServiceClient.PublishSeries(request);
        // FIXME: inspect the results
    }
    // [END canonical]

    public static void Main(string[] args)
    {
        new Parser(with => with.CaseInsensitiveEnumValues = true).ParseArguments<Options>(args)
            .WithParsed<Options>(opts =>
                SamplePublishSeries(opts.ShelfName, opts.Edition));
    }

    public class Options
    {
        [Option("shelf_name", Default = "Math")]
        public string ShelfName { get; set; }

        [Option("edition", Default = 123)]
        public uint Edition { get; set; }
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesRequestSecondEdition.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "second_edition")

// [START canonical]
// FIXME: import everything this sample needs
public class PublishSeriesRequestSecondEdition
{
    /// <summary>
    /// Testing calling forms
    /// </summary>
    public static void SamplePublishSeries()
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        PublishSeriesRequest request = new PublishSeriesRequest
        {
            Shelf = new Shelf(),
            Books = { },
            SeriesUuid = new SeriesUuid(),
            Edition = 2,
        };
        PublishSeriesResponse response = libraryServiceClient.PublishSeries(request);
        // FIXME: inspect the results
    }
    // [END canonical]

    public static void Main(string[] args)
    {
        SamplePublishSeries();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesRequestTestRequestObjectFieldComments.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "test_request_object_field_comments")

// [START sample]
// FIXME: import everything this sample needs
public class PublishSeriesRequestTestRequestObjectFieldComments
{
    /// <summary>
    /// Test request object field comments
    /// </summary>
    public static void SamplePublishSeries()
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        PublishSeriesRequest request = new PublishSeriesRequest
        {
            Shelf = new Shelf
            {
                Name = new ShelfName("math").ToString(),
                Theme = "Math",
                InternalTheme = "Statistics",
            },
            Books = { },
            SeriesUuid = new SeriesUuid
            {
                SeriesBytes = File.ReadAllBytes("xyz3141592654"),
            },
            Edition = 123,
        };
        PublishSeriesResponse response = libraryServiceClient.PublishSeries(request);
        // FIXME: inspect the results
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SamplePublishSeries();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/PublishSeriesRequestTestWriteToFile.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "test_write_to_file")

// [START sample]
// FIXME: import everything this sample needs
public class PublishSeriesRequestTestWriteToFile
{
    /// <summary>
    /// Testing write fields to files.
    /// </summary>
    public static void SamplePublishSeries()
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        PublishSeriesRequest request = new PublishSeriesRequest
        {
            Shelf = new Shelf(),
            Books = { },
            SeriesUuid = new SeriesUuid(),
        };
        PublishSeriesResponse response = libraryServiceClient.PublishSeries(request);
        // FIXME: inspect the results
    }
    // [END sample]

    public static void Main(string[] args)
    {
        SamplePublishSeries();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/SampleGetShelf.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("Request", "test_default_calling_form_unary")

// [START sample_get_shelf]
// FIXME: import everything this sample needs
public class SampleGetShelf
{
    /// <summary>
    /// Test default calling forms for unary methods.
    /// </summary>
    public static void SampleGetShelf()
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        GetShelfRequest request = new GetShelfRequest
        {
            ShelfName = new ShelfName("my-shelf"),
            Options = "",
        };
        Shelf response = libraryServiceClient.GetShelf(request);
        // FIXME: inspect the results
    }
    // [END sample_get_shelf]

    public static void Main(string[] args)
    {
        SampleGetShelf();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.Samples/TestDefaultCallingFormForPaging.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

// This is a generated sample ("RequestPagedAll", "test_default_calling_form_paging")

// [START test_default_calling_form_for_paging]
// FIXME: import everything this sample needs
public class TestDefaultCallingFormForPaging
{
    /// <summary>
    /// Test default calling form for paging methods.
    /// </summary>
    public static void SampleListShelves()
    {
        LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
        ListShelvesRequest request = new ListShelvesRequest();
        PagedEnumerable<ListShelvesResponse, Shelf> response = libraryServiceClient.ListShelves(request);
        // Iterate over pages (of server-defined size), performing one RPC per page
        foreach (Shelf item in response)
        {
            // FIXME: inspect the results
        }
    }
    // [END test_default_calling_form_for_paging]

    public static void Main(string[] args)
    {
        SampleListShelves();
    }
}
============== file: Google.Example.Library.V1/Google.Example.Library.V1.SmokeTests/Google.Example.Library.V1.SmokeTests.csproj ==============
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netcoreapp1.0</TargetFramework>
    <OutputType>Exe</OutputType>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="../Google.Example.Library.V1/Google.Example.Library.V1.csproj" />
  </ItemGroup>

</Project>

============== file: Google.Example.Library.V1/Google.Example.Library.V1.SmokeTests/LibraryServiceSmokeTest.g.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

namespace Google.Example.Library.V1.SmokeTests
{
    using Google.Api.Gax;
    using Google.Api.Gax.Grpc;
    using Google.Protobuf.WellKnownTypes;
    using Grpc.Core;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Threading;
    using System.Threading.Tasks;

    public class LibraryServiceSmokeTest
    {
        public static int Main(string[] args)
        {
            // Create client
            LibraryServiceClient client = LibraryServiceClient.Create();

            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            Book book = new Book
            {
                Rating = Book.Types.Rating.Good,
            };

            // Call API method
            Book response = client.UpdateBook(name, book);
            // Show the result
            Console.WriteLine(response);

            // Success
            Console.WriteLine("Smoke test passed OK");
            return 0;
        }
    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Snippets/Google.Example.Library.V1.Snippets.csproj ==============
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>netcoreapp1.0;netcoreapp2.0;net452</TargetFrameworks>
    <TargetFrameworks Condition=" '$(OS)' != 'Windows_NT' ">netcoreapp1.0;netcoreapp2.0</TargetFrameworks>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="../Google.Example.Library.V1/Google.Example.Library.V1.csproj" />
  </ItemGroup>

</Project>

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Snippets/LibraryServiceClientSnippets.g.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

namespace Google.Example.Library.V1.Snippets
{
    using Google.Api.Gax;
    using Google.Api.Gax.Grpc;
    using apis = Google.Example.Library.V1;
    using Google.LongRunning;
    using Google.Protobuf;
    using Google.Protobuf.WellKnownTypes;
    using Google.Tagger.V1;
    using Grpc.Core;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Linq;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>Generated snippets</summary>
    public class GeneratedLibraryServiceClientSnippets
    {
        /// <summary>Snippet for CreateShelfAsync</summary>
        public async Task CreateShelfAsync()
        {
            // Snippet: CreateShelfAsync(Shelf,CallSettings)
            // Additional: CreateShelfAsync(Shelf,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            Shelf shelf = new Shelf();
            // Make the request
            Shelf response = await libraryServiceClient.CreateShelfAsync(shelf);
            // End snippet
        }

        /// <summary>Snippet for CreateShelf</summary>
        public void CreateShelf()
        {
            // Snippet: CreateShelf(Shelf,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            Shelf shelf = new Shelf();
            // Make the request
            Shelf response = libraryServiceClient.CreateShelf(shelf);
            // End snippet
        }

        /// <summary>Snippet for CreateShelfAsync</summary>
        public async Task CreateShelfAsync_RequestObject()
        {
            // Snippet: CreateShelfAsync(CreateShelfRequest,CallSettings)
            // Additional: CreateShelfAsync(CreateShelfRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            CreateShelfRequest request = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            // Make the request
            Shelf response = await libraryServiceClient.CreateShelfAsync(request);
            // End snippet
        }

        /// <summary>Snippet for CreateShelf</summary>
        public void CreateShelf_RequestObject()
        {
            // Snippet: CreateShelf(CreateShelfRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            CreateShelfRequest request = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            // Make the request
            Shelf response = libraryServiceClient.CreateShelf(request);
            // End snippet
        }

        /// <summary>Snippet for GetShelfAsync</summary>
        public async Task GetShelfAsync1()
        {
            // Snippet: GetShelfAsync(ShelfName,CallSettings)
            // Additional: GetShelfAsync(ShelfName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            // Make the request
            Shelf response = await libraryServiceClient.GetShelfAsync(name);
            // End snippet
        }

        /// <summary>Snippet for GetShelf</summary>
        public void GetShelf1()
        {
            // Snippet: GetShelf(ShelfName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            // Make the request
            Shelf response = libraryServiceClient.GetShelf(name);
            // End snippet
        }

        /// <summary>Snippet for GetShelfAsync</summary>
        public async Task GetShelfAsync2()
        {
            // Snippet: GetShelfAsync(ShelfName,SomeMessage,CallSettings)
            // Additional: GetShelfAsync(ShelfName,SomeMessage,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            SomeMessage message = new SomeMessage();
            // Make the request
            Shelf response = await libraryServiceClient.GetShelfAsync(name, message);
            // End snippet
        }

        /// <summary>Snippet for GetShelf</summary>
        public void GetShelf2()
        {
            // Snippet: GetShelf(ShelfName,SomeMessage,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            SomeMessage message = new SomeMessage();
            // Make the request
            Shelf response = libraryServiceClient.GetShelf(name, message);
            // End snippet
        }

        /// <summary>Snippet for GetShelfAsync</summary>
        public async Task GetShelfAsync3()
        {
            // Snippet: GetShelfAsync(ShelfName,SomeMessage,StringBuilder,CallSettings)
            // Additional: GetShelfAsync(ShelfName,SomeMessage,StringBuilder,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            SomeMessage message = new SomeMessage();
            StringBuilder stringBuilder = new StringBuilder();
            // Make the request
            Shelf response = await libraryServiceClient.GetShelfAsync(name, message, stringBuilder);
            // End snippet
        }

        /// <summary>Snippet for GetShelf</summary>
        public void GetShelf3()
        {
            // Snippet: GetShelf(ShelfName,SomeMessage,StringBuilder,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            SomeMessage message = new SomeMessage();
            StringBuilder stringBuilder = new StringBuilder();
            // Make the request
            Shelf response = libraryServiceClient.GetShelf(name, message, stringBuilder);
            // End snippet
        }

        /// <summary>Snippet for GetShelfAsync</summary>
        public async Task GetShelfAsync_RequestObject()
        {
            // Snippet: GetShelfAsync(GetShelfRequest,CallSettings)
            // Additional: GetShelfAsync(GetShelfRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetShelfRequest request = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Options = "",
            };
            // Make the request
            Shelf response = await libraryServiceClient.GetShelfAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetShelf</summary>
        public void GetShelf_RequestObject()
        {
            // Snippet: GetShelf(GetShelfRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetShelfRequest request = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Options = "",
            };
            // Make the request
            Shelf response = libraryServiceClient.GetShelf(request);
            // End snippet
        }

        /// <summary>Snippet for ListShelvesAsync</summary>
        public async Task ListShelvesAsync()
        {
            // Snippet: ListShelvesAsync(string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Make the request
            PagedAsyncEnumerable<ListShelvesResponse, Shelf> response =
                libraryServiceClient.ListShelvesAsync();

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((Shelf item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListShelvesResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Shelf item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Shelf> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Shelf item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListShelves</summary>
        public void ListShelves()
        {
            // Snippet: ListShelves(string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Make the request
            PagedEnumerable<ListShelvesResponse, Shelf> response =
                libraryServiceClient.ListShelves();

            // Iterate over all response items, lazily performing RPCs as required
            foreach (Shelf item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListShelvesResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Shelf item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Shelf> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Shelf item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListShelvesAsync</summary>
        public async Task ListShelvesAsync_RequestObject()
        {
            // Snippet: ListShelvesAsync(ListShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ListShelvesRequest request = new ListShelvesRequest();
            // Make the request
            PagedAsyncEnumerable<ListShelvesResponse, Shelf> response =
                libraryServiceClient.ListShelvesAsync(request);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((Shelf item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListShelvesResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Shelf item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Shelf> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Shelf item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListShelves</summary>
        public void ListShelves_RequestObject()
        {
            // Snippet: ListShelves(ListShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ListShelvesRequest request = new ListShelvesRequest();
            // Make the request
            PagedEnumerable<ListShelvesResponse, Shelf> response =
                libraryServiceClient.ListShelves(request);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (Shelf item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListShelvesResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Shelf item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Shelf> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Shelf item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for DeleteShelfAsync</summary>
        public async Task DeleteShelfAsync()
        {
            // Snippet: DeleteShelfAsync(ShelfName,CallSettings)
            // Additional: DeleteShelfAsync(ShelfName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            // Make the request
            await libraryServiceClient.DeleteShelfAsync(name);
            // End snippet
        }

        /// <summary>Snippet for DeleteShelf</summary>
        public void DeleteShelf()
        {
            // Snippet: DeleteShelf(ShelfName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            // Make the request
            libraryServiceClient.DeleteShelf(name);
            // End snippet
        }

        /// <summary>Snippet for DeleteShelfAsync</summary>
        public async Task DeleteShelfAsync_RequestObject()
        {
            // Snippet: DeleteShelfAsync(DeleteShelfRequest,CallSettings)
            // Additional: DeleteShelfAsync(DeleteShelfRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            DeleteShelfRequest request = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            await libraryServiceClient.DeleteShelfAsync(request);
            // End snippet
        }

        /// <summary>Snippet for DeleteShelf</summary>
        public void DeleteShelf_RequestObject()
        {
            // Snippet: DeleteShelf(DeleteShelfRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            DeleteShelfRequest request = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            libraryServiceClient.DeleteShelf(request);
            // End snippet
        }

        /// <summary>Snippet for MergeShelvesAsync</summary>
        public async Task MergeShelvesAsync()
        {
            // Snippet: MergeShelvesAsync(ShelfName,ShelfName,CallSettings)
            // Additional: MergeShelvesAsync(ShelfName,ShelfName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            // Make the request
            Shelf response = await libraryServiceClient.MergeShelvesAsync(name, otherShelfName);
            // End snippet
        }

        /// <summary>Snippet for MergeShelves</summary>
        public void MergeShelves()
        {
            // Snippet: MergeShelves(ShelfName,ShelfName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            // Make the request
            Shelf response = libraryServiceClient.MergeShelves(name, otherShelfName);
            // End snippet
        }

        /// <summary>Snippet for MergeShelvesAsync</summary>
        public async Task MergeShelvesAsync_RequestObject()
        {
            // Snippet: MergeShelvesAsync(MergeShelvesRequest,CallSettings)
            // Additional: MergeShelvesAsync(MergeShelvesRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            MergeShelvesRequest request = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            Shelf response = await libraryServiceClient.MergeShelvesAsync(request);
            // End snippet
        }

        /// <summary>Snippet for MergeShelves</summary>
        public void MergeShelves_RequestObject()
        {
            // Snippet: MergeShelves(MergeShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            MergeShelvesRequest request = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            Shelf response = libraryServiceClient.MergeShelves(request);
            // End snippet
        }

        /// <summary>Snippet for CreateBookAsync</summary>
        public async Task CreateBookAsync()
        {
            // Snippet: CreateBookAsync(ShelfName,Book,CallSettings)
            // Additional: CreateBookAsync(ShelfName,Book,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            Book book = new Book();
            // Make the request
            Book response = await libraryServiceClient.CreateBookAsync(name, book);
            // End snippet
        }

        /// <summary>Snippet for CreateBook</summary>
        public void CreateBook()
        {
            // Snippet: CreateBook(ShelfName,Book,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            Book book = new Book();
            // Make the request
            Book response = libraryServiceClient.CreateBook(name, book);
            // End snippet
        }

        /// <summary>Snippet for CreateBookAsync</summary>
        public async Task CreateBookAsync_RequestObject()
        {
            // Snippet: CreateBookAsync(CreateBookRequest,CallSettings)
            // Additional: CreateBookAsync(CreateBookRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            CreateBookRequest request = new CreateBookRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Book = new Book(),
            };
            // Make the request
            Book response = await libraryServiceClient.CreateBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for CreateBook</summary>
        public void CreateBook_RequestObject()
        {
            // Snippet: CreateBook(CreateBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            CreateBookRequest request = new CreateBookRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Book = new Book(),
            };
            // Make the request
            Book response = libraryServiceClient.CreateBook(request);
            // End snippet
        }

        /// <summary>Snippet for PublishSeriesAsync</summary>
        public async Task PublishSeriesAsync()
        {
            // Snippet: PublishSeriesAsync(Shelf,IEnumerable<Book>,uint?,SeriesUuid,CallSettings)
            // Additional: PublishSeriesAsync(Shelf,IEnumerable<Book>,uint?,SeriesUuid,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            Shelf shelf = new Shelf();
            IEnumerable<Book> books = new List<Book>();
            uint edition = 0;
            SeriesUuid seriesUuid = new SeriesUuid
            {
                SeriesString = "foobar",
            };
            // Make the request
            PublishSeriesResponse response = await libraryServiceClient.PublishSeriesAsync(shelf, books, edition, seriesUuid);
            // End snippet
        }

        /// <summary>Snippet for PublishSeries</summary>
        public void PublishSeries()
        {
            // Snippet: PublishSeries(Shelf,IEnumerable<Book>,uint?,SeriesUuid,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            Shelf shelf = new Shelf();
            IEnumerable<Book> books = new List<Book>();
            uint edition = 0;
            SeriesUuid seriesUuid = new SeriesUuid
            {
                SeriesString = "foobar",
            };
            // Make the request
            PublishSeriesResponse response = libraryServiceClient.PublishSeries(shelf, books, edition, seriesUuid);
            // End snippet
        }

        /// <summary>Snippet for PublishSeriesAsync</summary>
        public async Task PublishSeriesAsync_RequestObject()
        {
            // Snippet: PublishSeriesAsync(PublishSeriesRequest,CallSettings)
            // Additional: PublishSeriesAsync(PublishSeriesRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                SeriesUuid = new SeriesUuid
                {
                    SeriesString = "foobar",
                },
            };
            // Make the request
            PublishSeriesResponse response = await libraryServiceClient.PublishSeriesAsync(request);
            // End snippet
        }

        /// <summary>Snippet for PublishSeries</summary>
        public void PublishSeries_RequestObject()
        {
            // Snippet: PublishSeries(PublishSeriesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                SeriesUuid = new SeriesUuid
                {
                    SeriesString = "foobar",
                },
            };
            // Make the request
            PublishSeriesResponse response = libraryServiceClient.PublishSeries(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookAsync</summary>
        public async Task GetBookAsync()
        {
            // Snippet: GetBookAsync(BookNameOneof,CallSettings)
            // Additional: GetBookAsync(BookNameOneof,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            // Make the request
            Book response = await libraryServiceClient.GetBookAsync(name);
            // End snippet
        }

        /// <summary>Snippet for GetBook</summary>
        public void GetBook()
        {
            // Snippet: GetBook(BookNameOneof,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            // Make the request
            Book response = libraryServiceClient.GetBook(name);
            // End snippet
        }

        /// <summary>Snippet for GetBookAsync</summary>
        public async Task GetBookAsync_RequestObject()
        {
            // Snippet: GetBookAsync(GetBookRequest,CallSettings)
            // Additional: GetBookAsync(GetBookRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            // Make the request
            Book response = await libraryServiceClient.GetBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetBook</summary>
        public void GetBook_RequestObject()
        {
            // Snippet: GetBook(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            // Make the request
            Book response = libraryServiceClient.GetBook(request);
            // End snippet
        }

        /// <summary>Snippet for ListBooksAsync</summary>
        public async Task ListBooksAsync()
        {
            // Snippet: ListBooksAsync(ShelfName,string,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            string filter = "book-filter-string";
            // Make the request
            PagedAsyncEnumerable<ListBooksResponse, Book> response =
                libraryServiceClient.ListBooksAsync(name, filter);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((Book item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListBooksResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Book item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Book> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Book item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListBooks</summary>
        public void ListBooks()
        {
            // Snippet: ListBooks(ShelfName,string,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ShelfName name = new ShelfName("[SHELF_ID]");
            string filter = "book-filter-string";
            // Make the request
            PagedEnumerable<ListBooksResponse, Book> response =
                libraryServiceClient.ListBooks(name, filter);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (Book item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListBooksResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Book item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Book> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Book item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListBooksAsync</summary>
        public async Task ListBooksAsync_RequestObject()
        {
            // Snippet: ListBooksAsync(ListBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ListBooksRequest request = new ListBooksRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Filter = "book-filter-string",
            };
            // Make the request
            PagedAsyncEnumerable<ListBooksResponse, Book> response =
                libraryServiceClient.ListBooksAsync(request);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((Book item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListBooksResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Book item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Book> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Book item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListBooks</summary>
        public void ListBooks_RequestObject()
        {
            // Snippet: ListBooks(ListBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ListBooksRequest request = new ListBooksRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Filter = "book-filter-string",
            };
            // Make the request
            PagedEnumerable<ListBooksResponse, Book> response =
                libraryServiceClient.ListBooks(request);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (Book item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListBooksResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (Book item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<Book> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (Book item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for DeleteBookAsync</summary>
        public async Task DeleteBookAsync()
        {
            // Snippet: DeleteBookAsync(BookNameOneof,CallSettings)
            // Additional: DeleteBookAsync(BookNameOneof,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            // Make the request
            await libraryServiceClient.DeleteBookAsync(name);
            // End snippet
        }

        /// <summary>Snippet for DeleteBook</summary>
        public void DeleteBook()
        {
            // Snippet: DeleteBook(BookNameOneof,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            // Make the request
            libraryServiceClient.DeleteBook(name);
            // End snippet
        }

        /// <summary>Snippet for DeleteBookAsync</summary>
        public async Task DeleteBookAsync_RequestObject()
        {
            // Snippet: DeleteBookAsync(DeleteBookRequest,CallSettings)
            // Additional: DeleteBookAsync(DeleteBookRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            DeleteBookRequest request = new DeleteBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            // Make the request
            await libraryServiceClient.DeleteBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for DeleteBook</summary>
        public void DeleteBook_RequestObject()
        {
            // Snippet: DeleteBook(DeleteBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            DeleteBookRequest request = new DeleteBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            // Make the request
            libraryServiceClient.DeleteBook(request);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookAsync</summary>
        public async Task UpdateBookAsync1()
        {
            // Snippet: UpdateBookAsync(BookNameOneof,Book,CallSettings)
            // Additional: UpdateBookAsync(BookNameOneof,Book,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            Book book = new Book();
            // Make the request
            Book response = await libraryServiceClient.UpdateBookAsync(name, book);
            // End snippet
        }

        /// <summary>Snippet for UpdateBook</summary>
        public void UpdateBook1()
        {
            // Snippet: UpdateBook(BookNameOneof,Book,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            Book book = new Book();
            // Make the request
            Book response = libraryServiceClient.UpdateBook(name, book);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookAsync</summary>
        public async Task UpdateBookAsync2()
        {
            // Snippet: UpdateBookAsync(BookNameOneof,string,Book,FieldMask,apis::FieldMask,CallSettings)
            // Additional: UpdateBookAsync(BookNameOneof,string,Book,FieldMask,apis::FieldMask,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            string optionalFoo = "";
            Book book = new Book();
            FieldMask updateMask = new FieldMask();
            apis::FieldMask physicalMask = new apis::FieldMask();
            // Make the request
            Book response = await libraryServiceClient.UpdateBookAsync(name, optionalFoo, book, updateMask, physicalMask);
            // End snippet
        }

        /// <summary>Snippet for UpdateBook</summary>
        public void UpdateBook2()
        {
            // Snippet: UpdateBook(BookNameOneof,string,Book,FieldMask,apis::FieldMask,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            string optionalFoo = "";
            Book book = new Book();
            FieldMask updateMask = new FieldMask();
            apis::FieldMask physicalMask = new apis::FieldMask();
            // Make the request
            Book response = libraryServiceClient.UpdateBook(name, optionalFoo, book, updateMask, physicalMask);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookAsync</summary>
        public async Task UpdateBookAsync_RequestObject()
        {
            // Snippet: UpdateBookAsync(UpdateBookRequest,CallSettings)
            // Additional: UpdateBookAsync(UpdateBookRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            UpdateBookRequest request = new UpdateBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Book = new Book(),
            };
            // Make the request
            Book response = await libraryServiceClient.UpdateBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for UpdateBook</summary>
        public void UpdateBook_RequestObject()
        {
            // Snippet: UpdateBook(UpdateBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            UpdateBookRequest request = new UpdateBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Book = new Book(),
            };
            // Make the request
            Book response = libraryServiceClient.UpdateBook(request);
            // End snippet
        }

        /// <summary>Snippet for MoveBookAsync</summary>
        public async Task MoveBookAsync()
        {
            // Snippet: MoveBookAsync(BookNameOneof,ShelfName,CallSettings)
            // Additional: MoveBookAsync(BookNameOneof,ShelfName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            // Make the request
            Book response = await libraryServiceClient.MoveBookAsync(name, otherShelfName);
            // End snippet
        }

        /// <summary>Snippet for MoveBook</summary>
        public void MoveBook()
        {
            // Snippet: MoveBook(BookNameOneof,ShelfName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            // Make the request
            Book response = libraryServiceClient.MoveBook(name, otherShelfName);
            // End snippet
        }

        /// <summary>Snippet for MoveBookAsync</summary>
        public async Task MoveBookAsync_RequestObject()
        {
            // Snippet: MoveBookAsync(MoveBookRequest,CallSettings)
            // Additional: MoveBookAsync(MoveBookRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            MoveBookRequest request = new MoveBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            Book response = await libraryServiceClient.MoveBookAsync(request);
            // End snippet
        }

        /// <summary>Snippet for MoveBook</summary>
        public void MoveBook_RequestObject()
        {
            // Snippet: MoveBook(MoveBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            MoveBookRequest request = new MoveBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request
            Book response = libraryServiceClient.MoveBook(request);
            // End snippet
        }

        /// <summary>Snippet for ListStringsAsync</summary>
        public async Task ListStringsAsync1()
        {
            // Snippet: ListStringsAsync(string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Make the request
            PagedAsyncEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStringsAsync();

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((IResourceName item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListStringsResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStrings</summary>
        public void ListStrings1()
        {
            // Snippet: ListStrings(string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Make the request
            PagedEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStrings();

            // Iterate over all response items, lazily performing RPCs as required
            foreach (IResourceName item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListStringsResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStringsAsync</summary>
        public async Task ListStringsAsync2()
        {
            // Snippet: ListStringsAsync(IResourceName,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            IResourceName name = new ArchiveBookName("[ARCHIVE]", "[BOOK]");
            // Make the request
            PagedAsyncEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStringsAsync(name);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((IResourceName item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListStringsResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStrings</summary>
        public void ListStrings2()
        {
            // Snippet: ListStrings(IResourceName,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            IResourceName name = new ArchiveBookName("[ARCHIVE]", "[BOOK]");
            // Make the request
            PagedEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStrings(name);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (IResourceName item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListStringsResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStringsAsync</summary>
        public async Task ListStringsAsync_RequestObject()
        {
            // Snippet: ListStringsAsync(ListStringsRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ListStringsRequest request = new ListStringsRequest();
            // Make the request
            PagedAsyncEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStringsAsync(request);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((IResourceName item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((ListStringsResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for ListStrings</summary>
        public void ListStrings_RequestObject()
        {
            // Snippet: ListStrings(ListStringsRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ListStringsRequest request = new ListStringsRequest();
            // Make the request
            PagedEnumerable<ListStringsResponse, IResourceName> response =
                libraryServiceClient.ListStrings(request);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (IResourceName item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (ListStringsResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (IResourceName item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<IResourceName> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (IResourceName item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for AddCommentsAsync</summary>
        public async Task AddCommentsAsync()
        {
            // Snippet: AddCommentsAsync(BookNameOneof,IEnumerable<Comment>,CallSettings)
            // Additional: AddCommentsAsync(BookNameOneof,IEnumerable<Comment>,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            IEnumerable<Comment> comments = new[]
            {
                new Comment
                {
                    Comment = ByteString.Empty,
                    Stage = Comment.Types.Stage.Unset,
                    Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                },
            };
            // Make the request
            await libraryServiceClient.AddCommentsAsync(name, comments);
            // End snippet
        }

        /// <summary>Snippet for AddComments</summary>
        public void AddComments()
        {
            // Snippet: AddComments(BookNameOneof,IEnumerable<Comment>,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            IEnumerable<Comment> comments = new[]
            {
                new Comment
                {
                    Comment = ByteString.Empty,
                    Stage = Comment.Types.Stage.Unset,
                    Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                },
            };
            // Make the request
            libraryServiceClient.AddComments(name, comments);
            // End snippet
        }

        /// <summary>Snippet for AddCommentsAsync</summary>
        public async Task AddCommentsAsync_RequestObject()
        {
            // Snippet: AddCommentsAsync(AddCommentsRequest,CallSettings)
            // Additional: AddCommentsAsync(AddCommentsRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            AddCommentsRequest request = new AddCommentsRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Comments =
                {
                    new Comment
                    {
                        Comment = ByteString.Empty,
                        Stage = Comment.Types.Stage.Unset,
                        Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                    },
                },
            };
            // Make the request
            await libraryServiceClient.AddCommentsAsync(request);
            // End snippet
        }

        /// <summary>Snippet for AddComments</summary>
        public void AddComments_RequestObject()
        {
            // Snippet: AddComments(AddCommentsRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            AddCommentsRequest request = new AddCommentsRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Comments =
                {
                    new Comment
                    {
                        Comment = ByteString.Empty,
                        Stage = Comment.Types.Stage.Unset,
                        Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                    },
                },
            };
            // Make the request
            libraryServiceClient.AddComments(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromArchiveAsync</summary>
        public async Task GetBookFromArchiveAsync()
        {
            // Snippet: GetBookFromArchiveAsync(ArchivedBookName,CallSettings)
            // Additional: GetBookFromArchiveAsync(ArchivedBookName,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ArchivedBookName name = new ArchivedBookName("[ARCHIVE]", "[BOOK]");
            // Make the request
            BookFromArchive response = await libraryServiceClient.GetBookFromArchiveAsync(name);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromArchive</summary>
        public void GetBookFromArchive()
        {
            // Snippet: GetBookFromArchive(ArchivedBookName,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ArchivedBookName name = new ArchivedBookName("[ARCHIVE]", "[BOOK]");
            // Make the request
            BookFromArchive response = libraryServiceClient.GetBookFromArchive(name);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromArchiveAsync</summary>
        public async Task GetBookFromArchiveAsync_RequestObject()
        {
            // Snippet: GetBookFromArchiveAsync(GetBookFromArchiveRequest,CallSettings)
            // Additional: GetBookFromArchiveAsync(GetBookFromArchiveRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookFromArchiveRequest request = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
            };
            // Make the request
            BookFromArchive response = await libraryServiceClient.GetBookFromArchiveAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromArchive</summary>
        public void GetBookFromArchive_RequestObject()
        {
            // Snippet: GetBookFromArchive(GetBookFromArchiveRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookFromArchiveRequest request = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
            };
            // Make the request
            BookFromArchive response = libraryServiceClient.GetBookFromArchive(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAnywhereAsync</summary>
        public async Task GetBookFromAnywhereAsync()
        {
            // Snippet: GetBookFromAnywhereAsync(BookNameOneof,BookNameOneof,CallSettings)
            // Additional: GetBookFromAnywhereAsync(BookNameOneof,BookNameOneof,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            BookNameOneof altBookName = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            // Make the request
            BookFromAnywhere response = await libraryServiceClient.GetBookFromAnywhereAsync(name, altBookName);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAnywhere</summary>
        public void GetBookFromAnywhere()
        {
            // Snippet: GetBookFromAnywhere(BookNameOneof,BookNameOneof,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            BookNameOneof altBookName = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            // Make the request
            BookFromAnywhere response = libraryServiceClient.GetBookFromAnywhere(name, altBookName);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAnywhereAsync</summary>
        public async Task GetBookFromAnywhereAsync_RequestObject()
        {
            // Snippet: GetBookFromAnywhereAsync(GetBookFromAnywhereRequest,CallSettings)
            // Additional: GetBookFromAnywhereAsync(GetBookFromAnywhereRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookFromAnywhereRequest request = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            // Make the request
            BookFromAnywhere response = await libraryServiceClient.GetBookFromAnywhereAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAnywhere</summary>
        public void GetBookFromAnywhere_RequestObject()
        {
            // Snippet: GetBookFromAnywhere(GetBookFromAnywhereRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookFromAnywhereRequest request = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            // Make the request
            BookFromAnywhere response = libraryServiceClient.GetBookFromAnywhere(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAbsolutelyAnywhereAsync</summary>
        public async Task GetBookFromAbsolutelyAnywhereAsync()
        {
            // Snippet: GetBookFromAbsolutelyAnywhereAsync(BookNameOneof,CallSettings)
            // Additional: GetBookFromAbsolutelyAnywhereAsync(BookNameOneof,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            // Make the request
            BookFromAnywhere response = await libraryServiceClient.GetBookFromAbsolutelyAnywhereAsync(name);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAbsolutelyAnywhere</summary>
        public void GetBookFromAbsolutelyAnywhere()
        {
            // Snippet: GetBookFromAbsolutelyAnywhere(BookNameOneof,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            // Make the request
            BookFromAnywhere response = libraryServiceClient.GetBookFromAbsolutelyAnywhere(name);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAbsolutelyAnywhereAsync</summary>
        public async Task GetBookFromAbsolutelyAnywhereAsync_RequestObject()
        {
            // Snippet: GetBookFromAbsolutelyAnywhereAsync(GetBookFromAbsolutelyAnywhereRequest,CallSettings)
            // Additional: GetBookFromAbsolutelyAnywhereAsync(GetBookFromAbsolutelyAnywhereRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookFromAbsolutelyAnywhereRequest request = new GetBookFromAbsolutelyAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            // Make the request
            BookFromAnywhere response = await libraryServiceClient.GetBookFromAbsolutelyAnywhereAsync(request);
            // End snippet
        }

        /// <summary>Snippet for GetBookFromAbsolutelyAnywhere</summary>
        public void GetBookFromAbsolutelyAnywhere_RequestObject()
        {
            // Snippet: GetBookFromAbsolutelyAnywhere(GetBookFromAbsolutelyAnywhereRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookFromAbsolutelyAnywhereRequest request = new GetBookFromAbsolutelyAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            // Make the request
            BookFromAnywhere response = libraryServiceClient.GetBookFromAbsolutelyAnywhere(request);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookIndexAsync</summary>
        public async Task UpdateBookIndexAsync()
        {
            // Snippet: UpdateBookIndexAsync(BookNameOneof,string,IDictionary<string, string>,CallSettings)
            // Additional: UpdateBookIndexAsync(BookNameOneof,string,IDictionary<string, string>,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            string indexName = "default index";
            IDictionary<string, string> indexMap = new Dictionary<string, string>
            {
                { "default_key", "" },
            };
            // Make the request
            await libraryServiceClient.UpdateBookIndexAsync(name, indexName, indexMap);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookIndex</summary>
        public void UpdateBookIndex()
        {
            // Snippet: UpdateBookIndex(BookNameOneof,string,IDictionary<string, string>,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            string indexName = "default index";
            IDictionary<string, string> indexMap = new Dictionary<string, string>
            {
                { "default_key", "" },
            };
            // Make the request
            libraryServiceClient.UpdateBookIndex(name, indexName, indexMap);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookIndexAsync</summary>
        public async Task UpdateBookIndexAsync_RequestObject()
        {
            // Snippet: UpdateBookIndexAsync(UpdateBookIndexRequest,CallSettings)
            // Additional: UpdateBookIndexAsync(UpdateBookIndexRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            UpdateBookIndexRequest request = new UpdateBookIndexRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                IndexName = "default index",
                IndexMap =
                {
                    { "default_key", "" },
                },
            };
            // Make the request
            await libraryServiceClient.UpdateBookIndexAsync(request);
            // End snippet
        }

        /// <summary>Snippet for UpdateBookIndex</summary>
        public void UpdateBookIndex_RequestObject()
        {
            // Snippet: UpdateBookIndex(UpdateBookIndexRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            UpdateBookIndexRequest request = new UpdateBookIndexRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                IndexName = "default index",
                IndexMap =
                {
                    { "default_key", "" },
                },
            };
            // Make the request
            libraryServiceClient.UpdateBookIndex(request);
            // End snippet
        }

        /// <summary>Snippet for StreamShelves</summary>
        public async Task StreamShelves()
        {
            // Snippet: StreamShelves(StreamShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument
            StreamShelvesRequest request = new StreamShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            // Make the request, returning a streaming response
            LibraryServiceClient.StreamShelvesStream streamingResponse = libraryServiceClient.StreamShelves(request);

            // Read streaming responses from server until complete
            IAsyncEnumerator<StreamShelvesResponse> responseStream = streamingResponse.ResponseStream;
            while (await responseStream.MoveNext())
            {
                StreamShelvesResponse response = responseStream.Current;
                // Do something with streamed response
            }
            // The response stream has completed
            // End snippet
        }

        /// <summary>Snippet for StreamBooks</summary>
        public async Task StreamBooks()
        {
            // Snippet: StreamBooks(StreamBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument
            StreamBooksRequest request = new StreamBooksRequest
            {
                Name = "",
            };
            // Make the request, returning a streaming response
            LibraryServiceClient.StreamBooksStream streamingResponse = libraryServiceClient.StreamBooks(request);

            // Read streaming responses from server until complete
            IAsyncEnumerator<Book> responseStream = streamingResponse.ResponseStream;
            while (await responseStream.MoveNext())
            {
                Book response = responseStream.Current;
                // Do something with streamed response
            }
            // The response stream has completed
            // End snippet
        }

        /// <summary>Snippet for DiscussBook</summary>
        public async Task DiscussBook()
        {
            // Snippet: DiscussBook(CallSettings,BidirectionalStreamingSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize streaming call, retrieving the stream object
            LibraryServiceClient.DiscussBookStream duplexStream = libraryServiceClient.DiscussBook();

            // Sending requests and retrieving responses can be arbitrarily interleaved.
            // Exact sequence will depend on client/server behavior.

            // Create task to do something with responses from server
            Task responseHandlerTask = Task.Run(async () =>
            {
                IAsyncEnumerator<Comment> responseStream = duplexStream.ResponseStream;
                while (await responseStream.MoveNext())
                {
                    Comment response = responseStream.Current;
                    // Do something with streamed response
                }
                // The response stream has completed
            });

            // Send requests to the server
            bool done = false;
            while (!done)
            {
                // Initialize a request
                DiscussBookRequest request = new DiscussBookRequest
                {
                    BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                };
                // Stream a request to the server
                await duplexStream.WriteAsync(request);

                // Set "done" to true when sending requests is complete
            }
            // Complete writing requests to the stream
            await duplexStream.WriteCompleteAsync();
            // Await the response handler.
            // This will complete once all server responses have been processed.
            await responseHandlerTask;
            // End snippet
        }

        /// <summary>Snippet for FindRelatedBooksAsync</summary>
        public async Task FindRelatedBooksAsync()
        {
            // Snippet: FindRelatedBooksAsync(IEnumerable<BookNameOneof>,IEnumerable<ShelfName>,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            IEnumerable<BookNameOneof> names = new[]
            {
                BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            IEnumerable<ShelfName> shelves = new List<ShelfName>();
            // Make the request
            PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> response =
                libraryServiceClient.FindRelatedBooksAsync(names, shelves);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((BookNameOneof item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((FindRelatedBooksResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (BookNameOneof item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookNameOneof> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (BookNameOneof item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for FindRelatedBooks</summary>
        public void FindRelatedBooks()
        {
            // Snippet: FindRelatedBooks(IEnumerable<BookNameOneof>,IEnumerable<ShelfName>,string,int?,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            IEnumerable<BookNameOneof> names = new[]
            {
                BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            IEnumerable<ShelfName> shelves = new List<ShelfName>();
            // Make the request
            PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> response =
                libraryServiceClient.FindRelatedBooks(names, shelves);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (BookNameOneof item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (FindRelatedBooksResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (BookNameOneof item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookNameOneof> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (BookNameOneof item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for FindRelatedBooksAsync</summary>
        public async Task FindRelatedBooksAsync_RequestObject()
        {
            // Snippet: FindRelatedBooksAsync(FindRelatedBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            FindRelatedBooksRequest request = new FindRelatedBooksRequest
            {
                BookNameOneofs =
                {
                    BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                },
                ShelvesAsShelfNames = { },
            };
            // Make the request
            PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> response =
                libraryServiceClient.FindRelatedBooksAsync(request);

            // Iterate over all response items, lazily performing RPCs as required
            await response.ForEachAsync((BookNameOneof item) =>
            {
                // Do something with each item
                Console.WriteLine(item);
            });

            // Or iterate over pages (of server-defined size), performing one RPC per page
            await response.AsRawResponses().ForEachAsync((FindRelatedBooksResponse page) =>
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (BookNameOneof item in page)
                {
                    Console.WriteLine(item);
                }
            });

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookNameOneof> singlePage = await response.ReadPageAsync(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (BookNameOneof item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for FindRelatedBooks</summary>
        public void FindRelatedBooks_RequestObject()
        {
            // Snippet: FindRelatedBooks(FindRelatedBooksRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            FindRelatedBooksRequest request = new FindRelatedBooksRequest
            {
                BookNameOneofs =
                {
                    BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                },
                ShelvesAsShelfNames = { },
            };
            // Make the request
            PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> response =
                libraryServiceClient.FindRelatedBooks(request);

            // Iterate over all response items, lazily performing RPCs as required
            foreach (BookNameOneof item in response)
            {
                // Do something with each item
                Console.WriteLine(item);
            }

            // Or iterate over pages (of server-defined size), performing one RPC per page
            foreach (FindRelatedBooksResponse page in response.AsRawResponses())
            {
                // Do something with each page of items
                Console.WriteLine("A page of results:");
                foreach (BookNameOneof item in page)
                {
                    Console.WriteLine(item);
                }
            }

            // Or retrieve a single page of known size (unless it's the final page), performing as many RPCs as required
            int pageSize = 10;
            Page<BookNameOneof> singlePage = response.ReadPage(pageSize);
            // Do something with the page of items
            Console.WriteLine($"A page of {pageSize} results (unless it's the final page):");
            foreach (BookNameOneof item in singlePage)
            {
                Console.WriteLine(item);
            }
            // Store the pageToken, for when the next page is required.
            string nextPageToken = singlePage.NextPageToken;
            // End snippet
        }

        /// <summary>Snippet for AddLabelAsync</summary>
        public async Task AddLabelAsync_RequestObject()
        {
            // Snippet: AddLabelAsync(AddLabelRequest,CallSettings)
            // Additional: AddLabelAsync(AddLabelRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            AddLabelRequest request = new AddLabelRequest
            {
                Resource = "",
                Label = "",
            };
            // Make the request
            AddLabelResponse response = await libraryServiceClient.AddLabelAsync(request);
            // End snippet
        }

        /// <summary>Snippet for AddLabel</summary>
        public void AddLabel_RequestObject()
        {
            // Snippet: AddLabel(AddLabelRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            AddLabelRequest request = new AddLabelRequest
            {
                Resource = "",
                Label = "",
            };
            // Make the request
            AddLabelResponse response = libraryServiceClient.AddLabel(request);
            // End snippet
        }

        /// <summary>Snippet for GetBigBookAsync</summary>
        public async Task GetBigBookAsync()
        {
            // Snippet: GetBigBookAsync(BookNameOneof,CallSettings)
            // Additional: GetBigBookAsync(BookNameOneof,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            // Make the request
            Operation<Book, GetBigBookMetadata> response =
                await libraryServiceClient.GetBigBookAsync(name);

            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> completedResponse =
                await response.PollUntilCompletedAsync();
            // Retrieve the operation result
            Book result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Book, GetBigBookMetadata> retrievedResponse =
                await libraryServiceClient.PollOnceGetBigBookAsync(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                Book retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigBook</summary>
        public void GetBigBook()
        {
            // Snippet: GetBigBook(BookNameOneof,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            // Make the request
            Operation<Book, GetBigBookMetadata> response =
                libraryServiceClient.GetBigBook(name);

            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> completedResponse =
                response.PollUntilCompleted();
            // Retrieve the operation result
            Book result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Book, GetBigBookMetadata> retrievedResponse =
                libraryServiceClient.PollOnceGetBigBook(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                Book retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigBookAsync</summary>
        public async Task GetBigBookAsync_RequestObject()
        {
            // Snippet: GetBigBookAsync(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            // Make the request
            Operation<Book, GetBigBookMetadata> response =
                await libraryServiceClient.GetBigBookAsync(request);

            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> completedResponse =
                await response.PollUntilCompletedAsync();
            // Retrieve the operation result
            Book result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Book, GetBigBookMetadata> retrievedResponse =
                await libraryServiceClient.PollOnceGetBigBookAsync(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                Book retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigBook</summary>
        public void GetBigBook_RequestObject()
        {
            // Snippet: GetBigBook(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            // Make the request
            Operation<Book, GetBigBookMetadata> response =
                libraryServiceClient.GetBigBook(request);

            // Poll until the returned long-running operation is complete
            Operation<Book, GetBigBookMetadata> completedResponse =
                response.PollUntilCompleted();
            // Retrieve the operation result
            Book result = completedResponse.Result;

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Book, GetBigBookMetadata> retrievedResponse =
                libraryServiceClient.PollOnceGetBigBook(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // If it has completed, then access the result
                Book retrievedResult = retrievedResponse.Result;
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigNothingAsync</summary>
        public async Task GetBigNothingAsync()
        {
            // Snippet: GetBigNothingAsync(BookNameOneof,CallSettings)
            // Additional: GetBigNothingAsync(BookNameOneof,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            // Make the request
            Operation<Empty, GetBigBookMetadata> response =
                await libraryServiceClient.GetBigNothingAsync(name);

            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> completedResponse =
                await response.PollUntilCompletedAsync();
            // The long-running operation is now complete.

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Empty, GetBigBookMetadata> retrievedResponse =
                await libraryServiceClient.PollOnceGetBigNothingAsync(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // The long-running operation is now complete.
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigNothing</summary>
        public void GetBigNothing()
        {
            // Snippet: GetBigNothing(BookNameOneof,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            // Make the request
            Operation<Empty, GetBigBookMetadata> response =
                libraryServiceClient.GetBigNothing(name);

            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> completedResponse =
                response.PollUntilCompleted();
            // The long-running operation is now complete.

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Empty, GetBigBookMetadata> retrievedResponse =
                libraryServiceClient.PollOnceGetBigNothing(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // The long-running operation is now complete.
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigNothingAsync</summary>
        public async Task GetBigNothingAsync_RequestObject()
        {
            // Snippet: GetBigNothingAsync(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            // Make the request
            Operation<Empty, GetBigBookMetadata> response =
                await libraryServiceClient.GetBigNothingAsync(request);

            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> completedResponse =
                await response.PollUntilCompletedAsync();
            // The long-running operation is now complete.

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Empty, GetBigBookMetadata> retrievedResponse =
                await libraryServiceClient.PollOnceGetBigNothingAsync(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // The long-running operation is now complete.
            }
            // End snippet
        }

        /// <summary>Snippet for GetBigNothing</summary>
        public void GetBigNothing_RequestObject()
        {
            // Snippet: GetBigNothing(GetBookRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            // Make the request
            Operation<Empty, GetBigBookMetadata> response =
                libraryServiceClient.GetBigNothing(request);

            // Poll until the returned long-running operation is complete
            Operation<Empty, GetBigBookMetadata> completedResponse =
                response.PollUntilCompleted();
            // The long-running operation is now complete.

            // Or get the name of the operation
            string operationName = response.Name;
            // This name can be stored, then the long-running operation retrieved later by name
            Operation<Empty, GetBigBookMetadata> retrievedResponse =
                libraryServiceClient.PollOnceGetBigNothing(operationName);
            // Check if the retrieved long-running operation has completed
            if (retrievedResponse.IsCompleted)
            {
                // The long-running operation is now complete.
            }
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParamsAsync</summary>
        public async Task TestOptionalRequiredFlatteningParamsAsync1()
        {
            // Snippet: TestOptionalRequiredFlatteningParamsAsync(,CallSettings)
            // Additional: TestOptionalRequiredFlatteningParamsAsync(,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = await libraryServiceClient.TestOptionalRequiredFlatteningParamsAsync();
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParams</summary>
        public void TestOptionalRequiredFlatteningParams1()
        {
            // Snippet: TestOptionalRequiredFlatteningParams(,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = libraryServiceClient.TestOptionalRequiredFlatteningParams();
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParamsAsync</summary>
        public async Task TestOptionalRequiredFlatteningParamsAsync2()
        {
            // Snippet: TestOptionalRequiredFlatteningParamsAsync(int,long,float,double,bool,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookNameOneof,BookNameOneof,string,int,long,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookNameOneof>,IEnumerable<BookNameOneof>,IEnumerable<string>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,int?,long?,float?,double?,bool?,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum?,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookNameOneof,BookNameOneof,string,int?,long?,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookNameOneof>,IEnumerable<BookNameOneof>,IEnumerable<string>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,Any,Struct,Value,ListValue,Timestamp,Duration,FieldMask,int?,uint?,long?,ulong?,float?,double?,string,bool?,ByteString,IEnumerable<Any>,IEnumerable<Struct>,IEnumerable<Value>,IEnumerable<ListValue>,IEnumerable<Timestamp>,IEnumerable<Duration>,IEnumerable<FieldMask>,IEnumerable<int?>,IEnumerable<uint?>,IEnumerable<long?>,IEnumerable<ulong?>,IEnumerable<float?>,IEnumerable<double?>,IEnumerable<string>,IEnumerable<bool?>,IEnumerable<ByteString>,CallSettings)
            // Additional: TestOptionalRequiredFlatteningParamsAsync(int,long,float,double,bool,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookNameOneof,BookNameOneof,string,int,long,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookNameOneof>,IEnumerable<BookNameOneof>,IEnumerable<string>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,int?,long?,float?,double?,bool?,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum?,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookNameOneof,BookNameOneof,string,int?,long?,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookNameOneof>,IEnumerable<BookNameOneof>,IEnumerable<string>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,Any,Struct,Value,ListValue,Timestamp,Duration,FieldMask,int?,uint?,long?,ulong?,float?,double?,string,bool?,ByteString,IEnumerable<Any>,IEnumerable<Struct>,IEnumerable<Value>,IEnumerable<ListValue>,IEnumerable<Timestamp>,IEnumerable<Duration>,IEnumerable<FieldMask>,IEnumerable<int?>,IEnumerable<uint?>,IEnumerable<long?>,IEnumerable<ulong?>,IEnumerable<float?>,IEnumerable<double?>,IEnumerable<string>,IEnumerable<bool?>,IEnumerable<ByteString>,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            int requiredSingularInt32 = 0;
            long requiredSingularInt64 = 0L;
            float requiredSingularFloat = 0.0f;
            double requiredSingularDouble = 0.0;
            bool requiredSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string requiredSingularString = "";
            ByteString requiredSingularBytes = ByteString.Empty;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookNameOneof requiredSingularResourceName = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            BookNameOneof requiredSingularResourceNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            string requiredSingularResourceNameCommon = "";
            int requiredSingularFixed32 = 0;
            long requiredSingularFixed64 = 0L;
            IEnumerable<int> requiredRepeatedInt32 = new List<int>();
            IEnumerable<long> requiredRepeatedInt64 = new List<long>();
            IEnumerable<float> requiredRepeatedFloat = new List<float>();
            IEnumerable<double> requiredRepeatedDouble = new List<double>();
            IEnumerable<bool> requiredRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> requiredRepeatedString = new List<string>();
            IEnumerable<ByteString> requiredRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceName = new List<BookNameOneof>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<string> requiredRepeatedResourceNameCommon = new List<string>();
            IEnumerable<int> requiredRepeatedFixed32 = new List<int>();
            IEnumerable<long> requiredRepeatedFixed64 = new List<long>();
            IDictionary<int, string> requiredMap = new Dictionary<int, string>();
            int optionalSingularInt32 = 0;
            long optionalSingularInt64 = 0L;
            float optionalSingularFloat = 0.0f;
            double optionalSingularDouble = 0.0;
            bool optionalSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum optionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string optionalSingularString = "";
            ByteString optionalSingularBytes = ByteString.Empty;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookNameOneof optionalSingularResourceName = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            BookNameOneof optionalSingularResourceNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            string optionalSingularResourceNameCommon = "";
            int optionalSingularFixed32 = 0;
            long optionalSingularFixed64 = 0L;
            IEnumerable<int> optionalRepeatedInt32 = new List<int>();
            IEnumerable<long> optionalRepeatedInt64 = new List<long>();
            IEnumerable<float> optionalRepeatedFloat = new List<float>();
            IEnumerable<double> optionalRepeatedDouble = new List<double>();
            IEnumerable<bool> optionalRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> optionalRepeatedString = new List<string>();
            IEnumerable<ByteString> optionalRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceName = new List<BookNameOneof>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<string> optionalRepeatedResourceNameCommon = new List<string>();
            IEnumerable<int> optionalRepeatedFixed32 = new List<int>();
            IEnumerable<long> optionalRepeatedFixed64 = new List<long>();
            IDictionary<int, string> optionalMap = new Dictionary<int, string>();
            Any anyValue = new Any();
            Struct structValue = new Struct();
            Value valueValue = new Value();
            ListValue listValueValue = new ListValue();
            Timestamp timeValue = new Timestamp();
            Duration durationValue = new Duration();
            FieldMask fieldMaskValue = new FieldMask();
            int? int32Value = null;
            uint? uint32Value = null;
            long? int64Value = null;
            ulong? uint64Value = null;
            float? floatValue = null;
            double? doubleValue = null;
            string stringValue = null;
            bool? boolValue = null;
            ByteString bytesValue = null;
            IEnumerable<Any> repeatedAnyValue = new List<Any>();
            IEnumerable<Struct> repeatedStructValue = new List<Struct>();
            IEnumerable<Value> repeatedValueValue = new List<Value>();
            IEnumerable<ListValue> repeatedListValueValue = new List<ListValue>();
            IEnumerable<Timestamp> repeatedTimeValue = new List<Timestamp>();
            IEnumerable<Duration> repeatedDurationValue = new List<Duration>();
            IEnumerable<FieldMask> repeatedFieldMaskValue = new List<FieldMask>();
            IEnumerable<int?> repeatedInt32Value = new List<int?>();
            IEnumerable<uint?> repeatedUint32Value = new List<uint?>();
            IEnumerable<long?> repeatedInt64Value = new List<long?>();
            IEnumerable<ulong?> repeatedUint64Value = new List<ulong?>();
            IEnumerable<float?> repeatedFloatValue = new List<float?>();
            IEnumerable<double?> repeatedDoubleValue = new List<double?>();
            IEnumerable<string> repeatedStringValue = new List<string>();
            IEnumerable<bool?> repeatedBoolValue = new List<bool?>();
            IEnumerable<ByteString> repeatedBytesValue = new List<ByteString>();
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = await libraryServiceClient.TestOptionalRequiredFlatteningParamsAsync(requiredSingularInt32, requiredSingularInt64, requiredSingularFloat, requiredSingularDouble, requiredSingularBool, requiredSingularEnum, requiredSingularString, requiredSingularBytes, requiredSingularMessage, requiredSingularResourceName, requiredSingularResourceNameOneof, requiredSingularResourceNameCommon, requiredSingularFixed32, requiredSingularFixed64, requiredRepeatedInt32, requiredRepeatedInt64, requiredRepeatedFloat, requiredRepeatedDouble, requiredRepeatedBool, requiredRepeatedEnum, requiredRepeatedString, requiredRepeatedBytes, requiredRepeatedMessage, requiredRepeatedResourceName, requiredRepeatedResourceNameOneof, requiredRepeatedResourceNameCommon, requiredRepeatedFixed32, requiredRepeatedFixed64, requiredMap, optionalSingularInt32, optionalSingularInt64, optionalSingularFloat, optionalSingularDouble, optionalSingularBool, optionalSingularEnum, optionalSingularString, optionalSingularBytes, optionalSingularMessage, optionalSingularResourceName, optionalSingularResourceNameOneof, optionalSingularResourceNameCommon, optionalSingularFixed32, optionalSingularFixed64, optionalRepeatedInt32, optionalRepeatedInt64, optionalRepeatedFloat, optionalRepeatedDouble, optionalRepeatedBool, optionalRepeatedEnum, optionalRepeatedString, optionalRepeatedBytes, optionalRepeatedMessage, optionalRepeatedResourceName, optionalRepeatedResourceNameOneof, optionalRepeatedResourceNameCommon, optionalRepeatedFixed32, optionalRepeatedFixed64, optionalMap, anyValue, structValue, valueValue, listValueValue, timeValue, durationValue, fieldMaskValue, int32Value, uint32Value, int64Value, uint64Value, floatValue, doubleValue, stringValue, boolValue, bytesValue, repeatedAnyValue, repeatedStructValue, repeatedValueValue, repeatedListValueValue, repeatedTimeValue, repeatedDurationValue, repeatedFieldMaskValue, repeatedInt32Value, repeatedUint32Value, repeatedInt64Value, repeatedUint64Value, repeatedFloatValue, repeatedDoubleValue, repeatedStringValue, repeatedBoolValue, repeatedBytesValue);
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParams</summary>
        public void TestOptionalRequiredFlatteningParams2()
        {
            // Snippet: TestOptionalRequiredFlatteningParams(int,long,float,double,bool,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookNameOneof,BookNameOneof,string,int,long,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookNameOneof>,IEnumerable<BookNameOneof>,IEnumerable<string>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,int?,long?,float?,double?,bool?,TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum?,string,ByteString,TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage,BookNameOneof,BookNameOneof,string,int?,long?,IEnumerable<int>,IEnumerable<long>,IEnumerable<float>,IEnumerable<double>,IEnumerable<bool>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>,IEnumerable<string>,IEnumerable<ByteString>,IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>,IEnumerable<BookNameOneof>,IEnumerable<BookNameOneof>,IEnumerable<string>,IEnumerable<int>,IEnumerable<long>,IDictionary<int, string>,Any,Struct,Value,ListValue,Timestamp,Duration,FieldMask,int?,uint?,long?,ulong?,float?,double?,string,bool?,ByteString,IEnumerable<Any>,IEnumerable<Struct>,IEnumerable<Value>,IEnumerable<ListValue>,IEnumerable<Timestamp>,IEnumerable<Duration>,IEnumerable<FieldMask>,IEnumerable<int?>,IEnumerable<uint?>,IEnumerable<long?>,IEnumerable<ulong?>,IEnumerable<float?>,IEnumerable<double?>,IEnumerable<string>,IEnumerable<bool?>,IEnumerable<ByteString>,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            int requiredSingularInt32 = 0;
            long requiredSingularInt64 = 0L;
            float requiredSingularFloat = 0.0f;
            double requiredSingularDouble = 0.0;
            bool requiredSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string requiredSingularString = "";
            ByteString requiredSingularBytes = ByteString.Empty;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookNameOneof requiredSingularResourceName = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            BookNameOneof requiredSingularResourceNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            string requiredSingularResourceNameCommon = "";
            int requiredSingularFixed32 = 0;
            long requiredSingularFixed64 = 0L;
            IEnumerable<int> requiredRepeatedInt32 = new List<int>();
            IEnumerable<long> requiredRepeatedInt64 = new List<long>();
            IEnumerable<float> requiredRepeatedFloat = new List<float>();
            IEnumerable<double> requiredRepeatedDouble = new List<double>();
            IEnumerable<bool> requiredRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> requiredRepeatedString = new List<string>();
            IEnumerable<ByteString> requiredRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceName = new List<BookNameOneof>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<string> requiredRepeatedResourceNameCommon = new List<string>();
            IEnumerable<int> requiredRepeatedFixed32 = new List<int>();
            IEnumerable<long> requiredRepeatedFixed64 = new List<long>();
            IDictionary<int, string> requiredMap = new Dictionary<int, string>();
            int optionalSingularInt32 = 0;
            long optionalSingularInt64 = 0L;
            float optionalSingularFloat = 0.0f;
            double optionalSingularDouble = 0.0;
            bool optionalSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum optionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string optionalSingularString = "";
            ByteString optionalSingularBytes = ByteString.Empty;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookNameOneof optionalSingularResourceName = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            BookNameOneof optionalSingularResourceNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            string optionalSingularResourceNameCommon = "";
            int optionalSingularFixed32 = 0;
            long optionalSingularFixed64 = 0L;
            IEnumerable<int> optionalRepeatedInt32 = new List<int>();
            IEnumerable<long> optionalRepeatedInt64 = new List<long>();
            IEnumerable<float> optionalRepeatedFloat = new List<float>();
            IEnumerable<double> optionalRepeatedDouble = new List<double>();
            IEnumerable<bool> optionalRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> optionalRepeatedString = new List<string>();
            IEnumerable<ByteString> optionalRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceName = new List<BookNameOneof>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<string> optionalRepeatedResourceNameCommon = new List<string>();
            IEnumerable<int> optionalRepeatedFixed32 = new List<int>();
            IEnumerable<long> optionalRepeatedFixed64 = new List<long>();
            IDictionary<int, string> optionalMap = new Dictionary<int, string>();
            Any anyValue = new Any();
            Struct structValue = new Struct();
            Value valueValue = new Value();
            ListValue listValueValue = new ListValue();
            Timestamp timeValue = new Timestamp();
            Duration durationValue = new Duration();
            FieldMask fieldMaskValue = new FieldMask();
            int? int32Value = null;
            uint? uint32Value = null;
            long? int64Value = null;
            ulong? uint64Value = null;
            float? floatValue = null;
            double? doubleValue = null;
            string stringValue = null;
            bool? boolValue = null;
            ByteString bytesValue = null;
            IEnumerable<Any> repeatedAnyValue = new List<Any>();
            IEnumerable<Struct> repeatedStructValue = new List<Struct>();
            IEnumerable<Value> repeatedValueValue = new List<Value>();
            IEnumerable<ListValue> repeatedListValueValue = new List<ListValue>();
            IEnumerable<Timestamp> repeatedTimeValue = new List<Timestamp>();
            IEnumerable<Duration> repeatedDurationValue = new List<Duration>();
            IEnumerable<FieldMask> repeatedFieldMaskValue = new List<FieldMask>();
            IEnumerable<int?> repeatedInt32Value = new List<int?>();
            IEnumerable<uint?> repeatedUint32Value = new List<uint?>();
            IEnumerable<long?> repeatedInt64Value = new List<long?>();
            IEnumerable<ulong?> repeatedUint64Value = new List<ulong?>();
            IEnumerable<float?> repeatedFloatValue = new List<float?>();
            IEnumerable<double?> repeatedDoubleValue = new List<double?>();
            IEnumerable<string> repeatedStringValue = new List<string>();
            IEnumerable<bool?> repeatedBoolValue = new List<bool?>();
            IEnumerable<ByteString> repeatedBytesValue = new List<ByteString>();
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = libraryServiceClient.TestOptionalRequiredFlatteningParams(requiredSingularInt32, requiredSingularInt64, requiredSingularFloat, requiredSingularDouble, requiredSingularBool, requiredSingularEnum, requiredSingularString, requiredSingularBytes, requiredSingularMessage, requiredSingularResourceName, requiredSingularResourceNameOneof, requiredSingularResourceNameCommon, requiredSingularFixed32, requiredSingularFixed64, requiredRepeatedInt32, requiredRepeatedInt64, requiredRepeatedFloat, requiredRepeatedDouble, requiredRepeatedBool, requiredRepeatedEnum, requiredRepeatedString, requiredRepeatedBytes, requiredRepeatedMessage, requiredRepeatedResourceName, requiredRepeatedResourceNameOneof, requiredRepeatedResourceNameCommon, requiredRepeatedFixed32, requiredRepeatedFixed64, requiredMap, optionalSingularInt32, optionalSingularInt64, optionalSingularFloat, optionalSingularDouble, optionalSingularBool, optionalSingularEnum, optionalSingularString, optionalSingularBytes, optionalSingularMessage, optionalSingularResourceName, optionalSingularResourceNameOneof, optionalSingularResourceNameCommon, optionalSingularFixed32, optionalSingularFixed64, optionalRepeatedInt32, optionalRepeatedInt64, optionalRepeatedFloat, optionalRepeatedDouble, optionalRepeatedBool, optionalRepeatedEnum, optionalRepeatedString, optionalRepeatedBytes, optionalRepeatedMessage, optionalRepeatedResourceName, optionalRepeatedResourceNameOneof, optionalRepeatedResourceNameCommon, optionalRepeatedFixed32, optionalRepeatedFixed64, optionalMap, anyValue, structValue, valueValue, listValueValue, timeValue, durationValue, fieldMaskValue, int32Value, uint32Value, int64Value, uint64Value, floatValue, doubleValue, stringValue, boolValue, bytesValue, repeatedAnyValue, repeatedStructValue, repeatedValueValue, repeatedListValueValue, repeatedTimeValue, repeatedDurationValue, repeatedFieldMaskValue, repeatedInt32Value, repeatedUint32Value, repeatedInt64Value, repeatedUint64Value, repeatedFloatValue, repeatedDoubleValue, repeatedStringValue, repeatedBoolValue, repeatedBytesValue);
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParamsAsync</summary>
        public async Task TestOptionalRequiredFlatteningParamsAsync_RequestObject()
        {
            // Snippet: TestOptionalRequiredFlatteningParamsAsync(TestOptionalRequiredFlatteningParamsRequest,CallSettings)
            // Additional: TestOptionalRequiredFlatteningParamsAsync(TestOptionalRequiredFlatteningParamsRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            TestOptionalRequiredFlatteningParamsRequest request = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 0,
                RequiredSingularInt64 = 0L,
                RequiredSingularFloat = 0.0f,
                RequiredSingularDouble = 0.0,
                RequiredSingularBool = false,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "",
                RequiredSingularBytes = ByteString.Empty,
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                RequiredSingularResourceNameCommon = "",
                RequiredSingularFixed32 = 0,
                RequiredSingularFixed64 = 0L,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNameOneofs = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedResourceNameCommon = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
            };
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = await libraryServiceClient.TestOptionalRequiredFlatteningParamsAsync(request);
            // End snippet
        }

        /// <summary>Snippet for TestOptionalRequiredFlatteningParams</summary>
        public void TestOptionalRequiredFlatteningParams_RequestObject()
        {
            // Snippet: TestOptionalRequiredFlatteningParams(TestOptionalRequiredFlatteningParamsRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            TestOptionalRequiredFlatteningParamsRequest request = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 0,
                RequiredSingularInt64 = 0L,
                RequiredSingularFloat = 0.0f,
                RequiredSingularDouble = 0.0,
                RequiredSingularBool = false,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "",
                RequiredSingularBytes = ByteString.Empty,
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                RequiredSingularResourceNameCommon = "",
                RequiredSingularFixed32 = 0,
                RequiredSingularFixed64 = 0L,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNameOneofs = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedResourceNameCommon = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
            };
            // Make the request
            TestOptionalRequiredFlatteningParamsResponse response = libraryServiceClient.TestOptionalRequiredFlatteningParams(request);
            // End snippet
        }

        /// <summary>Snippet for PrivateListShelvesAsync</summary>
        public async Task PrivateListShelvesAsync_RequestObject()
        {
            // Snippet: PrivateListShelvesAsync(ListShelvesRequest,CallSettings)
            // Additional: PrivateListShelvesAsync(ListShelvesRequest,CancellationToken)
            // Create client
            LibraryServiceClient libraryServiceClient = await LibraryServiceClient.CreateAsync();
            // Initialize request argument(s)
            ListShelvesRequest request = new ListShelvesRequest();
            // Make the request
            Book response = await libraryServiceClient.PrivateListShelvesAsync(request);
            // End snippet
        }

        /// <summary>Snippet for PrivateListShelves</summary>
        public void PrivateListShelves_RequestObject()
        {
            // Snippet: PrivateListShelves(ListShelvesRequest,CallSettings)
            // Create client
            LibraryServiceClient libraryServiceClient = LibraryServiceClient.Create();
            // Initialize request argument(s)
            ListShelvesRequest request = new ListShelvesRequest();
            // Make the request
            Book response = libraryServiceClient.PrivateListShelves(request);
            // End snippet
        }

    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Snippets/MyProtoClientSnippets.g.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

namespace Google.Example.Library.V1.Snippets
{
    using Google.Api.Gax;
    using Google.Api.Gax.Grpc;
    using apis = Google.Example.Library.V1;
    using Google.Protobuf;
    using Google.Protobuf.WellKnownTypes;
    using Grpc.Core;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Linq;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>Generated snippets</summary>
    public class GeneratedMyProtoClientSnippets
    {
        /// <summary>Snippet for MyMethodAsync</summary>
        public async Task MyMethodAsync_RequestObject()
        {
            // Snippet: MyMethodAsync(MethodRequest,CallSettings)
            // Additional: MyMethodAsync(MethodRequest,CancellationToken)
            // Create client
            MyProtoClient myProtoClient = await MyProtoClient.CreateAsync();
            // Initialize request argument(s)
            MethodRequest request = new MethodRequest();
            // Make the request
            MethodResponse response = await myProtoClient.MyMethodAsync(request);
            // End snippet
        }

        /// <summary>Snippet for MyMethod</summary>
        public void MyMethod_RequestObject()
        {
            // Snippet: MyMethod(MethodRequest,CallSettings)
            // Create client
            MyProtoClient myProtoClient = MyProtoClient.Create();
            // Initialize request argument(s)
            MethodRequest request = new MethodRequest();
            // Make the request
            MethodResponse response = myProtoClient.MyMethod(request);
            // End snippet
        }

    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Tests/Google.Example.Library.V1.Tests.csproj ==============
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFrameworks>netcoreapp1.0;netcoreapp2.0;net452</TargetFrameworks>
    <TargetFrameworks Condition=" '$(OS)' != 'Windows_NT' ">netcoreapp1.0;netcoreapp2.0</TargetFrameworks>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="15.5.0" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.3.1" />
    <DotNetCliToolReference Include="dotnet-xunit" Version="2.3.1" />
    <PackageReference Include="Moq" Version="4.7.145" />
    <PackageReference Include="xunit" Version="2.3.1" />
    <ProjectReference Include="../Google.Example.Library.V1/Google.Example.Library.V1.csproj" />
  </ItemGroup>

</Project>

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Tests/LibraryServiceClientTest.g.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

namespace Google.Example.Library.V1.Tests
{
    using Google.Api.Gax;
    using Google.Api.Gax.Grpc;
    using Google.Cloud.Tagger.V1;
    using apis = Google.Example.Library.V1;
    using Google.LongRunning;
    using Google.Protobuf;
    using Google.Protobuf.WellKnownTypes;
    using Grpc.Core;
    using Moq;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Threading;
    using System.Threading.Tasks;
    using Xunit;

    /// <summary>Generated unit tests</summary>
    public class GeneratedLibraryServiceClientTest
    {
        [Fact]
        public void CreateShelf()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateShelfRequest expectedRequest = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.CreateShelf(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf shelf = new Shelf();
            Shelf response = client.CreateShelf(shelf);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task CreateShelfAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateShelfRequest expectedRequest = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.CreateShelfAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf shelf = new Shelf();
            Shelf response = await client.CreateShelfAsync(shelf);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void CreateShelf2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateShelfRequest request = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.CreateShelf(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf response = client.CreateShelf(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task CreateShelfAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateShelfRequest request = new CreateShelfRequest
            {
                Shelf = new Shelf(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.CreateShelfAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf response = await client.CreateShelfAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetShelf()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest expectedRequest = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelf(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF_ID]");
            Shelf response = client.GetShelf(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetShelfAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest expectedRequest = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelfAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF_ID]");
            Shelf response = await client.GetShelfAsync(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetShelf2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest expectedRequest = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Message = new SomeMessage(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelf(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF_ID]");
            SomeMessage message = new SomeMessage();
            Shelf response = client.GetShelf(name, message);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetShelfAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest expectedRequest = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Message = new SomeMessage(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelfAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF_ID]");
            SomeMessage message = new SomeMessage();
            Shelf response = await client.GetShelfAsync(name, message);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetShelf3()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest expectedRequest = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Message = new SomeMessage(),
                StringBuilder = new StringBuilder(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelf(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF_ID]");
            SomeMessage message = new SomeMessage();
            StringBuilder stringBuilder = new StringBuilder();
            Shelf response = client.GetShelf(name, message, stringBuilder);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetShelfAsync3()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest expectedRequest = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Message = new SomeMessage(),
                StringBuilder = new StringBuilder(),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelfAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF_ID]");
            SomeMessage message = new SomeMessage();
            StringBuilder stringBuilder = new StringBuilder();
            Shelf response = await client.GetShelfAsync(name, message, stringBuilder);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetShelf4()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest request = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Options = "options-1249474914",
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelf(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf response = client.GetShelf(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetShelfAsync4()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetShelfRequest request = new GetShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Options = "options-1249474914",
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.GetShelfAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf response = await client.GetShelfAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void DeleteShelf()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteShelfRequest expectedRequest = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteShelf(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF_ID]");
            client.DeleteShelf(name);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task DeleteShelfAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteShelfRequest expectedRequest = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteShelfAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF_ID]");
            await client.DeleteShelfAsync(name);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void DeleteShelf2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteShelfRequest request = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteShelf(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            client.DeleteShelf(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task DeleteShelfAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteShelfRequest request = new DeleteShelfRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteShelfAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            await client.DeleteShelfAsync(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void MergeShelves()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MergeShelvesRequest expectedRequest = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.MergeShelves(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF_ID]");
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            Shelf response = client.MergeShelves(name, otherShelfName);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task MergeShelvesAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MergeShelvesRequest expectedRequest = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.MergeShelvesAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF_ID]");
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            Shelf response = await client.MergeShelvesAsync(name, otherShelfName);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void MergeShelves2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MergeShelvesRequest request = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.MergeShelves(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf response = client.MergeShelves(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task MergeShelvesAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MergeShelvesRequest request = new MergeShelvesRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            Shelf expectedResponse = new Shelf
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Theme = "theme110327241",
                InternalTheme = "internalTheme792518087",
            };
            mockGrpcClient.Setup(x => x.MergeShelvesAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Shelf>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf response = await client.MergeShelvesAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void CreateBook()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateBookRequest expectedRequest = new CreateBookRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.CreateBook(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF_ID]");
            Book book = new Book();
            Book response = client.CreateBook(name, book);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task CreateBookAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateBookRequest expectedRequest = new CreateBookRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.CreateBookAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ShelfName name = new ShelfName("[SHELF_ID]");
            Book book = new Book();
            Book response = await client.CreateBookAsync(name, book);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void CreateBook2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateBookRequest request = new CreateBookRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.CreateBook(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = client.CreateBook(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task CreateBookAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            CreateBookRequest request = new CreateBookRequest
            {
                ShelfName = new ShelfName("[SHELF_ID]"),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.CreateBookAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = await client.CreateBookAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void PublishSeries()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            PublishSeriesRequest expectedRequest = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                Edition = 1887963714,
                SeriesUuid = new SeriesUuid
                {
                    SeriesString = "foobar",
                },
            };
            PublishSeriesResponse expectedResponse = new PublishSeriesResponse
            {
                BookNames =
                {
                    "bookNamesElement1491670575",
                },
            };
            mockGrpcClient.Setup(x => x.PublishSeries(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf shelf = new Shelf();
            IEnumerable<Book> books = new List<Book>();
            uint edition = 1887963714;
            SeriesUuid seriesUuid = new SeriesUuid
            {
                SeriesString = "foobar",
            };
            PublishSeriesResponse response = client.PublishSeries(shelf, books, edition, seriesUuid);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task PublishSeriesAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            PublishSeriesRequest expectedRequest = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                Edition = 1887963714,
                SeriesUuid = new SeriesUuid
                {
                    SeriesString = "foobar",
                },
            };
            PublishSeriesResponse expectedResponse = new PublishSeriesResponse
            {
                BookNames =
                {
                    "bookNamesElement1491670575",
                },
            };
            mockGrpcClient.Setup(x => x.PublishSeriesAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<PublishSeriesResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Shelf shelf = new Shelf();
            IEnumerable<Book> books = new List<Book>();
            uint edition = 1887963714;
            SeriesUuid seriesUuid = new SeriesUuid
            {
                SeriesString = "foobar",
            };
            PublishSeriesResponse response = await client.PublishSeriesAsync(shelf, books, edition, seriesUuid);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void PublishSeries2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                SeriesUuid = new SeriesUuid
                {
                    SeriesString = "foobar",
                },
            };
            PublishSeriesResponse expectedResponse = new PublishSeriesResponse
            {
                BookNames =
                {
                    "bookNamesElement1491670575",
                },
            };
            mockGrpcClient.Setup(x => x.PublishSeries(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            PublishSeriesResponse response = client.PublishSeries(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task PublishSeriesAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            PublishSeriesRequest request = new PublishSeriesRequest
            {
                Shelf = new Shelf(),
                Books = { },
                SeriesUuid = new SeriesUuid
                {
                    SeriesString = "foobar",
                },
            };
            PublishSeriesResponse expectedResponse = new PublishSeriesResponse
            {
                BookNames =
                {
                    "bookNamesElement1491670575",
                },
            };
            mockGrpcClient.Setup(x => x.PublishSeriesAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<PublishSeriesResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            PublishSeriesResponse response = await client.PublishSeriesAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBook()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookRequest expectedRequest = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBook(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            Book response = client.GetBook(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookRequest expectedRequest = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            Book response = await client.GetBookAsync(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBook2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBook(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = client.GetBook(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookRequest request = new GetBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = await client.GetBookAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void DeleteBook()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteBookRequest expectedRequest = new DeleteBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteBook(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            client.DeleteBook(name);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task DeleteBookAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteBookRequest expectedRequest = new DeleteBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteBookAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            await client.DeleteBookAsync(name);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void DeleteBook2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteBookRequest request = new DeleteBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteBook(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            client.DeleteBook(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task DeleteBookAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            DeleteBookRequest request = new DeleteBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.DeleteBookAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            await client.DeleteBookAsync(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void UpdateBook()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookRequest expectedRequest = new UpdateBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.UpdateBook(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            Book book = new Book();
            Book response = client.UpdateBook(name, book);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task UpdateBookAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookRequest expectedRequest = new UpdateBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.UpdateBookAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            Book book = new Book();
            Book response = await client.UpdateBookAsync(name, book);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void UpdateBook2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookRequest expectedRequest = new UpdateBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                OptionalFoo = "optionalFoo1822578535",
                Book = new Book(),
                UpdateMask = new FieldMask(),
                PhysicalMask = new apis::FieldMask(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.UpdateBook(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            string optionalFoo = "optionalFoo1822578535";
            Book book = new Book();
            FieldMask updateMask = new FieldMask();
            apis::FieldMask physicalMask = new apis::FieldMask();
            Book response = client.UpdateBook(name, optionalFoo, book, updateMask, physicalMask);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task UpdateBookAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookRequest expectedRequest = new UpdateBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                OptionalFoo = "optionalFoo1822578535",
                Book = new Book(),
                UpdateMask = new FieldMask(),
                PhysicalMask = new apis::FieldMask(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.UpdateBookAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            string optionalFoo = "optionalFoo1822578535";
            Book book = new Book();
            FieldMask updateMask = new FieldMask();
            apis::FieldMask physicalMask = new apis::FieldMask();
            Book response = await client.UpdateBookAsync(name, optionalFoo, book, updateMask, physicalMask);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void UpdateBook3()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookRequest request = new UpdateBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.UpdateBook(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = client.UpdateBook(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task UpdateBookAsync3()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookRequest request = new UpdateBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Book = new Book(),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.UpdateBookAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = await client.UpdateBookAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void MoveBook()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MoveBookRequest expectedRequest = new MoveBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.MoveBook(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            Book response = client.MoveBook(name, otherShelfName);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task MoveBookAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MoveBookRequest expectedRequest = new MoveBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.MoveBookAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            ShelfName otherShelfName = new ShelfName("[SHELF_ID]");
            Book response = await client.MoveBookAsync(name, otherShelfName);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void MoveBook2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MoveBookRequest request = new MoveBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.MoveBook(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = client.MoveBook(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task MoveBookAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            MoveBookRequest request = new MoveBookRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                OtherShelfNameAsShelfName = new ShelfName("[SHELF_ID]"),
            };
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.MoveBookAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = await client.MoveBookAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void AddComments()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            AddCommentsRequest expectedRequest = new AddCommentsRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Comments =
                {
                    new Comment
                    {
                        Comment = ByteString.CopyFromUtf8("95"),
                        Stage = Comment.Types.Stage.Unset,
                        Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                    },
                },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.AddComments(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            IEnumerable<Comment> comments = new[]
            {
                new Comment
                {
                    Comment = ByteString.CopyFromUtf8("95"),
                    Stage = Comment.Types.Stage.Unset,
                    Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                },
            };
            client.AddComments(name, comments);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task AddCommentsAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            AddCommentsRequest expectedRequest = new AddCommentsRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Comments =
                {
                    new Comment
                    {
                        Comment = ByteString.CopyFromUtf8("95"),
                        Stage = Comment.Types.Stage.Unset,
                        Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                    },
                },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.AddCommentsAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            IEnumerable<Comment> comments = new[]
            {
                new Comment
                {
                    Comment = ByteString.CopyFromUtf8("95"),
                    Stage = Comment.Types.Stage.Unset,
                    Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                },
            };
            await client.AddCommentsAsync(name, comments);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void AddComments2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            AddCommentsRequest request = new AddCommentsRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Comments =
                {
                    new Comment
                    {
                        Comment = ByteString.CopyFromUtf8("95"),
                        Stage = Comment.Types.Stage.Unset,
                        Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                    },
                },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.AddComments(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            client.AddComments(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task AddCommentsAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            AddCommentsRequest request = new AddCommentsRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Comments =
                {
                    new Comment
                    {
                        Comment = ByteString.CopyFromUtf8("95"),
                        Stage = Comment.Types.Stage.Unset,
                        Alignment = SomeMessage2.Types.SomeMessage3.Types.Alignment.Char,
                    },
                },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.AddCommentsAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            await client.AddCommentsAsync(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBookFromArchive()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromArchiveRequest expectedRequest = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
            };
            BookFromArchive expectedResponse = new BookFromArchive
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromArchive(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ArchivedBookName name = new ArchivedBookName("[ARCHIVE]", "[BOOK]");
            BookFromArchive response = client.GetBookFromArchive(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookFromArchiveAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromArchiveRequest expectedRequest = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
            };
            BookFromArchive expectedResponse = new BookFromArchive
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromArchiveAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<BookFromArchive>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            ArchivedBookName name = new ArchivedBookName("[ARCHIVE]", "[BOOK]");
            BookFromArchive response = await client.GetBookFromArchiveAsync(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBookFromArchive2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromArchiveRequest request = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
            };
            BookFromArchive expectedResponse = new BookFromArchive
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromArchive(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookFromArchive response = client.GetBookFromArchive(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookFromArchiveAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromArchiveRequest request = new GetBookFromArchiveRequest
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
            };
            BookFromArchive expectedResponse = new BookFromArchive
            {
                ArchivedBookName = new ArchivedBookName("[ARCHIVE]", "[BOOK]"),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromArchiveAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<BookFromArchive>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookFromArchive response = await client.GetBookFromArchiveAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBookFromAnywhere()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAnywhereRequest expectedRequest = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAnywhere(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            BookNameOneof altBookName = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            BookFromAnywhere response = client.GetBookFromAnywhere(name, altBookName);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookFromAnywhereAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAnywhereRequest expectedRequest = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAnywhereAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<BookFromAnywhere>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            BookNameOneof altBookName = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            BookFromAnywhere response = await client.GetBookFromAnywhereAsync(name, altBookName);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBookFromAnywhere2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAnywhereRequest request = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAnywhere(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookFromAnywhere response = client.GetBookFromAnywhere(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookFromAnywhereAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAnywhereRequest request = new GetBookFromAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                AltBookNameAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAnywhereAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<BookFromAnywhere>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookFromAnywhere response = await client.GetBookFromAnywhereAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBookFromAbsolutelyAnywhere()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAbsolutelyAnywhereRequest expectedRequest = new GetBookFromAbsolutelyAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAbsolutelyAnywhere(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            BookFromAnywhere response = client.GetBookFromAbsolutelyAnywhere(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookFromAbsolutelyAnywhereAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAbsolutelyAnywhereRequest expectedRequest = new GetBookFromAbsolutelyAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAbsolutelyAnywhereAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<BookFromAnywhere>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            BookFromAnywhere response = await client.GetBookFromAbsolutelyAnywhereAsync(name);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void GetBookFromAbsolutelyAnywhere2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAbsolutelyAnywhereRequest request = new GetBookFromAbsolutelyAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAbsolutelyAnywhere(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookFromAnywhere response = client.GetBookFromAbsolutelyAnywhere(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task GetBookFromAbsolutelyAnywhereAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            GetBookFromAbsolutelyAnywhereRequest request = new GetBookFromAbsolutelyAnywhereRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
            };
            BookFromAnywhere expectedResponse = new BookFromAnywhere
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.GetBookFromAbsolutelyAnywhereAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<BookFromAnywhere>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookFromAnywhere response = await client.GetBookFromAbsolutelyAnywhereAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void UpdateBookIndex()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookIndexRequest expectedRequest = new UpdateBookIndexRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                IndexName = "default index",
                IndexMap =
                {
                    { "default_key", "indexMapItem1918721251" },
                },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.UpdateBookIndex(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            string indexName = "default index";
            IDictionary<string, string> indexMap = new Dictionary<string, string>
            {
                { "default_key", "indexMapItem1918721251" },
            };
            client.UpdateBookIndex(name, indexName, indexMap);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task UpdateBookIndexAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookIndexRequest expectedRequest = new UpdateBookIndexRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                IndexName = "default index",
                IndexMap =
                {
                    { "default_key", "indexMapItem1918721251" },
                },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.UpdateBookIndexAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            BookNameOneof name = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            string indexName = "default index";
            IDictionary<string, string> indexMap = new Dictionary<string, string>
            {
                { "default_key", "indexMapItem1918721251" },
            };
            await client.UpdateBookIndexAsync(name, indexName, indexMap);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void UpdateBookIndex2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookIndexRequest request = new UpdateBookIndexRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                IndexName = "default index",
                IndexMap =
                {
                    { "default_key", "indexMapItem1918721251" },
                },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.UpdateBookIndex(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            client.UpdateBookIndex(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task UpdateBookIndexAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            UpdateBookIndexRequest request = new UpdateBookIndexRequest
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                IndexName = "default index",
                IndexMap =
                {
                    { "default_key", "indexMapItem1918721251" },
                },
            };
            Empty expectedResponse = new Empty();
            mockGrpcClient.Setup(x => x.UpdateBookIndexAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Empty>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            await client.UpdateBookIndexAsync(request);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void TestOptionalRequiredFlatteningParams()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            TestOptionalRequiredFlatteningParamsRequest expectedRequest = new TestOptionalRequiredFlatteningParamsRequest();
            TestOptionalRequiredFlatteningParamsResponse expectedResponse = new TestOptionalRequiredFlatteningParamsResponse();
            mockGrpcClient.Setup(x => x.TestOptionalRequiredFlatteningParams(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);

            TestOptionalRequiredFlatteningParamsResponse response = client.TestOptionalRequiredFlatteningParams();
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task TestOptionalRequiredFlatteningParamsAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            TestOptionalRequiredFlatteningParamsRequest expectedRequest = new TestOptionalRequiredFlatteningParamsRequest();
            TestOptionalRequiredFlatteningParamsResponse expectedResponse = new TestOptionalRequiredFlatteningParamsResponse();
            mockGrpcClient.Setup(x => x.TestOptionalRequiredFlatteningParamsAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<TestOptionalRequiredFlatteningParamsResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);

            TestOptionalRequiredFlatteningParamsResponse response = await client.TestOptionalRequiredFlatteningParamsAsync();
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void TestOptionalRequiredFlatteningParams2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            TestOptionalRequiredFlatteningParamsRequest expectedRequest = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 72313594,
                RequiredSingularInt64 = 72313499L,
                RequiredSingularFloat = -7514705.0f,
                RequiredSingularDouble = 1.9111005E8,
                RequiredSingularBool = true,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "requiredSingularString-1949894503",
                RequiredSingularBytes = ByteString.CopyFromUtf8("-29"),
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                RequiredSingularResourceNameCommon = "requiredSingularResourceNameCommon-1126805002",
                RequiredSingularFixed32 = 720656715,
                RequiredSingularFixed64 = 720656810,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNameOneofs = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedResourceNameCommon = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
                OptionalSingularInt32 = 1196565723,
                OptionalSingularInt64 = 1196565628L,
                OptionalSingularFloat = -1.19939918E8f,
                OptionalSingularDouble = 1.41902287E8,
                OptionalSingularBool = false,
                OptionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                OptionalSingularString = "optionalSingularString1852995162",
                OptionalSingularBytes = ByteString.CopyFromUtf8("2"),
                OptionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                OptionalSingularResourceNameAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                OptionalSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                OptionalSingularResourceNameCommon = "optionalSingularResourceNameCommon-108123657",
                OptionalSingularFixed32 = 1648847958,
                OptionalSingularFixed64 = 1648847863,
                OptionalRepeatedInt32 = { },
                OptionalRepeatedInt64 = { },
                OptionalRepeatedFloat = { },
                OptionalRepeatedDouble = { },
                OptionalRepeatedBool = { },
                OptionalRepeatedEnum = { },
                OptionalRepeatedString = { },
                OptionalRepeatedBytes = { },
                OptionalRepeatedMessage = { },
                OptionalRepeatedResourceNameAsBookNameOneofs = { },
                OptionalRepeatedResourceNameOneofAsBookNameOneofs = { },
                OptionalRepeatedResourceNameCommon = { },
                OptionalRepeatedFixed32 = { },
                OptionalRepeatedFixed64 = { },
                OptionalMap = { },
                AnyValue = new Any(),
                StructValue = new Struct(),
                ValueValue = new Value(),
                ListValueValue = new ListValue(),
                TimeValue = new Timestamp(),
                DurationValue = new Duration(),
                FieldMaskValue = new FieldMask(),
                Int32Value = null,
                Uint32Value = null,
                Int64Value = null,
                Uint64Value = null,
                FloatValue = null,
                DoubleValue = null,
                StringValue = null,
                BoolValue = null,
                BytesValue = null,
                RepeatedAnyValue = { },
                RepeatedStructValue = { },
                RepeatedValueValue = { },
                RepeatedListValueValue = { },
                RepeatedTimeValue = { },
                RepeatedDurationValue = { },
                RepeatedFieldMaskValue = { },
                RepeatedInt32Value = { },
                RepeatedUint32Value = { },
                RepeatedInt64Value = { },
                RepeatedUint64Value = { },
                RepeatedFloatValue = { },
                RepeatedDoubleValue = { },
                RepeatedStringValue = { },
                RepeatedBoolValue = { },
                RepeatedBytesValue = { },
            };
            TestOptionalRequiredFlatteningParamsResponse expectedResponse = new TestOptionalRequiredFlatteningParamsResponse();
            mockGrpcClient.Setup(x => x.TestOptionalRequiredFlatteningParams(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            int requiredSingularInt32 = 72313594;
            long requiredSingularInt64 = 72313499L;
            float requiredSingularFloat = -7514705.0f;
            double requiredSingularDouble = 1.9111005E8;
            bool requiredSingularBool = true;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string requiredSingularString = "requiredSingularString-1949894503";
            ByteString requiredSingularBytes = ByteString.CopyFromUtf8("-29");
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookNameOneof requiredSingularResourceName = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            BookNameOneof requiredSingularResourceNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            string requiredSingularResourceNameCommon = "requiredSingularResourceNameCommon-1126805002";
            int requiredSingularFixed32 = 720656715;
            long requiredSingularFixed64 = 720656810;
            IEnumerable<int> requiredRepeatedInt32 = new List<int>();
            IEnumerable<long> requiredRepeatedInt64 = new List<long>();
            IEnumerable<float> requiredRepeatedFloat = new List<float>();
            IEnumerable<double> requiredRepeatedDouble = new List<double>();
            IEnumerable<bool> requiredRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> requiredRepeatedString = new List<string>();
            IEnumerable<ByteString> requiredRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceName = new List<BookNameOneof>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<string> requiredRepeatedResourceNameCommon = new List<string>();
            IEnumerable<int> requiredRepeatedFixed32 = new List<int>();
            IEnumerable<long> requiredRepeatedFixed64 = new List<long>();
            IDictionary<int, string> requiredMap = new Dictionary<int, string>();
            int optionalSingularInt32 = 1196565723;
            long optionalSingularInt64 = 1196565628L;
            float optionalSingularFloat = -1.19939918E8f;
            double optionalSingularDouble = 1.41902287E8;
            bool optionalSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum optionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string optionalSingularString = "optionalSingularString1852995162";
            ByteString optionalSingularBytes = ByteString.CopyFromUtf8("2");
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookNameOneof optionalSingularResourceName = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            BookNameOneof optionalSingularResourceNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            string optionalSingularResourceNameCommon = "optionalSingularResourceNameCommon-108123657";
            int optionalSingularFixed32 = 1648847958;
            long optionalSingularFixed64 = 1648847863;
            IEnumerable<int> optionalRepeatedInt32 = new List<int>();
            IEnumerable<long> optionalRepeatedInt64 = new List<long>();
            IEnumerable<float> optionalRepeatedFloat = new List<float>();
            IEnumerable<double> optionalRepeatedDouble = new List<double>();
            IEnumerable<bool> optionalRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> optionalRepeatedString = new List<string>();
            IEnumerable<ByteString> optionalRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceName = new List<BookNameOneof>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<string> optionalRepeatedResourceNameCommon = new List<string>();
            IEnumerable<int> optionalRepeatedFixed32 = new List<int>();
            IEnumerable<long> optionalRepeatedFixed64 = new List<long>();
            IDictionary<int, string> optionalMap = new Dictionary<int, string>();
            Any anyValue = new Any();
            Struct structValue = new Struct();
            Value valueValue = new Value();
            ListValue listValueValue = new ListValue();
            Timestamp timeValue = new Timestamp();
            Duration durationValue = new Duration();
            FieldMask fieldMaskValue = new FieldMask();
            int? int32Value = null;
            uint? uint32Value = null;
            long? int64Value = null;
            ulong? uint64Value = null;
            float? floatValue = null;
            double? doubleValue = null;
            string stringValue = null;
            bool? boolValue = null;
            ByteString bytesValue = null;
            IEnumerable<Any> repeatedAnyValue = new List<Any>();
            IEnumerable<Struct> repeatedStructValue = new List<Struct>();
            IEnumerable<Value> repeatedValueValue = new List<Value>();
            IEnumerable<ListValue> repeatedListValueValue = new List<ListValue>();
            IEnumerable<Timestamp> repeatedTimeValue = new List<Timestamp>();
            IEnumerable<Duration> repeatedDurationValue = new List<Duration>();
            IEnumerable<FieldMask> repeatedFieldMaskValue = new List<FieldMask>();
            IEnumerable<int?> repeatedInt32Value = new List<int?>();
            IEnumerable<uint?> repeatedUint32Value = new List<uint?>();
            IEnumerable<long?> repeatedInt64Value = new List<long?>();
            IEnumerable<ulong?> repeatedUint64Value = new List<ulong?>();
            IEnumerable<float?> repeatedFloatValue = new List<float?>();
            IEnumerable<double?> repeatedDoubleValue = new List<double?>();
            IEnumerable<string> repeatedStringValue = new List<string>();
            IEnumerable<bool?> repeatedBoolValue = new List<bool?>();
            IEnumerable<ByteString> repeatedBytesValue = new List<ByteString>();
            TestOptionalRequiredFlatteningParamsResponse response = client.TestOptionalRequiredFlatteningParams(requiredSingularInt32, requiredSingularInt64, requiredSingularFloat, requiredSingularDouble, requiredSingularBool, requiredSingularEnum, requiredSingularString, requiredSingularBytes, requiredSingularMessage, requiredSingularResourceName, requiredSingularResourceNameOneof, requiredSingularResourceNameCommon, requiredSingularFixed32, requiredSingularFixed64, requiredRepeatedInt32, requiredRepeatedInt64, requiredRepeatedFloat, requiredRepeatedDouble, requiredRepeatedBool, requiredRepeatedEnum, requiredRepeatedString, requiredRepeatedBytes, requiredRepeatedMessage, requiredRepeatedResourceName, requiredRepeatedResourceNameOneof, requiredRepeatedResourceNameCommon, requiredRepeatedFixed32, requiredRepeatedFixed64, requiredMap, optionalSingularInt32, optionalSingularInt64, optionalSingularFloat, optionalSingularDouble, optionalSingularBool, optionalSingularEnum, optionalSingularString, optionalSingularBytes, optionalSingularMessage, optionalSingularResourceName, optionalSingularResourceNameOneof, optionalSingularResourceNameCommon, optionalSingularFixed32, optionalSingularFixed64, optionalRepeatedInt32, optionalRepeatedInt64, optionalRepeatedFloat, optionalRepeatedDouble, optionalRepeatedBool, optionalRepeatedEnum, optionalRepeatedString, optionalRepeatedBytes, optionalRepeatedMessage, optionalRepeatedResourceName, optionalRepeatedResourceNameOneof, optionalRepeatedResourceNameCommon, optionalRepeatedFixed32, optionalRepeatedFixed64, optionalMap, anyValue, structValue, valueValue, listValueValue, timeValue, durationValue, fieldMaskValue, int32Value, uint32Value, int64Value, uint64Value, floatValue, doubleValue, stringValue, boolValue, bytesValue, repeatedAnyValue, repeatedStructValue, repeatedValueValue, repeatedListValueValue, repeatedTimeValue, repeatedDurationValue, repeatedFieldMaskValue, repeatedInt32Value, repeatedUint32Value, repeatedInt64Value, repeatedUint64Value, repeatedFloatValue, repeatedDoubleValue, repeatedStringValue, repeatedBoolValue, repeatedBytesValue);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task TestOptionalRequiredFlatteningParamsAsync2()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            TestOptionalRequiredFlatteningParamsRequest expectedRequest = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 72313594,
                RequiredSingularInt64 = 72313499L,
                RequiredSingularFloat = -7514705.0f,
                RequiredSingularDouble = 1.9111005E8,
                RequiredSingularBool = true,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "requiredSingularString-1949894503",
                RequiredSingularBytes = ByteString.CopyFromUtf8("-29"),
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                RequiredSingularResourceNameCommon = "requiredSingularResourceNameCommon-1126805002",
                RequiredSingularFixed32 = 720656715,
                RequiredSingularFixed64 = 720656810,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNameOneofs = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedResourceNameCommon = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
                OptionalSingularInt32 = 1196565723,
                OptionalSingularInt64 = 1196565628L,
                OptionalSingularFloat = -1.19939918E8f,
                OptionalSingularDouble = 1.41902287E8,
                OptionalSingularBool = false,
                OptionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                OptionalSingularString = "optionalSingularString1852995162",
                OptionalSingularBytes = ByteString.CopyFromUtf8("2"),
                OptionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                OptionalSingularResourceNameAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                OptionalSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                OptionalSingularResourceNameCommon = "optionalSingularResourceNameCommon-108123657",
                OptionalSingularFixed32 = 1648847958,
                OptionalSingularFixed64 = 1648847863,
                OptionalRepeatedInt32 = { },
                OptionalRepeatedInt64 = { },
                OptionalRepeatedFloat = { },
                OptionalRepeatedDouble = { },
                OptionalRepeatedBool = { },
                OptionalRepeatedEnum = { },
                OptionalRepeatedString = { },
                OptionalRepeatedBytes = { },
                OptionalRepeatedMessage = { },
                OptionalRepeatedResourceNameAsBookNameOneofs = { },
                OptionalRepeatedResourceNameOneofAsBookNameOneofs = { },
                OptionalRepeatedResourceNameCommon = { },
                OptionalRepeatedFixed32 = { },
                OptionalRepeatedFixed64 = { },
                OptionalMap = { },
                AnyValue = new Any(),
                StructValue = new Struct(),
                ValueValue = new Value(),
                ListValueValue = new ListValue(),
                TimeValue = new Timestamp(),
                DurationValue = new Duration(),
                FieldMaskValue = new FieldMask(),
                Int32Value = null,
                Uint32Value = null,
                Int64Value = null,
                Uint64Value = null,
                FloatValue = null,
                DoubleValue = null,
                StringValue = null,
                BoolValue = null,
                BytesValue = null,
                RepeatedAnyValue = { },
                RepeatedStructValue = { },
                RepeatedValueValue = { },
                RepeatedListValueValue = { },
                RepeatedTimeValue = { },
                RepeatedDurationValue = { },
                RepeatedFieldMaskValue = { },
                RepeatedInt32Value = { },
                RepeatedUint32Value = { },
                RepeatedInt64Value = { },
                RepeatedUint64Value = { },
                RepeatedFloatValue = { },
                RepeatedDoubleValue = { },
                RepeatedStringValue = { },
                RepeatedBoolValue = { },
                RepeatedBytesValue = { },
            };
            TestOptionalRequiredFlatteningParamsResponse expectedResponse = new TestOptionalRequiredFlatteningParamsResponse();
            mockGrpcClient.Setup(x => x.TestOptionalRequiredFlatteningParamsAsync(expectedRequest, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<TestOptionalRequiredFlatteningParamsResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            int requiredSingularInt32 = 72313594;
            long requiredSingularInt64 = 72313499L;
            float requiredSingularFloat = -7514705.0f;
            double requiredSingularDouble = 1.9111005E8;
            bool requiredSingularBool = true;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string requiredSingularString = "requiredSingularString-1949894503";
            ByteString requiredSingularBytes = ByteString.CopyFromUtf8("-29");
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookNameOneof requiredSingularResourceName = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            BookNameOneof requiredSingularResourceNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            string requiredSingularResourceNameCommon = "requiredSingularResourceNameCommon-1126805002";
            int requiredSingularFixed32 = 720656715;
            long requiredSingularFixed64 = 720656810;
            IEnumerable<int> requiredRepeatedInt32 = new List<int>();
            IEnumerable<long> requiredRepeatedInt64 = new List<long>();
            IEnumerable<float> requiredRepeatedFloat = new List<float>();
            IEnumerable<double> requiredRepeatedDouble = new List<double>();
            IEnumerable<bool> requiredRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> requiredRepeatedString = new List<string>();
            IEnumerable<ByteString> requiredRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceName = new List<BookNameOneof>();
            IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<string> requiredRepeatedResourceNameCommon = new List<string>();
            IEnumerable<int> requiredRepeatedFixed32 = new List<int>();
            IEnumerable<long> requiredRepeatedFixed64 = new List<long>();
            IDictionary<int, string> requiredMap = new Dictionary<int, string>();
            int optionalSingularInt32 = 1196565723;
            long optionalSingularInt64 = 1196565628L;
            float optionalSingularFloat = -1.19939918E8f;
            double optionalSingularDouble = 1.41902287E8;
            bool optionalSingularBool = false;
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum optionalSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero;
            string optionalSingularString = "optionalSingularString1852995162";
            ByteString optionalSingularBytes = ByteString.CopyFromUtf8("2");
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage();
            BookNameOneof optionalSingularResourceName = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            BookNameOneof optionalSingularResourceNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]"));
            string optionalSingularResourceNameCommon = "optionalSingularResourceNameCommon-108123657";
            int optionalSingularFixed32 = 1648847958;
            long optionalSingularFixed64 = 1648847863;
            IEnumerable<int> optionalRepeatedInt32 = new List<int>();
            IEnumerable<long> optionalRepeatedInt64 = new List<long>();
            IEnumerable<float> optionalRepeatedFloat = new List<float>();
            IEnumerable<double> optionalRepeatedDouble = new List<double>();
            IEnumerable<bool> optionalRepeatedBool = new List<bool>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>();
            IEnumerable<string> optionalRepeatedString = new List<string>();
            IEnumerable<ByteString> optionalRepeatedBytes = new List<ByteString>();
            IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage = new List<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceName = new List<BookNameOneof>();
            IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof = new List<BookNameOneof>();
            IEnumerable<string> optionalRepeatedResourceNameCommon = new List<string>();
            IEnumerable<int> optionalRepeatedFixed32 = new List<int>();
            IEnumerable<long> optionalRepeatedFixed64 = new List<long>();
            IDictionary<int, string> optionalMap = new Dictionary<int, string>();
            Any anyValue = new Any();
            Struct structValue = new Struct();
            Value valueValue = new Value();
            ListValue listValueValue = new ListValue();
            Timestamp timeValue = new Timestamp();
            Duration durationValue = new Duration();
            FieldMask fieldMaskValue = new FieldMask();
            int? int32Value = null;
            uint? uint32Value = null;
            long? int64Value = null;
            ulong? uint64Value = null;
            float? floatValue = null;
            double? doubleValue = null;
            string stringValue = null;
            bool? boolValue = null;
            ByteString bytesValue = null;
            IEnumerable<Any> repeatedAnyValue = new List<Any>();
            IEnumerable<Struct> repeatedStructValue = new List<Struct>();
            IEnumerable<Value> repeatedValueValue = new List<Value>();
            IEnumerable<ListValue> repeatedListValueValue = new List<ListValue>();
            IEnumerable<Timestamp> repeatedTimeValue = new List<Timestamp>();
            IEnumerable<Duration> repeatedDurationValue = new List<Duration>();
            IEnumerable<FieldMask> repeatedFieldMaskValue = new List<FieldMask>();
            IEnumerable<int?> repeatedInt32Value = new List<int?>();
            IEnumerable<uint?> repeatedUint32Value = new List<uint?>();
            IEnumerable<long?> repeatedInt64Value = new List<long?>();
            IEnumerable<ulong?> repeatedUint64Value = new List<ulong?>();
            IEnumerable<float?> repeatedFloatValue = new List<float?>();
            IEnumerable<double?> repeatedDoubleValue = new List<double?>();
            IEnumerable<string> repeatedStringValue = new List<string>();
            IEnumerable<bool?> repeatedBoolValue = new List<bool?>();
            IEnumerable<ByteString> repeatedBytesValue = new List<ByteString>();
            TestOptionalRequiredFlatteningParamsResponse response = await client.TestOptionalRequiredFlatteningParamsAsync(requiredSingularInt32, requiredSingularInt64, requiredSingularFloat, requiredSingularDouble, requiredSingularBool, requiredSingularEnum, requiredSingularString, requiredSingularBytes, requiredSingularMessage, requiredSingularResourceName, requiredSingularResourceNameOneof, requiredSingularResourceNameCommon, requiredSingularFixed32, requiredSingularFixed64, requiredRepeatedInt32, requiredRepeatedInt64, requiredRepeatedFloat, requiredRepeatedDouble, requiredRepeatedBool, requiredRepeatedEnum, requiredRepeatedString, requiredRepeatedBytes, requiredRepeatedMessage, requiredRepeatedResourceName, requiredRepeatedResourceNameOneof, requiredRepeatedResourceNameCommon, requiredRepeatedFixed32, requiredRepeatedFixed64, requiredMap, optionalSingularInt32, optionalSingularInt64, optionalSingularFloat, optionalSingularDouble, optionalSingularBool, optionalSingularEnum, optionalSingularString, optionalSingularBytes, optionalSingularMessage, optionalSingularResourceName, optionalSingularResourceNameOneof, optionalSingularResourceNameCommon, optionalSingularFixed32, optionalSingularFixed64, optionalRepeatedInt32, optionalRepeatedInt64, optionalRepeatedFloat, optionalRepeatedDouble, optionalRepeatedBool, optionalRepeatedEnum, optionalRepeatedString, optionalRepeatedBytes, optionalRepeatedMessage, optionalRepeatedResourceName, optionalRepeatedResourceNameOneof, optionalRepeatedResourceNameCommon, optionalRepeatedFixed32, optionalRepeatedFixed64, optionalMap, anyValue, structValue, valueValue, listValueValue, timeValue, durationValue, fieldMaskValue, int32Value, uint32Value, int64Value, uint64Value, floatValue, doubleValue, stringValue, boolValue, bytesValue, repeatedAnyValue, repeatedStructValue, repeatedValueValue, repeatedListValueValue, repeatedTimeValue, repeatedDurationValue, repeatedFieldMaskValue, repeatedInt32Value, repeatedUint32Value, repeatedInt64Value, repeatedUint64Value, repeatedFloatValue, repeatedDoubleValue, repeatedStringValue, repeatedBoolValue, repeatedBytesValue);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void TestOptionalRequiredFlatteningParams3()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            TestOptionalRequiredFlatteningParamsRequest request = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 72313594,
                RequiredSingularInt64 = 72313499L,
                RequiredSingularFloat = -7514705.0f,
                RequiredSingularDouble = 1.9111005E8,
                RequiredSingularBool = true,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "requiredSingularString-1949894503",
                RequiredSingularBytes = ByteString.CopyFromUtf8("-29"),
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                RequiredSingularResourceNameCommon = "requiredSingularResourceNameCommon-1126805002",
                RequiredSingularFixed32 = 720656715,
                RequiredSingularFixed64 = 720656810,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNameOneofs = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedResourceNameCommon = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
            };
            TestOptionalRequiredFlatteningParamsResponse expectedResponse = new TestOptionalRequiredFlatteningParamsResponse();
            mockGrpcClient.Setup(x => x.TestOptionalRequiredFlatteningParams(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            TestOptionalRequiredFlatteningParamsResponse response = client.TestOptionalRequiredFlatteningParams(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task TestOptionalRequiredFlatteningParamsAsync3()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            TestOptionalRequiredFlatteningParamsRequest request = new TestOptionalRequiredFlatteningParamsRequest
            {
                RequiredSingularInt32 = 72313594,
                RequiredSingularInt64 = 72313499L,
                RequiredSingularFloat = -7514705.0f,
                RequiredSingularDouble = 1.9111005E8,
                RequiredSingularBool = true,
                RequiredSingularEnum = TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero,
                RequiredSingularString = "requiredSingularString-1949894503",
                RequiredSingularBytes = ByteString.CopyFromUtf8("-29"),
                RequiredSingularMessage = new TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage(),
                RequiredSingularResourceNameAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                RequiredSingularResourceNameOneofAsBookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                RequiredSingularResourceNameCommon = "requiredSingularResourceNameCommon-1126805002",
                RequiredSingularFixed32 = 720656715,
                RequiredSingularFixed64 = 720656810,
                RequiredRepeatedInt32 = { },
                RequiredRepeatedInt64 = { },
                RequiredRepeatedFloat = { },
                RequiredRepeatedDouble = { },
                RequiredRepeatedBool = { },
                RequiredRepeatedEnum = { },
                RequiredRepeatedString = { },
                RequiredRepeatedBytes = { },
                RequiredRepeatedMessage = { },
                RequiredRepeatedResourceNameAsBookNameOneofs = { },
                RequiredRepeatedResourceNameOneofAsBookNameOneofs = { },
                RequiredRepeatedResourceNameCommon = { },
                RequiredRepeatedFixed32 = { },
                RequiredRepeatedFixed64 = { },
                RequiredMap = { },
            };
            TestOptionalRequiredFlatteningParamsResponse expectedResponse = new TestOptionalRequiredFlatteningParamsResponse();
            mockGrpcClient.Setup(x => x.TestOptionalRequiredFlatteningParamsAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<TestOptionalRequiredFlatteningParamsResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            TestOptionalRequiredFlatteningParamsResponse response = await client.TestOptionalRequiredFlatteningParamsAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public void PrivateListShelves()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            ListShelvesRequest request = new ListShelvesRequest();
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.PrivateListShelves(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = client.PrivateListShelves(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task PrivateListShelvesAsync()
        {
            Mock<LibraryService.LibraryServiceClient> mockGrpcClient = new Mock<LibraryService.LibraryServiceClient>(MockBehavior.Strict);
            mockGrpcClient.Setup(x => x.CreateLabelerClient())
                .Returns(new Mock<Labeler.LabelerClient>().Object);
            mockGrpcClient.Setup(x => x.CreateOperationsClient())
                .Returns(new Mock<Operations.OperationsClient>().Object);
            ListShelvesRequest request = new ListShelvesRequest();
            Book expectedResponse = new Book
            {
                BookNameOneof = BookNameOneof.From(new BookName("[BOOK_SHELF]", "[BOOK]")),
                Author = "author-1406328437",
                Title = "title110371416",
                Read = true,
            };
            mockGrpcClient.Setup(x => x.PrivateListShelvesAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<Book>(Task.FromResult(expectedResponse), null, null, null, null));
            LibraryServiceClient client = new LibraryServiceClientImpl(mockGrpcClient.Object, null);
            Book response = await client.PrivateListShelvesAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1.Tests/MyProtoClientTest.g.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

namespace Google.Example.Library.V1.Tests
{
    using Google.Api.Gax;
    using Google.Api.Gax.Grpc;
    using apis = Google.Example.Library.V1;
    using Google.Protobuf.WellKnownTypes;
    using Grpc.Core;
    using Moq;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Threading;
    using System.Threading.Tasks;
    using Xunit;

    /// <summary>Generated unit tests</summary>
    public class GeneratedMyProtoClientTest
    {
        [Fact]
        public void MyMethod()
        {
            Mock<MyProto.MyProtoClient> mockGrpcClient = new Mock<MyProto.MyProtoClient>(MockBehavior.Strict);
            MethodRequest request = new MethodRequest();
            MethodResponse expectedResponse = new MethodResponse
            {
                Myfield = "myfield1515208398",
            };
            mockGrpcClient.Setup(x => x.MyMethod(request, It.IsAny<CallOptions>()))
                .Returns(expectedResponse);
            MyProtoClient client = new MyProtoClientImpl(mockGrpcClient.Object, null);
            MethodResponse response = client.MyMethod(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

        [Fact]
        public async Task MyMethodAsync()
        {
            Mock<MyProto.MyProtoClient> mockGrpcClient = new Mock<MyProto.MyProtoClient>(MockBehavior.Strict);
            MethodRequest request = new MethodRequest();
            MethodResponse expectedResponse = new MethodResponse
            {
                Myfield = "myfield1515208398",
            };
            mockGrpcClient.Setup(x => x.MyMethodAsync(request, It.IsAny<CallOptions>()))
                .Returns(new Grpc.Core.AsyncUnaryCall<MethodResponse>(Task.FromResult(expectedResponse), null, null, null, null));
            MyProtoClient client = new MyProtoClientImpl(mockGrpcClient.Object, null);
            MethodResponse response = await client.MyMethodAsync(request);
            Assert.Same(expectedResponse, response);
            mockGrpcClient.VerifyAll();
        }

    }
}

============== file: Google.Example.Library.V1/Google.Example.Library.V1/Google.Example.Library.V1.csproj ==============
<?xml version="1.0" encoding="utf-8"?>
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>

    <!-- TODO: Version defaults to 1.0.0, edit as required -->
    <Version>1.0.0</Version>

    <!-- TODO: NuGet packaging options -->
    <!--
      <Description>
        Google Example Library API
        A simple Google Example Library API.
      </Description>
      <PackageTags>PubSub;Google;Cloud</PackageTags>
      <Copyright>Copyright 2019 Google LLC</Copyright>
      <Authors>Google LLC</Authors>
      *** TODO: These Icon, License, Project, and repo settings *MUST* be checked and edited ***
      *** The values given are just examples ***
      <PackageIconUrl>TODO: https://cloud.google.com/images/gcp-icon-64x64.png</PackageIconUrl>
      <PackageLicenseUrl>TODO: https://www.apache.org/licenses/LICENSE-2.0</PackageLicenseUrl>
      <PackageProjectUrl>TODO: https://github.com/GoogleCloudPlatform/google-cloud-dotnet</PackageProjectUrl>
      <RepositoryType>TODO: git</RepositoryType>
      <RepositoryUrl>TODO: https://github.com/GoogleCloudPlatform/google-cloud-dotnet</RepositoryUrl>
    -->

    <!-- TODO: Configure package signing -->
    <!--
      <AssemblyOriginatorKeyFile>...</AssemblyOriginatorKeyFile>
      <SignAssembly>true</SignAssembly>
      <PublicSign Condition=" '$(OS)' != 'Windows_NT' ">true</PublicSign>
    -->

    <!-- These items should not require editing -->
    <TargetFrameworks>netstandard1.5;net45</TargetFrameworks>
    <TargetFrameworks Condition=" '$(OS)' != 'Windows_NT' ">netstandard1.5</TargetFrameworks>
    <LangVersion>latest</LangVersion>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <Deterministic>true</Deterministic>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>

  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Google.Api.Gax.Grpc" Version="2.1.0" />
    <PackageReference Include="Grpc.Core" Version="1.6.1" />
  </ItemGroup>

</Project>

============== file: Google.Example.Library.V1/Google.Example.Library.V1/LibraryServiceClient.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

using gax = Google.Api.Gax;
using gaxgrpc = Google.Api.Gax.Grpc;
using gctv = Google.Cloud.Tagger.V1;
using lro = Google.LongRunning;
using pb = Google.Protobuf;
using pbwkt = Google.Protobuf.WellKnownTypes;
using gtv = Google.Tagger.V1;
using grpccore = Grpc.Core;
using sys = System;
using sc = System.Collections;
using scg = System.Collections.Generic;
using sco = System.Collections.ObjectModel;
using linq = System.Linq;
using st = System.Threading;
using stt = System.Threading.Tasks;

namespace Google.Example.Library.V1
{
    /// <summary>
    /// Settings for a <see cref="LibraryServiceClient"/>.
    /// </summary>
    public sealed partial class LibraryServiceSettings : gaxgrpc::ServiceSettingsBase
    {
        /// <summary>
        /// Get a new instance of the default <see cref="LibraryServiceSettings"/>.
        /// </summary>
        /// <returns>
        /// A new instance of the default <see cref="LibraryServiceSettings"/>.
        /// </returns>
        public static LibraryServiceSettings GetDefault() => new LibraryServiceSettings();

        /// <summary>
        /// Constructs a new <see cref="LibraryServiceSettings"/> object with default settings.
        /// </summary>
        public LibraryServiceSettings() { }

        private LibraryServiceSettings(LibraryServiceSettings existing) : base(existing)
        {
            gax::GaxPreconditions.CheckNotNull(existing, nameof(existing));
            CreateShelfSettings = existing.CreateShelfSettings;
            GetShelfSettings = existing.GetShelfSettings;
            ListShelvesSettings = existing.ListShelvesSettings;
            DeleteShelfSettings = existing.DeleteShelfSettings;
            MergeShelvesSettings = existing.MergeShelvesSettings;
            CreateBookSettings = existing.CreateBookSettings;
            PublishSeriesSettings = existing.PublishSeriesSettings;
            GetBookSettings = existing.GetBookSettings;
            ListBooksSettings = existing.ListBooksSettings;
            DeleteBookSettings = existing.DeleteBookSettings;
            UpdateBookSettings = existing.UpdateBookSettings;
            MoveBookSettings = existing.MoveBookSettings;
            ListStringsSettings = existing.ListStringsSettings;
            AddCommentsSettings = existing.AddCommentsSettings;
            GetBookFromArchiveSettings = existing.GetBookFromArchiveSettings;
            GetBookFromAnywhereSettings = existing.GetBookFromAnywhereSettings;
            GetBookFromAbsolutelyAnywhereSettings = existing.GetBookFromAbsolutelyAnywhereSettings;
            UpdateBookIndexSettings = existing.UpdateBookIndexSettings;
            StreamShelvesSettings = existing.StreamShelvesSettings;
            StreamBooksSettings = existing.StreamBooksSettings;
            DiscussBookSettings = existing.DiscussBookSettings;
            DiscussBookStreamingSettings = existing.DiscussBookStreamingSettings;
            FindRelatedBooksSettings = existing.FindRelatedBooksSettings;
            AddLabelSettings = existing.AddLabelSettings;
            GetBigBookSettings = existing.GetBigBookSettings;
            GetBigBookOperationsSettings = existing.GetBigBookOperationsSettings?.Clone();
            GetBigNothingSettings = existing.GetBigNothingSettings;
            GetBigNothingOperationsSettings = existing.GetBigNothingOperationsSettings?.Clone();
            TestOptionalRequiredFlatteningParamsSettings = existing.TestOptionalRequiredFlatteningParamsSettings;
            PrivateListShelvesSettings = existing.PrivateListShelvesSettings;
            OnCopy(existing);
        }

        partial void OnCopy(LibraryServiceSettings existing);

        /// <summary>
        /// The filter specifying which RPC <see cref="grpccore::StatusCode"/>s are eligible for retry
        /// for "Idempotent" <see cref="LibraryServiceClient"/> RPC methods.
        /// </summary>
        /// <remarks>
        /// The eligible RPC <see cref="grpccore::StatusCode"/>s for retry for "Idempotent" RPC methods are:
        /// <list type="bullet">
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// </remarks>
        public static sys::Predicate<grpccore::RpcException> IdempotentRetryFilter { get; } =
            gaxgrpc::RetrySettings.FilterForStatusCodes(grpccore::StatusCode.DeadlineExceeded, grpccore::StatusCode.Unavailable);

        /// <summary>
        /// The filter specifying which RPC <see cref="grpccore::StatusCode"/>s are eligible for retry
        /// for "NonIdempotent" <see cref="LibraryServiceClient"/> RPC methods.
        /// </summary>
        /// <remarks>
        /// There are no RPC <see cref="grpccore::StatusCode"/>s eligible for retry for "NonIdempotent" RPC methods.
        /// </remarks>
        public static sys::Predicate<grpccore::RpcException> NonIdempotentRetryFilter { get; } =
            gaxgrpc::RetrySettings.FilterForStatusCodes();

        /// <summary>
        /// "Default" retry backoff for <see cref="LibraryServiceClient"/> RPC methods.
        /// </summary>
        /// <returns>
        /// The "Default" retry backoff for <see cref="LibraryServiceClient"/> RPC methods.
        /// </returns>
        /// <remarks>
        /// The "Default" retry backoff for <see cref="LibraryServiceClient"/> RPC methods is defined as:
        /// <list type="bullet">
        /// <item><description>Initial delay: 100 milliseconds</description></item>
        /// <item><description>Maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Delay multiplier: 1.2</description></item>
        /// </list>
        /// </remarks>
        public static gaxgrpc::BackoffSettings GetDefaultRetryBackoff() => new gaxgrpc::BackoffSettings(
            delay: sys::TimeSpan.FromMilliseconds(100),
            maxDelay: sys::TimeSpan.FromMilliseconds(1000),
            delayMultiplier: 1.2
        );

        /// <summary>
        /// "Default" timeout backoff for <see cref="LibraryServiceClient"/> RPC methods.
        /// </summary>
        /// <returns>
        /// The "Default" timeout backoff for <see cref="LibraryServiceClient"/> RPC methods.
        /// </returns>
        /// <remarks>
        /// The "Default" timeout backoff for <see cref="LibraryServiceClient"/> RPC methods is defined as:
        /// <list type="bullet">
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Maximum timeout: 3000 milliseconds</description></item>
        /// </list>
        /// </remarks>
        public static gaxgrpc::BackoffSettings GetDefaultTimeoutBackoff() => new gaxgrpc::BackoffSettings(
            delay: sys::TimeSpan.FromMilliseconds(300),
            maxDelay: sys::TimeSpan.FromMilliseconds(3000),
            delayMultiplier: 1.3
        );

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.CreateShelf</c> and <c>LibraryServiceClient.CreateShelfAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.CreateShelf</c> and
        /// <c>LibraryServiceClient.CreateShelfAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings CreateShelfSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetShelf</c> and <c>LibraryServiceClient.GetShelfAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetShelf</c> and
        /// <c>LibraryServiceClient.GetShelfAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetShelfSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.ListShelves</c> and <c>LibraryServiceClient.ListShelvesAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.ListShelves</c> and
        /// <c>LibraryServiceClient.ListShelvesAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings ListShelvesSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.DeleteShelf</c> and <c>LibraryServiceClient.DeleteShelfAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.DeleteShelf</c> and
        /// <c>LibraryServiceClient.DeleteShelfAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings DeleteShelfSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.MergeShelves</c> and <c>LibraryServiceClient.MergeShelvesAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.MergeShelves</c> and
        /// <c>LibraryServiceClient.MergeShelvesAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings MergeShelvesSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.CreateBook</c> and <c>LibraryServiceClient.CreateBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.CreateBook</c> and
        /// <c>LibraryServiceClient.CreateBookAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings CreateBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.PublishSeries</c> and <c>LibraryServiceClient.PublishSeriesAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.PublishSeries</c> and
        /// <c>LibraryServiceClient.PublishSeriesAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings PublishSeriesSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBook</c> and <c>LibraryServiceClient.GetBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBook</c> and
        /// <c>LibraryServiceClient.GetBookAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.ListBooks</c> and <c>LibraryServiceClient.ListBooksAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.ListBooks</c> and
        /// <c>LibraryServiceClient.ListBooksAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings ListBooksSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.DeleteBook</c> and <c>LibraryServiceClient.DeleteBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.DeleteBook</c> and
        /// <c>LibraryServiceClient.DeleteBookAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings DeleteBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.UpdateBook</c> and <c>LibraryServiceClient.UpdateBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.UpdateBook</c> and
        /// <c>LibraryServiceClient.UpdateBookAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings UpdateBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.MoveBook</c> and <c>LibraryServiceClient.MoveBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.MoveBook</c> and
        /// <c>LibraryServiceClient.MoveBookAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings MoveBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.ListStrings</c> and <c>LibraryServiceClient.ListStringsAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.ListStrings</c> and
        /// <c>LibraryServiceClient.ListStringsAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings ListStringsSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.AddComments</c> and <c>LibraryServiceClient.AddCommentsAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.AddComments</c> and
        /// <c>LibraryServiceClient.AddCommentsAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings AddCommentsSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBookFromArchive</c> and <c>LibraryServiceClient.GetBookFromArchiveAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBookFromArchive</c> and
        /// <c>LibraryServiceClient.GetBookFromArchiveAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetBookFromArchiveSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBookFromAnywhere</c> and <c>LibraryServiceClient.GetBookFromAnywhereAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBookFromAnywhere</c> and
        /// <c>LibraryServiceClient.GetBookFromAnywhereAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetBookFromAnywhereSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBookFromAbsolutelyAnywhere</c> and <c>LibraryServiceClient.GetBookFromAbsolutelyAnywhereAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBookFromAbsolutelyAnywhere</c> and
        /// <c>LibraryServiceClient.GetBookFromAbsolutelyAnywhereAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetBookFromAbsolutelyAnywhereSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.UpdateBookIndex</c> and <c>LibraryServiceClient.UpdateBookIndexAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.UpdateBookIndex</c> and
        /// <c>LibraryServiceClient.UpdateBookIndexAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings UpdateBookIndexSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for calls to <c>LibraryServiceClient.StreamShelves</c>.
        /// </summary>
        /// <remarks>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings StreamShelvesSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for calls to <c>LibraryServiceClient.StreamBooks</c>.
        /// </summary>
        /// <remarks>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings StreamBooksSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for calls to <c>LibraryServiceClient.DiscussBook</c>.
        /// </summary>
        /// <remarks>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings DiscussBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)));

        /// <summary>
        /// <see cref="gaxgrpc::BidirectionalStreamingSettings"/> for calls to
        /// <c>LibraryServiceClient.DiscussBook</c>.
        /// </summary>
        /// <remarks>
        /// The default local send queue size is 100.
        /// </remarks>
        public gaxgrpc::BidirectionalStreamingSettings DiscussBookStreamingSettings { get; set; } =
            new gaxgrpc::BidirectionalStreamingSettings(100);

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.FindRelatedBooks</c> and <c>LibraryServiceClient.FindRelatedBooksAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.FindRelatedBooks</c> and
        /// <c>LibraryServiceClient.FindRelatedBooksAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings FindRelatedBooksSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.AddLabel</c> and <c>LibraryServiceClient.AddLabelAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.AddLabel</c> and
        /// <c>LibraryServiceClient.AddLabelAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings AddLabelSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBigBook</c> and <c>LibraryServiceClient.GetBigBookAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBigBook</c> and
        /// <c>LibraryServiceClient.GetBigBookAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetBigBookSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// Long Running Operation settings for calls to <c>LibraryServiceClient.GetBigBook</c>.
        /// </summary>
        /// <remarks>
        /// Uses default <see cref="gax::PollSettings"/> of:
        /// <list type="bullet">
        /// <item><description>Initial delay: 3000 milliseconds</description></item>
        /// <item><description>Delay multiplier: 1.3</description></item>
        /// <item><description>Maximum delay: 30000 milliseconds</description></item>
        /// <item><description>Total timeout: 86400000 milliseconds</description></item>
        /// </list>
        /// </remarks>
        public lro::OperationsSettings GetBigBookOperationsSettings { get; set; } = new lro::OperationsSettings
        {
            DefaultPollSettings = new gax::PollSettings(
                gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(86400000L)),
                sys::TimeSpan.FromMilliseconds(3000L),
                1.3,
                sys::TimeSpan.FromMilliseconds(30000L))
        };

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.GetBigNothing</c> and <c>LibraryServiceClient.GetBigNothingAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.GetBigNothing</c> and
        /// <c>LibraryServiceClient.GetBigNothingAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings GetBigNothingSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// Long Running Operation settings for calls to <c>LibraryServiceClient.GetBigNothing</c>.
        /// </summary>
        /// <remarks>
        /// Uses default <see cref="gax::PollSettings"/> of:
        /// <list type="bullet">
        /// <item><description>Initial delay: 3000 milliseconds</description></item>
        /// <item><description>Delay multiplier: 1.3</description></item>
        /// <item><description>Maximum delay: 60000 milliseconds</description></item>
        /// <item><description>Total timeout: 600000 milliseconds</description></item>
        /// </list>
        /// </remarks>
        public lro::OperationsSettings GetBigNothingOperationsSettings { get; set; } = new lro::OperationsSettings
        {
            DefaultPollSettings = new gax::PollSettings(
                gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(600000L)),
                sys::TimeSpan.FromMilliseconds(3000L),
                1.3,
                sys::TimeSpan.FromMilliseconds(60000L))
        };

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.TestOptionalRequiredFlatteningParams</c> and <c>LibraryServiceClient.TestOptionalRequiredFlatteningParamsAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.TestOptionalRequiredFlatteningParams</c> and
        /// <c>LibraryServiceClient.TestOptionalRequiredFlatteningParamsAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings TestOptionalRequiredFlatteningParamsSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>LibraryServiceClient.PrivateListShelves</c> and <c>LibraryServiceClient.PrivateListShelvesAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>LibraryServiceClient.PrivateListShelves</c> and
        /// <c>LibraryServiceClient.PrivateListShelvesAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.2</description></item>
        /// <item><description>Retry maximum delay: 1000 milliseconds</description></item>
        /// <item><description>Initial timeout: 300 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.3</description></item>
        /// <item><description>Timeout maximum delay: 3000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// Default RPC expiration is 30000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings PrivateListShelvesSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(30000)),
                retryFilter: IdempotentRetryFilter
            )));

        /// <summary>
        /// Creates a deep clone of this object, with all the same property values.
        /// </summary>
        /// <returns>A deep clone of this <see cref="LibraryServiceSettings"/> object.</returns>
        public LibraryServiceSettings Clone() => new LibraryServiceSettings(this);
    }

    /// <summary>
    /// LibraryService client wrapper, for convenient use.
    /// </summary>
    public abstract partial class LibraryServiceClient
    {
        /// <summary>
        /// The default endpoint for the LibraryService service, which is a host of "library-example.googleapis.com" and a port of 1234.
        /// </summary>
        public static gaxgrpc::ServiceEndpoint DefaultEndpoint { get; } = new gaxgrpc::ServiceEndpoint("library-example.googleapis.com", 1234);

        /// <summary>
        /// The default LibraryService scopes.
        /// </summary>
        /// <remarks>
        /// The default LibraryService scopes are:
        /// <list type="bullet">
        /// <item><description>"https://www.googleapis.com/auth/cloud-platform"</description></item>
        /// <item><description>"https://www.googleapis.com/auth/library"</description></item>
        /// </list>
        /// </remarks>
        public static scg::IReadOnlyList<string> DefaultScopes { get; } = new sco::ReadOnlyCollection<string>(new string[] {
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/library",
        });

        private static readonly gaxgrpc::ChannelPool s_channelPool = new gaxgrpc::ChannelPool(DefaultScopes);

        /// <summary>
        /// Asynchronously creates a <see cref="LibraryServiceClient"/>, applying defaults for all unspecified settings,
        /// and creating a channel connecting to the given endpoint with application default credentials where
        /// necessary. See the example for how to use custom credentials.
        /// </summary>
        /// <example>
        /// This sample shows how to create a client using default credentials:
        /// <code>
        /// using Google.Example.Library.V1;
        /// ...
        /// // When running on Google Cloud Platform this will use the project Compute Credential.
        /// // Or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to the path of a JSON
        /// // credential file to use that credential.
        /// LibraryServiceClient client = await LibraryServiceClient.CreateAsync();
        /// </code>
        /// This sample shows how to create a client using credentials loaded from a JSON file:
        /// <code>
        /// using Google.Example.Library.V1;
        /// using Google.Apis.Auth.OAuth2;
        /// using Grpc.Auth;
        /// using Grpc.Core;
        /// ...
        /// GoogleCredential cred = GoogleCredential.FromFile("/path/to/credentials.json");
        /// Channel channel = new Channel(
        ///     LibraryServiceClient.DefaultEndpoint.Host, LibraryServiceClient.DefaultEndpoint.Port, cred.ToChannelCredentials());
        /// LibraryServiceClient client = LibraryServiceClient.Create(channel);
        /// ...
        /// // Shutdown the channel when it is no longer required.
        /// await channel.ShutdownAsync();
        /// </code>
        /// </example>
        /// <param name="endpoint">Optional <see cref="gaxgrpc::ServiceEndpoint"/>.</param>
        /// <param name="settings">Optional <see cref="LibraryServiceSettings"/>.</param>
        /// <returns>The task representing the created <see cref="LibraryServiceClient"/>.</returns>
        public static async stt::Task<LibraryServiceClient> CreateAsync(gaxgrpc::ServiceEndpoint endpoint = null, LibraryServiceSettings settings = null)
        {
            grpccore::Channel channel = await s_channelPool.GetChannelAsync(endpoint ?? DefaultEndpoint).ConfigureAwait(false);
            return Create(channel, settings);
        }

        /// <summary>
        /// Synchronously creates a <see cref="LibraryServiceClient"/>, applying defaults for all unspecified settings,
        /// and creating a channel connecting to the given endpoint with application default credentials where
        /// necessary. See the example for how to use custom credentials.
        /// </summary>
        /// <example>
        /// This sample shows how to create a client using default credentials:
        /// <code>
        /// using Google.Example.Library.V1;
        /// ...
        /// // When running on Google Cloud Platform this will use the project Compute Credential.
        /// // Or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to the path of a JSON
        /// // credential file to use that credential.
        /// LibraryServiceClient client = LibraryServiceClient.Create();
        /// </code>
        /// This sample shows how to create a client using credentials loaded from a JSON file:
        /// <code>
        /// using Google.Example.Library.V1;
        /// using Google.Apis.Auth.OAuth2;
        /// using Grpc.Auth;
        /// using Grpc.Core;
        /// ...
        /// GoogleCredential cred = GoogleCredential.FromFile("/path/to/credentials.json");
        /// Channel channel = new Channel(
        ///     LibraryServiceClient.DefaultEndpoint.Host, LibraryServiceClient.DefaultEndpoint.Port, cred.ToChannelCredentials());
        /// LibraryServiceClient client = LibraryServiceClient.Create(channel);
        /// ...
        /// // Shutdown the channel when it is no longer required.
        /// channel.ShutdownAsync().Wait();
        /// </code>
        /// </example>
        /// <param name="endpoint">Optional <see cref="gaxgrpc::ServiceEndpoint"/>.</param>
        /// <param name="settings">Optional <see cref="LibraryServiceSettings"/>.</param>
        /// <returns>The created <see cref="LibraryServiceClient"/>.</returns>
        public static LibraryServiceClient Create(gaxgrpc::ServiceEndpoint endpoint = null, LibraryServiceSettings settings = null)
        {
            grpccore::Channel channel = s_channelPool.GetChannel(endpoint ?? DefaultEndpoint);
            return Create(channel, settings);
        }

        /// <summary>
        /// Creates a <see cref="LibraryServiceClient"/> which uses the specified channel for remote operations.
        /// </summary>
        /// <param name="channel">The <see cref="grpccore::Channel"/> for remote operations. Must not be null.</param>
        /// <param name="settings">Optional <see cref="LibraryServiceSettings"/>.</param>
        /// <returns>The created <see cref="LibraryServiceClient"/>.</returns>
        public static LibraryServiceClient Create(grpccore::Channel channel, LibraryServiceSettings settings = null)
        {
            gax::GaxPreconditions.CheckNotNull(channel, nameof(channel));
            return Create(new grpccore::DefaultCallInvoker(channel), settings);
        }

        /// <summary>
        /// Creates a <see cref="LibraryServiceClient"/> which uses the specified call invoker for remote operations.
        /// </summary>
        /// <param name="callInvoker">The <see cref="grpccore::CallInvoker"/> for remote operations. Must not be null.</param>
        /// <param name="settings">Optional <see cref="LibraryServiceSettings"/>.</param>
        /// <returns>The created <see cref="LibraryServiceClient"/>.</returns>
        public static LibraryServiceClient Create(grpccore::CallInvoker callInvoker, LibraryServiceSettings settings = null)
        {
            gax::GaxPreconditions.CheckNotNull(callInvoker, nameof(callInvoker));
            grpccore::Interceptors.Interceptor interceptor = settings?.Interceptor;
            if (interceptor != null)
            {
                callInvoker = grpccore::Interceptors.CallInvokerExtensions.Intercept(callInvoker, interceptor);
            }
            LibraryService.LibraryServiceClient grpcClient = new LibraryService.LibraryServiceClient(callInvoker);
            return new LibraryServiceClientImpl(grpcClient, settings);
        }

        /// <summary>
        /// Shuts down any channels automatically created by <see cref="Create(gaxgrpc::ServiceEndpoint, LibraryServiceSettings)"/>
        /// and <see cref="CreateAsync(gaxgrpc::ServiceEndpoint, LibraryServiceSettings)"/>. Channels which weren't automatically
        /// created are not affected.
        /// </summary>
        /// <remarks>After calling this method, further calls to <see cref="Create(gaxgrpc::ServiceEndpoint, LibraryServiceSettings)"/>
        /// and <see cref="CreateAsync(gaxgrpc::ServiceEndpoint, LibraryServiceSettings)"/> will create new channels, which could
        /// in turn be shut down by another call to this method.</remarks>
        /// <returns>A task representing the asynchronous shutdown operation.</returns>
        public static stt::Task ShutdownDefaultChannelsAsync() => s_channelPool.ShutdownChannelsAsync();

        /// <summary>
        /// The underlying gRPC LibraryService client.
        /// </summary>
        public virtual LibraryService.LibraryServiceClient GrpcClient
        {
            get { throw new sys::NotImplementedException(); }
        }

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="shelf">
        /// The shelf to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> CreateShelfAsync(
            Shelf shelf,
            gaxgrpc::CallSettings callSettings = null) => CreateShelfAsync(
                new CreateShelfRequest
                {
                    Shelf = gax::GaxPreconditions.CheckNotNull(shelf, nameof(shelf)),
                },
                callSettings);

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="shelf">
        /// The shelf to create.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> CreateShelfAsync(
            Shelf shelf,
            st::CancellationToken cancellationToken) => CreateShelfAsync(
                shelf,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="shelf">
        /// The shelf to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf CreateShelf(
            Shelf shelf,
            gaxgrpc::CallSettings callSettings = null) => CreateShelf(
                new CreateShelfRequest
                {
                    Shelf = gax::GaxPreconditions.CheckNotNull(shelf, nameof(shelf)),
                },
                callSettings);

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> CreateShelfAsync(
            CreateShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> CreateShelfAsync(
            CreateShelfRequest request,
            st::CancellationToken cancellationToken) => CreateShelfAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf CreateShelf(
            CreateShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            ShelfName name,
            gaxgrpc::CallSettings callSettings = null) => GetShelfAsync(
                new GetShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            ShelfName name,
            st::CancellationToken cancellationToken) => GetShelfAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            ShelfName name,
            gaxgrpc::CallSettings callSettings = null) => GetShelf(
                new GetShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetShelfAsync(
                new GetShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            string name,
            st::CancellationToken cancellationToken) => GetShelfAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetShelf(
                new GetShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            ShelfName name,
            SomeMessage message,
            gaxgrpc::CallSettings callSettings = null) => GetShelfAsync(
                new GetShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Message = message, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            ShelfName name,
            SomeMessage message,
            st::CancellationToken cancellationToken) => GetShelfAsync(
                name,
                message,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            ShelfName name,
            SomeMessage message,
            gaxgrpc::CallSettings callSettings = null) => GetShelf(
                new GetShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Message = message, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            string name,
            SomeMessage message,
            gaxgrpc::CallSettings callSettings = null) => GetShelfAsync(
                new GetShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Message = message, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            string name,
            SomeMessage message,
            st::CancellationToken cancellationToken) => GetShelfAsync(
                name,
                message,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            string name,
            SomeMessage message,
            gaxgrpc::CallSettings callSettings = null) => GetShelf(
                new GetShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Message = message, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="stringBuilder">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            ShelfName name,
            SomeMessage message,
            StringBuilder stringBuilder,
            gaxgrpc::CallSettings callSettings = null) => GetShelfAsync(
                new GetShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Message = message, // Optional
                    StringBuilder = stringBuilder, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="stringBuilder">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            ShelfName name,
            SomeMessage message,
            StringBuilder stringBuilder,
            st::CancellationToken cancellationToken) => GetShelfAsync(
                name,
                message,
                stringBuilder,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="stringBuilder">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            ShelfName name,
            SomeMessage message,
            StringBuilder stringBuilder,
            gaxgrpc::CallSettings callSettings = null) => GetShelf(
                new GetShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Message = message, // Optional
                    StringBuilder = stringBuilder, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="stringBuilder">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            string name,
            SomeMessage message,
            StringBuilder stringBuilder,
            gaxgrpc::CallSettings callSettings = null) => GetShelfAsync(
                new GetShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Message = message, // Optional
                    StringBuilder = stringBuilder, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="stringBuilder">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            string name,
            SomeMessage message,
            StringBuilder stringBuilder,
            st::CancellationToken cancellationToken) => GetShelfAsync(
                name,
                message,
                stringBuilder,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to retrieve.
        /// </param>
        /// <param name="message">
        /// Field to verify that message-type query parameter gets flattened.
        /// </param>
        /// <param name="stringBuilder">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            string name,
            SomeMessage message,
            StringBuilder stringBuilder,
            gaxgrpc::CallSettings callSettings = null) => GetShelf(
                new GetShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Message = message, // Optional
                    StringBuilder = stringBuilder, // Optional
                },
                callSettings);

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            GetShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> GetShelfAsync(
            GetShelfRequest request,
            st::CancellationToken cancellationToken) => GetShelfAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf GetShelf(
            GetShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListShelvesResponse, Shelf> ListShelvesAsync(
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListShelvesAsync(
                new ListShelvesRequest
                {
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListShelvesResponse, Shelf> ListShelves(
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListShelves(
                new ListShelvesRequest
                {
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListShelvesResponse, Shelf> ListShelvesAsync(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListShelvesResponse, Shelf> ListShelves(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteShelfAsync(
            ShelfName name,
            gaxgrpc::CallSettings callSettings = null) => DeleteShelfAsync(
                new DeleteShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to delete.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteShelfAsync(
            ShelfName name,
            st::CancellationToken cancellationToken) => DeleteShelfAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void DeleteShelf(
            ShelfName name,
            gaxgrpc::CallSettings callSettings = null) => DeleteShelf(
                new DeleteShelfRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteShelfAsync(
            string name,
            gaxgrpc::CallSettings callSettings = null) => DeleteShelfAsync(
                new DeleteShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to delete.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteShelfAsync(
            string name,
            st::CancellationToken cancellationToken) => DeleteShelfAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void DeleteShelf(
            string name,
            gaxgrpc::CallSettings callSettings = null) => DeleteShelf(
                new DeleteShelfRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteShelfAsync(
            DeleteShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteShelfAsync(
            DeleteShelfRequest request,
            st::CancellationToken cancellationToken) => DeleteShelfAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void DeleteShelf(
            DeleteShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf we're adding books to.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the shelf we're removing books from and deleting.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> MergeShelvesAsync(
            ShelfName name,
            ShelfName otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MergeShelvesAsync(
                new MergeShelvesRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OtherShelfNameAsShelfName = gax::GaxPreconditions.CheckNotNull(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf we're adding books to.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the shelf we're removing books from and deleting.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> MergeShelvesAsync(
            ShelfName name,
            ShelfName otherShelfName,
            st::CancellationToken cancellationToken) => MergeShelvesAsync(
                name,
                otherShelfName,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf we're adding books to.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the shelf we're removing books from and deleting.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf MergeShelves(
            ShelfName name,
            ShelfName otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MergeShelves(
                new MergeShelvesRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OtherShelfNameAsShelfName = gax::GaxPreconditions.CheckNotNull(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf we're adding books to.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the shelf we're removing books from and deleting.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> MergeShelvesAsync(
            string name,
            string otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MergeShelvesAsync(
                new MergeShelvesRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    OtherShelfName = gax::GaxPreconditions.CheckNotNullOrEmpty(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf we're adding books to.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the shelf we're removing books from and deleting.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> MergeShelvesAsync(
            string name,
            string otherShelfName,
            st::CancellationToken cancellationToken) => MergeShelvesAsync(
                name,
                otherShelfName,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf we're adding books to.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the shelf we're removing books from and deleting.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf MergeShelves(
            string name,
            string otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MergeShelves(
                new MergeShelvesRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    OtherShelfName = gax::GaxPreconditions.CheckNotNullOrEmpty(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> MergeShelvesAsync(
            MergeShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Shelf> MergeShelvesAsync(
            MergeShelvesRequest request,
            st::CancellationToken cancellationToken) => MergeShelvesAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Shelf MergeShelves(
            MergeShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf in which the book is created.
        /// </param>
        /// <param name="book">
        /// The book to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> CreateBookAsync(
            ShelfName name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => CreateBookAsync(
                new CreateBookRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf in which the book is created.
        /// </param>
        /// <param name="book">
        /// The book to create.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> CreateBookAsync(
            ShelfName name,
            Book book,
            st::CancellationToken cancellationToken) => CreateBookAsync(
                name,
                book,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf in which the book is created.
        /// </param>
        /// <param name="book">
        /// The book to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book CreateBook(
            ShelfName name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => CreateBook(
                new CreateBookRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf in which the book is created.
        /// </param>
        /// <param name="book">
        /// The book to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> CreateBookAsync(
            string name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => CreateBookAsync(
                new CreateBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf in which the book is created.
        /// </param>
        /// <param name="book">
        /// The book to create.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> CreateBookAsync(
            string name,
            Book book,
            st::CancellationToken cancellationToken) => CreateBookAsync(
                name,
                book,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf in which the book is created.
        /// </param>
        /// <param name="book">
        /// The book to create.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book CreateBook(
            string name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => CreateBook(
                new CreateBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> CreateBookAsync(
            CreateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> CreateBookAsync(
            CreateBookRequest request,
            st::CancellationToken cancellationToken) => CreateBookAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book CreateBook(
            CreateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="shelf">
        /// The shelf in which the series is created.
        /// </param>
        /// <param name="books">
        /// The books to publish in the series.
        /// </param>
        /// <param name="edition">
        /// The edition of the series
        /// </param>
        /// <param name="seriesUuid">
        /// Uniquely identifies the series to the publishing house.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<PublishSeriesResponse> PublishSeriesAsync(
            Shelf shelf,
            scg::IEnumerable<Book> books,
            uint? edition,
            SeriesUuid seriesUuid,
            gaxgrpc::CallSettings callSettings = null) => PublishSeriesAsync(
                new PublishSeriesRequest
                {
                    Shelf = gax::GaxPreconditions.CheckNotNull(shelf, nameof(shelf)),
                    Books = { gax::GaxPreconditions.CheckNotNull(books, nameof(books)) },
                    Edition = edition ?? 0, // Optional
                    SeriesUuid = gax::GaxPreconditions.CheckNotNull(seriesUuid, nameof(seriesUuid)),
                },
                callSettings);

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="shelf">
        /// The shelf in which the series is created.
        /// </param>
        /// <param name="books">
        /// The books to publish in the series.
        /// </param>
        /// <param name="edition">
        /// The edition of the series
        /// </param>
        /// <param name="seriesUuid">
        /// Uniquely identifies the series to the publishing house.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<PublishSeriesResponse> PublishSeriesAsync(
            Shelf shelf,
            scg::IEnumerable<Book> books,
            uint? edition,
            SeriesUuid seriesUuid,
            st::CancellationToken cancellationToken) => PublishSeriesAsync(
                shelf,
                books,
                edition,
                seriesUuid,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="shelf">
        /// The shelf in which the series is created.
        /// </param>
        /// <param name="books">
        /// The books to publish in the series.
        /// </param>
        /// <param name="edition">
        /// The edition of the series
        /// </param>
        /// <param name="seriesUuid">
        /// Uniquely identifies the series to the publishing house.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual PublishSeriesResponse PublishSeries(
            Shelf shelf,
            scg::IEnumerable<Book> books,
            uint? edition,
            SeriesUuid seriesUuid,
            gaxgrpc::CallSettings callSettings = null) => PublishSeries(
                new PublishSeriesRequest
                {
                    Shelf = gax::GaxPreconditions.CheckNotNull(shelf, nameof(shelf)),
                    Books = { gax::GaxPreconditions.CheckNotNull(books, nameof(books)) },
                    Edition = edition ?? 0, // Optional
                    SeriesUuid = gax::GaxPreconditions.CheckNotNull(seriesUuid, nameof(seriesUuid)),
                },
                callSettings);

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<PublishSeriesResponse> PublishSeriesAsync(
            PublishSeriesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<PublishSeriesResponse> PublishSeriesAsync(
            PublishSeriesRequest request,
            st::CancellationToken cancellationToken) => PublishSeriesAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual PublishSeriesResponse PublishSeries(
            PublishSeriesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> GetBookAsync(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => GetBookAsync(
                new GetBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> GetBookAsync(
            BookNameOneof name,
            st::CancellationToken cancellationToken) => GetBookAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book GetBook(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => GetBook(
                new GetBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> GetBookAsync(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetBookAsync(
                new GetBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> GetBookAsync(
            string name,
            st::CancellationToken cancellationToken) => GetBookAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book GetBook(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetBook(
                new GetBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> GetBookAsync(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> GetBookAsync(
            GetBookRequest request,
            st::CancellationToken cancellationToken) => GetBookAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book GetBook(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf whose books we'd like to list.
        /// </param>
        /// <param name="filter">
        /// To test python built-in wrapping.
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListBooksResponse, Book> ListBooksAsync(
            ShelfName name,
            string filter,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListBooksAsync(
                new ListBooksRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Filter = filter ?? "", // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf whose books we'd like to list.
        /// </param>
        /// <param name="filter">
        /// To test python built-in wrapping.
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListBooksResponse, Book> ListBooks(
            ShelfName name,
            string filter,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListBooks(
                new ListBooksRequest
                {
                    ShelfName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Filter = filter ?? "", // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf whose books we'd like to list.
        /// </param>
        /// <param name="filter">
        /// To test python built-in wrapping.
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListBooksResponse, Book> ListBooksAsync(
            string name,
            string filter,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListBooksAsync(
                new ListBooksRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Filter = filter ?? "", // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf whose books we'd like to list.
        /// </param>
        /// <param name="filter">
        /// To test python built-in wrapping.
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListBooksResponse, Book> ListBooks(
            string name,
            string filter,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListBooks(
                new ListBooksRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Filter = filter ?? "", // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListBooksResponse, Book> ListBooksAsync(
            ListBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Book"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListBooksResponse, Book> ListBooks(
            ListBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteBookAsync(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => DeleteBookAsync(
                new DeleteBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to delete.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteBookAsync(
            BookNameOneof name,
            st::CancellationToken cancellationToken) => DeleteBookAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void DeleteBook(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => DeleteBook(
                new DeleteBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteBookAsync(
            string name,
            gaxgrpc::CallSettings callSettings = null) => DeleteBookAsync(
                new DeleteBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to delete.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteBookAsync(
            string name,
            st::CancellationToken cancellationToken) => DeleteBookAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to delete.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void DeleteBook(
            string name,
            gaxgrpc::CallSettings callSettings = null) => DeleteBook(
                new DeleteBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteBookAsync(
            DeleteBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task DeleteBookAsync(
            DeleteBookRequest request,
            st::CancellationToken cancellationToken) => DeleteBookAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void DeleteBook(
            DeleteBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            BookNameOneof name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookAsync(
                new UpdateBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            BookNameOneof name,
            Book book,
            st::CancellationToken cancellationToken) => UpdateBookAsync(
                name,
                book,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book UpdateBook(
            BookNameOneof name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => UpdateBook(
                new UpdateBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            string name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookAsync(
                new UpdateBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            string name,
            Book book,
            st::CancellationToken cancellationToken) => UpdateBookAsync(
                name,
                book,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book UpdateBook(
            string name,
            Book book,
            gaxgrpc::CallSettings callSettings = null) => UpdateBook(
                new UpdateBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="optionalFoo">
        /// An optional foo.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="updateMask">
        /// A field mask to apply, rendered as an HTTP parameter.
        /// </param>
        /// <param name="physicalMask">
        /// To test Python import clash resolution.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            BookNameOneof name,
            string optionalFoo,
            Book book,
            pbwkt::FieldMask updateMask,
            FieldMask physicalMask,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookAsync(
                new UpdateBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OptionalFoo = optionalFoo ?? "", // Optional
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                    UpdateMask = updateMask, // Optional
                    PhysicalMask = physicalMask, // Optional
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="optionalFoo">
        /// An optional foo.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="updateMask">
        /// A field mask to apply, rendered as an HTTP parameter.
        /// </param>
        /// <param name="physicalMask">
        /// To test Python import clash resolution.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            BookNameOneof name,
            string optionalFoo,
            Book book,
            pbwkt::FieldMask updateMask,
            FieldMask physicalMask,
            st::CancellationToken cancellationToken) => UpdateBookAsync(
                name,
                optionalFoo,
                book,
                updateMask,
                physicalMask,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="optionalFoo">
        /// An optional foo.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="updateMask">
        /// A field mask to apply, rendered as an HTTP parameter.
        /// </param>
        /// <param name="physicalMask">
        /// To test Python import clash resolution.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book UpdateBook(
            BookNameOneof name,
            string optionalFoo,
            Book book,
            pbwkt::FieldMask updateMask,
            FieldMask physicalMask,
            gaxgrpc::CallSettings callSettings = null) => UpdateBook(
                new UpdateBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OptionalFoo = optionalFoo ?? "", // Optional
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                    UpdateMask = updateMask, // Optional
                    PhysicalMask = physicalMask, // Optional
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="optionalFoo">
        /// An optional foo.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="updateMask">
        /// A field mask to apply, rendered as an HTTP parameter.
        /// </param>
        /// <param name="physicalMask">
        /// To test Python import clash resolution.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            string name,
            string optionalFoo,
            Book book,
            pbwkt::FieldMask updateMask,
            FieldMask physicalMask,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookAsync(
                new UpdateBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    OptionalFoo = optionalFoo ?? "", // Optional
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                    UpdateMask = updateMask, // Optional
                    PhysicalMask = physicalMask, // Optional
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="optionalFoo">
        /// An optional foo.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="updateMask">
        /// A field mask to apply, rendered as an HTTP parameter.
        /// </param>
        /// <param name="physicalMask">
        /// To test Python import clash resolution.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            string name,
            string optionalFoo,
            Book book,
            pbwkt::FieldMask updateMask,
            FieldMask physicalMask,
            st::CancellationToken cancellationToken) => UpdateBookAsync(
                name,
                optionalFoo,
                book,
                updateMask,
                physicalMask,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="optionalFoo">
        /// An optional foo.
        /// </param>
        /// <param name="book">
        /// The book to update with.
        /// </param>
        /// <param name="updateMask">
        /// A field mask to apply, rendered as an HTTP parameter.
        /// </param>
        /// <param name="physicalMask">
        /// To test Python import clash resolution.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book UpdateBook(
            string name,
            string optionalFoo,
            Book book,
            pbwkt::FieldMask updateMask,
            FieldMask physicalMask,
            gaxgrpc::CallSettings callSettings = null) => UpdateBook(
                new UpdateBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    OptionalFoo = optionalFoo ?? "", // Optional
                    Book = gax::GaxPreconditions.CheckNotNull(book, nameof(book)),
                    UpdateMask = updateMask, // Optional
                    PhysicalMask = physicalMask, // Optional
                },
                callSettings);

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            UpdateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> UpdateBookAsync(
            UpdateBookRequest request,
            st::CancellationToken cancellationToken) => UpdateBookAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book UpdateBook(
            UpdateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to move.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the destination shelf.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> MoveBookAsync(
            BookNameOneof name,
            ShelfName otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MoveBookAsync(
                new MoveBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OtherShelfNameAsShelfName = gax::GaxPreconditions.CheckNotNull(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to move.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the destination shelf.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> MoveBookAsync(
            BookNameOneof name,
            ShelfName otherShelfName,
            st::CancellationToken cancellationToken) => MoveBookAsync(
                name,
                otherShelfName,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to move.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the destination shelf.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book MoveBook(
            BookNameOneof name,
            ShelfName otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MoveBook(
                new MoveBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    OtherShelfNameAsShelfName = gax::GaxPreconditions.CheckNotNull(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to move.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the destination shelf.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> MoveBookAsync(
            string name,
            string otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MoveBookAsync(
                new MoveBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    OtherShelfName = gax::GaxPreconditions.CheckNotNullOrEmpty(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to move.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the destination shelf.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> MoveBookAsync(
            string name,
            string otherShelfName,
            st::CancellationToken cancellationToken) => MoveBookAsync(
                name,
                otherShelfName,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to move.
        /// </param>
        /// <param name="otherShelfName">
        /// The name of the destination shelf.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book MoveBook(
            string name,
            string otherShelfName,
            gaxgrpc::CallSettings callSettings = null) => MoveBook(
                new MoveBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    OtherShelfName = gax::GaxPreconditions.CheckNotNullOrEmpty(otherShelfName, nameof(otherShelfName)),
                },
                callSettings);

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> MoveBookAsync(
            MoveBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> MoveBookAsync(
            MoveBookRequest request,
            st::CancellationToken cancellationToken) => MoveBookAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book MoveBook(
            MoveBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListStringsResponse, IResourceName> ListStringsAsync(
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListStringsAsync(
                new ListStringsRequest
                {
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListStringsResponse, IResourceName> ListStrings(
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListStrings(
                new ListStringsRequest
                {
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListStringsResponse, IResourceName> ListStringsAsync(
            IResourceName name,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListStringsAsync(
                new ListStringsRequest
                {
                    AsResourceName = name, // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListStringsResponse, IResourceName> ListStrings(
            IResourceName name,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListStrings(
                new ListStringsRequest
                {
                    AsResourceName = name, // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListStringsResponse, IResourceName> ListStringsAsync(
            string name,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListStringsAsync(
                new ListStringsRequest
                {
                    Name = name ?? "", // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListStringsResponse, IResourceName> ListStrings(
            string name,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => ListStrings(
                new ListStringsRequest
                {
                    Name = name ?? "", // Optional
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<ListStringsResponse, IResourceName> ListStringsAsync(
            ListStringsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<ListStringsResponse, IResourceName> ListStrings(
            ListStringsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="comments">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task AddCommentsAsync(
            BookNameOneof name,
            scg::IEnumerable<Comment> comments,
            gaxgrpc::CallSettings callSettings = null) => AddCommentsAsync(
                new AddCommentsRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Comments = { gax::GaxPreconditions.CheckNotNull(comments, nameof(comments)) },
                },
                callSettings);

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="comments">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task AddCommentsAsync(
            BookNameOneof name,
            scg::IEnumerable<Comment> comments,
            st::CancellationToken cancellationToken) => AddCommentsAsync(
                name,
                comments,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="comments">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void AddComments(
            BookNameOneof name,
            scg::IEnumerable<Comment> comments,
            gaxgrpc::CallSettings callSettings = null) => AddComments(
                new AddCommentsRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    Comments = { gax::GaxPreconditions.CheckNotNull(comments, nameof(comments)) },
                },
                callSettings);

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="comments">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task AddCommentsAsync(
            string name,
            scg::IEnumerable<Comment> comments,
            gaxgrpc::CallSettings callSettings = null) => AddCommentsAsync(
                new AddCommentsRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Comments = { gax::GaxPreconditions.CheckNotNull(comments, nameof(comments)) },
                },
                callSettings);

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="comments">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task AddCommentsAsync(
            string name,
            scg::IEnumerable<Comment> comments,
            st::CancellationToken cancellationToken) => AddCommentsAsync(
                name,
                comments,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="name">
        ///
        /// </param>
        /// <param name="comments">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void AddComments(
            string name,
            scg::IEnumerable<Comment> comments,
            gaxgrpc::CallSettings callSettings = null) => AddComments(
                new AddCommentsRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    Comments = { gax::GaxPreconditions.CheckNotNull(comments, nameof(comments)) },
                },
                callSettings);

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task AddCommentsAsync(
            AddCommentsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task AddCommentsAsync(
            AddCommentsRequest request,
            st::CancellationToken cancellationToken) => AddCommentsAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void AddComments(
            AddCommentsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromArchive> GetBookFromArchiveAsync(
            ArchivedBookName name,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromArchiveAsync(
                new GetBookFromArchiveRequest
                {
                    ArchivedBookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromArchive> GetBookFromArchiveAsync(
            ArchivedBookName name,
            st::CancellationToken cancellationToken) => GetBookFromArchiveAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromArchive GetBookFromArchive(
            ArchivedBookName name,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromArchive(
                new GetBookFromArchiveRequest
                {
                    ArchivedBookName = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromArchive> GetBookFromArchiveAsync(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromArchiveAsync(
                new GetBookFromArchiveRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromArchive> GetBookFromArchiveAsync(
            string name,
            st::CancellationToken cancellationToken) => GetBookFromArchiveAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromArchive GetBookFromArchive(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromArchive(
                new GetBookFromArchiveRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromArchive> GetBookFromArchiveAsync(
            GetBookFromArchiveRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromArchive> GetBookFromArchiveAsync(
            GetBookFromArchiveRequest request,
            st::CancellationToken cancellationToken) => GetBookFromArchiveAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromArchive GetBookFromArchive(
            GetBookFromArchiveRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="altBookName">
        /// An alternate book name, used to test restricting flattened field to a
        /// single resource name type in a oneof.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            BookNameOneof name,
            BookNameOneof altBookName,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAnywhereAsync(
                new GetBookFromAnywhereRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    AltBookNameAsBookNameOneof = gax::GaxPreconditions.CheckNotNull(altBookName, nameof(altBookName)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="altBookName">
        /// An alternate book name, used to test restricting flattened field to a
        /// single resource name type in a oneof.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            BookNameOneof name,
            BookNameOneof altBookName,
            st::CancellationToken cancellationToken) => GetBookFromAnywhereAsync(
                name,
                altBookName,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="altBookName">
        /// An alternate book name, used to test restricting flattened field to a
        /// single resource name type in a oneof.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAnywhere(
            BookNameOneof name,
            BookNameOneof altBookName,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAnywhere(
                new GetBookFromAnywhereRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    AltBookNameAsBookNameOneof = gax::GaxPreconditions.CheckNotNull(altBookName, nameof(altBookName)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="altBookName">
        /// An alternate book name, used to test restricting flattened field to a
        /// single resource name type in a oneof.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            string name,
            string altBookName,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAnywhereAsync(
                new GetBookFromAnywhereRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    AltBookName = gax::GaxPreconditions.CheckNotNullOrEmpty(altBookName, nameof(altBookName)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="altBookName">
        /// An alternate book name, used to test restricting flattened field to a
        /// single resource name type in a oneof.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            string name,
            string altBookName,
            st::CancellationToken cancellationToken) => GetBookFromAnywhereAsync(
                name,
                altBookName,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="altBookName">
        /// An alternate book name, used to test restricting flattened field to a
        /// single resource name type in a oneof.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAnywhere(
            string name,
            string altBookName,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAnywhere(
                new GetBookFromAnywhereRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    AltBookName = gax::GaxPreconditions.CheckNotNullOrEmpty(altBookName, nameof(altBookName)),
                },
                callSettings);

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            GetBookFromAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            GetBookFromAnywhereRequest request,
            st::CancellationToken cancellationToken) => GetBookFromAnywhereAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAnywhere(
            GetBookFromAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAbsolutelyAnywhereAsync(
                new GetBookFromAbsolutelyAnywhereRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            BookNameOneof name,
            st::CancellationToken cancellationToken) => GetBookFromAbsolutelyAnywhereAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAbsolutelyAnywhere(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAbsolutelyAnywhere(
                new GetBookFromAbsolutelyAnywhereRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAbsolutelyAnywhereAsync(
                new GetBookFromAbsolutelyAnywhereRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            string name,
            st::CancellationToken cancellationToken) => GetBookFromAbsolutelyAnywhereAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAbsolutelyAnywhere(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetBookFromAbsolutelyAnywhere(
                new GetBookFromAbsolutelyAnywhereRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            GetBookFromAbsolutelyAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            GetBookFromAbsolutelyAnywhereRequest request,
            st::CancellationToken cancellationToken) => GetBookFromAbsolutelyAnywhereAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual BookFromAnywhere GetBookFromAbsolutelyAnywhere(
            GetBookFromAbsolutelyAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="indexName">
        /// The name of the index for the book
        /// </param>
        /// <param name="indexMap">
        /// The index to update the book with
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task UpdateBookIndexAsync(
            BookNameOneof name,
            string indexName,
            scg::IDictionary<string, string> indexMap,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookIndexAsync(
                new UpdateBookIndexRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    IndexName = gax::GaxPreconditions.CheckNotNullOrEmpty(indexName, nameof(indexName)),
                    IndexMap = { gax::GaxPreconditions.CheckNotNull(indexMap, nameof(indexMap)) },
                },
                callSettings);

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="indexName">
        /// The name of the index for the book
        /// </param>
        /// <param name="indexMap">
        /// The index to update the book with
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task UpdateBookIndexAsync(
            BookNameOneof name,
            string indexName,
            scg::IDictionary<string, string> indexMap,
            st::CancellationToken cancellationToken) => UpdateBookIndexAsync(
                name,
                indexName,
                indexMap,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="indexName">
        /// The name of the index for the book
        /// </param>
        /// <param name="indexMap">
        /// The index to update the book with
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void UpdateBookIndex(
            BookNameOneof name,
            string indexName,
            scg::IDictionary<string, string> indexMap,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookIndex(
                new UpdateBookIndexRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                    IndexName = gax::GaxPreconditions.CheckNotNullOrEmpty(indexName, nameof(indexName)),
                    IndexMap = { gax::GaxPreconditions.CheckNotNull(indexMap, nameof(indexMap)) },
                },
                callSettings);

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="indexName">
        /// The name of the index for the book
        /// </param>
        /// <param name="indexMap">
        /// The index to update the book with
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task UpdateBookIndexAsync(
            string name,
            string indexName,
            scg::IDictionary<string, string> indexMap,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookIndexAsync(
                new UpdateBookIndexRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    IndexName = gax::GaxPreconditions.CheckNotNullOrEmpty(indexName, nameof(indexName)),
                    IndexMap = { gax::GaxPreconditions.CheckNotNull(indexMap, nameof(indexMap)) },
                },
                callSettings);

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="indexName">
        /// The name of the index for the book
        /// </param>
        /// <param name="indexMap">
        /// The index to update the book with
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task UpdateBookIndexAsync(
            string name,
            string indexName,
            scg::IDictionary<string, string> indexMap,
            st::CancellationToken cancellationToken) => UpdateBookIndexAsync(
                name,
                indexName,
                indexMap,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="name">
        /// The name of the book to update.
        /// </param>
        /// <param name="indexName">
        /// The name of the index for the book
        /// </param>
        /// <param name="indexMap">
        /// The index to update the book with
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void UpdateBookIndex(
            string name,
            string indexName,
            scg::IDictionary<string, string> indexMap,
            gaxgrpc::CallSettings callSettings = null) => UpdateBookIndex(
                new UpdateBookIndexRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                    IndexName = gax::GaxPreconditions.CheckNotNullOrEmpty(indexName, nameof(indexName)),
                    IndexMap = { gax::GaxPreconditions.CheckNotNull(indexMap, nameof(indexMap)) },
                },
                callSettings);

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task UpdateBookIndexAsync(
            UpdateBookIndexRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public virtual stt::Task UpdateBookIndexAsync(
            UpdateBookIndexRequest request,
            st::CancellationToken cancellationToken) => UpdateBookIndexAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public virtual void UpdateBookIndex(
            UpdateBookIndexRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Test server streaming
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The server stream.
        /// </returns>
        public virtual StreamShelvesStream StreamShelves(
            StreamShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Server streaming methods for <c>StreamShelves</c>.
        /// </summary>
        public abstract partial class StreamShelvesStream : gaxgrpc::ServerStreamingBase<StreamShelvesResponse>
        {
        }

        /// <summary>
        /// Test server streaming, non-paged responses.
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="name">
        /// The name of the shelf whose books we'd like to list.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The server stream.
        /// </returns>
        public virtual StreamBooksStream StreamBooks(
            string name,
            gaxgrpc::CallSettings callSettings = null) => StreamBooks(
                new StreamBooksRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test server streaming, non-paged responses.
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The server stream.
        /// </returns>
        public virtual StreamBooksStream StreamBooks(
            StreamBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Server streaming methods for <c>StreamBooks</c>.
        /// </summary>
        public abstract partial class StreamBooksStream : gaxgrpc::ServerStreamingBase<Book>
        {
        }

        /// <summary>
        /// Test bidi-streaming.
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The client-server stream.
        /// </returns>
        *** ERROR: Cannot handle streaming type 'BidiStreaming' ***

        /// <summary>
        /// Test bidi-streaming.
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The client-server stream.
        /// </returns>
        *** ERROR: Cannot handle streaming type 'BidiStreaming' ***

        /// <summary>
        /// Test bidi-streaming.
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <param name="streamingSettings">
        /// If not null, applies streaming overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The client-server stream.
        /// </returns>
        public virtual DiscussBookStream DiscussBook(
            gaxgrpc::CallSettings callSettings = null,
            gaxgrpc::BidirectionalStreamingSettings streamingSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Bidirectional streaming methods for <c>DiscussBook</c>.
        /// </summary>
        public abstract partial class DiscussBookStream : gaxgrpc::BidirectionalStreamingBase<DiscussBookRequest, Comment>
        {
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="names">
        ///
        /// </param>
        /// <param name="shelves">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> FindRelatedBooksAsync(
            scg::IEnumerable<BookNameOneof> names,
            scg::IEnumerable<ShelfName> shelves,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => FindRelatedBooksAsync(
                new FindRelatedBooksRequest
                {
                    BookNameOneofs = { gax::GaxPreconditions.CheckNotNull(names, nameof(names)) },
                    ShelvesAsShelfNames = { gax::GaxPreconditions.CheckNotNull(shelves, nameof(shelves)) },
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="names">
        ///
        /// </param>
        /// <param name="shelves">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> FindRelatedBooks(
            scg::IEnumerable<BookNameOneof> names,
            scg::IEnumerable<ShelfName> shelves,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => FindRelatedBooks(
                new FindRelatedBooksRequest
                {
                    BookNameOneofs = { gax::GaxPreconditions.CheckNotNull(names, nameof(names)) },
                    ShelvesAsShelfNames = { gax::GaxPreconditions.CheckNotNull(shelves, nameof(shelves)) },
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="names">
        ///
        /// </param>
        /// <param name="shelves">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> FindRelatedBooksAsync(
            scg::IEnumerable<string> names,
            scg::IEnumerable<string> shelves,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => FindRelatedBooksAsync(
                new FindRelatedBooksRequest
                {
                    Names = { gax::GaxPreconditions.CheckNotNull(names, nameof(names)) },
                    Shelves = { gax::GaxPreconditions.CheckNotNull(shelves, nameof(shelves)) },
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="names">
        ///
        /// </param>
        /// <param name="shelves">
        ///
        /// </param>
        /// <param name="pageToken">
        /// The token returned from the previous request.
        /// A value of <c>null</c> or an empty string retrieves the first page.
        /// </param>
        /// <param name="pageSize">
        /// The size of page to request. The response will not be larger than this, but may be smaller.
        /// A value of <c>null</c> or 0 uses a server-defined page size.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> FindRelatedBooks(
            scg::IEnumerable<string> names,
            scg::IEnumerable<string> shelves,
            string pageToken = null,
            int? pageSize = null,
            gaxgrpc::CallSettings callSettings = null) => FindRelatedBooks(
                new FindRelatedBooksRequest
                {
                    Names = { gax::GaxPreconditions.CheckNotNull(names, nameof(names)) },
                    Shelves = { gax::GaxPreconditions.CheckNotNull(shelves, nameof(shelves)) },
                    PageToken = pageToken ?? "",
                    PageSize = pageSize ?? 0,
                },
                callSettings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> FindRelatedBooksAsync(
            FindRelatedBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public virtual gax::PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> FindRelatedBooks(
            FindRelatedBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<gtv::AddLabelResponse> AddLabelAsync(
            gtv::AddLabelRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<gtv::AddLabelResponse> AddLabelAsync(
            gtv::AddLabelRequest request,
            st::CancellationToken cancellationToken) => AddLabelAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual gtv::AddLabelResponse AddLabel(
            gtv::AddLabelRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => GetBigBookAsync(
                new GetBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            BookNameOneof name,
            st::CancellationToken cancellationToken) => GetBigBookAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<Book, GetBigBookMetadata> GetBigBook(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => GetBigBook(
                new GetBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetBigBookAsync(
                new GetBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            string name,
            st::CancellationToken cancellationToken) => GetBigBookAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<Book, GetBigBookMetadata> GetBigBook(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetBigBook(
                new GetBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Asynchronously poll an operation once, using an <c>operationName</c> from a previous invocation of <c>GetBigBookAsync</c>.
        /// </summary>
        /// <param name="operationName">The name of a previously invoked operation. Must not be <c>null</c> or empty.</param>
        /// <param name="callSettings">If not null, applies overrides to this RPC call.</param>
        /// <returns>A task representing the result of polling the operation.</returns>
        public virtual stt::Task<lro::Operation<Book, GetBigBookMetadata>> PollOnceGetBigBookAsync(
            string operationName,
            gaxgrpc::CallSettings callSettings = null) => lro::Operation<Book, GetBigBookMetadata>.PollOnceFromNameAsync(
                gax::GaxPreconditions.CheckNotNullOrEmpty(operationName, nameof(operationName)),
                GetBigBookOperationsClient,
                callSettings);

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<Book, GetBigBookMetadata> GetBigBook(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// The long-running operations client for <c>GetBigBook</c>.
        /// </summary>
        public virtual lro::OperationsClient GetBigBookOperationsClient
        {
            get { throw new sys::NotImplementedException(); }
        }

        /// <summary>
        /// Poll an operation once, using an <c>operationName</c> from a previous invocation of <c>GetBigBook</c>.
        /// </summary>
        /// <param name="operationName">The name of a previously invoked operation. Must not be <c>null</c> or empty.</param>
        /// <param name="callSettings">If not null, applies overrides to this RPC call.</param>
        /// <returns>The result of polling the operation.</returns>
        public virtual lro::Operation<Book, GetBigBookMetadata> PollOnceGetBigBook(
            string operationName,
            gaxgrpc::CallSettings callSettings = null) => lro::Operation<Book, GetBigBookMetadata>.PollOnceFromName(
                gax::GaxPreconditions.CheckNotNullOrEmpty(operationName, nameof(operationName)),
                GetBigBookOperationsClient,
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<pbwkt::Empty, GetBigBookMetadata>> GetBigNothingAsync(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => GetBigNothingAsync(
                new GetBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<pbwkt::Empty, GetBigBookMetadata>> GetBigNothingAsync(
            BookNameOneof name,
            st::CancellationToken cancellationToken) => GetBigNothingAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<pbwkt::Empty, GetBigBookMetadata> GetBigNothing(
            BookNameOneof name,
            gaxgrpc::CallSettings callSettings = null) => GetBigNothing(
                new GetBookRequest
                {
                    BookNameOneof = gax::GaxPreconditions.CheckNotNull(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<pbwkt::Empty, GetBigBookMetadata>> GetBigNothingAsync(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetBigNothingAsync(
                new GetBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<pbwkt::Empty, GetBigBookMetadata>> GetBigNothingAsync(
            string name,
            st::CancellationToken cancellationToken) => GetBigNothingAsync(
                name,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="name">
        /// The name of the book to retrieve.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<pbwkt::Empty, GetBigBookMetadata> GetBigNothing(
            string name,
            gaxgrpc::CallSettings callSettings = null) => GetBigNothing(
                new GetBookRequest
                {
                    Name = gax::GaxPreconditions.CheckNotNullOrEmpty(name, nameof(name)),
                },
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<lro::Operation<pbwkt::Empty, GetBigBookMetadata>> GetBigNothingAsync(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Asynchronously poll an operation once, using an <c>operationName</c> from a previous invocation of <c>GetBigNothingAsync</c>.
        /// </summary>
        /// <param name="operationName">The name of a previously invoked operation. Must not be <c>null</c> or empty.</param>
        /// <param name="callSettings">If not null, applies overrides to this RPC call.</param>
        /// <returns>A task representing the result of polling the operation.</returns>
        public virtual stt::Task<lro::Operation<pbwkt::Empty, GetBigBookMetadata>> PollOnceGetBigNothingAsync(
            string operationName,
            gaxgrpc::CallSettings callSettings = null) => lro::Operation<pbwkt::Empty, GetBigBookMetadata>.PollOnceFromNameAsync(
                gax::GaxPreconditions.CheckNotNullOrEmpty(operationName, nameof(operationName)),
                GetBigNothingOperationsClient,
                callSettings);

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual lro::Operation<pbwkt::Empty, GetBigBookMetadata> GetBigNothing(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// The long-running operations client for <c>GetBigNothing</c>.
        /// </summary>
        public virtual lro::OperationsClient GetBigNothingOperationsClient
        {
            get { throw new sys::NotImplementedException(); }
        }

        /// <summary>
        /// Poll an operation once, using an <c>operationName</c> from a previous invocation of <c>GetBigNothing</c>.
        /// </summary>
        /// <param name="operationName">The name of a previously invoked operation. Must not be <c>null</c> or empty.</param>
        /// <param name="callSettings">If not null, applies overrides to this RPC call.</param>
        /// <returns>The result of polling the operation.</returns>
        public virtual lro::Operation<pbwkt::Empty, GetBigBookMetadata> PollOnceGetBigNothing(
            string operationName,
            gaxgrpc::CallSettings callSettings = null) => lro::Operation<pbwkt::Empty, GetBigBookMetadata>.PollOnceFromName(
                gax::GaxPreconditions.CheckNotNullOrEmpty(operationName, nameof(operationName)),
                GetBigNothingOperationsClient,
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            gaxgrpc::CallSettings callSettings = null) => TestOptionalRequiredFlatteningParamsAsync(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            st::CancellationToken cancellationToken) => TestOptionalRequiredFlatteningParamsAsync(
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual TestOptionalRequiredFlatteningParamsResponse TestOptionalRequiredFlatteningParams(
            gaxgrpc::CallSettings callSettings = null) => TestOptionalRequiredFlatteningParams(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="requiredSingularInt32">
        ///
        /// </param>
        /// <param name="requiredSingularInt64">
        ///
        /// </param>
        /// <param name="requiredSingularFloat">
        ///
        /// </param>
        /// <param name="requiredSingularDouble">
        ///
        /// </param>
        /// <param name="requiredSingularBool">
        ///
        /// </param>
        /// <param name="requiredSingularEnum">
        ///
        /// </param>
        /// <param name="requiredSingularString">
        ///
        /// </param>
        /// <param name="requiredSingularBytes">
        ///
        /// </param>
        /// <param name="requiredSingularMessage">
        ///
        /// </param>
        /// <param name="requiredSingularResourceName">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredSingularFixed32">
        ///
        /// </param>
        /// <param name="requiredSingularFixed64">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloat">
        ///
        /// </param>
        /// <param name="requiredRepeatedDouble">
        ///
        /// </param>
        /// <param name="requiredRepeatedBool">
        ///
        /// </param>
        /// <param name="requiredRepeatedEnum">
        ///
        /// </param>
        /// <param name="requiredRepeatedString">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytes">
        ///
        /// </param>
        /// <param name="requiredRepeatedMessage">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceName">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed32">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed64">
        ///
        /// </param>
        /// <param name="requiredMap">
        ///
        /// </param>
        /// <param name="optionalSingularInt32">
        ///
        /// </param>
        /// <param name="optionalSingularInt64">
        ///
        /// </param>
        /// <param name="optionalSingularFloat">
        ///
        /// </param>
        /// <param name="optionalSingularDouble">
        ///
        /// </param>
        /// <param name="optionalSingularBool">
        ///
        /// </param>
        /// <param name="optionalSingularEnum">
        ///
        /// </param>
        /// <param name="optionalSingularString">
        ///
        /// </param>
        /// <param name="optionalSingularBytes">
        ///
        /// </param>
        /// <param name="optionalSingularMessage">
        ///
        /// </param>
        /// <param name="optionalSingularResourceName">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalSingularFixed32">
        ///
        /// </param>
        /// <param name="optionalSingularFixed64">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt32">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt64">
        ///
        /// </param>
        /// <param name="optionalRepeatedFloat">
        ///
        /// </param>
        /// <param name="optionalRepeatedDouble">
        ///
        /// </param>
        /// <param name="optionalRepeatedBool">
        ///
        /// </param>
        /// <param name="optionalRepeatedEnum">
        ///
        /// </param>
        /// <param name="optionalRepeatedString">
        ///
        /// </param>
        /// <param name="optionalRepeatedBytes">
        ///
        /// </param>
        /// <param name="optionalRepeatedMessage">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceName">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed32">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed64">
        ///
        /// </param>
        /// <param name="optionalMap">
        ///
        /// </param>
        /// <param name="anyValue">
        ///
        /// </param>
        /// <param name="structValue">
        ///
        /// </param>
        /// <param name="valueValue">
        ///
        /// </param>
        /// <param name="listValueValue">
        ///
        /// </param>
        /// <param name="timeValue">
        ///
        /// </param>
        /// <param name="durationValue">
        ///
        /// </param>
        /// <param name="fieldMaskValue">
        ///
        /// </param>
        /// <param name="int32Value">
        ///
        /// </param>
        /// <param name="uint32Value">
        ///
        /// </param>
        /// <param name="int64Value">
        ///
        /// </param>
        /// <param name="uint64Value">
        ///
        /// </param>
        /// <param name="floatValue">
        ///
        /// </param>
        /// <param name="doubleValue">
        ///
        /// </param>
        /// <param name="stringValue">
        ///
        /// </param>
        /// <param name="boolValue">
        ///
        /// </param>
        /// <param name="bytesValue">
        ///
        /// </param>
        /// <param name="repeatedAnyValue">
        ///
        /// </param>
        /// <param name="repeatedStructValue">
        ///
        /// </param>
        /// <param name="repeatedValueValue">
        ///
        /// </param>
        /// <param name="repeatedListValueValue">
        ///
        /// </param>
        /// <param name="repeatedTimeValue">
        ///
        /// </param>
        /// <param name="repeatedDurationValue">
        ///
        /// </param>
        /// <param name="repeatedFieldMaskValue">
        ///
        /// </param>
        /// <param name="repeatedInt32Value">
        ///
        /// </param>
        /// <param name="repeatedUint32Value">
        ///
        /// </param>
        /// <param name="repeatedInt64Value">
        ///
        /// </param>
        /// <param name="repeatedUint64Value">
        ///
        /// </param>
        /// <param name="repeatedFloatValue">
        ///
        /// </param>
        /// <param name="repeatedDoubleValue">
        ///
        /// </param>
        /// <param name="repeatedStringValue">
        ///
        /// </param>
        /// <param name="repeatedBoolValue">
        ///
        /// </param>
        /// <param name="repeatedBytesValue">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            int requiredSingularInt32,
            long requiredSingularInt64,
            float requiredSingularFloat,
            double requiredSingularDouble,
            bool requiredSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum,
            string requiredSingularString,
            pb::ByteString requiredSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage,
            BookNameOneof requiredSingularResourceName,
            BookNameOneof requiredSingularResourceNameOneof,
            string requiredSingularResourceNameCommon,
            int requiredSingularFixed32,
            long requiredSingularFixed64,
            scg::IEnumerable<int> requiredRepeatedInt32,
            scg::IEnumerable<long> requiredRepeatedInt64,
            scg::IEnumerable<float> requiredRepeatedFloat,
            scg::IEnumerable<double> requiredRepeatedDouble,
            scg::IEnumerable<bool> requiredRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum,
            scg::IEnumerable<string> requiredRepeatedString,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage,
            scg::IEnumerable<BookNameOneof> requiredRepeatedResourceName,
            scg::IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof,
            scg::IEnumerable<string> requiredRepeatedResourceNameCommon,
            scg::IEnumerable<int> requiredRepeatedFixed32,
            scg::IEnumerable<long> requiredRepeatedFixed64,
            scg::IDictionary<int, string> requiredMap,
            int? optionalSingularInt32,
            long? optionalSingularInt64,
            float? optionalSingularFloat,
            double? optionalSingularDouble,
            bool? optionalSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum? optionalSingularEnum,
            string optionalSingularString,
            pb::ByteString optionalSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage,
            BookNameOneof optionalSingularResourceName,
            BookNameOneof optionalSingularResourceNameOneof,
            string optionalSingularResourceNameCommon,
            int? optionalSingularFixed32,
            long? optionalSingularFixed64,
            scg::IEnumerable<int> optionalRepeatedInt32,
            scg::IEnumerable<long> optionalRepeatedInt64,
            scg::IEnumerable<float> optionalRepeatedFloat,
            scg::IEnumerable<double> optionalRepeatedDouble,
            scg::IEnumerable<bool> optionalRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum,
            scg::IEnumerable<string> optionalRepeatedString,
            scg::IEnumerable<pb::ByteString> optionalRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage,
            scg::IEnumerable<BookNameOneof> optionalRepeatedResourceName,
            scg::IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof,
            scg::IEnumerable<string> optionalRepeatedResourceNameCommon,
            scg::IEnumerable<int> optionalRepeatedFixed32,
            scg::IEnumerable<long> optionalRepeatedFixed64,
            scg::IDictionary<int, string> optionalMap,
            pbwkt::Any anyValue,
            pbwkt::Struct structValue,
            pbwkt::Value valueValue,
            pbwkt::ListValue listValueValue,
            pbwkt::Timestamp timeValue,
            pbwkt::Duration durationValue,
            pbwkt::FieldMask fieldMaskValue,
            int? int32Value,
            uint? uint32Value,
            long? int64Value,
            ulong? uint64Value,
            float? floatValue,
            double? doubleValue,
            string stringValue,
            bool? boolValue,
            pb::ByteString bytesValue,
            scg::IEnumerable<pbwkt::Any> repeatedAnyValue,
            scg::IEnumerable<pbwkt::Struct> repeatedStructValue,
            scg::IEnumerable<pbwkt::Value> repeatedValueValue,
            scg::IEnumerable<pbwkt::ListValue> repeatedListValueValue,
            scg::IEnumerable<pbwkt::Timestamp> repeatedTimeValue,
            scg::IEnumerable<pbwkt::Duration> repeatedDurationValue,
            scg::IEnumerable<pbwkt::FieldMask> repeatedFieldMaskValue,
            scg::IEnumerable<int?> repeatedInt32Value,
            scg::IEnumerable<uint?> repeatedUint32Value,
            scg::IEnumerable<long?> repeatedInt64Value,
            scg::IEnumerable<ulong?> repeatedUint64Value,
            scg::IEnumerable<float?> repeatedFloatValue,
            scg::IEnumerable<double?> repeatedDoubleValue,
            scg::IEnumerable<string> repeatedStringValue,
            scg::IEnumerable<bool?> repeatedBoolValue,
            scg::IEnumerable<pb::ByteString> repeatedBytesValue,
            gaxgrpc::CallSettings callSettings = null) => TestOptionalRequiredFlatteningParamsAsync(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                    RequiredSingularInt32 = requiredSingularInt32,
                    RequiredSingularInt64 = requiredSingularInt64,
                    RequiredSingularFloat = requiredSingularFloat,
                    RequiredSingularDouble = requiredSingularDouble,
                    RequiredSingularBool = requiredSingularBool,
                    RequiredSingularEnum = requiredSingularEnum,
                    RequiredSingularString = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularString, nameof(requiredSingularString)),
                    RequiredSingularBytes = gax::GaxPreconditions.CheckNotNull(requiredSingularBytes, nameof(requiredSingularBytes)),
                    RequiredSingularMessage = gax::GaxPreconditions.CheckNotNull(requiredSingularMessage, nameof(requiredSingularMessage)),
                    RequiredSingularResourceNameAsBookNameOneof = gax::GaxPreconditions.CheckNotNull(requiredSingularResourceName, nameof(requiredSingularResourceName)),
                    RequiredSingularResourceNameOneofAsBookNameOneof = gax::GaxPreconditions.CheckNotNull(requiredSingularResourceNameOneof, nameof(requiredSingularResourceNameOneof)),
                    RequiredSingularResourceNameCommon = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularResourceNameCommon, nameof(requiredSingularResourceNameCommon)),
                    RequiredSingularFixed32 = requiredSingularFixed32,
                    RequiredSingularFixed64 = requiredSingularFixed64,
                    RequiredRepeatedInt32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt32, nameof(requiredRepeatedInt32)) },
                    RequiredRepeatedInt64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt64, nameof(requiredRepeatedInt64)) },
                    RequiredRepeatedFloat = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFloat, nameof(requiredRepeatedFloat)) },
                    RequiredRepeatedDouble = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedDouble, nameof(requiredRepeatedDouble)) },
                    RequiredRepeatedBool = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBool, nameof(requiredRepeatedBool)) },
                    RequiredRepeatedEnum = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedEnum, nameof(requiredRepeatedEnum)) },
                    RequiredRepeatedString = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedString, nameof(requiredRepeatedString)) },
                    RequiredRepeatedBytes = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBytes, nameof(requiredRepeatedBytes)) },
                    RequiredRepeatedMessage = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedMessage, nameof(requiredRepeatedMessage)) },
                    RequiredRepeatedResourceNameAsBookNameOneofs = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceName, nameof(requiredRepeatedResourceName)) },
                    RequiredRepeatedResourceNameOneofAsBookNameOneofs = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameOneof, nameof(requiredRepeatedResourceNameOneof)) },
                    RequiredRepeatedResourceNameCommon = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameCommon, nameof(requiredRepeatedResourceNameCommon)) },
                    RequiredRepeatedFixed32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed32, nameof(requiredRepeatedFixed32)) },
                    RequiredRepeatedFixed64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed64, nameof(requiredRepeatedFixed64)) },
                    RequiredMap = { gax::GaxPreconditions.CheckNotNull(requiredMap, nameof(requiredMap)) },
                    OptionalSingularInt32 = optionalSingularInt32 ?? 0, // Optional
                    OptionalSingularInt64 = optionalSingularInt64 ?? 0L, // Optional
                    OptionalSingularFloat = optionalSingularFloat ?? 0.0f, // Optional
                    OptionalSingularDouble = optionalSingularDouble ?? 0.0, // Optional
                    OptionalSingularBool = optionalSingularBool ?? false, // Optional
                    OptionalSingularEnum = optionalSingularEnum ?? TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero, // Optional
                    OptionalSingularString = optionalSingularString ?? "", // Optional
                    OptionalSingularBytes = optionalSingularBytes ?? pb::ByteString.Empty, // Optional
                    OptionalSingularMessage = optionalSingularMessage, // Optional
                    OptionalSingularResourceNameAsBookNameOneof = optionalSingularResourceName, // Optional
                    OptionalSingularResourceNameOneofAsBookNameOneof = optionalSingularResourceNameOneof, // Optional
                    OptionalSingularResourceNameCommon = optionalSingularResourceNameCommon ?? "", // Optional
                    OptionalSingularFixed32 = optionalSingularFixed32 ?? 0, // Optional
                    OptionalSingularFixed64 = optionalSingularFixed64 ?? 0L, // Optional
                    OptionalRepeatedInt32 = { optionalRepeatedInt32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedInt64 = { optionalRepeatedInt64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalRepeatedFloat = { optionalRepeatedFloat ?? linq::Enumerable.Empty<float>() }, // Optional
                    OptionalRepeatedDouble = { optionalRepeatedDouble ?? linq::Enumerable.Empty<double>() }, // Optional
                    OptionalRepeatedBool = { optionalRepeatedBool ?? linq::Enumerable.Empty<bool>() }, // Optional
                    OptionalRepeatedEnum = { optionalRepeatedEnum ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>() }, // Optional
                    OptionalRepeatedString = { optionalRepeatedString ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedBytes = { optionalRepeatedBytes ?? linq::Enumerable.Empty<pb::ByteString>() }, // Optional
                    OptionalRepeatedMessage = { optionalRepeatedMessage ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>() }, // Optional
                    OptionalRepeatedResourceNameAsBookNameOneofs = { optionalRepeatedResourceName ?? linq::Enumerable.Empty<BookNameOneof>() }, // Optional
                    OptionalRepeatedResourceNameOneofAsBookNameOneofs = { optionalRepeatedResourceNameOneof ?? linq::Enumerable.Empty<BookNameOneof>() }, // Optional
                    OptionalRepeatedResourceNameCommon = { optionalRepeatedResourceNameCommon ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedFixed32 = { optionalRepeatedFixed32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedFixed64 = { optionalRepeatedFixed64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalMap = { optionalMap ?? gax::EmptyDictionary<int, string>.Instance }, // Optional
                    AnyValue = anyValue, // Optional
                    StructValue = structValue, // Optional
                    ValueValue = valueValue, // Optional
                    ListValueValue = listValueValue, // Optional
                    TimeValue = timeValue, // Optional
                    DurationValue = durationValue, // Optional
                    FieldMaskValue = fieldMaskValue, // Optional
                    Int32Value = int32Value, // Optional
                    Uint32Value = uint32Value, // Optional
                    Int64Value = int64Value, // Optional
                    Uint64Value = uint64Value, // Optional
                    FloatValue = floatValue, // Optional
                    DoubleValue = doubleValue, // Optional
                    StringValue = stringValue, // Optional
                    BoolValue = boolValue, // Optional
                    BytesValue = bytesValue, // Optional
                    RepeatedAnyValue = { repeatedAnyValue ?? linq::Enumerable.Empty<pbwkt::Any>() }, // Optional
                    RepeatedStructValue = { repeatedStructValue ?? linq::Enumerable.Empty<pbwkt::Struct>() }, // Optional
                    RepeatedValueValue = { repeatedValueValue ?? linq::Enumerable.Empty<pbwkt::Value>() }, // Optional
                    RepeatedListValueValue = { repeatedListValueValue ?? linq::Enumerable.Empty<pbwkt::ListValue>() }, // Optional
                    RepeatedTimeValue = { repeatedTimeValue ?? linq::Enumerable.Empty<pbwkt::Timestamp>() }, // Optional
                    RepeatedDurationValue = { repeatedDurationValue ?? linq::Enumerable.Empty<pbwkt::Duration>() }, // Optional
                    RepeatedFieldMaskValue = { repeatedFieldMaskValue ?? linq::Enumerable.Empty<pbwkt::FieldMask>() }, // Optional
                    RepeatedInt32Value = { repeatedInt32Value ?? linq::Enumerable.Empty<int?>() }, // Optional
                    RepeatedUint32Value = { repeatedUint32Value ?? linq::Enumerable.Empty<uint?>() }, // Optional
                    RepeatedInt64Value = { repeatedInt64Value ?? linq::Enumerable.Empty<long?>() }, // Optional
                    RepeatedUint64Value = { repeatedUint64Value ?? linq::Enumerable.Empty<ulong?>() }, // Optional
                    RepeatedFloatValue = { repeatedFloatValue ?? linq::Enumerable.Empty<float?>() }, // Optional
                    RepeatedDoubleValue = { repeatedDoubleValue ?? linq::Enumerable.Empty<double?>() }, // Optional
                    RepeatedStringValue = { repeatedStringValue ?? linq::Enumerable.Empty<string>() }, // Optional
                    RepeatedBoolValue = { repeatedBoolValue ?? linq::Enumerable.Empty<bool?>() }, // Optional
                    RepeatedBytesValue = { repeatedBytesValue ?? linq::Enumerable.Empty<pb::ByteString>() }, // Optional
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="requiredSingularInt32">
        ///
        /// </param>
        /// <param name="requiredSingularInt64">
        ///
        /// </param>
        /// <param name="requiredSingularFloat">
        ///
        /// </param>
        /// <param name="requiredSingularDouble">
        ///
        /// </param>
        /// <param name="requiredSingularBool">
        ///
        /// </param>
        /// <param name="requiredSingularEnum">
        ///
        /// </param>
        /// <param name="requiredSingularString">
        ///
        /// </param>
        /// <param name="requiredSingularBytes">
        ///
        /// </param>
        /// <param name="requiredSingularMessage">
        ///
        /// </param>
        /// <param name="requiredSingularResourceName">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredSingularFixed32">
        ///
        /// </param>
        /// <param name="requiredSingularFixed64">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloat">
        ///
        /// </param>
        /// <param name="requiredRepeatedDouble">
        ///
        /// </param>
        /// <param name="requiredRepeatedBool">
        ///
        /// </param>
        /// <param name="requiredRepeatedEnum">
        ///
        /// </param>
        /// <param name="requiredRepeatedString">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytes">
        ///
        /// </param>
        /// <param name="requiredRepeatedMessage">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceName">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed32">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed64">
        ///
        /// </param>
        /// <param name="requiredMap">
        ///
        /// </param>
        /// <param name="optionalSingularInt32">
        ///
        /// </param>
        /// <param name="optionalSingularInt64">
        ///
        /// </param>
        /// <param name="optionalSingularFloat">
        ///
        /// </param>
        /// <param name="optionalSingularDouble">
        ///
        /// </param>
        /// <param name="optionalSingularBool">
        ///
        /// </param>
        /// <param name="optionalSingularEnum">
        ///
        /// </param>
        /// <param name="optionalSingularString">
        ///
        /// </param>
        /// <param name="optionalSingularBytes">
        ///
        /// </param>
        /// <param name="optionalSingularMessage">
        ///
        /// </param>
        /// <param name="optionalSingularResourceName">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalSingularFixed32">
        ///
        /// </param>
        /// <param name="optionalSingularFixed64">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt32">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt64">
        ///
        /// </param>
        /// <param name="optionalRepeatedFloat">
        ///
        /// </param>
        /// <param name="optionalRepeatedDouble">
        ///
        /// </param>
        /// <param name="optionalRepeatedBool">
        ///
        /// </param>
        /// <param name="optionalRepeatedEnum">
        ///
        /// </param>
        /// <param name="optionalRepeatedString">
        ///
        /// </param>
        /// <param name="optionalRepeatedBytes">
        ///
        /// </param>
        /// <param name="optionalRepeatedMessage">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceName">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed32">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed64">
        ///
        /// </param>
        /// <param name="optionalMap">
        ///
        /// </param>
        /// <param name="anyValue">
        ///
        /// </param>
        /// <param name="structValue">
        ///
        /// </param>
        /// <param name="valueValue">
        ///
        /// </param>
        /// <param name="listValueValue">
        ///
        /// </param>
        /// <param name="timeValue">
        ///
        /// </param>
        /// <param name="durationValue">
        ///
        /// </param>
        /// <param name="fieldMaskValue">
        ///
        /// </param>
        /// <param name="int32Value">
        ///
        /// </param>
        /// <param name="uint32Value">
        ///
        /// </param>
        /// <param name="int64Value">
        ///
        /// </param>
        /// <param name="uint64Value">
        ///
        /// </param>
        /// <param name="floatValue">
        ///
        /// </param>
        /// <param name="doubleValue">
        ///
        /// </param>
        /// <param name="stringValue">
        ///
        /// </param>
        /// <param name="boolValue">
        ///
        /// </param>
        /// <param name="bytesValue">
        ///
        /// </param>
        /// <param name="repeatedAnyValue">
        ///
        /// </param>
        /// <param name="repeatedStructValue">
        ///
        /// </param>
        /// <param name="repeatedValueValue">
        ///
        /// </param>
        /// <param name="repeatedListValueValue">
        ///
        /// </param>
        /// <param name="repeatedTimeValue">
        ///
        /// </param>
        /// <param name="repeatedDurationValue">
        ///
        /// </param>
        /// <param name="repeatedFieldMaskValue">
        ///
        /// </param>
        /// <param name="repeatedInt32Value">
        ///
        /// </param>
        /// <param name="repeatedUint32Value">
        ///
        /// </param>
        /// <param name="repeatedInt64Value">
        ///
        /// </param>
        /// <param name="repeatedUint64Value">
        ///
        /// </param>
        /// <param name="repeatedFloatValue">
        ///
        /// </param>
        /// <param name="repeatedDoubleValue">
        ///
        /// </param>
        /// <param name="repeatedStringValue">
        ///
        /// </param>
        /// <param name="repeatedBoolValue">
        ///
        /// </param>
        /// <param name="repeatedBytesValue">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            int requiredSingularInt32,
            long requiredSingularInt64,
            float requiredSingularFloat,
            double requiredSingularDouble,
            bool requiredSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum,
            string requiredSingularString,
            pb::ByteString requiredSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage,
            BookNameOneof requiredSingularResourceName,
            BookNameOneof requiredSingularResourceNameOneof,
            string requiredSingularResourceNameCommon,
            int requiredSingularFixed32,
            long requiredSingularFixed64,
            scg::IEnumerable<int> requiredRepeatedInt32,
            scg::IEnumerable<long> requiredRepeatedInt64,
            scg::IEnumerable<float> requiredRepeatedFloat,
            scg::IEnumerable<double> requiredRepeatedDouble,
            scg::IEnumerable<bool> requiredRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum,
            scg::IEnumerable<string> requiredRepeatedString,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage,
            scg::IEnumerable<BookNameOneof> requiredRepeatedResourceName,
            scg::IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof,
            scg::IEnumerable<string> requiredRepeatedResourceNameCommon,
            scg::IEnumerable<int> requiredRepeatedFixed32,
            scg::IEnumerable<long> requiredRepeatedFixed64,
            scg::IDictionary<int, string> requiredMap,
            int? optionalSingularInt32,
            long? optionalSingularInt64,
            float? optionalSingularFloat,
            double? optionalSingularDouble,
            bool? optionalSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum? optionalSingularEnum,
            string optionalSingularString,
            pb::ByteString optionalSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage,
            BookNameOneof optionalSingularResourceName,
            BookNameOneof optionalSingularResourceNameOneof,
            string optionalSingularResourceNameCommon,
            int? optionalSingularFixed32,
            long? optionalSingularFixed64,
            scg::IEnumerable<int> optionalRepeatedInt32,
            scg::IEnumerable<long> optionalRepeatedInt64,
            scg::IEnumerable<float> optionalRepeatedFloat,
            scg::IEnumerable<double> optionalRepeatedDouble,
            scg::IEnumerable<bool> optionalRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum,
            scg::IEnumerable<string> optionalRepeatedString,
            scg::IEnumerable<pb::ByteString> optionalRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage,
            scg::IEnumerable<BookNameOneof> optionalRepeatedResourceName,
            scg::IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof,
            scg::IEnumerable<string> optionalRepeatedResourceNameCommon,
            scg::IEnumerable<int> optionalRepeatedFixed32,
            scg::IEnumerable<long> optionalRepeatedFixed64,
            scg::IDictionary<int, string> optionalMap,
            pbwkt::Any anyValue,
            pbwkt::Struct structValue,
            pbwkt::Value valueValue,
            pbwkt::ListValue listValueValue,
            pbwkt::Timestamp timeValue,
            pbwkt::Duration durationValue,
            pbwkt::FieldMask fieldMaskValue,
            int? int32Value,
            uint? uint32Value,
            long? int64Value,
            ulong? uint64Value,
            float? floatValue,
            double? doubleValue,
            string stringValue,
            bool? boolValue,
            pb::ByteString bytesValue,
            scg::IEnumerable<pbwkt::Any> repeatedAnyValue,
            scg::IEnumerable<pbwkt::Struct> repeatedStructValue,
            scg::IEnumerable<pbwkt::Value> repeatedValueValue,
            scg::IEnumerable<pbwkt::ListValue> repeatedListValueValue,
            scg::IEnumerable<pbwkt::Timestamp> repeatedTimeValue,
            scg::IEnumerable<pbwkt::Duration> repeatedDurationValue,
            scg::IEnumerable<pbwkt::FieldMask> repeatedFieldMaskValue,
            scg::IEnumerable<int?> repeatedInt32Value,
            scg::IEnumerable<uint?> repeatedUint32Value,
            scg::IEnumerable<long?> repeatedInt64Value,
            scg::IEnumerable<ulong?> repeatedUint64Value,
            scg::IEnumerable<float?> repeatedFloatValue,
            scg::IEnumerable<double?> repeatedDoubleValue,
            scg::IEnumerable<string> repeatedStringValue,
            scg::IEnumerable<bool?> repeatedBoolValue,
            scg::IEnumerable<pb::ByteString> repeatedBytesValue,
            st::CancellationToken cancellationToken) => TestOptionalRequiredFlatteningParamsAsync(
                requiredSingularInt32,
                requiredSingularInt64,
                requiredSingularFloat,
                requiredSingularDouble,
                requiredSingularBool,
                requiredSingularEnum,
                requiredSingularString,
                requiredSingularBytes,
                requiredSingularMessage,
                requiredSingularResourceName,
                requiredSingularResourceNameOneof,
                requiredSingularResourceNameCommon,
                requiredSingularFixed32,
                requiredSingularFixed64,
                requiredRepeatedInt32,
                requiredRepeatedInt64,
                requiredRepeatedFloat,
                requiredRepeatedDouble,
                requiredRepeatedBool,
                requiredRepeatedEnum,
                requiredRepeatedString,
                requiredRepeatedBytes,
                requiredRepeatedMessage,
                requiredRepeatedResourceName,
                requiredRepeatedResourceNameOneof,
                requiredRepeatedResourceNameCommon,
                requiredRepeatedFixed32,
                requiredRepeatedFixed64,
                requiredMap,
                optionalSingularInt32,
                optionalSingularInt64,
                optionalSingularFloat,
                optionalSingularDouble,
                optionalSingularBool,
                optionalSingularEnum,
                optionalSingularString,
                optionalSingularBytes,
                optionalSingularMessage,
                optionalSingularResourceName,
                optionalSingularResourceNameOneof,
                optionalSingularResourceNameCommon,
                optionalSingularFixed32,
                optionalSingularFixed64,
                optionalRepeatedInt32,
                optionalRepeatedInt64,
                optionalRepeatedFloat,
                optionalRepeatedDouble,
                optionalRepeatedBool,
                optionalRepeatedEnum,
                optionalRepeatedString,
                optionalRepeatedBytes,
                optionalRepeatedMessage,
                optionalRepeatedResourceName,
                optionalRepeatedResourceNameOneof,
                optionalRepeatedResourceNameCommon,
                optionalRepeatedFixed32,
                optionalRepeatedFixed64,
                optionalMap,
                anyValue,
                structValue,
                valueValue,
                listValueValue,
                timeValue,
                durationValue,
                fieldMaskValue,
                int32Value,
                uint32Value,
                int64Value,
                uint64Value,
                floatValue,
                doubleValue,
                stringValue,
                boolValue,
                bytesValue,
                repeatedAnyValue,
                repeatedStructValue,
                repeatedValueValue,
                repeatedListValueValue,
                repeatedTimeValue,
                repeatedDurationValue,
                repeatedFieldMaskValue,
                repeatedInt32Value,
                repeatedUint32Value,
                repeatedInt64Value,
                repeatedUint64Value,
                repeatedFloatValue,
                repeatedDoubleValue,
                repeatedStringValue,
                repeatedBoolValue,
                repeatedBytesValue,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="requiredSingularInt32">
        ///
        /// </param>
        /// <param name="requiredSingularInt64">
        ///
        /// </param>
        /// <param name="requiredSingularFloat">
        ///
        /// </param>
        /// <param name="requiredSingularDouble">
        ///
        /// </param>
        /// <param name="requiredSingularBool">
        ///
        /// </param>
        /// <param name="requiredSingularEnum">
        ///
        /// </param>
        /// <param name="requiredSingularString">
        ///
        /// </param>
        /// <param name="requiredSingularBytes">
        ///
        /// </param>
        /// <param name="requiredSingularMessage">
        ///
        /// </param>
        /// <param name="requiredSingularResourceName">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredSingularFixed32">
        ///
        /// </param>
        /// <param name="requiredSingularFixed64">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloat">
        ///
        /// </param>
        /// <param name="requiredRepeatedDouble">
        ///
        /// </param>
        /// <param name="requiredRepeatedBool">
        ///
        /// </param>
        /// <param name="requiredRepeatedEnum">
        ///
        /// </param>
        /// <param name="requiredRepeatedString">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytes">
        ///
        /// </param>
        /// <param name="requiredRepeatedMessage">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceName">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed32">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed64">
        ///
        /// </param>
        /// <param name="requiredMap">
        ///
        /// </param>
        /// <param name="optionalSingularInt32">
        ///
        /// </param>
        /// <param name="optionalSingularInt64">
        ///
        /// </param>
        /// <param name="optionalSingularFloat">
        ///
        /// </param>
        /// <param name="optionalSingularDouble">
        ///
        /// </param>
        /// <param name="optionalSingularBool">
        ///
        /// </param>
        /// <param name="optionalSingularEnum">
        ///
        /// </param>
        /// <param name="optionalSingularString">
        ///
        /// </param>
        /// <param name="optionalSingularBytes">
        ///
        /// </param>
        /// <param name="optionalSingularMessage">
        ///
        /// </param>
        /// <param name="optionalSingularResourceName">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalSingularFixed32">
        ///
        /// </param>
        /// <param name="optionalSingularFixed64">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt32">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt64">
        ///
        /// </param>
        /// <param name="optionalRepeatedFloat">
        ///
        /// </param>
        /// <param name="optionalRepeatedDouble">
        ///
        /// </param>
        /// <param name="optionalRepeatedBool">
        ///
        /// </param>
        /// <param name="optionalRepeatedEnum">
        ///
        /// </param>
        /// <param name="optionalRepeatedString">
        ///
        /// </param>
        /// <param name="optionalRepeatedBytes">
        ///
        /// </param>
        /// <param name="optionalRepeatedMessage">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceName">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed32">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed64">
        ///
        /// </param>
        /// <param name="optionalMap">
        ///
        /// </param>
        /// <param name="anyValue">
        ///
        /// </param>
        /// <param name="structValue">
        ///
        /// </param>
        /// <param name="valueValue">
        ///
        /// </param>
        /// <param name="listValueValue">
        ///
        /// </param>
        /// <param name="timeValue">
        ///
        /// </param>
        /// <param name="durationValue">
        ///
        /// </param>
        /// <param name="fieldMaskValue">
        ///
        /// </param>
        /// <param name="int32Value">
        ///
        /// </param>
        /// <param name="uint32Value">
        ///
        /// </param>
        /// <param name="int64Value">
        ///
        /// </param>
        /// <param name="uint64Value">
        ///
        /// </param>
        /// <param name="floatValue">
        ///
        /// </param>
        /// <param name="doubleValue">
        ///
        /// </param>
        /// <param name="stringValue">
        ///
        /// </param>
        /// <param name="boolValue">
        ///
        /// </param>
        /// <param name="bytesValue">
        ///
        /// </param>
        /// <param name="repeatedAnyValue">
        ///
        /// </param>
        /// <param name="repeatedStructValue">
        ///
        /// </param>
        /// <param name="repeatedValueValue">
        ///
        /// </param>
        /// <param name="repeatedListValueValue">
        ///
        /// </param>
        /// <param name="repeatedTimeValue">
        ///
        /// </param>
        /// <param name="repeatedDurationValue">
        ///
        /// </param>
        /// <param name="repeatedFieldMaskValue">
        ///
        /// </param>
        /// <param name="repeatedInt32Value">
        ///
        /// </param>
        /// <param name="repeatedUint32Value">
        ///
        /// </param>
        /// <param name="repeatedInt64Value">
        ///
        /// </param>
        /// <param name="repeatedUint64Value">
        ///
        /// </param>
        /// <param name="repeatedFloatValue">
        ///
        /// </param>
        /// <param name="repeatedDoubleValue">
        ///
        /// </param>
        /// <param name="repeatedStringValue">
        ///
        /// </param>
        /// <param name="repeatedBoolValue">
        ///
        /// </param>
        /// <param name="repeatedBytesValue">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual TestOptionalRequiredFlatteningParamsResponse TestOptionalRequiredFlatteningParams(
            int requiredSingularInt32,
            long requiredSingularInt64,
            float requiredSingularFloat,
            double requiredSingularDouble,
            bool requiredSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum,
            string requiredSingularString,
            pb::ByteString requiredSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage,
            BookNameOneof requiredSingularResourceName,
            BookNameOneof requiredSingularResourceNameOneof,
            string requiredSingularResourceNameCommon,
            int requiredSingularFixed32,
            long requiredSingularFixed64,
            scg::IEnumerable<int> requiredRepeatedInt32,
            scg::IEnumerable<long> requiredRepeatedInt64,
            scg::IEnumerable<float> requiredRepeatedFloat,
            scg::IEnumerable<double> requiredRepeatedDouble,
            scg::IEnumerable<bool> requiredRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum,
            scg::IEnumerable<string> requiredRepeatedString,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage,
            scg::IEnumerable<BookNameOneof> requiredRepeatedResourceName,
            scg::IEnumerable<BookNameOneof> requiredRepeatedResourceNameOneof,
            scg::IEnumerable<string> requiredRepeatedResourceNameCommon,
            scg::IEnumerable<int> requiredRepeatedFixed32,
            scg::IEnumerable<long> requiredRepeatedFixed64,
            scg::IDictionary<int, string> requiredMap,
            int? optionalSingularInt32,
            long? optionalSingularInt64,
            float? optionalSingularFloat,
            double? optionalSingularDouble,
            bool? optionalSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum? optionalSingularEnum,
            string optionalSingularString,
            pb::ByteString optionalSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage,
            BookNameOneof optionalSingularResourceName,
            BookNameOneof optionalSingularResourceNameOneof,
            string optionalSingularResourceNameCommon,
            int? optionalSingularFixed32,
            long? optionalSingularFixed64,
            scg::IEnumerable<int> optionalRepeatedInt32,
            scg::IEnumerable<long> optionalRepeatedInt64,
            scg::IEnumerable<float> optionalRepeatedFloat,
            scg::IEnumerable<double> optionalRepeatedDouble,
            scg::IEnumerable<bool> optionalRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum,
            scg::IEnumerable<string> optionalRepeatedString,
            scg::IEnumerable<pb::ByteString> optionalRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage,
            scg::IEnumerable<BookNameOneof> optionalRepeatedResourceName,
            scg::IEnumerable<BookNameOneof> optionalRepeatedResourceNameOneof,
            scg::IEnumerable<string> optionalRepeatedResourceNameCommon,
            scg::IEnumerable<int> optionalRepeatedFixed32,
            scg::IEnumerable<long> optionalRepeatedFixed64,
            scg::IDictionary<int, string> optionalMap,
            pbwkt::Any anyValue,
            pbwkt::Struct structValue,
            pbwkt::Value valueValue,
            pbwkt::ListValue listValueValue,
            pbwkt::Timestamp timeValue,
            pbwkt::Duration durationValue,
            pbwkt::FieldMask fieldMaskValue,
            int? int32Value,
            uint? uint32Value,
            long? int64Value,
            ulong? uint64Value,
            float? floatValue,
            double? doubleValue,
            string stringValue,
            bool? boolValue,
            pb::ByteString bytesValue,
            scg::IEnumerable<pbwkt::Any> repeatedAnyValue,
            scg::IEnumerable<pbwkt::Struct> repeatedStructValue,
            scg::IEnumerable<pbwkt::Value> repeatedValueValue,
            scg::IEnumerable<pbwkt::ListValue> repeatedListValueValue,
            scg::IEnumerable<pbwkt::Timestamp> repeatedTimeValue,
            scg::IEnumerable<pbwkt::Duration> repeatedDurationValue,
            scg::IEnumerable<pbwkt::FieldMask> repeatedFieldMaskValue,
            scg::IEnumerable<int?> repeatedInt32Value,
            scg::IEnumerable<uint?> repeatedUint32Value,
            scg::IEnumerable<long?> repeatedInt64Value,
            scg::IEnumerable<ulong?> repeatedUint64Value,
            scg::IEnumerable<float?> repeatedFloatValue,
            scg::IEnumerable<double?> repeatedDoubleValue,
            scg::IEnumerable<string> repeatedStringValue,
            scg::IEnumerable<bool?> repeatedBoolValue,
            scg::IEnumerable<pb::ByteString> repeatedBytesValue,
            gaxgrpc::CallSettings callSettings = null) => TestOptionalRequiredFlatteningParams(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                    RequiredSingularInt32 = requiredSingularInt32,
                    RequiredSingularInt64 = requiredSingularInt64,
                    RequiredSingularFloat = requiredSingularFloat,
                    RequiredSingularDouble = requiredSingularDouble,
                    RequiredSingularBool = requiredSingularBool,
                    RequiredSingularEnum = requiredSingularEnum,
                    RequiredSingularString = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularString, nameof(requiredSingularString)),
                    RequiredSingularBytes = gax::GaxPreconditions.CheckNotNull(requiredSingularBytes, nameof(requiredSingularBytes)),
                    RequiredSingularMessage = gax::GaxPreconditions.CheckNotNull(requiredSingularMessage, nameof(requiredSingularMessage)),
                    RequiredSingularResourceNameAsBookNameOneof = gax::GaxPreconditions.CheckNotNull(requiredSingularResourceName, nameof(requiredSingularResourceName)),
                    RequiredSingularResourceNameOneofAsBookNameOneof = gax::GaxPreconditions.CheckNotNull(requiredSingularResourceNameOneof, nameof(requiredSingularResourceNameOneof)),
                    RequiredSingularResourceNameCommon = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularResourceNameCommon, nameof(requiredSingularResourceNameCommon)),
                    RequiredSingularFixed32 = requiredSingularFixed32,
                    RequiredSingularFixed64 = requiredSingularFixed64,
                    RequiredRepeatedInt32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt32, nameof(requiredRepeatedInt32)) },
                    RequiredRepeatedInt64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt64, nameof(requiredRepeatedInt64)) },
                    RequiredRepeatedFloat = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFloat, nameof(requiredRepeatedFloat)) },
                    RequiredRepeatedDouble = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedDouble, nameof(requiredRepeatedDouble)) },
                    RequiredRepeatedBool = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBool, nameof(requiredRepeatedBool)) },
                    RequiredRepeatedEnum = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedEnum, nameof(requiredRepeatedEnum)) },
                    RequiredRepeatedString = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedString, nameof(requiredRepeatedString)) },
                    RequiredRepeatedBytes = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBytes, nameof(requiredRepeatedBytes)) },
                    RequiredRepeatedMessage = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedMessage, nameof(requiredRepeatedMessage)) },
                    RequiredRepeatedResourceNameAsBookNameOneofs = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceName, nameof(requiredRepeatedResourceName)) },
                    RequiredRepeatedResourceNameOneofAsBookNameOneofs = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameOneof, nameof(requiredRepeatedResourceNameOneof)) },
                    RequiredRepeatedResourceNameCommon = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameCommon, nameof(requiredRepeatedResourceNameCommon)) },
                    RequiredRepeatedFixed32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed32, nameof(requiredRepeatedFixed32)) },
                    RequiredRepeatedFixed64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed64, nameof(requiredRepeatedFixed64)) },
                    RequiredMap = { gax::GaxPreconditions.CheckNotNull(requiredMap, nameof(requiredMap)) },
                    OptionalSingularInt32 = optionalSingularInt32 ?? 0, // Optional
                    OptionalSingularInt64 = optionalSingularInt64 ?? 0L, // Optional
                    OptionalSingularFloat = optionalSingularFloat ?? 0.0f, // Optional
                    OptionalSingularDouble = optionalSingularDouble ?? 0.0, // Optional
                    OptionalSingularBool = optionalSingularBool ?? false, // Optional
                    OptionalSingularEnum = optionalSingularEnum ?? TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero, // Optional
                    OptionalSingularString = optionalSingularString ?? "", // Optional
                    OptionalSingularBytes = optionalSingularBytes ?? pb::ByteString.Empty, // Optional
                    OptionalSingularMessage = optionalSingularMessage, // Optional
                    OptionalSingularResourceNameAsBookNameOneof = optionalSingularResourceName, // Optional
                    OptionalSingularResourceNameOneofAsBookNameOneof = optionalSingularResourceNameOneof, // Optional
                    OptionalSingularResourceNameCommon = optionalSingularResourceNameCommon ?? "", // Optional
                    OptionalSingularFixed32 = optionalSingularFixed32 ?? 0, // Optional
                    OptionalSingularFixed64 = optionalSingularFixed64 ?? 0L, // Optional
                    OptionalRepeatedInt32 = { optionalRepeatedInt32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedInt64 = { optionalRepeatedInt64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalRepeatedFloat = { optionalRepeatedFloat ?? linq::Enumerable.Empty<float>() }, // Optional
                    OptionalRepeatedDouble = { optionalRepeatedDouble ?? linq::Enumerable.Empty<double>() }, // Optional
                    OptionalRepeatedBool = { optionalRepeatedBool ?? linq::Enumerable.Empty<bool>() }, // Optional
                    OptionalRepeatedEnum = { optionalRepeatedEnum ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>() }, // Optional
                    OptionalRepeatedString = { optionalRepeatedString ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedBytes = { optionalRepeatedBytes ?? linq::Enumerable.Empty<pb::ByteString>() }, // Optional
                    OptionalRepeatedMessage = { optionalRepeatedMessage ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>() }, // Optional
                    OptionalRepeatedResourceNameAsBookNameOneofs = { optionalRepeatedResourceName ?? linq::Enumerable.Empty<BookNameOneof>() }, // Optional
                    OptionalRepeatedResourceNameOneofAsBookNameOneofs = { optionalRepeatedResourceNameOneof ?? linq::Enumerable.Empty<BookNameOneof>() }, // Optional
                    OptionalRepeatedResourceNameCommon = { optionalRepeatedResourceNameCommon ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedFixed32 = { optionalRepeatedFixed32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedFixed64 = { optionalRepeatedFixed64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalMap = { optionalMap ?? gax::EmptyDictionary<int, string>.Instance }, // Optional
                    AnyValue = anyValue, // Optional
                    StructValue = structValue, // Optional
                    ValueValue = valueValue, // Optional
                    ListValueValue = listValueValue, // Optional
                    TimeValue = timeValue, // Optional
                    DurationValue = durationValue, // Optional
                    FieldMaskValue = fieldMaskValue, // Optional
                    Int32Value = int32Value, // Optional
                    Uint32Value = uint32Value, // Optional
                    Int64Value = int64Value, // Optional
                    Uint64Value = uint64Value, // Optional
                    FloatValue = floatValue, // Optional
                    DoubleValue = doubleValue, // Optional
                    StringValue = stringValue, // Optional
                    BoolValue = boolValue, // Optional
                    BytesValue = bytesValue, // Optional
                    RepeatedAnyValue = { repeatedAnyValue ?? linq::Enumerable.Empty<pbwkt::Any>() }, // Optional
                    RepeatedStructValue = { repeatedStructValue ?? linq::Enumerable.Empty<pbwkt::Struct>() }, // Optional
                    RepeatedValueValue = { repeatedValueValue ?? linq::Enumerable.Empty<pbwkt::Value>() }, // Optional
                    RepeatedListValueValue = { repeatedListValueValue ?? linq::Enumerable.Empty<pbwkt::ListValue>() }, // Optional
                    RepeatedTimeValue = { repeatedTimeValue ?? linq::Enumerable.Empty<pbwkt::Timestamp>() }, // Optional
                    RepeatedDurationValue = { repeatedDurationValue ?? linq::Enumerable.Empty<pbwkt::Duration>() }, // Optional
                    RepeatedFieldMaskValue = { repeatedFieldMaskValue ?? linq::Enumerable.Empty<pbwkt::FieldMask>() }, // Optional
                    RepeatedInt32Value = { repeatedInt32Value ?? linq::Enumerable.Empty<int?>() }, // Optional
                    RepeatedUint32Value = { repeatedUint32Value ?? linq::Enumerable.Empty<uint?>() }, // Optional
                    RepeatedInt64Value = { repeatedInt64Value ?? linq::Enumerable.Empty<long?>() }, // Optional
                    RepeatedUint64Value = { repeatedUint64Value ?? linq::Enumerable.Empty<ulong?>() }, // Optional
                    RepeatedFloatValue = { repeatedFloatValue ?? linq::Enumerable.Empty<float?>() }, // Optional
                    RepeatedDoubleValue = { repeatedDoubleValue ?? linq::Enumerable.Empty<double?>() }, // Optional
                    RepeatedStringValue = { repeatedStringValue ?? linq::Enumerable.Empty<string>() }, // Optional
                    RepeatedBoolValue = { repeatedBoolValue ?? linq::Enumerable.Empty<bool?>() }, // Optional
                    RepeatedBytesValue = { repeatedBytesValue ?? linq::Enumerable.Empty<pb::ByteString>() }, // Optional
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="requiredSingularInt32">
        ///
        /// </param>
        /// <param name="requiredSingularInt64">
        ///
        /// </param>
        /// <param name="requiredSingularFloat">
        ///
        /// </param>
        /// <param name="requiredSingularDouble">
        ///
        /// </param>
        /// <param name="requiredSingularBool">
        ///
        /// </param>
        /// <param name="requiredSingularEnum">
        ///
        /// </param>
        /// <param name="requiredSingularString">
        ///
        /// </param>
        /// <param name="requiredSingularBytes">
        ///
        /// </param>
        /// <param name="requiredSingularMessage">
        ///
        /// </param>
        /// <param name="requiredSingularResourceName">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredSingularFixed32">
        ///
        /// </param>
        /// <param name="requiredSingularFixed64">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloat">
        ///
        /// </param>
        /// <param name="requiredRepeatedDouble">
        ///
        /// </param>
        /// <param name="requiredRepeatedBool">
        ///
        /// </param>
        /// <param name="requiredRepeatedEnum">
        ///
        /// </param>
        /// <param name="requiredRepeatedString">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytes">
        ///
        /// </param>
        /// <param name="requiredRepeatedMessage">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceName">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed32">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed64">
        ///
        /// </param>
        /// <param name="requiredMap">
        ///
        /// </param>
        /// <param name="optionalSingularInt32">
        ///
        /// </param>
        /// <param name="optionalSingularInt64">
        ///
        /// </param>
        /// <param name="optionalSingularFloat">
        ///
        /// </param>
        /// <param name="optionalSingularDouble">
        ///
        /// </param>
        /// <param name="optionalSingularBool">
        ///
        /// </param>
        /// <param name="optionalSingularEnum">
        ///
        /// </param>
        /// <param name="optionalSingularString">
        ///
        /// </param>
        /// <param name="optionalSingularBytes">
        ///
        /// </param>
        /// <param name="optionalSingularMessage">
        ///
        /// </param>
        /// <param name="optionalSingularResourceName">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalSingularFixed32">
        ///
        /// </param>
        /// <param name="optionalSingularFixed64">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt32">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt64">
        ///
        /// </param>
        /// <param name="optionalRepeatedFloat">
        ///
        /// </param>
        /// <param name="optionalRepeatedDouble">
        ///
        /// </param>
        /// <param name="optionalRepeatedBool">
        ///
        /// </param>
        /// <param name="optionalRepeatedEnum">
        ///
        /// </param>
        /// <param name="optionalRepeatedString">
        ///
        /// </param>
        /// <param name="optionalRepeatedBytes">
        ///
        /// </param>
        /// <param name="optionalRepeatedMessage">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceName">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed32">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed64">
        ///
        /// </param>
        /// <param name="optionalMap">
        ///
        /// </param>
        /// <param name="anyValue">
        ///
        /// </param>
        /// <param name="structValue">
        ///
        /// </param>
        /// <param name="valueValue">
        ///
        /// </param>
        /// <param name="listValueValue">
        ///
        /// </param>
        /// <param name="timeValue">
        ///
        /// </param>
        /// <param name="durationValue">
        ///
        /// </param>
        /// <param name="fieldMaskValue">
        ///
        /// </param>
        /// <param name="int32Value">
        ///
        /// </param>
        /// <param name="uint32Value">
        ///
        /// </param>
        /// <param name="int64Value">
        ///
        /// </param>
        /// <param name="uint64Value">
        ///
        /// </param>
        /// <param name="floatValue">
        ///
        /// </param>
        /// <param name="doubleValue">
        ///
        /// </param>
        /// <param name="stringValue">
        ///
        /// </param>
        /// <param name="boolValue">
        ///
        /// </param>
        /// <param name="bytesValue">
        ///
        /// </param>
        /// <param name="repeatedAnyValue">
        ///
        /// </param>
        /// <param name="repeatedStructValue">
        ///
        /// </param>
        /// <param name="repeatedValueValue">
        ///
        /// </param>
        /// <param name="repeatedListValueValue">
        ///
        /// </param>
        /// <param name="repeatedTimeValue">
        ///
        /// </param>
        /// <param name="repeatedDurationValue">
        ///
        /// </param>
        /// <param name="repeatedFieldMaskValue">
        ///
        /// </param>
        /// <param name="repeatedInt32Value">
        ///
        /// </param>
        /// <param name="repeatedUint32Value">
        ///
        /// </param>
        /// <param name="repeatedInt64Value">
        ///
        /// </param>
        /// <param name="repeatedUint64Value">
        ///
        /// </param>
        /// <param name="repeatedFloatValue">
        ///
        /// </param>
        /// <param name="repeatedDoubleValue">
        ///
        /// </param>
        /// <param name="repeatedStringValue">
        ///
        /// </param>
        /// <param name="repeatedBoolValue">
        ///
        /// </param>
        /// <param name="repeatedBytesValue">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            int requiredSingularInt32,
            long requiredSingularInt64,
            float requiredSingularFloat,
            double requiredSingularDouble,
            bool requiredSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum,
            string requiredSingularString,
            pb::ByteString requiredSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage,
            string requiredSingularResourceName,
            string requiredSingularResourceNameOneof,
            string requiredSingularResourceNameCommon,
            int requiredSingularFixed32,
            long requiredSingularFixed64,
            scg::IEnumerable<int> requiredRepeatedInt32,
            scg::IEnumerable<long> requiredRepeatedInt64,
            scg::IEnumerable<float> requiredRepeatedFloat,
            scg::IEnumerable<double> requiredRepeatedDouble,
            scg::IEnumerable<bool> requiredRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum,
            scg::IEnumerable<string> requiredRepeatedString,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage,
            scg::IEnumerable<string> requiredRepeatedResourceName,
            scg::IEnumerable<string> requiredRepeatedResourceNameOneof,
            scg::IEnumerable<string> requiredRepeatedResourceNameCommon,
            scg::IEnumerable<int> requiredRepeatedFixed32,
            scg::IEnumerable<long> requiredRepeatedFixed64,
            scg::IDictionary<int, string> requiredMap,
            int? optionalSingularInt32,
            long? optionalSingularInt64,
            float? optionalSingularFloat,
            double? optionalSingularDouble,
            bool? optionalSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum? optionalSingularEnum,
            string optionalSingularString,
            pb::ByteString optionalSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage,
            string optionalSingularResourceName,
            string optionalSingularResourceNameOneof,
            string optionalSingularResourceNameCommon,
            int? optionalSingularFixed32,
            long? optionalSingularFixed64,
            scg::IEnumerable<int> optionalRepeatedInt32,
            scg::IEnumerable<long> optionalRepeatedInt64,
            scg::IEnumerable<float> optionalRepeatedFloat,
            scg::IEnumerable<double> optionalRepeatedDouble,
            scg::IEnumerable<bool> optionalRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum,
            scg::IEnumerable<string> optionalRepeatedString,
            scg::IEnumerable<pb::ByteString> optionalRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage,
            scg::IEnumerable<string> optionalRepeatedResourceName,
            scg::IEnumerable<string> optionalRepeatedResourceNameOneof,
            scg::IEnumerable<string> optionalRepeatedResourceNameCommon,
            scg::IEnumerable<int> optionalRepeatedFixed32,
            scg::IEnumerable<long> optionalRepeatedFixed64,
            scg::IDictionary<int, string> optionalMap,
            pbwkt::Any anyValue,
            pbwkt::Struct structValue,
            pbwkt::Value valueValue,
            pbwkt::ListValue listValueValue,
            pbwkt::Timestamp timeValue,
            pbwkt::Duration durationValue,
            pbwkt::FieldMask fieldMaskValue,
            int? int32Value,
            uint? uint32Value,
            long? int64Value,
            ulong? uint64Value,
            float? floatValue,
            double? doubleValue,
            string stringValue,
            bool? boolValue,
            pb::ByteString bytesValue,
            scg::IEnumerable<pbwkt::Any> repeatedAnyValue,
            scg::IEnumerable<pbwkt::Struct> repeatedStructValue,
            scg::IEnumerable<pbwkt::Value> repeatedValueValue,
            scg::IEnumerable<pbwkt::ListValue> repeatedListValueValue,
            scg::IEnumerable<pbwkt::Timestamp> repeatedTimeValue,
            scg::IEnumerable<pbwkt::Duration> repeatedDurationValue,
            scg::IEnumerable<pbwkt::FieldMask> repeatedFieldMaskValue,
            scg::IEnumerable<int?> repeatedInt32Value,
            scg::IEnumerable<uint?> repeatedUint32Value,
            scg::IEnumerable<long?> repeatedInt64Value,
            scg::IEnumerable<ulong?> repeatedUint64Value,
            scg::IEnumerable<float?> repeatedFloatValue,
            scg::IEnumerable<double?> repeatedDoubleValue,
            scg::IEnumerable<string> repeatedStringValue,
            scg::IEnumerable<bool?> repeatedBoolValue,
            scg::IEnumerable<pb::ByteString> repeatedBytesValue,
            gaxgrpc::CallSettings callSettings = null) => TestOptionalRequiredFlatteningParamsAsync(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                    RequiredSingularInt32 = requiredSingularInt32,
                    RequiredSingularInt64 = requiredSingularInt64,
                    RequiredSingularFloat = requiredSingularFloat,
                    RequiredSingularDouble = requiredSingularDouble,
                    RequiredSingularBool = requiredSingularBool,
                    RequiredSingularEnum = requiredSingularEnum,
                    RequiredSingularString = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularString, nameof(requiredSingularString)),
                    RequiredSingularBytes = gax::GaxPreconditions.CheckNotNull(requiredSingularBytes, nameof(requiredSingularBytes)),
                    RequiredSingularMessage = gax::GaxPreconditions.CheckNotNull(requiredSingularMessage, nameof(requiredSingularMessage)),
                    RequiredSingularResourceName = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularResourceName, nameof(requiredSingularResourceName)),
                    RequiredSingularResourceNameOneof = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularResourceNameOneof, nameof(requiredSingularResourceNameOneof)),
                    RequiredSingularResourceNameCommon = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularResourceNameCommon, nameof(requiredSingularResourceNameCommon)),
                    RequiredSingularFixed32 = requiredSingularFixed32,
                    RequiredSingularFixed64 = requiredSingularFixed64,
                    RequiredRepeatedInt32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt32, nameof(requiredRepeatedInt32)) },
                    RequiredRepeatedInt64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt64, nameof(requiredRepeatedInt64)) },
                    RequiredRepeatedFloat = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFloat, nameof(requiredRepeatedFloat)) },
                    RequiredRepeatedDouble = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedDouble, nameof(requiredRepeatedDouble)) },
                    RequiredRepeatedBool = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBool, nameof(requiredRepeatedBool)) },
                    RequiredRepeatedEnum = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedEnum, nameof(requiredRepeatedEnum)) },
                    RequiredRepeatedString = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedString, nameof(requiredRepeatedString)) },
                    RequiredRepeatedBytes = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBytes, nameof(requiredRepeatedBytes)) },
                    RequiredRepeatedMessage = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedMessage, nameof(requiredRepeatedMessage)) },
                    RequiredRepeatedResourceName = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceName, nameof(requiredRepeatedResourceName)) },
                    RequiredRepeatedResourceNameOneof = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameOneof, nameof(requiredRepeatedResourceNameOneof)) },
                    RequiredRepeatedResourceNameCommon = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameCommon, nameof(requiredRepeatedResourceNameCommon)) },
                    RequiredRepeatedFixed32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed32, nameof(requiredRepeatedFixed32)) },
                    RequiredRepeatedFixed64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed64, nameof(requiredRepeatedFixed64)) },
                    RequiredMap = { gax::GaxPreconditions.CheckNotNull(requiredMap, nameof(requiredMap)) },
                    OptionalSingularInt32 = optionalSingularInt32 ?? 0, // Optional
                    OptionalSingularInt64 = optionalSingularInt64 ?? 0L, // Optional
                    OptionalSingularFloat = optionalSingularFloat ?? 0.0f, // Optional
                    OptionalSingularDouble = optionalSingularDouble ?? 0.0, // Optional
                    OptionalSingularBool = optionalSingularBool ?? false, // Optional
                    OptionalSingularEnum = optionalSingularEnum ?? TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero, // Optional
                    OptionalSingularString = optionalSingularString ?? "", // Optional
                    OptionalSingularBytes = optionalSingularBytes ?? pb::ByteString.Empty, // Optional
                    OptionalSingularMessage = optionalSingularMessage, // Optional
                    OptionalSingularResourceName = optionalSingularResourceName ?? "", // Optional
                    OptionalSingularResourceNameOneof = optionalSingularResourceNameOneof ?? "", // Optional
                    OptionalSingularResourceNameCommon = optionalSingularResourceNameCommon ?? "", // Optional
                    OptionalSingularFixed32 = optionalSingularFixed32 ?? 0, // Optional
                    OptionalSingularFixed64 = optionalSingularFixed64 ?? 0L, // Optional
                    OptionalRepeatedInt32 = { optionalRepeatedInt32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedInt64 = { optionalRepeatedInt64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalRepeatedFloat = { optionalRepeatedFloat ?? linq::Enumerable.Empty<float>() }, // Optional
                    OptionalRepeatedDouble = { optionalRepeatedDouble ?? linq::Enumerable.Empty<double>() }, // Optional
                    OptionalRepeatedBool = { optionalRepeatedBool ?? linq::Enumerable.Empty<bool>() }, // Optional
                    OptionalRepeatedEnum = { optionalRepeatedEnum ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>() }, // Optional
                    OptionalRepeatedString = { optionalRepeatedString ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedBytes = { optionalRepeatedBytes ?? linq::Enumerable.Empty<pb::ByteString>() }, // Optional
                    OptionalRepeatedMessage = { optionalRepeatedMessage ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>() }, // Optional
                    OptionalRepeatedResourceName = { optionalRepeatedResourceName ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedResourceNameOneof = { optionalRepeatedResourceNameOneof ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedResourceNameCommon = { optionalRepeatedResourceNameCommon ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedFixed32 = { optionalRepeatedFixed32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedFixed64 = { optionalRepeatedFixed64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalMap = { optionalMap ?? gax::EmptyDictionary<int, string>.Instance }, // Optional
                    AnyValue = anyValue, // Optional
                    StructValue = structValue, // Optional
                    ValueValue = valueValue, // Optional
                    ListValueValue = listValueValue, // Optional
                    TimeValue = timeValue, // Optional
                    DurationValue = durationValue, // Optional
                    FieldMaskValue = fieldMaskValue, // Optional
                    Int32Value = int32Value, // Optional
                    Uint32Value = uint32Value, // Optional
                    Int64Value = int64Value, // Optional
                    Uint64Value = uint64Value, // Optional
                    FloatValue = floatValue, // Optional
                    DoubleValue = doubleValue, // Optional
                    StringValue = stringValue, // Optional
                    BoolValue = boolValue, // Optional
                    BytesValue = bytesValue, // Optional
                    RepeatedAnyValue = { repeatedAnyValue ?? linq::Enumerable.Empty<pbwkt::Any>() }, // Optional
                    RepeatedStructValue = { repeatedStructValue ?? linq::Enumerable.Empty<pbwkt::Struct>() }, // Optional
                    RepeatedValueValue = { repeatedValueValue ?? linq::Enumerable.Empty<pbwkt::Value>() }, // Optional
                    RepeatedListValueValue = { repeatedListValueValue ?? linq::Enumerable.Empty<pbwkt::ListValue>() }, // Optional
                    RepeatedTimeValue = { repeatedTimeValue ?? linq::Enumerable.Empty<pbwkt::Timestamp>() }, // Optional
                    RepeatedDurationValue = { repeatedDurationValue ?? linq::Enumerable.Empty<pbwkt::Duration>() }, // Optional
                    RepeatedFieldMaskValue = { repeatedFieldMaskValue ?? linq::Enumerable.Empty<pbwkt::FieldMask>() }, // Optional
                    RepeatedInt32Value = { repeatedInt32Value ?? linq::Enumerable.Empty<int?>() }, // Optional
                    RepeatedUint32Value = { repeatedUint32Value ?? linq::Enumerable.Empty<uint?>() }, // Optional
                    RepeatedInt64Value = { repeatedInt64Value ?? linq::Enumerable.Empty<long?>() }, // Optional
                    RepeatedUint64Value = { repeatedUint64Value ?? linq::Enumerable.Empty<ulong?>() }, // Optional
                    RepeatedFloatValue = { repeatedFloatValue ?? linq::Enumerable.Empty<float?>() }, // Optional
                    RepeatedDoubleValue = { repeatedDoubleValue ?? linq::Enumerable.Empty<double?>() }, // Optional
                    RepeatedStringValue = { repeatedStringValue ?? linq::Enumerable.Empty<string>() }, // Optional
                    RepeatedBoolValue = { repeatedBoolValue ?? linq::Enumerable.Empty<bool?>() }, // Optional
                    RepeatedBytesValue = { repeatedBytesValue ?? linq::Enumerable.Empty<pb::ByteString>() }, // Optional
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="requiredSingularInt32">
        ///
        /// </param>
        /// <param name="requiredSingularInt64">
        ///
        /// </param>
        /// <param name="requiredSingularFloat">
        ///
        /// </param>
        /// <param name="requiredSingularDouble">
        ///
        /// </param>
        /// <param name="requiredSingularBool">
        ///
        /// </param>
        /// <param name="requiredSingularEnum">
        ///
        /// </param>
        /// <param name="requiredSingularString">
        ///
        /// </param>
        /// <param name="requiredSingularBytes">
        ///
        /// </param>
        /// <param name="requiredSingularMessage">
        ///
        /// </param>
        /// <param name="requiredSingularResourceName">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredSingularFixed32">
        ///
        /// </param>
        /// <param name="requiredSingularFixed64">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloat">
        ///
        /// </param>
        /// <param name="requiredRepeatedDouble">
        ///
        /// </param>
        /// <param name="requiredRepeatedBool">
        ///
        /// </param>
        /// <param name="requiredRepeatedEnum">
        ///
        /// </param>
        /// <param name="requiredRepeatedString">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytes">
        ///
        /// </param>
        /// <param name="requiredRepeatedMessage">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceName">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed32">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed64">
        ///
        /// </param>
        /// <param name="requiredMap">
        ///
        /// </param>
        /// <param name="optionalSingularInt32">
        ///
        /// </param>
        /// <param name="optionalSingularInt64">
        ///
        /// </param>
        /// <param name="optionalSingularFloat">
        ///
        /// </param>
        /// <param name="optionalSingularDouble">
        ///
        /// </param>
        /// <param name="optionalSingularBool">
        ///
        /// </param>
        /// <param name="optionalSingularEnum">
        ///
        /// </param>
        /// <param name="optionalSingularString">
        ///
        /// </param>
        /// <param name="optionalSingularBytes">
        ///
        /// </param>
        /// <param name="optionalSingularMessage">
        ///
        /// </param>
        /// <param name="optionalSingularResourceName">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalSingularFixed32">
        ///
        /// </param>
        /// <param name="optionalSingularFixed64">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt32">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt64">
        ///
        /// </param>
        /// <param name="optionalRepeatedFloat">
        ///
        /// </param>
        /// <param name="optionalRepeatedDouble">
        ///
        /// </param>
        /// <param name="optionalRepeatedBool">
        ///
        /// </param>
        /// <param name="optionalRepeatedEnum">
        ///
        /// </param>
        /// <param name="optionalRepeatedString">
        ///
        /// </param>
        /// <param name="optionalRepeatedBytes">
        ///
        /// </param>
        /// <param name="optionalRepeatedMessage">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceName">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed32">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed64">
        ///
        /// </param>
        /// <param name="optionalMap">
        ///
        /// </param>
        /// <param name="anyValue">
        ///
        /// </param>
        /// <param name="structValue">
        ///
        /// </param>
        /// <param name="valueValue">
        ///
        /// </param>
        /// <param name="listValueValue">
        ///
        /// </param>
        /// <param name="timeValue">
        ///
        /// </param>
        /// <param name="durationValue">
        ///
        /// </param>
        /// <param name="fieldMaskValue">
        ///
        /// </param>
        /// <param name="int32Value">
        ///
        /// </param>
        /// <param name="uint32Value">
        ///
        /// </param>
        /// <param name="int64Value">
        ///
        /// </param>
        /// <param name="uint64Value">
        ///
        /// </param>
        /// <param name="floatValue">
        ///
        /// </param>
        /// <param name="doubleValue">
        ///
        /// </param>
        /// <param name="stringValue">
        ///
        /// </param>
        /// <param name="boolValue">
        ///
        /// </param>
        /// <param name="bytesValue">
        ///
        /// </param>
        /// <param name="repeatedAnyValue">
        ///
        /// </param>
        /// <param name="repeatedStructValue">
        ///
        /// </param>
        /// <param name="repeatedValueValue">
        ///
        /// </param>
        /// <param name="repeatedListValueValue">
        ///
        /// </param>
        /// <param name="repeatedTimeValue">
        ///
        /// </param>
        /// <param name="repeatedDurationValue">
        ///
        /// </param>
        /// <param name="repeatedFieldMaskValue">
        ///
        /// </param>
        /// <param name="repeatedInt32Value">
        ///
        /// </param>
        /// <param name="repeatedUint32Value">
        ///
        /// </param>
        /// <param name="repeatedInt64Value">
        ///
        /// </param>
        /// <param name="repeatedUint64Value">
        ///
        /// </param>
        /// <param name="repeatedFloatValue">
        ///
        /// </param>
        /// <param name="repeatedDoubleValue">
        ///
        /// </param>
        /// <param name="repeatedStringValue">
        ///
        /// </param>
        /// <param name="repeatedBoolValue">
        ///
        /// </param>
        /// <param name="repeatedBytesValue">
        ///
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            int requiredSingularInt32,
            long requiredSingularInt64,
            float requiredSingularFloat,
            double requiredSingularDouble,
            bool requiredSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum,
            string requiredSingularString,
            pb::ByteString requiredSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage,
            string requiredSingularResourceName,
            string requiredSingularResourceNameOneof,
            string requiredSingularResourceNameCommon,
            int requiredSingularFixed32,
            long requiredSingularFixed64,
            scg::IEnumerable<int> requiredRepeatedInt32,
            scg::IEnumerable<long> requiredRepeatedInt64,
            scg::IEnumerable<float> requiredRepeatedFloat,
            scg::IEnumerable<double> requiredRepeatedDouble,
            scg::IEnumerable<bool> requiredRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum,
            scg::IEnumerable<string> requiredRepeatedString,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage,
            scg::IEnumerable<string> requiredRepeatedResourceName,
            scg::IEnumerable<string> requiredRepeatedResourceNameOneof,
            scg::IEnumerable<string> requiredRepeatedResourceNameCommon,
            scg::IEnumerable<int> requiredRepeatedFixed32,
            scg::IEnumerable<long> requiredRepeatedFixed64,
            scg::IDictionary<int, string> requiredMap,
            int? optionalSingularInt32,
            long? optionalSingularInt64,
            float? optionalSingularFloat,
            double? optionalSingularDouble,
            bool? optionalSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum? optionalSingularEnum,
            string optionalSingularString,
            pb::ByteString optionalSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage,
            string optionalSingularResourceName,
            string optionalSingularResourceNameOneof,
            string optionalSingularResourceNameCommon,
            int? optionalSingularFixed32,
            long? optionalSingularFixed64,
            scg::IEnumerable<int> optionalRepeatedInt32,
            scg::IEnumerable<long> optionalRepeatedInt64,
            scg::IEnumerable<float> optionalRepeatedFloat,
            scg::IEnumerable<double> optionalRepeatedDouble,
            scg::IEnumerable<bool> optionalRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum,
            scg::IEnumerable<string> optionalRepeatedString,
            scg::IEnumerable<pb::ByteString> optionalRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage,
            scg::IEnumerable<string> optionalRepeatedResourceName,
            scg::IEnumerable<string> optionalRepeatedResourceNameOneof,
            scg::IEnumerable<string> optionalRepeatedResourceNameCommon,
            scg::IEnumerable<int> optionalRepeatedFixed32,
            scg::IEnumerable<long> optionalRepeatedFixed64,
            scg::IDictionary<int, string> optionalMap,
            pbwkt::Any anyValue,
            pbwkt::Struct structValue,
            pbwkt::Value valueValue,
            pbwkt::ListValue listValueValue,
            pbwkt::Timestamp timeValue,
            pbwkt::Duration durationValue,
            pbwkt::FieldMask fieldMaskValue,
            int? int32Value,
            uint? uint32Value,
            long? int64Value,
            ulong? uint64Value,
            float? floatValue,
            double? doubleValue,
            string stringValue,
            bool? boolValue,
            pb::ByteString bytesValue,
            scg::IEnumerable<pbwkt::Any> repeatedAnyValue,
            scg::IEnumerable<pbwkt::Struct> repeatedStructValue,
            scg::IEnumerable<pbwkt::Value> repeatedValueValue,
            scg::IEnumerable<pbwkt::ListValue> repeatedListValueValue,
            scg::IEnumerable<pbwkt::Timestamp> repeatedTimeValue,
            scg::IEnumerable<pbwkt::Duration> repeatedDurationValue,
            scg::IEnumerable<pbwkt::FieldMask> repeatedFieldMaskValue,
            scg::IEnumerable<int?> repeatedInt32Value,
            scg::IEnumerable<uint?> repeatedUint32Value,
            scg::IEnumerable<long?> repeatedInt64Value,
            scg::IEnumerable<ulong?> repeatedUint64Value,
            scg::IEnumerable<float?> repeatedFloatValue,
            scg::IEnumerable<double?> repeatedDoubleValue,
            scg::IEnumerable<string> repeatedStringValue,
            scg::IEnumerable<bool?> repeatedBoolValue,
            scg::IEnumerable<pb::ByteString> repeatedBytesValue,
            st::CancellationToken cancellationToken) => TestOptionalRequiredFlatteningParamsAsync(
                requiredSingularInt32,
                requiredSingularInt64,
                requiredSingularFloat,
                requiredSingularDouble,
                requiredSingularBool,
                requiredSingularEnum,
                requiredSingularString,
                requiredSingularBytes,
                requiredSingularMessage,
                requiredSingularResourceName,
                requiredSingularResourceNameOneof,
                requiredSingularResourceNameCommon,
                requiredSingularFixed32,
                requiredSingularFixed64,
                requiredRepeatedInt32,
                requiredRepeatedInt64,
                requiredRepeatedFloat,
                requiredRepeatedDouble,
                requiredRepeatedBool,
                requiredRepeatedEnum,
                requiredRepeatedString,
                requiredRepeatedBytes,
                requiredRepeatedMessage,
                requiredRepeatedResourceName,
                requiredRepeatedResourceNameOneof,
                requiredRepeatedResourceNameCommon,
                requiredRepeatedFixed32,
                requiredRepeatedFixed64,
                requiredMap,
                optionalSingularInt32,
                optionalSingularInt64,
                optionalSingularFloat,
                optionalSingularDouble,
                optionalSingularBool,
                optionalSingularEnum,
                optionalSingularString,
                optionalSingularBytes,
                optionalSingularMessage,
                optionalSingularResourceName,
                optionalSingularResourceNameOneof,
                optionalSingularResourceNameCommon,
                optionalSingularFixed32,
                optionalSingularFixed64,
                optionalRepeatedInt32,
                optionalRepeatedInt64,
                optionalRepeatedFloat,
                optionalRepeatedDouble,
                optionalRepeatedBool,
                optionalRepeatedEnum,
                optionalRepeatedString,
                optionalRepeatedBytes,
                optionalRepeatedMessage,
                optionalRepeatedResourceName,
                optionalRepeatedResourceNameOneof,
                optionalRepeatedResourceNameCommon,
                optionalRepeatedFixed32,
                optionalRepeatedFixed64,
                optionalMap,
                anyValue,
                structValue,
                valueValue,
                listValueValue,
                timeValue,
                durationValue,
                fieldMaskValue,
                int32Value,
                uint32Value,
                int64Value,
                uint64Value,
                floatValue,
                doubleValue,
                stringValue,
                boolValue,
                bytesValue,
                repeatedAnyValue,
                repeatedStructValue,
                repeatedValueValue,
                repeatedListValueValue,
                repeatedTimeValue,
                repeatedDurationValue,
                repeatedFieldMaskValue,
                repeatedInt32Value,
                repeatedUint32Value,
                repeatedInt64Value,
                repeatedUint64Value,
                repeatedFloatValue,
                repeatedDoubleValue,
                repeatedStringValue,
                repeatedBoolValue,
                repeatedBytesValue,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="requiredSingularInt32">
        ///
        /// </param>
        /// <param name="requiredSingularInt64">
        ///
        /// </param>
        /// <param name="requiredSingularFloat">
        ///
        /// </param>
        /// <param name="requiredSingularDouble">
        ///
        /// </param>
        /// <param name="requiredSingularBool">
        ///
        /// </param>
        /// <param name="requiredSingularEnum">
        ///
        /// </param>
        /// <param name="requiredSingularString">
        ///
        /// </param>
        /// <param name="requiredSingularBytes">
        ///
        /// </param>
        /// <param name="requiredSingularMessage">
        ///
        /// </param>
        /// <param name="requiredSingularResourceName">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredSingularFixed32">
        ///
        /// </param>
        /// <param name="requiredSingularFixed64">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt32">
        ///
        /// </param>
        /// <param name="requiredRepeatedInt64">
        ///
        /// </param>
        /// <param name="requiredRepeatedFloat">
        ///
        /// </param>
        /// <param name="requiredRepeatedDouble">
        ///
        /// </param>
        /// <param name="requiredRepeatedBool">
        ///
        /// </param>
        /// <param name="requiredRepeatedEnum">
        ///
        /// </param>
        /// <param name="requiredRepeatedString">
        ///
        /// </param>
        /// <param name="requiredRepeatedBytes">
        ///
        /// </param>
        /// <param name="requiredRepeatedMessage">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceName">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="requiredRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed32">
        ///
        /// </param>
        /// <param name="requiredRepeatedFixed64">
        ///
        /// </param>
        /// <param name="requiredMap">
        ///
        /// </param>
        /// <param name="optionalSingularInt32">
        ///
        /// </param>
        /// <param name="optionalSingularInt64">
        ///
        /// </param>
        /// <param name="optionalSingularFloat">
        ///
        /// </param>
        /// <param name="optionalSingularDouble">
        ///
        /// </param>
        /// <param name="optionalSingularBool">
        ///
        /// </param>
        /// <param name="optionalSingularEnum">
        ///
        /// </param>
        /// <param name="optionalSingularString">
        ///
        /// </param>
        /// <param name="optionalSingularBytes">
        ///
        /// </param>
        /// <param name="optionalSingularMessage">
        ///
        /// </param>
        /// <param name="optionalSingularResourceName">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalSingularResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalSingularFixed32">
        ///
        /// </param>
        /// <param name="optionalSingularFixed64">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt32">
        ///
        /// </param>
        /// <param name="optionalRepeatedInt64">
        ///
        /// </param>
        /// <param name="optionalRepeatedFloat">
        ///
        /// </param>
        /// <param name="optionalRepeatedDouble">
        ///
        /// </param>
        /// <param name="optionalRepeatedBool">
        ///
        /// </param>
        /// <param name="optionalRepeatedEnum">
        ///
        /// </param>
        /// <param name="optionalRepeatedString">
        ///
        /// </param>
        /// <param name="optionalRepeatedBytes">
        ///
        /// </param>
        /// <param name="optionalRepeatedMessage">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceName">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameOneof">
        ///
        /// </param>
        /// <param name="optionalRepeatedResourceNameCommon">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed32">
        ///
        /// </param>
        /// <param name="optionalRepeatedFixed64">
        ///
        /// </param>
        /// <param name="optionalMap">
        ///
        /// </param>
        /// <param name="anyValue">
        ///
        /// </param>
        /// <param name="structValue">
        ///
        /// </param>
        /// <param name="valueValue">
        ///
        /// </param>
        /// <param name="listValueValue">
        ///
        /// </param>
        /// <param name="timeValue">
        ///
        /// </param>
        /// <param name="durationValue">
        ///
        /// </param>
        /// <param name="fieldMaskValue">
        ///
        /// </param>
        /// <param name="int32Value">
        ///
        /// </param>
        /// <param name="uint32Value">
        ///
        /// </param>
        /// <param name="int64Value">
        ///
        /// </param>
        /// <param name="uint64Value">
        ///
        /// </param>
        /// <param name="floatValue">
        ///
        /// </param>
        /// <param name="doubleValue">
        ///
        /// </param>
        /// <param name="stringValue">
        ///
        /// </param>
        /// <param name="boolValue">
        ///
        /// </param>
        /// <param name="bytesValue">
        ///
        /// </param>
        /// <param name="repeatedAnyValue">
        ///
        /// </param>
        /// <param name="repeatedStructValue">
        ///
        /// </param>
        /// <param name="repeatedValueValue">
        ///
        /// </param>
        /// <param name="repeatedListValueValue">
        ///
        /// </param>
        /// <param name="repeatedTimeValue">
        ///
        /// </param>
        /// <param name="repeatedDurationValue">
        ///
        /// </param>
        /// <param name="repeatedFieldMaskValue">
        ///
        /// </param>
        /// <param name="repeatedInt32Value">
        ///
        /// </param>
        /// <param name="repeatedUint32Value">
        ///
        /// </param>
        /// <param name="repeatedInt64Value">
        ///
        /// </param>
        /// <param name="repeatedUint64Value">
        ///
        /// </param>
        /// <param name="repeatedFloatValue">
        ///
        /// </param>
        /// <param name="repeatedDoubleValue">
        ///
        /// </param>
        /// <param name="repeatedStringValue">
        ///
        /// </param>
        /// <param name="repeatedBoolValue">
        ///
        /// </param>
        /// <param name="repeatedBytesValue">
        ///
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual TestOptionalRequiredFlatteningParamsResponse TestOptionalRequiredFlatteningParams(
            int requiredSingularInt32,
            long requiredSingularInt64,
            float requiredSingularFloat,
            double requiredSingularDouble,
            bool requiredSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum requiredSingularEnum,
            string requiredSingularString,
            pb::ByteString requiredSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage requiredSingularMessage,
            string requiredSingularResourceName,
            string requiredSingularResourceNameOneof,
            string requiredSingularResourceNameCommon,
            int requiredSingularFixed32,
            long requiredSingularFixed64,
            scg::IEnumerable<int> requiredRepeatedInt32,
            scg::IEnumerable<long> requiredRepeatedInt64,
            scg::IEnumerable<float> requiredRepeatedFloat,
            scg::IEnumerable<double> requiredRepeatedDouble,
            scg::IEnumerable<bool> requiredRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> requiredRepeatedEnum,
            scg::IEnumerable<string> requiredRepeatedString,
            scg::IEnumerable<pb::ByteString> requiredRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> requiredRepeatedMessage,
            scg::IEnumerable<string> requiredRepeatedResourceName,
            scg::IEnumerable<string> requiredRepeatedResourceNameOneof,
            scg::IEnumerable<string> requiredRepeatedResourceNameCommon,
            scg::IEnumerable<int> requiredRepeatedFixed32,
            scg::IEnumerable<long> requiredRepeatedFixed64,
            scg::IDictionary<int, string> requiredMap,
            int? optionalSingularInt32,
            long? optionalSingularInt64,
            float? optionalSingularFloat,
            double? optionalSingularDouble,
            bool? optionalSingularBool,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum? optionalSingularEnum,
            string optionalSingularString,
            pb::ByteString optionalSingularBytes,
            TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage optionalSingularMessage,
            string optionalSingularResourceName,
            string optionalSingularResourceNameOneof,
            string optionalSingularResourceNameCommon,
            int? optionalSingularFixed32,
            long? optionalSingularFixed64,
            scg::IEnumerable<int> optionalRepeatedInt32,
            scg::IEnumerable<long> optionalRepeatedInt64,
            scg::IEnumerable<float> optionalRepeatedFloat,
            scg::IEnumerable<double> optionalRepeatedDouble,
            scg::IEnumerable<bool> optionalRepeatedBool,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum> optionalRepeatedEnum,
            scg::IEnumerable<string> optionalRepeatedString,
            scg::IEnumerable<pb::ByteString> optionalRepeatedBytes,
            scg::IEnumerable<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage> optionalRepeatedMessage,
            scg::IEnumerable<string> optionalRepeatedResourceName,
            scg::IEnumerable<string> optionalRepeatedResourceNameOneof,
            scg::IEnumerable<string> optionalRepeatedResourceNameCommon,
            scg::IEnumerable<int> optionalRepeatedFixed32,
            scg::IEnumerable<long> optionalRepeatedFixed64,
            scg::IDictionary<int, string> optionalMap,
            pbwkt::Any anyValue,
            pbwkt::Struct structValue,
            pbwkt::Value valueValue,
            pbwkt::ListValue listValueValue,
            pbwkt::Timestamp timeValue,
            pbwkt::Duration durationValue,
            pbwkt::FieldMask fieldMaskValue,
            int? int32Value,
            uint? uint32Value,
            long? int64Value,
            ulong? uint64Value,
            float? floatValue,
            double? doubleValue,
            string stringValue,
            bool? boolValue,
            pb::ByteString bytesValue,
            scg::IEnumerable<pbwkt::Any> repeatedAnyValue,
            scg::IEnumerable<pbwkt::Struct> repeatedStructValue,
            scg::IEnumerable<pbwkt::Value> repeatedValueValue,
            scg::IEnumerable<pbwkt::ListValue> repeatedListValueValue,
            scg::IEnumerable<pbwkt::Timestamp> repeatedTimeValue,
            scg::IEnumerable<pbwkt::Duration> repeatedDurationValue,
            scg::IEnumerable<pbwkt::FieldMask> repeatedFieldMaskValue,
            scg::IEnumerable<int?> repeatedInt32Value,
            scg::IEnumerable<uint?> repeatedUint32Value,
            scg::IEnumerable<long?> repeatedInt64Value,
            scg::IEnumerable<ulong?> repeatedUint64Value,
            scg::IEnumerable<float?> repeatedFloatValue,
            scg::IEnumerable<double?> repeatedDoubleValue,
            scg::IEnumerable<string> repeatedStringValue,
            scg::IEnumerable<bool?> repeatedBoolValue,
            scg::IEnumerable<pb::ByteString> repeatedBytesValue,
            gaxgrpc::CallSettings callSettings = null) => TestOptionalRequiredFlatteningParams(
                new TestOptionalRequiredFlatteningParamsRequest
                {
                    RequiredSingularInt32 = requiredSingularInt32,
                    RequiredSingularInt64 = requiredSingularInt64,
                    RequiredSingularFloat = requiredSingularFloat,
                    RequiredSingularDouble = requiredSingularDouble,
                    RequiredSingularBool = requiredSingularBool,
                    RequiredSingularEnum = requiredSingularEnum,
                    RequiredSingularString = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularString, nameof(requiredSingularString)),
                    RequiredSingularBytes = gax::GaxPreconditions.CheckNotNull(requiredSingularBytes, nameof(requiredSingularBytes)),
                    RequiredSingularMessage = gax::GaxPreconditions.CheckNotNull(requiredSingularMessage, nameof(requiredSingularMessage)),
                    RequiredSingularResourceName = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularResourceName, nameof(requiredSingularResourceName)),
                    RequiredSingularResourceNameOneof = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularResourceNameOneof, nameof(requiredSingularResourceNameOneof)),
                    RequiredSingularResourceNameCommon = gax::GaxPreconditions.CheckNotNullOrEmpty(requiredSingularResourceNameCommon, nameof(requiredSingularResourceNameCommon)),
                    RequiredSingularFixed32 = requiredSingularFixed32,
                    RequiredSingularFixed64 = requiredSingularFixed64,
                    RequiredRepeatedInt32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt32, nameof(requiredRepeatedInt32)) },
                    RequiredRepeatedInt64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedInt64, nameof(requiredRepeatedInt64)) },
                    RequiredRepeatedFloat = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFloat, nameof(requiredRepeatedFloat)) },
                    RequiredRepeatedDouble = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedDouble, nameof(requiredRepeatedDouble)) },
                    RequiredRepeatedBool = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBool, nameof(requiredRepeatedBool)) },
                    RequiredRepeatedEnum = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedEnum, nameof(requiredRepeatedEnum)) },
                    RequiredRepeatedString = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedString, nameof(requiredRepeatedString)) },
                    RequiredRepeatedBytes = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedBytes, nameof(requiredRepeatedBytes)) },
                    RequiredRepeatedMessage = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedMessage, nameof(requiredRepeatedMessage)) },
                    RequiredRepeatedResourceName = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceName, nameof(requiredRepeatedResourceName)) },
                    RequiredRepeatedResourceNameOneof = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameOneof, nameof(requiredRepeatedResourceNameOneof)) },
                    RequiredRepeatedResourceNameCommon = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedResourceNameCommon, nameof(requiredRepeatedResourceNameCommon)) },
                    RequiredRepeatedFixed32 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed32, nameof(requiredRepeatedFixed32)) },
                    RequiredRepeatedFixed64 = { gax::GaxPreconditions.CheckNotNull(requiredRepeatedFixed64, nameof(requiredRepeatedFixed64)) },
                    RequiredMap = { gax::GaxPreconditions.CheckNotNull(requiredMap, nameof(requiredMap)) },
                    OptionalSingularInt32 = optionalSingularInt32 ?? 0, // Optional
                    OptionalSingularInt64 = optionalSingularInt64 ?? 0L, // Optional
                    OptionalSingularFloat = optionalSingularFloat ?? 0.0f, // Optional
                    OptionalSingularDouble = optionalSingularDouble ?? 0.0, // Optional
                    OptionalSingularBool = optionalSingularBool ?? false, // Optional
                    OptionalSingularEnum = optionalSingularEnum ?? TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum.Zero, // Optional
                    OptionalSingularString = optionalSingularString ?? "", // Optional
                    OptionalSingularBytes = optionalSingularBytes ?? pb::ByteString.Empty, // Optional
                    OptionalSingularMessage = optionalSingularMessage, // Optional
                    OptionalSingularResourceName = optionalSingularResourceName ?? "", // Optional
                    OptionalSingularResourceNameOneof = optionalSingularResourceNameOneof ?? "", // Optional
                    OptionalSingularResourceNameCommon = optionalSingularResourceNameCommon ?? "", // Optional
                    OptionalSingularFixed32 = optionalSingularFixed32 ?? 0, // Optional
                    OptionalSingularFixed64 = optionalSingularFixed64 ?? 0L, // Optional
                    OptionalRepeatedInt32 = { optionalRepeatedInt32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedInt64 = { optionalRepeatedInt64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalRepeatedFloat = { optionalRepeatedFloat ?? linq::Enumerable.Empty<float>() }, // Optional
                    OptionalRepeatedDouble = { optionalRepeatedDouble ?? linq::Enumerable.Empty<double>() }, // Optional
                    OptionalRepeatedBool = { optionalRepeatedBool ?? linq::Enumerable.Empty<bool>() }, // Optional
                    OptionalRepeatedEnum = { optionalRepeatedEnum ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerEnum>() }, // Optional
                    OptionalRepeatedString = { optionalRepeatedString ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedBytes = { optionalRepeatedBytes ?? linq::Enumerable.Empty<pb::ByteString>() }, // Optional
                    OptionalRepeatedMessage = { optionalRepeatedMessage ?? linq::Enumerable.Empty<TestOptionalRequiredFlatteningParamsRequest.Types.InnerMessage>() }, // Optional
                    OptionalRepeatedResourceName = { optionalRepeatedResourceName ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedResourceNameOneof = { optionalRepeatedResourceNameOneof ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedResourceNameCommon = { optionalRepeatedResourceNameCommon ?? linq::Enumerable.Empty<string>() }, // Optional
                    OptionalRepeatedFixed32 = { optionalRepeatedFixed32 ?? linq::Enumerable.Empty<int>() }, // Optional
                    OptionalRepeatedFixed64 = { optionalRepeatedFixed64 ?? linq::Enumerable.Empty<long>() }, // Optional
                    OptionalMap = { optionalMap ?? gax::EmptyDictionary<int, string>.Instance }, // Optional
                    AnyValue = anyValue, // Optional
                    StructValue = structValue, // Optional
                    ValueValue = valueValue, // Optional
                    ListValueValue = listValueValue, // Optional
                    TimeValue = timeValue, // Optional
                    DurationValue = durationValue, // Optional
                    FieldMaskValue = fieldMaskValue, // Optional
                    Int32Value = int32Value, // Optional
                    Uint32Value = uint32Value, // Optional
                    Int64Value = int64Value, // Optional
                    Uint64Value = uint64Value, // Optional
                    FloatValue = floatValue, // Optional
                    DoubleValue = doubleValue, // Optional
                    StringValue = stringValue, // Optional
                    BoolValue = boolValue, // Optional
                    BytesValue = bytesValue, // Optional
                    RepeatedAnyValue = { repeatedAnyValue ?? linq::Enumerable.Empty<pbwkt::Any>() }, // Optional
                    RepeatedStructValue = { repeatedStructValue ?? linq::Enumerable.Empty<pbwkt::Struct>() }, // Optional
                    RepeatedValueValue = { repeatedValueValue ?? linq::Enumerable.Empty<pbwkt::Value>() }, // Optional
                    RepeatedListValueValue = { repeatedListValueValue ?? linq::Enumerable.Empty<pbwkt::ListValue>() }, // Optional
                    RepeatedTimeValue = { repeatedTimeValue ?? linq::Enumerable.Empty<pbwkt::Timestamp>() }, // Optional
                    RepeatedDurationValue = { repeatedDurationValue ?? linq::Enumerable.Empty<pbwkt::Duration>() }, // Optional
                    RepeatedFieldMaskValue = { repeatedFieldMaskValue ?? linq::Enumerable.Empty<pbwkt::FieldMask>() }, // Optional
                    RepeatedInt32Value = { repeatedInt32Value ?? linq::Enumerable.Empty<int?>() }, // Optional
                    RepeatedUint32Value = { repeatedUint32Value ?? linq::Enumerable.Empty<uint?>() }, // Optional
                    RepeatedInt64Value = { repeatedInt64Value ?? linq::Enumerable.Empty<long?>() }, // Optional
                    RepeatedUint64Value = { repeatedUint64Value ?? linq::Enumerable.Empty<ulong?>() }, // Optional
                    RepeatedFloatValue = { repeatedFloatValue ?? linq::Enumerable.Empty<float?>() }, // Optional
                    RepeatedDoubleValue = { repeatedDoubleValue ?? linq::Enumerable.Empty<double?>() }, // Optional
                    RepeatedStringValue = { repeatedStringValue ?? linq::Enumerable.Empty<string>() }, // Optional
                    RepeatedBoolValue = { repeatedBoolValue ?? linq::Enumerable.Empty<bool?>() }, // Optional
                    RepeatedBytesValue = { repeatedBytesValue ?? linq::Enumerable.Empty<pb::ByteString>() }, // Optional
                },
                callSettings);

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            TestOptionalRequiredFlatteningParamsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            TestOptionalRequiredFlatteningParamsRequest request,
            st::CancellationToken cancellationToken) => TestOptionalRequiredFlatteningParamsAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual TestOptionalRequiredFlatteningParamsResponse TestOptionalRequiredFlatteningParams(
            TestOptionalRequiredFlatteningParamsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// This method is not exposed in the GAPIC config. It should be generated.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> PrivateListShelvesAsync(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        /// This method is not exposed in the GAPIC config. It should be generated.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<Book> PrivateListShelvesAsync(
            ListShelvesRequest request,
            st::CancellationToken cancellationToken) => PrivateListShelvesAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        /// This method is not exposed in the GAPIC config. It should be generated.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual Book PrivateListShelves(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

    }

    /// <summary>
    /// LibraryService client wrapper implementation, for convenient use.
    /// </summary>
    public sealed partial class LibraryServiceClientImpl : LibraryServiceClient
    {
        private readonly gaxgrpc::ApiCall<CreateShelfRequest, Shelf> _callCreateShelf;
        private readonly gaxgrpc::ApiCall<GetShelfRequest, Shelf> _callGetShelf;
        private readonly gaxgrpc::ApiCall<ListShelvesRequest, ListShelvesResponse> _callListShelves;
        private readonly gaxgrpc::ApiCall<DeleteShelfRequest, pbwkt::Empty> _callDeleteShelf;
        private readonly gaxgrpc::ApiCall<MergeShelvesRequest, Shelf> _callMergeShelves;
        private readonly gaxgrpc::ApiCall<CreateBookRequest, Book> _callCreateBook;
        private readonly gaxgrpc::ApiCall<PublishSeriesRequest, PublishSeriesResponse> _callPublishSeries;
        private readonly gaxgrpc::ApiCall<GetBookRequest, Book> _callGetBook;
        private readonly gaxgrpc::ApiCall<ListBooksRequest, ListBooksResponse> _callListBooks;
        private readonly gaxgrpc::ApiCall<DeleteBookRequest, pbwkt::Empty> _callDeleteBook;
        private readonly gaxgrpc::ApiCall<UpdateBookRequest, Book> _callUpdateBook;
        private readonly gaxgrpc::ApiCall<MoveBookRequest, Book> _callMoveBook;
        private readonly gaxgrpc::ApiCall<ListStringsRequest, ListStringsResponse> _callListStrings;
        private readonly gaxgrpc::ApiCall<AddCommentsRequest, pbwkt::Empty> _callAddComments;
        private readonly gaxgrpc::ApiCall<GetBookFromArchiveRequest, BookFromArchive> _callGetBookFromArchive;
        private readonly gaxgrpc::ApiCall<GetBookFromAnywhereRequest, BookFromAnywhere> _callGetBookFromAnywhere;
        private readonly gaxgrpc::ApiCall<GetBookFromAbsolutelyAnywhereRequest, BookFromAnywhere> _callGetBookFromAbsolutelyAnywhere;
        private readonly gaxgrpc::ApiCall<UpdateBookIndexRequest, pbwkt::Empty> _callUpdateBookIndex;
        private readonly gaxgrpc::ApiServerStreamingCall<StreamShelvesRequest, StreamShelvesResponse> _callStreamShelves;
        private readonly gaxgrpc::ApiServerStreamingCall<StreamBooksRequest, Book> _callStreamBooks;
        private readonly gaxgrpc::ApiBidirectionalStreamingCall<DiscussBookRequest, Comment> _callDiscussBook;
        private readonly gaxgrpc::ApiCall<FindRelatedBooksRequest, FindRelatedBooksResponse> _callFindRelatedBooks;
        private readonly gaxgrpc::ApiCall<gtv::AddLabelRequest, gtv::AddLabelResponse> _callAddLabel;
        private readonly gaxgrpc::ApiCall<GetBookRequest, lro::Operation> _callGetBigBook;
        private readonly gaxgrpc::ApiCall<GetBookRequest, lro::Operation> _callGetBigNothing;
        private readonly gaxgrpc::ApiCall<TestOptionalRequiredFlatteningParamsRequest, TestOptionalRequiredFlatteningParamsResponse> _callTestOptionalRequiredFlatteningParams;
        private readonly gaxgrpc::ApiCall<ListShelvesRequest, Book> _callPrivateListShelves;

        /// <summary>
        /// Constructs a client wrapper for the LibraryService service, with the specified gRPC client and settings.
        /// </summary>
        /// <param name="grpcClient">The underlying gRPC client.</param>
        /// <param name="settings">The base <see cref="LibraryServiceSettings"/> used within this client </param>
        public LibraryServiceClientImpl(LibraryService.LibraryServiceClient grpcClient, LibraryServiceSettings settings)
        {
            GrpcClient = grpcClient;
            LibraryServiceSettings effectiveSettings = settings ?? LibraryServiceSettings.GetDefault();
            gaxgrpc::ClientHelper clientHelper = new gaxgrpc::ClientHelper(effectiveSettings);
            gctv::Labeler.LabelerClient grpcLabelerClient = grpcClient.CreateLabelerClient();
            GetBigBookOperationsClient = new lro::OperationsClientImpl(
                grpcClient.CreateOperationsClient(), effectiveSettings.GetBigBookOperationsSettings);
            GetBigNothingOperationsClient = new lro::OperationsClientImpl(
                grpcClient.CreateOperationsClient(), effectiveSettings.GetBigNothingOperationsSettings);
            _callCreateShelf = clientHelper.BuildApiCall<CreateShelfRequest, Shelf>(
                GrpcClient.CreateShelfAsync, GrpcClient.CreateShelf, effectiveSettings.CreateShelfSettings);
            _callGetShelf = clientHelper.BuildApiCall<GetShelfRequest, Shelf>(
                GrpcClient.GetShelfAsync, GrpcClient.GetShelf, effectiveSettings.GetShelfSettings)
                .WithCallSettingsOverlay(request => gaxgrpc::CallSettings.FromHeader("x-goog-request-params", $"name={request.Name}"));
            _callListShelves = clientHelper.BuildApiCall<ListShelvesRequest, ListShelvesResponse>(
                GrpcClient.ListShelvesAsync, GrpcClient.ListShelves, effectiveSettings.ListShelvesSettings);
            _callDeleteShelf = clientHelper.BuildApiCall<DeleteShelfRequest, pbwkt::Empty>(
                GrpcClient.DeleteShelfAsync, GrpcClient.DeleteShelf, effectiveSettings.DeleteShelfSettings)
                .WithCallSettingsOverlay(request => gaxgrpc::CallSettings.FromHeader("x-goog-request-params", $"name={request.Name}"));
            _callMergeShelves = clientHelper.BuildApiCall<MergeShelvesRequest, Shelf>(
                GrpcClient.MergeShelvesAsync, GrpcClient.MergeShelves, effectiveSettings.MergeShelvesSettings)
                .WithCallSettingsOverlay(request => gaxgrpc::CallSettings.FromHeader("x-goog-request-params", $"name={request.Name}"));
            _callCreateBook = clientHelper.BuildApiCall<CreateBookRequest, Book>(
                GrpcClient.CreateBookAsync, GrpcClient.CreateBook, effectiveSettings.CreateBookSettings)
                .WithCallSettingsOverlay(request => gaxgrpc::CallSettings.FromHeader("x-goog-request-params", $"name={request.Name}"));
            _callPublishSeries = clientHelper.BuildApiCall<PublishSeriesRequest, PublishSeriesResponse>(
                GrpcClient.PublishSeriesAsync, GrpcClient.PublishSeries, effectiveSettings.PublishSeriesSettings)
                .WithCallSettingsOverlay(request => gaxgrpc::CallSettings.FromHeader("x-goog-request-params", $"shelf.name={request.Shelf.Name}"));
            _callGetBook = clientHelper.BuildApiCall<GetBookRequest, Book>(
                GrpcClient.GetBookAsync, GrpcClient.GetBook, effectiveSettings.GetBookSettings)
                .WithCallSettingsOverlay(request => gaxgrpc::CallSettings.FromHeader("x-goog-request-params", $"name={request.Name}"));
            _callListBooks = clientHelper.BuildApiCall<ListBooksRequest, ListBooksResponse>(
                GrpcClient.ListBooksAsync, GrpcClient.ListBooks, effectiveSettings.ListBooksSettings)
                .WithCallSettingsOverlay(request => gaxgrpc::CallSettings.FromHeader("x-goog-request-params", $"name={request.Name}"));
            _callDeleteBook = clientHelper.BuildApiCall<DeleteBookRequest, pbwkt::Empty>(
                GrpcClient.DeleteBookAsync, GrpcClient.DeleteBook, effectiveSettings.DeleteBookSettings)
                .WithCallSettingsOverlay(request => gaxgrpc::CallSettings.FromHeader("x-goog-request-params", $"name={request.Name}"));
            _callUpdateBook = clientHelper.BuildApiCall<UpdateBookRequest, Book>(
                GrpcClient.UpdateBookAsync, GrpcClient.UpdateBook, effectiveSettings.UpdateBookSettings)
                .WithCallSettingsOverlay(request => gaxgrpc::CallSettings.FromHeader("x-goog-request-params", $"name={request.Name}"));
            _callMoveBook = clientHelper.BuildApiCall<MoveBookRequest, Book>(
                GrpcClient.MoveBookAsync, GrpcClient.MoveBook, effectiveSettings.MoveBookSettings)
                .WithCallSettingsOverlay(request => gaxgrpc::CallSettings.FromHeader("x-goog-request-params", $"name={request.Name}"));
            _callListStrings = clientHelper.BuildApiCall<ListStringsRequest, ListStringsResponse>(
                GrpcClient.ListStringsAsync, GrpcClient.ListStrings, effectiveSettings.ListStringsSettings);
            _callAddComments = clientHelper.BuildApiCall<AddCommentsRequest, pbwkt::Empty>(
                GrpcClient.AddCommentsAsync, GrpcClient.AddComments, effectiveSettings.AddCommentsSettings)
                .WithCallSettingsOverlay(request => gaxgrpc::CallSettings.FromHeader("x-goog-request-params", $"name={request.Name}"));
            _callGetBookFromArchive = clientHelper.BuildApiCall<GetBookFromArchiveRequest, BookFromArchive>(
                GrpcClient.GetBookFromArchiveAsync, GrpcClient.GetBookFromArchive, effectiveSettings.GetBookFromArchiveSettings)
                .WithCallSettingsOverlay(request => gaxgrpc::CallSettings.FromHeader("x-goog-request-params", $"name={request.Name}"));
            _callGetBookFromAnywhere = clientHelper.BuildApiCall<GetBookFromAnywhereRequest, BookFromAnywhere>(
                GrpcClient.GetBookFromAnywhereAsync, GrpcClient.GetBookFromAnywhere, effectiveSettings.GetBookFromAnywhereSettings)
                .WithCallSettingsOverlay(request => gaxgrpc::CallSettings.FromHeader("x-goog-request-params", $"name={request.Name}"));
            _callGetBookFromAbsolutelyAnywhere = clientHelper.BuildApiCall<GetBookFromAbsolutelyAnywhereRequest, BookFromAnywhere>(
                GrpcClient.GetBookFromAbsolutelyAnywhereAsync, GrpcClient.GetBookFromAbsolutelyAnywhere, effectiveSettings.GetBookFromAbsolutelyAnywhereSettings)
                .WithCallSettingsOverlay(request => gaxgrpc::CallSettings.FromHeader("x-goog-request-params", $"name={request.Name}&alt_book_name={request.AltBookName}"));
            _callUpdateBookIndex = clientHelper.BuildApiCall<UpdateBookIndexRequest, pbwkt::Empty>(
                GrpcClient.UpdateBookIndexAsync, GrpcClient.UpdateBookIndex, effectiveSettings.UpdateBookIndexSettings)
                .WithCallSettingsOverlay(request => gaxgrpc::CallSettings.FromHeader("x-goog-request-params", $"name={request.Name}"));
            _callStreamShelves = clientHelper.BuildApiCall<StreamShelvesRequest, StreamShelvesResponse>(
                GrpcClient.StreamShelves, effectiveSettings.StreamShelvesSettings);
            _callStreamBooks = clientHelper.BuildApiCall<StreamBooksRequest, Book>(
                GrpcClient.StreamBooks, effectiveSettings.StreamBooksSettings);
            _callDiscussBook = clientHelper.BuildApiCall<DiscussBookRequest, Comment>(
                GrpcClient.DiscussBook, effectiveSettings.DiscussBookSettings, effectiveSettings.DiscussBookStreamingSettings);
            _callFindRelatedBooks = clientHelper.BuildApiCall<FindRelatedBooksRequest, FindRelatedBooksResponse>(
                GrpcClient.FindRelatedBooksAsync, GrpcClient.FindRelatedBooks, effectiveSettings.FindRelatedBooksSettings);
            _callAddLabel = clientHelper.BuildApiCall<gtv::AddLabelRequest, gtv::AddLabelResponse>(
                grpcLabelerClient.AddLabelAsync, grpcLabelerClient.AddLabel, effectiveSettings.AddLabelSettings)
                .WithCallSettingsOverlay(request => gaxgrpc::CallSettings.FromHeader("x-goog-request-params", $"resource={request.Resource}"));
            _callGetBigBook = clientHelper.BuildApiCall<GetBookRequest, lro::Operation>(
                GrpcClient.GetBigBookAsync, GrpcClient.GetBigBook, effectiveSettings.GetBigBookSettings)
                .WithCallSettingsOverlay(request => gaxgrpc::CallSettings.FromHeader("x-goog-request-params", $"name={request.Name}"));
            _callGetBigNothing = clientHelper.BuildApiCall<GetBookRequest, lro::Operation>(
                GrpcClient.GetBigNothingAsync, GrpcClient.GetBigNothing, effectiveSettings.GetBigNothingSettings)
                .WithCallSettingsOverlay(request => gaxgrpc::CallSettings.FromHeader("x-goog-request-params", $"name={request.Name}"));
            _callTestOptionalRequiredFlatteningParams = clientHelper.BuildApiCall<TestOptionalRequiredFlatteningParamsRequest, TestOptionalRequiredFlatteningParamsResponse>(
                GrpcClient.TestOptionalRequiredFlatteningParamsAsync, GrpcClient.TestOptionalRequiredFlatteningParams, effectiveSettings.TestOptionalRequiredFlatteningParamsSettings);
            _callPrivateListShelves = clientHelper.BuildApiCall<ListShelvesRequest, Book>(
                GrpcClient.PrivateListShelvesAsync, GrpcClient.PrivateListShelves, effectiveSettings.PrivateListShelvesSettings);
            Modify_ApiCall(ref _callCreateShelf);
            Modify_CreateShelfApiCall(ref _callCreateShelf);
            Modify_ApiCall(ref _callGetShelf);
            Modify_GetShelfApiCall(ref _callGetShelf);
            Modify_ApiCall(ref _callListShelves);
            Modify_ListShelvesApiCall(ref _callListShelves);
            Modify_ApiCall(ref _callDeleteShelf);
            Modify_DeleteShelfApiCall(ref _callDeleteShelf);
            Modify_ApiCall(ref _callMergeShelves);
            Modify_MergeShelvesApiCall(ref _callMergeShelves);
            Modify_ApiCall(ref _callCreateBook);
            Modify_CreateBookApiCall(ref _callCreateBook);
            Modify_ApiCall(ref _callPublishSeries);
            Modify_PublishSeriesApiCall(ref _callPublishSeries);
            Modify_ApiCall(ref _callGetBook);
            Modify_GetBookApiCall(ref _callGetBook);
            Modify_ApiCall(ref _callListBooks);
            Modify_ListBooksApiCall(ref _callListBooks);
            Modify_ApiCall(ref _callDeleteBook);
            Modify_DeleteBookApiCall(ref _callDeleteBook);
            Modify_ApiCall(ref _callUpdateBook);
            Modify_UpdateBookApiCall(ref _callUpdateBook);
            Modify_ApiCall(ref _callMoveBook);
            Modify_MoveBookApiCall(ref _callMoveBook);
            Modify_ApiCall(ref _callListStrings);
            Modify_ListStringsApiCall(ref _callListStrings);
            Modify_ApiCall(ref _callAddComments);
            Modify_AddCommentsApiCall(ref _callAddComments);
            Modify_ApiCall(ref _callGetBookFromArchive);
            Modify_GetBookFromArchiveApiCall(ref _callGetBookFromArchive);
            Modify_ApiCall(ref _callGetBookFromAnywhere);
            Modify_GetBookFromAnywhereApiCall(ref _callGetBookFromAnywhere);
            Modify_ApiCall(ref _callGetBookFromAbsolutelyAnywhere);
            Modify_GetBookFromAbsolutelyAnywhereApiCall(ref _callGetBookFromAbsolutelyAnywhere);
            Modify_ApiCall(ref _callUpdateBookIndex);
            Modify_UpdateBookIndexApiCall(ref _callUpdateBookIndex);
            Modify_ApiCall(ref _callStreamShelves);
            Modify_StreamShelvesApiCall(ref _callStreamShelves);
            Modify_ApiCall(ref _callStreamBooks);
            Modify_StreamBooksApiCall(ref _callStreamBooks);
            Modify_ApiCall(ref _callDiscussBook);
            Modify_DiscussBookApiCall(ref _callDiscussBook);
            Modify_ApiCall(ref _callFindRelatedBooks);
            Modify_FindRelatedBooksApiCall(ref _callFindRelatedBooks);
            Modify_ApiCall(ref _callAddLabel);
            Modify_AddLabelApiCall(ref _callAddLabel);
            Modify_ApiCall(ref _callGetBigBook);
            Modify_GetBigBookApiCall(ref _callGetBigBook);
            Modify_ApiCall(ref _callGetBigNothing);
            Modify_GetBigNothingApiCall(ref _callGetBigNothing);
            Modify_ApiCall(ref _callTestOptionalRequiredFlatteningParams);
            Modify_TestOptionalRequiredFlatteningParamsApiCall(ref _callTestOptionalRequiredFlatteningParams);
            Modify_ApiCall(ref _callPrivateListShelves);
            Modify_PrivateListShelvesApiCall(ref _callPrivateListShelves);
            OnConstruction(grpcClient, effectiveSettings, clientHelper);
        }

        // Partial methods are named to (mostly) ensure there cannot be conflicts with RPC method names.

        // Partial methods called for every ApiCall on construction.
        // Allows modification of all the underlying ApiCall objects.
        partial void Modify_ApiCall<TRequest, TResponse>(ref gaxgrpc::ApiCall<TRequest, TResponse> call)
            where TRequest : class, pb::IMessage<TRequest>
            where TResponse : class, pb::IMessage<TResponse>;
        partial void Modify_ApiCall<TRequest, TResponse>(ref gaxgrpc::ApiServerStreamingCall<TRequest, TResponse> call)
            where TRequest : class, pb::IMessage<TRequest>
            where TResponse : class, pb::IMessage<TResponse>;
        partial void Modify_ApiCall<TRequest, TResponse>(ref gaxgrpc::ApiBidirectionalStreamingCall<TRequest, TResponse> call)
            where TRequest : class, pb::IMessage<TRequest>
            where TResponse : class, pb::IMessage<TResponse>;

        // Partial methods called for each ApiCall on construction.
        // Allows per-RPC-method modification of the underlying ApiCall object.
        partial void Modify_CreateShelfApiCall(ref gaxgrpc::ApiCall<CreateShelfRequest, Shelf> call);
        partial void Modify_GetShelfApiCall(ref gaxgrpc::ApiCall<GetShelfRequest, Shelf> call);
        partial void Modify_ListShelvesApiCall(ref gaxgrpc::ApiCall<ListShelvesRequest, ListShelvesResponse> call);
        partial void Modify_DeleteShelfApiCall(ref gaxgrpc::ApiCall<DeleteShelfRequest, pbwkt::Empty> call);
        partial void Modify_MergeShelvesApiCall(ref gaxgrpc::ApiCall<MergeShelvesRequest, Shelf> call);
        partial void Modify_CreateBookApiCall(ref gaxgrpc::ApiCall<CreateBookRequest, Book> call);
        partial void Modify_PublishSeriesApiCall(ref gaxgrpc::ApiCall<PublishSeriesRequest, PublishSeriesResponse> call);
        partial void Modify_GetBookApiCall(ref gaxgrpc::ApiCall<GetBookRequest, Book> call);
        partial void Modify_ListBooksApiCall(ref gaxgrpc::ApiCall<ListBooksRequest, ListBooksResponse> call);
        partial void Modify_DeleteBookApiCall(ref gaxgrpc::ApiCall<DeleteBookRequest, pbwkt::Empty> call);
        partial void Modify_UpdateBookApiCall(ref gaxgrpc::ApiCall<UpdateBookRequest, Book> call);
        partial void Modify_MoveBookApiCall(ref gaxgrpc::ApiCall<MoveBookRequest, Book> call);
        partial void Modify_ListStringsApiCall(ref gaxgrpc::ApiCall<ListStringsRequest, ListStringsResponse> call);
        partial void Modify_AddCommentsApiCall(ref gaxgrpc::ApiCall<AddCommentsRequest, pbwkt::Empty> call);
        partial void Modify_GetBookFromArchiveApiCall(ref gaxgrpc::ApiCall<GetBookFromArchiveRequest, BookFromArchive> call);
        partial void Modify_GetBookFromAnywhereApiCall(ref gaxgrpc::ApiCall<GetBookFromAnywhereRequest, BookFromAnywhere> call);
        partial void Modify_GetBookFromAbsolutelyAnywhereApiCall(ref gaxgrpc::ApiCall<GetBookFromAbsolutelyAnywhereRequest, BookFromAnywhere> call);
        partial void Modify_UpdateBookIndexApiCall(ref gaxgrpc::ApiCall<UpdateBookIndexRequest, pbwkt::Empty> call);
        partial void Modify_StreamShelvesApiCall(ref gaxgrpc::ApiServerStreamingCall<StreamShelvesRequest, StreamShelvesResponse> call);
        partial void Modify_StreamBooksApiCall(ref gaxgrpc::ApiServerStreamingCall<StreamBooksRequest, Book> call);
        partial void Modify_DiscussBookApiCall(ref gaxgrpc::ApiBidirectionalStreamingCall<DiscussBookRequest, Comment> call);
        partial void Modify_FindRelatedBooksApiCall(ref gaxgrpc::ApiCall<FindRelatedBooksRequest, FindRelatedBooksResponse> call);
        partial void Modify_AddLabelApiCall(ref gaxgrpc::ApiCall<gtv::AddLabelRequest, gtv::AddLabelResponse> call);
        partial void Modify_GetBigBookApiCall(ref gaxgrpc::ApiCall<GetBookRequest, lro::Operation> call);
        partial void Modify_GetBigNothingApiCall(ref gaxgrpc::ApiCall<GetBookRequest, lro::Operation> call);
        partial void Modify_TestOptionalRequiredFlatteningParamsApiCall(ref gaxgrpc::ApiCall<TestOptionalRequiredFlatteningParamsRequest, TestOptionalRequiredFlatteningParamsResponse> call);
        partial void Modify_PrivateListShelvesApiCall(ref gaxgrpc::ApiCall<ListShelvesRequest, Book> call);
        partial void OnConstruction(LibraryService.LibraryServiceClient grpcClient, LibraryServiceSettings effectiveSettings, gaxgrpc::ClientHelper clientHelper);

        /// <summary>
        /// The underlying gRPC LibraryService client.
        /// </summary>
        public override LibraryService.LibraryServiceClient GrpcClient { get; }

        // Partial methods called on each request.
        // Allows per-RPC-call modification to the request and CallSettings objects,
        // before the underlying RPC is performed.
        partial void Modify_CreateShelfRequest(ref CreateShelfRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_GetShelfRequest(ref GetShelfRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_ListShelvesRequest(ref ListShelvesRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_DeleteShelfRequest(ref DeleteShelfRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_MergeShelvesRequest(ref MergeShelvesRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_CreateBookRequest(ref CreateBookRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_PublishSeriesRequest(ref PublishSeriesRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_GetBookRequest(ref GetBookRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_ListBooksRequest(ref ListBooksRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_DeleteBookRequest(ref DeleteBookRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_UpdateBookRequest(ref UpdateBookRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_MoveBookRequest(ref MoveBookRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_ListStringsRequest(ref ListStringsRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_AddCommentsRequest(ref AddCommentsRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_GetBookFromArchiveRequest(ref GetBookFromArchiveRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_GetBookFromAnywhereRequest(ref GetBookFromAnywhereRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_GetBookFromAbsolutelyAnywhereRequest(ref GetBookFromAbsolutelyAnywhereRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_UpdateBookIndexRequest(ref UpdateBookIndexRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_StreamShelvesRequest(ref StreamShelvesRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_StreamBooksRequest(ref StreamBooksRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_DiscussBookRequestCallSettings(ref gaxgrpc::CallSettings settings);
        partial void Modify_DiscussBookRequestRequest(ref DiscussBookRequest request);
        partial void Modify_FindRelatedBooksRequest(ref FindRelatedBooksRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_AddLabelRequest(ref gtv::AddLabelRequest request, ref gaxgrpc::CallSettings settings);
        partial void Modify_TestOptionalRequiredFlatteningParamsRequest(ref TestOptionalRequiredFlatteningParamsRequest request, ref gaxgrpc::CallSettings settings);

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Shelf> CreateShelfAsync(
            CreateShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_CreateShelfRequest(ref request, ref callSettings);
            return _callCreateShelf.Async(request, callSettings);
        }

        /// <summary>
        /// Creates a shelf, and returns the new Shelf.
        /// RPC method comment may include special characters: &lt;&gt;&amp;"`'@.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Shelf CreateShelf(
            CreateShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_CreateShelfRequest(ref request, ref callSettings);
            return _callCreateShelf.Sync(request, callSettings);
        }

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Shelf> GetShelfAsync(
            GetShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetShelfRequest(ref request, ref callSettings);
            return _callGetShelf.Async(request, callSettings);
        }

        /// <summary>
        /// Gets a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Shelf GetShelf(
            GetShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetShelfRequest(ref request, ref callSettings);
            return _callGetShelf.Sync(request, callSettings);
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public override gax::PagedAsyncEnumerable<ListShelvesResponse, Shelf> ListShelvesAsync(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListShelvesRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedAsyncEnumerable<ListShelvesRequest, ListShelvesResponse, Shelf>(_callListShelves, request, callSettings);
        }

        /// <summary>
        /// Lists shelves.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Shelf"/> resources.
        /// </returns>
        public override gax::PagedEnumerable<ListShelvesResponse, Shelf> ListShelves(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListShelvesRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedEnumerable<ListShelvesRequest, ListShelvesResponse, Shelf>(_callListShelves, request, callSettings);
        }

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public override stt::Task DeleteShelfAsync(
            DeleteShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_DeleteShelfRequest(ref request, ref callSettings);
            return _callDeleteShelf.Async(request, callSettings);
        }

        /// <summary>
        /// Deletes a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public override void DeleteShelf(
            DeleteShelfRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_DeleteShelfRequest(ref request, ref callSettings);
            _callDeleteShelf.Sync(request, callSettings);
        }

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Shelf> MergeShelvesAsync(
            MergeShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MergeShelvesRequest(ref request, ref callSettings);
            return _callMergeShelves.Async(request, callSettings);
        }

        /// <summary>
        /// Merges two shelves by adding all books from the shelf named
        /// `other_shelf_name` to shelf `name`, and deletes
        /// `other_shelf_name`. Returns the updated shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Shelf MergeShelves(
            MergeShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MergeShelvesRequest(ref request, ref callSettings);
            return _callMergeShelves.Sync(request, callSettings);
        }

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Book> CreateBookAsync(
            CreateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_CreateBookRequest(ref request, ref callSettings);
            return _callCreateBook.Async(request, callSettings);
        }

        /// <summary>
        /// Creates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Book CreateBook(
            CreateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_CreateBookRequest(ref request, ref callSettings);
            return _callCreateBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<PublishSeriesResponse> PublishSeriesAsync(
            PublishSeriesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_PublishSeriesRequest(ref request, ref callSettings);
            return _callPublishSeries.Async(request, callSettings);
        }

        /// <summary>
        /// Creates a series of books.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override PublishSeriesResponse PublishSeries(
            PublishSeriesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_PublishSeriesRequest(ref request, ref callSettings);
            return _callPublishSeries.Sync(request, callSettings);
        }

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Book> GetBookAsync(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return _callGetBook.Async(request, callSettings);
        }

        /// <summary>
        /// Gets a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Book GetBook(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return _callGetBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="Book"/> resources.
        /// </returns>
        public override gax::PagedAsyncEnumerable<ListBooksResponse, Book> ListBooksAsync(
            ListBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListBooksRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedAsyncEnumerable<ListBooksRequest, ListBooksResponse, Book>(_callListBooks, request, callSettings);
        }

        /// <summary>
        /// Lists books in a shelf.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="Book"/> resources.
        /// </returns>
        public override gax::PagedEnumerable<ListBooksResponse, Book> ListBooks(
            ListBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListBooksRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedEnumerable<ListBooksRequest, ListBooksResponse, Book>(_callListBooks, request, callSettings);
        }

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public override stt::Task DeleteBookAsync(
            DeleteBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_DeleteBookRequest(ref request, ref callSettings);
            return _callDeleteBook.Async(request, callSettings);
        }

        /// <summary>
        /// Deletes a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public override void DeleteBook(
            DeleteBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_DeleteBookRequest(ref request, ref callSettings);
            _callDeleteBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Book> UpdateBookAsync(
            UpdateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_UpdateBookRequest(ref request, ref callSettings);
            return _callUpdateBook.Async(request, callSettings);
        }

        /// <summary>
        /// Updates a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Book UpdateBook(
            UpdateBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_UpdateBookRequest(ref request, ref callSettings);
            return _callUpdateBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Book> MoveBookAsync(
            MoveBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MoveBookRequest(ref request, ref callSettings);
            return _callMoveBook.Async(request, callSettings);
        }

        /// <summary>
        /// Moves a book to another shelf, and returns the new book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Book MoveBook(
            MoveBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MoveBookRequest(ref request, ref callSettings);
            return _callMoveBook.Sync(request, callSettings);
        }

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public override gax::PagedAsyncEnumerable<ListStringsResponse, IResourceName> ListStringsAsync(
            ListStringsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListStringsRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedAsyncEnumerable<ListStringsRequest, ListStringsResponse, IResourceName>(_callListStrings, request, callSettings);
        }

        /// <summary>
        /// Lists a primitive resource. To test go page streaming.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public override gax::PagedEnumerable<ListStringsResponse, IResourceName> ListStrings(
            ListStringsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListStringsRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedEnumerable<ListStringsRequest, ListStringsResponse, IResourceName>(_callListStrings, request, callSettings);
        }

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public override stt::Task AddCommentsAsync(
            AddCommentsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_AddCommentsRequest(ref request, ref callSettings);
            return _callAddComments.Async(request, callSettings);
        }

        /// <summary>
        /// Adds comments to a book
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public override void AddComments(
            AddCommentsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_AddCommentsRequest(ref request, ref callSettings);
            _callAddComments.Sync(request, callSettings);
        }

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<BookFromArchive> GetBookFromArchiveAsync(
            GetBookFromArchiveRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookFromArchiveRequest(ref request, ref callSettings);
            return _callGetBookFromArchive.Async(request, callSettings);
        }

        /// <summary>
        /// Gets a book from an archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override BookFromArchive GetBookFromArchive(
            GetBookFromArchiveRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookFromArchiveRequest(ref request, ref callSettings);
            return _callGetBookFromArchive.Sync(request, callSettings);
        }

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<BookFromAnywhere> GetBookFromAnywhereAsync(
            GetBookFromAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookFromAnywhereRequest(ref request, ref callSettings);
            return _callGetBookFromAnywhere.Async(request, callSettings);
        }

        /// <summary>
        /// Gets a book from a shelf or archive.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override BookFromAnywhere GetBookFromAnywhere(
            GetBookFromAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookFromAnywhereRequest(ref request, ref callSettings);
            return _callGetBookFromAnywhere.Sync(request, callSettings);
        }

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<BookFromAnywhere> GetBookFromAbsolutelyAnywhereAsync(
            GetBookFromAbsolutelyAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookFromAbsolutelyAnywhereRequest(ref request, ref callSettings);
            return _callGetBookFromAbsolutelyAnywhere.Async(request, callSettings);
        }

        /// <summary>
        /// Test proper OneOf-Any resource name mapping
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override BookFromAnywhere GetBookFromAbsolutelyAnywhere(
            GetBookFromAbsolutelyAnywhereRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookFromAbsolutelyAnywhereRequest(ref request, ref callSettings);
            return _callGetBookFromAbsolutelyAnywhere.Sync(request, callSettings);
        }

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task that completes when the RPC has completed.
        /// </returns>
        public override stt::Task UpdateBookIndexAsync(
            UpdateBookIndexRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_UpdateBookIndexRequest(ref request, ref callSettings);
            return _callUpdateBookIndex.Async(request, callSettings);
        }

        /// <summary>
        /// Updates the index of a book.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        public override void UpdateBookIndex(
            UpdateBookIndexRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_UpdateBookIndexRequest(ref request, ref callSettings);
            _callUpdateBookIndex.Sync(request, callSettings);
        }

        /// <summary>
        /// Test server streaming
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The server stream.
        /// </returns>
        public override StreamShelvesStream StreamShelves(
            StreamShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_StreamShelvesRequest(ref request, ref callSettings);
            return new StreamShelvesStreamImpl(_callStreamShelves.Call(request, callSettings));
        }

        internal sealed partial class StreamShelvesStreamImpl : StreamShelvesStream
        {
            /// <summary>
            /// Construct the server-streaming method for <c>StreamShelves</c>.
            /// </summary>
            /// <param name="call">The underlying gRPC server-streaming call.</param>
            internal StreamShelvesStreamImpl(grpccore::AsyncServerStreamingCall<StreamShelvesResponse> call)
            {
                GrpcCall = call;
            }

            /// <inheritdoc/>
            public override grpccore::AsyncServerStreamingCall<StreamShelvesResponse> GrpcCall { get; }

            /// <inheritdoc/>
            public override scg::IAsyncEnumerator<StreamShelvesResponse> ResponseStream => GrpcCall.ResponseStream;
        }

        /// <summary>
        /// Test server streaming, non-paged responses.
        /// gRPC streaming methods don't have an HTTP equivalent and don't need to have the google.api.http option.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The server stream.
        /// </returns>
        public override StreamBooksStream StreamBooks(
            StreamBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_StreamBooksRequest(ref request, ref callSettings);
            return new StreamBooksStreamImpl(_callStreamBooks.Call(request, callSettings));
        }

        internal sealed partial class StreamBooksStreamImpl : StreamBooksStream
        {
            /// <summary>
            /// Construct the server-streaming method for <c>StreamBooks</c>.
            /// </summary>
            /// <param name="call">The underlying gRPC server-streaming call.</param>
            internal StreamBooksStreamImpl(grpccore::AsyncServerStreamingCall<Book> call)
            {
                GrpcCall = call;
            }

            /// <inheritdoc/>
            public override grpccore::AsyncServerStreamingCall<Book> GrpcCall { get; }

            /// <inheritdoc/>
            public override scg::IAsyncEnumerator<Book> ResponseStream => GrpcCall.ResponseStream;
        }

        /// <summary>
        /// Test bidi-streaming.
        /// </summary>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <param name="streamingSettings">
        /// If not null, applies streaming overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The client-server stream.
        /// </returns>
        public override DiscussBookStream DiscussBook(
            gaxgrpc::CallSettings callSettings = null,
            gaxgrpc::BidirectionalStreamingSettings streamingSettings = null)
        {
            Modify_DiscussBookRequestCallSettings(ref callSettings);
            gaxgrpc::BidirectionalStreamingSettings effectiveStreamingSettings =
                streamingSettings ?? _callDiscussBook.StreamingSettings;
            grpccore::AsyncDuplexStreamingCall<DiscussBookRequest, Comment> call =
                _callDiscussBook.Call(callSettings);
            gaxgrpc::BufferedClientStreamWriter<DiscussBookRequest> writeBuffer =
                new gaxgrpc::BufferedClientStreamWriter<DiscussBookRequest>(
                    call.RequestStream, effectiveStreamingSettings.BufferedClientWriterCapacity);
            return new DiscussBookStreamImpl(this, call, writeBuffer);
        }

        internal sealed partial class DiscussBookStreamImpl : DiscussBookStream
        {
            /// <summary>
            /// Construct the bidirectional streaming method for <c>DiscussBook</c>.
            /// </summary>
            /// <param name="service">The service containing this streaming method.</param>
            /// <param name="call">The underlying gRPC duplex streaming call.</param>
            /// <param name="writeBuffer">The <see cref="gaxgrpc::BufferedClientStreamWriter{DiscussBookRequest}"/>
            /// instance associated with this streaming call.</param>
            public DiscussBookStreamImpl(
                LibraryServiceClientImpl service,
                grpccore::AsyncDuplexStreamingCall<DiscussBookRequest, Comment> call,
                gaxgrpc::BufferedClientStreamWriter<DiscussBookRequest> writeBuffer)
            {
                _service = service;
                GrpcCall = call;
                _writeBuffer = writeBuffer;
            }

            private LibraryServiceClientImpl _service;
            private gaxgrpc::BufferedClientStreamWriter<DiscussBookRequest> _writeBuffer;

            private DiscussBookRequest ModifyRequest(DiscussBookRequest request)
            {
                _service.Modify_DiscussBookRequestRequest(ref request);
                return request;
            }

            /// <inheritdoc/>
            public override grpccore::AsyncDuplexStreamingCall<DiscussBookRequest, Comment> GrpcCall { get; }

            /// <inheritdoc/>
            public override stt::Task TryWriteAsync(DiscussBookRequest message) =>
                _writeBuffer.TryWriteAsync(ModifyRequest(message));

            /// <inheritdoc/>
            public override stt::Task WriteAsync(DiscussBookRequest message) =>
                _writeBuffer.WriteAsync(ModifyRequest(message));

            /// <inheritdoc/>
            public override stt::Task TryWriteAsync(DiscussBookRequest message, grpccore::WriteOptions options) =>
                _writeBuffer.TryWriteAsync(ModifyRequest(message), options);

            /// <inheritdoc/>
            public override stt::Task WriteAsync(DiscussBookRequest message, grpccore::WriteOptions options) =>
                _writeBuffer.WriteAsync(ModifyRequest(message), options);

            /// <inheritdoc/>
            public override stt::Task TryWriteCompleteAsync() =>
                _writeBuffer.TryWriteCompleteAsync();

            /// <inheritdoc/>
            public override stt::Task WriteCompleteAsync() =>
                _writeBuffer.WriteCompleteAsync();

            /// <inheritdoc/>
            public override scg::IAsyncEnumerator<Comment> ResponseStream =>
                GrpcCall.ResponseStream;
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable asynchronous sequence of <see cref="string"/> resources.
        /// </returns>
        public override gax::PagedAsyncEnumerable<FindRelatedBooksResponse, BookNameOneof> FindRelatedBooksAsync(
            FindRelatedBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_FindRelatedBooksRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedAsyncEnumerable<FindRelatedBooksRequest, FindRelatedBooksResponse, BookNameOneof>(_callFindRelatedBooks, request, callSettings);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A pageable sequence of <see cref="string"/> resources.
        /// </returns>
        public override gax::PagedEnumerable<FindRelatedBooksResponse, BookNameOneof> FindRelatedBooks(
            FindRelatedBooksRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_FindRelatedBooksRequest(ref request, ref callSettings);
            return new gaxgrpc::GrpcPagedEnumerable<FindRelatedBooksRequest, FindRelatedBooksResponse, BookNameOneof>(_callFindRelatedBooks, request, callSettings);
        }

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<gtv::AddLabelResponse> AddLabelAsync(
            gtv::AddLabelRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_AddLabelRequest(ref request, ref callSettings);
            return _callAddLabel.Async(request, callSettings);
        }

        /// <summary>
        /// Adds a label to the entity.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override gtv::AddLabelResponse AddLabel(
            gtv::AddLabelRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_AddLabelRequest(ref request, ref callSettings);
            return _callAddLabel.Sync(request, callSettings);
        }

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override async stt::Task<lro::Operation<Book, GetBigBookMetadata>> GetBigBookAsync(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return new lro::Operation<Book, GetBigBookMetadata>(
                await _callGetBigBook.Async(request, callSettings).ConfigureAwait(false), GetBigBookOperationsClient);
        }

        /// <summary>
        /// Test long-running operations
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override lro::Operation<Book, GetBigBookMetadata> GetBigBook(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return new lro::Operation<Book, GetBigBookMetadata>(
                _callGetBigBook.Sync(request, callSettings), GetBigBookOperationsClient);
        }

        /// <summary>
        /// The long-running operations client for <c>GetBigBook</c>.
        /// </summary>
        public override lro::OperationsClient GetBigBookOperationsClient { get; }

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override async stt::Task<lro::Operation<pbwkt::Empty, GetBigBookMetadata>> GetBigNothingAsync(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return new lro::Operation<pbwkt::Empty, GetBigBookMetadata>(
                await _callGetBigNothing.Async(request, callSettings).ConfigureAwait(false), GetBigNothingOperationsClient);
        }

        /// <summary>
        /// Test long-running operations with empty return type.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override lro::Operation<pbwkt::Empty, GetBigBookMetadata> GetBigNothing(
            GetBookRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_GetBookRequest(ref request, ref callSettings);
            return new lro::Operation<pbwkt::Empty, GetBigBookMetadata>(
                _callGetBigNothing.Sync(request, callSettings), GetBigNothingOperationsClient);
        }

        /// <summary>
        /// The long-running operations client for <c>GetBigNothing</c>.
        /// </summary>
        public override lro::OperationsClient GetBigNothingOperationsClient { get; }

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<TestOptionalRequiredFlatteningParamsResponse> TestOptionalRequiredFlatteningParamsAsync(
            TestOptionalRequiredFlatteningParamsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_TestOptionalRequiredFlatteningParamsRequest(ref request, ref callSettings);
            return _callTestOptionalRequiredFlatteningParams.Async(request, callSettings);
        }

        /// <summary>
        /// Test optional flattening parameters of all types
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override TestOptionalRequiredFlatteningParamsResponse TestOptionalRequiredFlatteningParams(
            TestOptionalRequiredFlatteningParamsRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_TestOptionalRequiredFlatteningParamsRequest(ref request, ref callSettings);
            return _callTestOptionalRequiredFlatteningParams.Sync(request, callSettings);
        }

        /// <summary>
        /// This method is not exposed in the GAPIC config. It should be generated.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<Book> PrivateListShelvesAsync(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListShelvesRequest(ref request, ref callSettings);
            return _callPrivateListShelves.Async(request, callSettings);
        }

        /// <summary>
        /// This method is not exposed in the GAPIC config. It should be generated.
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override Book PrivateListShelves(
            ListShelvesRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_ListShelvesRequest(ref request, ref callSettings);
            return _callPrivateListShelves.Sync(request, callSettings);
        }

    }

    // Partial classes to enable page-streaming

    public partial class ListShelvesRequest : gaxgrpc::IPageRequest { }
    public partial class ListShelvesResponse : gaxgrpc::IPageResponse<Shelf>
    {
        /// <summary>
        /// Returns an enumerator that iterates through the resources in this response.
        /// </summary>
        public scg::IEnumerator<Shelf> GetEnumerator() => Shelves.GetEnumerator();

        /// <inheritdoc/>
        sc::IEnumerator sc::IEnumerable.GetEnumerator() => GetEnumerator();
    }

    public partial class ListBooksRequest : gaxgrpc::IPageRequest { }
    public partial class ListBooksResponse : gaxgrpc::IPageResponse<Book>
    {
        /// <summary>
        /// Returns an enumerator that iterates through the resources in this response.
        /// </summary>
        public scg::IEnumerator<Book> GetEnumerator() => Books.GetEnumerator();

        /// <inheritdoc/>
        sc::IEnumerator sc::IEnumerable.GetEnumerator() => GetEnumerator();
    }

    public partial class ListStringsRequest : gaxgrpc::IPageRequest { }
    public partial class ListStringsResponse : gaxgrpc::IPageResponse<IResourceName>
    {
        /// <summary>
        /// Returns an enumerator that iterates through the resources in this response.
        /// </summary>
        public scg::IEnumerator<IResourceName> GetEnumerator() => StringsAsResourceNames.GetEnumerator();

        /// <inheritdoc/>
        sc::IEnumerator sc::IEnumerable.GetEnumerator() => GetEnumerator();
    }

    public partial class FindRelatedBooksRequest : gaxgrpc::IPageRequest { }
    public partial class FindRelatedBooksResponse : gaxgrpc::IPageResponse<BookNameOneof>
    {
        /// <summary>
        /// Returns an enumerator that iterates through the resources in this response.
        /// </summary>
        public scg::IEnumerator<BookNameOneof> GetEnumerator() => BookNameOneofs.GetEnumerator();

        /// <inheritdoc/>
        sc::IEnumerator sc::IEnumerable.GetEnumerator() => GetEnumerator();
    }

    // Partial Grpc class to enable LRO client creation
    public static partial class LibraryService
    {
        public partial class LibraryServiceClient
        {
            /// <summary>
            /// Creates a new instance of <see cref="lro::Operations.OperationsClient"/> using the same call invoker as this client.
            /// </summary>
            /// <returns>A new Operations client for the same target as this client.</returns>
            public virtual lro::Operations.OperationsClient CreateOperationsClient() => new lro::Operations.OperationsClient(CallInvoker);
        }
    }

    // Partial Grpc class to enable gctv::Labeler.LabelerClient client creation
    public static partial class LibraryService
    {
        public partial class LibraryServiceClient
        {
            /// <summary>
            /// Creates a new instance of <see cref="gctv::Labeler.LabelerClient"/> using the same call invoker as this client.
            /// </summary>
            /// <returns>A new gctv::Labeler.LabelerClient for the same target as this client.</returns>
            public virtual gctv::Labeler.LabelerClient CreateLabelerClient() => new gctv::Labeler.LabelerClient(CallInvoker);
        }
    }


}

============== file: Google.Example.Library.V1/Google.Example.Library.V1/MyProtoClient.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

using gax = Google.Api.Gax;
using gaxgrpc = Google.Api.Gax.Grpc;
using pb = Google.Protobuf;
using pbwkt = Google.Protobuf.WellKnownTypes;
using grpccore = Grpc.Core;
using sys = System;
using sc = System.Collections;
using scg = System.Collections.Generic;
using sco = System.Collections.ObjectModel;
using st = System.Threading;
using stt = System.Threading.Tasks;

namespace Google.Example.Library.V1
{
    /// <summary>
    /// Settings for a <see cref="MyProtoClient"/>.
    /// </summary>
    public sealed partial class MyProtoSettings : gaxgrpc::ServiceSettingsBase
    {
        /// <summary>
        /// Get a new instance of the default <see cref="MyProtoSettings"/>.
        /// </summary>
        /// <returns>
        /// A new instance of the default <see cref="MyProtoSettings"/>.
        /// </returns>
        public static MyProtoSettings GetDefault() => new MyProtoSettings();

        /// <summary>
        /// Constructs a new <see cref="MyProtoSettings"/> object with default settings.
        /// </summary>
        public MyProtoSettings() { }

        private MyProtoSettings(MyProtoSettings existing) : base(existing)
        {
            gax::GaxPreconditions.CheckNotNull(existing, nameof(existing));
            MyMethodSettings = existing.MyMethodSettings;
            OnCopy(existing);
        }

        partial void OnCopy(MyProtoSettings existing);

        /// <summary>
        /// The filter specifying which RPC <see cref="grpccore::StatusCode"/>s are eligible for retry
        /// for "Idempotent" <see cref="MyProtoClient"/> RPC methods.
        /// </summary>
        /// <remarks>
        /// The eligible RPC <see cref="grpccore::StatusCode"/>s for retry for "Idempotent" RPC methods are:
        /// <list type="bullet">
        /// <item><description><see cref="grpccore::StatusCode.DeadlineExceeded"/></description></item>
        /// <item><description><see cref="grpccore::StatusCode.Unavailable"/></description></item>
        /// </list>
        /// </remarks>
        public static sys::Predicate<grpccore::RpcException> IdempotentRetryFilter { get; } =
            gaxgrpc::RetrySettings.FilterForStatusCodes(grpccore::StatusCode.DeadlineExceeded, grpccore::StatusCode.Unavailable);

        /// <summary>
        /// The filter specifying which RPC <see cref="grpccore::StatusCode"/>s are eligible for retry
        /// for "NonIdempotent" <see cref="MyProtoClient"/> RPC methods.
        /// </summary>
        /// <remarks>
        /// There are no RPC <see cref="grpccore::StatusCode"/>s eligible for retry for "NonIdempotent" RPC methods.
        /// </remarks>
        public static sys::Predicate<grpccore::RpcException> NonIdempotentRetryFilter { get; } =
            gaxgrpc::RetrySettings.FilterForStatusCodes();

        /// <summary>
        /// "Default" retry backoff for <see cref="MyProtoClient"/> RPC methods.
        /// </summary>
        /// <returns>
        /// The "Default" retry backoff for <see cref="MyProtoClient"/> RPC methods.
        /// </returns>
        /// <remarks>
        /// The "Default" retry backoff for <see cref="MyProtoClient"/> RPC methods is defined as:
        /// <list type="bullet">
        /// <item><description>Initial delay: 100 milliseconds</description></item>
        /// <item><description>Maximum delay: 60000 milliseconds</description></item>
        /// <item><description>Delay multiplier: 1.3</description></item>
        /// </list>
        /// </remarks>
        public static gaxgrpc::BackoffSettings GetDefaultRetryBackoff() => new gaxgrpc::BackoffSettings(
            delay: sys::TimeSpan.FromMilliseconds(100),
            maxDelay: sys::TimeSpan.FromMilliseconds(60000),
            delayMultiplier: 1.3
        );

        /// <summary>
        /// "Default" timeout backoff for <see cref="MyProtoClient"/> RPC methods.
        /// </summary>
        /// <returns>
        /// The "Default" timeout backoff for <see cref="MyProtoClient"/> RPC methods.
        /// </returns>
        /// <remarks>
        /// The "Default" timeout backoff for <see cref="MyProtoClient"/> RPC methods is defined as:
        /// <list type="bullet">
        /// <item><description>Initial timeout: 20000 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.0</description></item>
        /// <item><description>Maximum timeout: 20000 milliseconds</description></item>
        /// </list>
        /// </remarks>
        public static gaxgrpc::BackoffSettings GetDefaultTimeoutBackoff() => new gaxgrpc::BackoffSettings(
            delay: sys::TimeSpan.FromMilliseconds(20000),
            maxDelay: sys::TimeSpan.FromMilliseconds(20000),
            delayMultiplier: 1.0
        );

        /// <summary>
        /// <see cref="gaxgrpc::CallSettings"/> for synchronous and asynchronous calls to
        /// <c>MyProtoClient.MyMethod</c> and <c>MyProtoClient.MyMethodAsync</c>.
        /// </summary>
        /// <remarks>
        /// The default <c>MyProtoClient.MyMethod</c> and
        /// <c>MyProtoClient.MyMethodAsync</c> <see cref="gaxgrpc::RetrySettings"/> are:
        /// <list type="bullet">
        /// <item><description>Initial retry delay: 100 milliseconds</description></item>
        /// <item><description>Retry delay multiplier: 1.3</description></item>
        /// <item><description>Retry maximum delay: 60000 milliseconds</description></item>
        /// <item><description>Initial timeout: 20000 milliseconds</description></item>
        /// <item><description>Timeout multiplier: 1.0</description></item>
        /// <item><description>Timeout maximum delay: 20000 milliseconds</description></item>
        /// </list>
        /// Retry will be attempted on the following response status codes:
        /// <list>
        /// <item><description>No status codes</description></item>
        /// </list>
        /// Default RPC expiration is 600000 milliseconds.
        /// </remarks>
        public gaxgrpc::CallSettings MyMethodSettings { get; set; } = gaxgrpc::CallSettings.FromCallTiming(
            gaxgrpc::CallTiming.FromRetry(new gaxgrpc::RetrySettings(
                retryBackoff: GetDefaultRetryBackoff(),
                timeoutBackoff: GetDefaultTimeoutBackoff(),
                totalExpiration: gax::Expiration.FromTimeout(sys::TimeSpan.FromMilliseconds(600000)),
                retryFilter: NonIdempotentRetryFilter
            )));

        /// <summary>
        /// Creates a deep clone of this object, with all the same property values.
        /// </summary>
        /// <returns>A deep clone of this <see cref="MyProtoSettings"/> object.</returns>
        public MyProtoSettings Clone() => new MyProtoSettings(this);
    }

    /// <summary>
    /// MyProto client wrapper, for convenient use.
    /// </summary>
    public abstract partial class MyProtoClient
    {
        /// <summary>
        /// The default endpoint for the MyProto service, which is a host of "library-example.googleapis.com" and a port of 1234.
        /// </summary>
        public static gaxgrpc::ServiceEndpoint DefaultEndpoint { get; } = new gaxgrpc::ServiceEndpoint("library-example.googleapis.com", 1234);

        /// <summary>
        /// The default MyProto scopes.
        /// </summary>
        /// <remarks>
        /// The default MyProto scopes are:
        /// <list type="bullet">
        /// <item><description>"https://www.googleapis.com/auth/cloud-platform"</description></item>
        /// <item><description>"https://www.googleapis.com/auth/library"</description></item>
        /// </list>
        /// </remarks>
        public static scg::IReadOnlyList<string> DefaultScopes { get; } = new sco::ReadOnlyCollection<string>(new string[] {
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/library",
        });

        private static readonly gaxgrpc::ChannelPool s_channelPool = new gaxgrpc::ChannelPool(DefaultScopes);

        /// <summary>
        /// Asynchronously creates a <see cref="MyProtoClient"/>, applying defaults for all unspecified settings,
        /// and creating a channel connecting to the given endpoint with application default credentials where
        /// necessary. See the example for how to use custom credentials.
        /// </summary>
        /// <example>
        /// This sample shows how to create a client using default credentials:
        /// <code>
        /// using Google.Example.Library.V1;
        /// ...
        /// // When running on Google Cloud Platform this will use the project Compute Credential.
        /// // Or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to the path of a JSON
        /// // credential file to use that credential.
        /// MyProtoClient client = await MyProtoClient.CreateAsync();
        /// </code>
        /// This sample shows how to create a client using credentials loaded from a JSON file:
        /// <code>
        /// using Google.Example.Library.V1;
        /// using Google.Apis.Auth.OAuth2;
        /// using Grpc.Auth;
        /// using Grpc.Core;
        /// ...
        /// GoogleCredential cred = GoogleCredential.FromFile("/path/to/credentials.json");
        /// Channel channel = new Channel(
        ///     MyProtoClient.DefaultEndpoint.Host, MyProtoClient.DefaultEndpoint.Port, cred.ToChannelCredentials());
        /// MyProtoClient client = MyProtoClient.Create(channel);
        /// ...
        /// // Shutdown the channel when it is no longer required.
        /// await channel.ShutdownAsync();
        /// </code>
        /// </example>
        /// <param name="endpoint">Optional <see cref="gaxgrpc::ServiceEndpoint"/>.</param>
        /// <param name="settings">Optional <see cref="MyProtoSettings"/>.</param>
        /// <returns>The task representing the created <see cref="MyProtoClient"/>.</returns>
        public static async stt::Task<MyProtoClient> CreateAsync(gaxgrpc::ServiceEndpoint endpoint = null, MyProtoSettings settings = null)
        {
            grpccore::Channel channel = await s_channelPool.GetChannelAsync(endpoint ?? DefaultEndpoint).ConfigureAwait(false);
            return Create(channel, settings);
        }

        /// <summary>
        /// Synchronously creates a <see cref="MyProtoClient"/>, applying defaults for all unspecified settings,
        /// and creating a channel connecting to the given endpoint with application default credentials where
        /// necessary. See the example for how to use custom credentials.
        /// </summary>
        /// <example>
        /// This sample shows how to create a client using default credentials:
        /// <code>
        /// using Google.Example.Library.V1;
        /// ...
        /// // When running on Google Cloud Platform this will use the project Compute Credential.
        /// // Or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to the path of a JSON
        /// // credential file to use that credential.
        /// MyProtoClient client = MyProtoClient.Create();
        /// </code>
        /// This sample shows how to create a client using credentials loaded from a JSON file:
        /// <code>
        /// using Google.Example.Library.V1;
        /// using Google.Apis.Auth.OAuth2;
        /// using Grpc.Auth;
        /// using Grpc.Core;
        /// ...
        /// GoogleCredential cred = GoogleCredential.FromFile("/path/to/credentials.json");
        /// Channel channel = new Channel(
        ///     MyProtoClient.DefaultEndpoint.Host, MyProtoClient.DefaultEndpoint.Port, cred.ToChannelCredentials());
        /// MyProtoClient client = MyProtoClient.Create(channel);
        /// ...
        /// // Shutdown the channel when it is no longer required.
        /// channel.ShutdownAsync().Wait();
        /// </code>
        /// </example>
        /// <param name="endpoint">Optional <see cref="gaxgrpc::ServiceEndpoint"/>.</param>
        /// <param name="settings">Optional <see cref="MyProtoSettings"/>.</param>
        /// <returns>The created <see cref="MyProtoClient"/>.</returns>
        public static MyProtoClient Create(gaxgrpc::ServiceEndpoint endpoint = null, MyProtoSettings settings = null)
        {
            grpccore::Channel channel = s_channelPool.GetChannel(endpoint ?? DefaultEndpoint);
            return Create(channel, settings);
        }

        /// <summary>
        /// Creates a <see cref="MyProtoClient"/> which uses the specified channel for remote operations.
        /// </summary>
        /// <param name="channel">The <see cref="grpccore::Channel"/> for remote operations. Must not be null.</param>
        /// <param name="settings">Optional <see cref="MyProtoSettings"/>.</param>
        /// <returns>The created <see cref="MyProtoClient"/>.</returns>
        public static MyProtoClient Create(grpccore::Channel channel, MyProtoSettings settings = null)
        {
            gax::GaxPreconditions.CheckNotNull(channel, nameof(channel));
            return Create(new grpccore::DefaultCallInvoker(channel), settings);
        }

        /// <summary>
        /// Creates a <see cref="MyProtoClient"/> which uses the specified call invoker for remote operations.
        /// </summary>
        /// <param name="callInvoker">The <see cref="grpccore::CallInvoker"/> for remote operations. Must not be null.</param>
        /// <param name="settings">Optional <see cref="MyProtoSettings"/>.</param>
        /// <returns>The created <see cref="MyProtoClient"/>.</returns>
        public static MyProtoClient Create(grpccore::CallInvoker callInvoker, MyProtoSettings settings = null)
        {
            gax::GaxPreconditions.CheckNotNull(callInvoker, nameof(callInvoker));
            grpccore::Interceptors.Interceptor interceptor = settings?.Interceptor;
            if (interceptor != null)
            {
                callInvoker = grpccore::Interceptors.CallInvokerExtensions.Intercept(callInvoker, interceptor);
            }
            MyProto.MyProtoClient grpcClient = new MyProto.MyProtoClient(callInvoker);
            return new MyProtoClientImpl(grpcClient, settings);
        }

        /// <summary>
        /// Shuts down any channels automatically created by <see cref="Create(gaxgrpc::ServiceEndpoint, MyProtoSettings)"/>
        /// and <see cref="CreateAsync(gaxgrpc::ServiceEndpoint, MyProtoSettings)"/>. Channels which weren't automatically
        /// created are not affected.
        /// </summary>
        /// <remarks>After calling this method, further calls to <see cref="Create(gaxgrpc::ServiceEndpoint, MyProtoSettings)"/>
        /// and <see cref="CreateAsync(gaxgrpc::ServiceEndpoint, MyProtoSettings)"/> will create new channels, which could
        /// in turn be shut down by another call to this method.</remarks>
        /// <returns>A task representing the asynchronous shutdown operation.</returns>
        public static stt::Task ShutdownDefaultChannelsAsync() => s_channelPool.ShutdownChannelsAsync();

        /// <summary>
        /// The underlying gRPC MyProto client.
        /// </summary>
        public virtual MyProto.MyProtoClient GrpcClient
        {
            get { throw new sys::NotImplementedException(); }
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MethodResponse> MyMethodAsync(
            MethodRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="cancellationToken">
        /// A <see cref="st::CancellationToken"/> to use for this RPC.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public virtual stt::Task<MethodResponse> MyMethodAsync(
            MethodRequest request,
            st::CancellationToken cancellationToken) => MyMethodAsync(
                request,
                gaxgrpc::CallSettings.FromCancellationToken(cancellationToken));

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public virtual MethodResponse MyMethod(
            MethodRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            throw new sys::NotImplementedException();
        }

    }

    /// <summary>
    /// MyProto client wrapper implementation, for convenient use.
    /// </summary>
    public sealed partial class MyProtoClientImpl : MyProtoClient
    {
        private readonly gaxgrpc::ApiCall<MethodRequest, MethodResponse> _callMyMethod;

        /// <summary>
        /// Constructs a client wrapper for the MyProto service, with the specified gRPC client and settings.
        /// </summary>
        /// <param name="grpcClient">The underlying gRPC client.</param>
        /// <param name="settings">The base <see cref="MyProtoSettings"/> used within this client </param>
        public MyProtoClientImpl(MyProto.MyProtoClient grpcClient, MyProtoSettings settings)
        {
            GrpcClient = grpcClient;
            MyProtoSettings effectiveSettings = settings ?? MyProtoSettings.GetDefault();
            gaxgrpc::ClientHelper clientHelper = new gaxgrpc::ClientHelper(effectiveSettings);
            _callMyMethod = clientHelper.BuildApiCall<MethodRequest, MethodResponse>(
                GrpcClient.MyMethodAsync, GrpcClient.MyMethod, effectiveSettings.MyMethodSettings);
            Modify_ApiCall(ref _callMyMethod);
            Modify_MyMethodApiCall(ref _callMyMethod);
            OnConstruction(grpcClient, effectiveSettings, clientHelper);
        }

        // Partial methods are named to (mostly) ensure there cannot be conflicts with RPC method names.

        // Partial methods called for every ApiCall on construction.
        // Allows modification of all the underlying ApiCall objects.
        partial void Modify_ApiCall<TRequest, TResponse>(ref gaxgrpc::ApiCall<TRequest, TResponse> call)
            where TRequest : class, pb::IMessage<TRequest>
            where TResponse : class, pb::IMessage<TResponse>;

        // Partial methods called for each ApiCall on construction.
        // Allows per-RPC-method modification of the underlying ApiCall object.
        partial void Modify_MyMethodApiCall(ref gaxgrpc::ApiCall<MethodRequest, MethodResponse> call);
        partial void OnConstruction(MyProto.MyProtoClient grpcClient, MyProtoSettings effectiveSettings, gaxgrpc::ClientHelper clientHelper);

        /// <summary>
        /// The underlying gRPC MyProto client.
        /// </summary>
        public override MyProto.MyProtoClient GrpcClient { get; }

        // Partial methods called on each request.
        // Allows per-RPC-call modification to the request and CallSettings objects,
        // before the underlying RPC is performed.
        partial void Modify_MethodRequest(ref MethodRequest request, ref gaxgrpc::CallSettings settings);

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// A Task containing the RPC response.
        /// </returns>
        public override stt::Task<MethodResponse> MyMethodAsync(
            MethodRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MethodRequest(ref request, ref callSettings);
            return _callMyMethod.Async(request, callSettings);
        }

        /// <summary>
        ///
        /// </summary>
        /// <param name="request">
        /// The request object containing all of the parameters for the API call.
        /// </param>
        /// <param name="callSettings">
        /// If not null, applies overrides to this RPC call.
        /// </param>
        /// <returns>
        /// The RPC response.
        /// </returns>
        public override MethodResponse MyMethod(
            MethodRequest request,
            gaxgrpc::CallSettings callSettings = null)
        {
            Modify_MethodRequest(ref request, ref callSettings);
            return _callMyMethod.Sync(request, callSettings);
        }

    }

    // Partial classes to enable page-streaming


}

============== file: Google.Example.Library.V1/Google.Example.Library.V1/ResourceNames.cs ==============
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated code. DO NOT EDIT!

using gax = Google.Api.Gax;
using sys = System;
using scg = System.Collections.Generic;
using linq = System.Linq;

namespace Google.Example.Library.V1
{
    /// <summary>
    /// Resource name for the 'archive_book' resource.
    /// </summary>
    public sealed partial class ArchiveBookName : gax::IResourceName, sys::IEquatable<ArchiveBookName>
    {
        private static readonly gax::PathTemplate s_template = new gax::PathTemplate("archives/{archive}/books/{book}");

        /// <summary>
        /// Parses the given archive_book resource name in string form into a new
        /// <see cref="ArchiveBookName"/> instance.
        /// </summary>
        /// <param name="archiveBookName">The archive_book resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="ArchiveBookName"/> if successful.</returns>
        public static ArchiveBookName Parse(string archiveBookName)
        {
            gax::GaxPreconditions.CheckNotNull(archiveBookName, nameof(archiveBookName));
            gax::TemplatedResourceName resourceName = s_template.ParseName(archiveBookName);
            return new ArchiveBookName(resourceName[0], resourceName[1]);
        }

        /// <summary>
        /// Tries to parse the given archive_book resource name in string form into a new
        /// <see cref="ArchiveBookName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="sys::ArgumentNullException"/> if <paramref name="archiveBookName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="archiveBookName">The archive_book resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="ArchiveBookName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed successfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string archiveBookName, out ArchiveBookName result)
        {
            gax::GaxPreconditions.CheckNotNull(archiveBookName, nameof(archiveBookName));
            gax::TemplatedResourceName resourceName;
            if (s_template.TryParseName(archiveBookName, out resourceName))
            {
                result = new ArchiveBookName(resourceName[0], resourceName[1]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>
        /// Constructs a new instance of the <see cref="ArchiveBookName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="archiveId">The archive ID. Must not be <c>null</c>.</param>
        /// <param name="bookId">The book ID. Must not be <c>null</c>.</param>
        public ArchiveBookName(string archiveId, string bookId)
        {
            ArchiveId = gax::GaxPreconditions.CheckNotNull(archiveId, nameof(archiveId));
            BookId = gax::GaxPreconditions.CheckNotNull(bookId, nameof(bookId));
        }

        /// <summary>
        /// The archive ID. Never <c>null</c>.
        /// </summary>
        public string ArchiveId { get; }

        /// <summary>
        /// The book ID. Never <c>null</c>.
        /// </summary>
        public string BookId { get; }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ArchiveId, BookId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as ArchiveBookName);

        /// <inheritdoc />
        public bool Equals(ArchiveBookName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(ArchiveBookName a, ArchiveBookName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(ArchiveBookName a, ArchiveBookName b) => !(a == b);
    }

    /// <summary>
    /// Resource name for the 'archived_book' resource.
    /// </summary>
    public sealed partial class ArchivedBookName : gax::IResourceName, sys::IEquatable<ArchivedBookName>
    {
        private static readonly gax::PathTemplate s_template = new gax::PathTemplate("archives/{archive}/books/{book}");

        /// <summary>
        /// Parses the given archived_book resource name in string form into a new
        /// <see cref="ArchivedBookName"/> instance.
        /// </summary>
        /// <param name="archivedBookName">The archived_book resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="ArchivedBookName"/> if successful.</returns>
        public static ArchivedBookName Parse(string archivedBookName)
        {
            gax::GaxPreconditions.CheckNotNull(archivedBookName, nameof(archivedBookName));
            gax::TemplatedResourceName resourceName = s_template.ParseName(archivedBookName);
            return new ArchivedBookName(resourceName[0], resourceName[1]);
        }

        /// <summary>
        /// Tries to parse the given archived_book resource name in string form into a new
        /// <see cref="ArchivedBookName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="sys::ArgumentNullException"/> if <paramref name="archivedBookName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="archivedBookName">The archived_book resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="ArchivedBookName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed successfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string archivedBookName, out ArchivedBookName result)
        {
            gax::GaxPreconditions.CheckNotNull(archivedBookName, nameof(archivedBookName));
            gax::TemplatedResourceName resourceName;
            if (s_template.TryParseName(archivedBookName, out resourceName))
            {
                result = new ArchivedBookName(resourceName[0], resourceName[1]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>
        /// Constructs a new instance of the <see cref="ArchivedBookName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="archiveId">The archive ID. Must not be <c>null</c>.</param>
        /// <param name="bookId">The book ID. Must not be <c>null</c>.</param>
        public ArchivedBookName(string archiveId, string bookId)
        {
            ArchiveId = gax::GaxPreconditions.CheckNotNull(archiveId, nameof(archiveId));
            BookId = gax::GaxPreconditions.CheckNotNull(bookId, nameof(bookId));
        }

        /// <summary>
        /// The archive ID. Never <c>null</c>.
        /// </summary>
        public string ArchiveId { get; }

        /// <summary>
        /// The book ID. Never <c>null</c>.
        /// </summary>
        public string BookId { get; }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ArchiveId, BookId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as ArchivedBookName);

        /// <inheritdoc />
        public bool Equals(ArchivedBookName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(ArchivedBookName a, ArchivedBookName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(ArchivedBookName a, ArchivedBookName b) => !(a == b);
    }

    /// <summary>
    /// Resource name for the 'book' resource.
    /// </summary>
    public sealed partial class BookName : gax::IResourceName, sys::IEquatable<BookName>
    {
        private static readonly gax::PathTemplate s_template = new gax::PathTemplate("bookShelves/{book_shelf}/books/{book}");

        /// <summary>
        /// Parses the given book resource name in string form into a new
        /// <see cref="BookName"/> instance.
        /// </summary>
        /// <param name="bookName">The book resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="BookName"/> if successful.</returns>
        public static BookName Parse(string bookName)
        {
            gax::GaxPreconditions.CheckNotNull(bookName, nameof(bookName));
            gax::TemplatedResourceName resourceName = s_template.ParseName(bookName);
            return new BookName(resourceName[0], resourceName[1]);
        }

        /// <summary>
        /// Tries to parse the given book resource name in string form into a new
        /// <see cref="BookName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="sys::ArgumentNullException"/> if <paramref name="bookName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="bookName">The book resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="BookName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed successfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string bookName, out BookName result)
        {
            gax::GaxPreconditions.CheckNotNull(bookName, nameof(bookName));
            gax::TemplatedResourceName resourceName;
            if (s_template.TryParseName(bookName, out resourceName))
            {
                result = new BookName(resourceName[0], resourceName[1]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>
        /// Constructs a new instance of the <see cref="BookName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="bookShelfId">The bookShelf ID. Must not be <c>null</c>.</param>
        /// <param name="bookId">The book ID. Must not be <c>null</c>.</param>
        public BookName(string bookShelfId, string bookId)
        {
            BookShelfId = gax::GaxPreconditions.CheckNotNull(bookShelfId, nameof(bookShelfId));
            BookId = gax::GaxPreconditions.CheckNotNull(bookId, nameof(bookId));
        }

        /// <summary>
        /// The bookShelf ID. Never <c>null</c>.
        /// </summary>
        public string BookShelfId { get; }

        /// <summary>
        /// The book ID. Never <c>null</c>.
        /// </summary>
        public string BookId { get; }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(BookShelfId, BookId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as BookName);

        /// <inheritdoc />
        public bool Equals(BookName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(BookName a, BookName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(BookName a, BookName b) => !(a == b);
    }

    /// <summary>
    /// Resource name which will contain one of a choice of resource names.
    /// </summary>
    /// <remarks>
    /// This resource name will contain one of the following:
    /// <list type="bullet">
    /// <item><description>BookName: A resource of type 'book'.</description></item>
    /// <item><description>ArchiveBookName: A resource of type 'archive_book'.</description></item>
    /// </list>
    /// </remarks>
    public sealed partial class BookNameOneof : gax::IResourceName, sys::IEquatable<BookNameOneof>
    {
        /// <summary>
        /// The possible contents of <see cref="BookNameOneof"/>.
        /// </summary>
        public enum OneofType
        {
            /// <summary>
            /// A resource of an unknown type.
            /// </summary>
            Unknown = 0,

            /// <summary>
            /// A resource of type 'book'.
            /// </summary>
            BookName = 1,

            /// <summary>
            /// A resource of type 'archive_book'.
            /// </summary>
            ArchiveBookName = 2,
        }

        /// <summary>
        /// Parses a resource name in string form into a new <see cref="BookNameOneof"/> instance.
        /// </summary>
        /// <remarks>
        /// To parse successfully the resource name must be one of the following:
        /// <list type="bullet">
        /// <item><description>BookName: A resource of type 'book'.</description></item>
        /// <item><description>ArchiveBookName: A resource of type 'archive_book'.</description></item>
        /// </list>
        /// Or an <see cref="gax::UnknownResourceName"/> if <paramref name="allowUnknown"/> is <c>true</c>.
        /// </remarks>
        /// <param name="name">The resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="allowUnknown">If true, will successfully parse an unknown resource name
        /// into an <see cref="gax::UnknownResourceName"/>; otherwise will throw an
        /// <see cref="sys::ArgumentException"/> if an unknown resource name is given.</param>
        /// <returns>The parsed <see cref="BookNameOneof"/> if successful.</returns>
        public static BookNameOneof Parse(string name, bool allowUnknown)
        {
            BookNameOneof result;
            if (TryParse(name, allowUnknown, out result))
            {
                return result;
            }
            throw new sys::ArgumentException("Invalid name", nameof(name));
        }

        /// <summary>
        /// Tries to parse a resource name in string form into a new <see cref="BookNameOneof"/> instance.
        /// </summary>
        /// <remarks>
        /// To parse successfully the resource name must be one of the following:
        /// <list type="bullet">
        /// <item><description>BookName: A resource of type 'book'.</description></item>
        /// <item><description>ArchiveBookName: A resource of type 'archive_book'.</description></item>
        /// </list>
        /// Or an <see cref="gax::UnknownResourceName"/> if <paramref name="allowUnknown"/> is <c>true</c>.
        /// </remarks>
        /// <param name="name">The resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="allowUnknown">If true, will successfully parse an unknown resource name
        /// into an <see cref="gax::UnknownResourceName"/>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="BookNameOneof"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed succssfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string name, bool allowUnknown, out BookNameOneof result)
        {
            gax::GaxPreconditions.CheckNotNull(name, nameof(name));
            BookName bookName;
            if (BookName.TryParse(name, out bookName))
            {
                result = new BookNameOneof(OneofType.BookName, bookName);
                return true;
            }
            ArchiveBookName archiveBookName;
            if (ArchiveBookName.TryParse(name, out archiveBookName))
            {
                result = new BookNameOneof(OneofType.ArchiveBookName, archiveBookName);
                return true;
            }
            if (allowUnknown)
            {
                gax::UnknownResourceName unknownResourceName;
                if (gax::UnknownResourceName.TryParse(name, out unknownResourceName))
                {
                    result = new BookNameOneof(OneofType.Unknown, unknownResourceName);
                    return true;
                }
            }
            result = null;
            return false;
        }

        /// <summary>
        /// Construct a new instance of <see cref="BookNameOneof"/> from the provided <see cref="BookName"/>
        /// </summary>
        /// <param name="bookName">The <see cref="BookName"/> to be contained within
        /// the returned <see cref="BookNameOneof"/>. Must not be <c>null</c>.</param>
        /// <returns>A new <see cref="BookNameOneof"/>, containing <paramref name="bookName"/>.</returns>
        public static BookNameOneof From(BookName bookName) => new BookNameOneof(OneofType.BookName, bookName);

        /// <summary>
        /// Construct a new instance of <see cref="BookNameOneof"/> from the provided <see cref="ArchiveBookName"/>
        /// </summary>
        /// <param name="archiveBookName">The <see cref="ArchiveBookName"/> to be contained within
        /// the returned <see cref="BookNameOneof"/>. Must not be <c>null</c>.</param>
        /// <returns>A new <see cref="BookNameOneof"/>, containing <paramref name="archiveBookName"/>.</returns>
        public static BookNameOneof From(ArchiveBookName archiveBookName) => new BookNameOneof(OneofType.ArchiveBookName, archiveBookName);

        private static bool IsValid(OneofType type, gax::IResourceName name)
        {
            switch (type)
            {
                case OneofType.Unknown: return true; // Anything goes with Unknown.
                case OneofType.BookName: return name is BookName;
                case OneofType.ArchiveBookName: return name is ArchiveBookName;
                default: return false;
            }
        }

        /// <summary>
        /// Constructs a new instance of the <see cref="BookNameOneof"/> resource name class
        /// from a suitable <see cref="gax::IResourceName"/> instance.
        /// </summary>
        public BookNameOneof(OneofType type, gax::IResourceName name)
        {
            Type = gax::GaxPreconditions.CheckEnumValue<OneofType>(type, nameof(type));
            Name = gax::GaxPreconditions.CheckNotNull(name, nameof(name));
            if (!IsValid(type, name))
            {
                throw new sys::ArgumentException($"Mismatched OneofType '{type}' and resource name '{name}'");
            }
        }

        /// <summary>
        /// The <see cref="OneofType"/> of the Name contained in this instance.
        /// </summary>
        public OneofType Type { get; }

        /// <summary>
        /// The <see cref="gax::IResourceName"/> contained in this instance.
        /// </summary>
        public gax::IResourceName Name { get; }

        private T CheckAndReturn<T>(OneofType type)
        {
            if (Type != type)
            {
                throw new sys::InvalidOperationException($"Requested type {type}, but this one-of contains type {Type}");
            }
            return (T)Name;
        }

        /// <summary>
        /// Get the contained <see cref="gax::IResourceName"/> as <see cref="BookName"/>.
        /// </summary>
        /// <remarks>
        /// An <see cref="sys::InvalidOperationException"/> will be thrown if this does not
        /// contain an instance of <see cref="BookName"/>.
        /// </remarks>
        public BookName BookName => CheckAndReturn<BookName>(OneofType.BookName);

        /// <summary>
        /// Get the contained <see cref="gax::IResourceName"/> as <see cref="ArchiveBookName"/>.
        /// </summary>
        /// <remarks>
        /// An <see cref="sys::InvalidOperationException"/> will be thrown if this does not
        /// contain an instance of <see cref="ArchiveBookName"/>.
        /// </remarks>
        public ArchiveBookName ArchiveBookName => CheckAndReturn<ArchiveBookName>(OneofType.ArchiveBookName);

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Oneof;

        /// <inheritdoc />
        public override string ToString() => Name.ToString();

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as BookNameOneof);

        /// <inheritdoc />
        public bool Equals(BookNameOneof other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(BookNameOneof a, BookNameOneof b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(BookNameOneof a, BookNameOneof b) => !(a == b);
    }

    /// <summary>
    /// Resource name for the 'shelf' resource.
    /// </summary>
    public sealed partial class ShelfName : gax::IResourceName, sys::IEquatable<ShelfName>
    {
        private static readonly gax::PathTemplate s_template = new gax::PathTemplate("shelves/{shelf_id}");

        /// <summary>
        /// Parses the given shelf resource name in string form into a new
        /// <see cref="ShelfName"/> instance.
        /// </summary>
        /// <param name="shelfName">The shelf resource name in string form. Must not be <c>null</c>.</param>
        /// <returns>The parsed <see cref="ShelfName"/> if successful.</returns>
        public static ShelfName Parse(string shelfName)
        {
            gax::GaxPreconditions.CheckNotNull(shelfName, nameof(shelfName));
            gax::TemplatedResourceName resourceName = s_template.ParseName(shelfName);
            return new ShelfName(resourceName[0]);
        }

        /// <summary>
        /// Tries to parse the given shelf resource name in string form into a new
        /// <see cref="ShelfName"/> instance.
        /// </summary>
        /// <remarks>
        /// This method still throws <see cref="sys::ArgumentNullException"/> if <paramref name="shelfName"/> is null,
        /// as this would usually indicate a programming error rather than a data error.
        /// </remarks>
        /// <param name="shelfName">The shelf resource name in string form. Must not be <c>null</c>.</param>
        /// <param name="result">When this method returns, the parsed <see cref="ShelfName"/>,
        /// or <c>null</c> if parsing fails.</param>
        /// <returns><c>true</c> if the name was parsed successfully; <c>false</c> otherwise.</returns>
        public static bool TryParse(string shelfName, out ShelfName result)
        {
            gax::GaxPreconditions.CheckNotNull(shelfName, nameof(shelfName));
            gax::TemplatedResourceName resourceName;
            if (s_template.TryParseName(shelfName, out resourceName))
            {
                result = new ShelfName(resourceName[0]);
                return true;
            }
            else
            {
                result = null;
                return false;
            }
        }

        /// <summary>
        /// Constructs a new instance of the <see cref="ShelfName"/> resource name class
        /// from its component parts.
        /// </summary>
        /// <param name="shelfId">The shelf ID. Must not be <c>null</c>.</param>
        public ShelfName(string shelfId)
        {
            ShelfId = gax::GaxPreconditions.CheckNotNull(shelfId, nameof(shelfId));
        }

        /// <summary>
        /// The shelf ID. Never <c>null</c>.
        /// </summary>
        public string ShelfId { get; }

        /// <inheritdoc />
        public gax::ResourceNameKind Kind => gax::ResourceNameKind.Simple;

        /// <inheritdoc />
        public override string ToString() => s_template.Expand(ShelfId);

        /// <inheritdoc />
        public override int GetHashCode() => ToString().GetHashCode();

        /// <inheritdoc />
        public override bool Equals(object obj) => Equals(obj as ShelfName);

        /// <inheritdoc />
        public bool Equals(ShelfName other) => ToString() == other?.ToString();

        /// <inheritdoc />
        public static bool operator ==(ShelfName a, ShelfName b) => ReferenceEquals(a, b) || (a?.Equals(b) ?? false);

        /// <inheritdoc />
        public static bool operator !=(ShelfName a, ShelfName b) => !(a == b);
    }


    public partial class AddCommentsRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class Book
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class BookFromAnywhere
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class BookFromArchive
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ArchivedBookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ArchivedBookName ArchivedBookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ArchivedBookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class CreateBookRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class DeleteBookRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class DeleteShelfRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class DiscussBookRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class FindRelatedBooksRequest
    {
        /// <summary>
        /// <see cref="gax::ResourceNameList{BookNameOneof}"/>-typed view over the <see cref="Names"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<BookNameOneof> BookNameOneofs =>
            new gax::ResourceNameList<BookNameOneof>(Names,
                str => BookNameOneof.Parse(str, true));

        /// <summary>
        /// <see cref="gax::ResourceNameList{ShelfName}"/>-typed view over the <see cref="Shelves"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<ShelfName> ShelvesAsShelfNames =>
            new gax::ResourceNameList<ShelfName>(Shelves,
                str => ShelfName.Parse(str));

    }

    public partial class FindRelatedBooksResponse
    {
        /// <summary>
        /// <see cref="gax::ResourceNameList{BookNameOneof}"/>-typed view over the <see cref="Names"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<BookNameOneof> BookNameOneofs =>
            new gax::ResourceNameList<BookNameOneof>(Names,
                str => BookNameOneof.Parse(str, true));

    }

    public partial class GetBookFromAbsolutelyAnywhereRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class GetBookFromAnywhereRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="AltBookName"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof AltBookNameAsBookNameOneof
        {
            get { return string.IsNullOrEmpty(AltBookName) ? null : Google.Example.Library.V1.BookNameOneof.Parse(AltBookName, true); }
            set { AltBookName = value != null ? value.ToString() : ""; }
        }

    }

    public partial class GetBookFromArchiveRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ArchivedBookName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ArchivedBookName ArchivedBookName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ArchivedBookName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class GetBookRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class GetShelfRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class ListBooksRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class ListStringsRequest
    {
        /// <summary>
        /// <see cref="gax::IResourceName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public gax::IResourceName AsResourceName
        {
            get { return string.IsNullOrEmpty(Name) ? null : gax::UnknownResourceName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class ListStringsResponse
    {
        /// <summary>
        /// <see cref="gax::ResourceNameList{gax::IResourceName}"/>-typed view over the <see cref="Strings"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<gax::IResourceName> StringsAsResourceNames =>
            new gax::ResourceNameList<gax::IResourceName>(Strings,
                str => gax::UnknownResourceName.Parse(str));

    }

    public partial class MergeShelvesRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="OtherShelfName"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName OtherShelfNameAsShelfName
        {
            get { return string.IsNullOrEmpty(OtherShelfName) ? null : Google.Example.Library.V1.ShelfName.Parse(OtherShelfName); }
            set { OtherShelfName = value != null ? value.ToString() : ""; }
        }

    }

    public partial class MoveBookRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="OtherShelfName"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName OtherShelfNameAsShelfName
        {
            get { return string.IsNullOrEmpty(OtherShelfName) ? null : Google.Example.Library.V1.ShelfName.Parse(OtherShelfName); }
            set { OtherShelfName = value != null ? value.ToString() : ""; }
        }

    }

    public partial class Shelf
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class StreamShelvesRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.ShelfName"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.ShelfName ShelfName
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.ShelfName.Parse(Name); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class TestOptionalRequiredFlatteningParamsRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="RequiredSingularResourceName"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof RequiredSingularResourceNameAsBookNameOneof
        {
            get { return string.IsNullOrEmpty(RequiredSingularResourceName) ? null : Google.Example.Library.V1.BookNameOneof.Parse(RequiredSingularResourceName, true); }
            set { RequiredSingularResourceName = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="RequiredSingularResourceNameOneof"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof RequiredSingularResourceNameOneofAsBookNameOneof
        {
            get { return string.IsNullOrEmpty(RequiredSingularResourceNameOneof) ? null : Google.Example.Library.V1.BookNameOneof.Parse(RequiredSingularResourceNameOneof, true); }
            set { RequiredSingularResourceNameOneof = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="gax::ResourceNameList{BookNameOneof}"/>-typed view over the <see cref="RequiredRepeatedResourceName"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<BookNameOneof> RequiredRepeatedResourceNameAsBookNameOneofs =>
            new gax::ResourceNameList<BookNameOneof>(RequiredRepeatedResourceName,
                str => BookNameOneof.Parse(str, true));

        /// <summary>
        /// <see cref="gax::ResourceNameList{BookNameOneof}"/>-typed view over the <see cref="RequiredRepeatedResourceNameOneof"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<BookNameOneof> RequiredRepeatedResourceNameOneofAsBookNameOneofs =>
            new gax::ResourceNameList<BookNameOneof>(RequiredRepeatedResourceNameOneof,
                str => BookNameOneof.Parse(str, true));

        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="OptionalSingularResourceName"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof OptionalSingularResourceNameAsBookNameOneof
        {
            get { return string.IsNullOrEmpty(OptionalSingularResourceName) ? null : Google.Example.Library.V1.BookNameOneof.Parse(OptionalSingularResourceName, true); }
            set { OptionalSingularResourceName = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="OptionalSingularResourceNameOneof"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof OptionalSingularResourceNameOneofAsBookNameOneof
        {
            get { return string.IsNullOrEmpty(OptionalSingularResourceNameOneof) ? null : Google.Example.Library.V1.BookNameOneof.Parse(OptionalSingularResourceNameOneof, true); }
            set { OptionalSingularResourceNameOneof = value != null ? value.ToString() : ""; }
        }

        /// <summary>
        /// <see cref="gax::ResourceNameList{BookNameOneof}"/>-typed view over the <see cref="OptionalRepeatedResourceName"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<BookNameOneof> OptionalRepeatedResourceNameAsBookNameOneofs =>
            new gax::ResourceNameList<BookNameOneof>(OptionalRepeatedResourceName,
                str => BookNameOneof.Parse(str, true));

        /// <summary>
        /// <see cref="gax::ResourceNameList{BookNameOneof}"/>-typed view over the <see cref="OptionalRepeatedResourceNameOneof"/> resource name property.
        /// </summary>
        public gax::ResourceNameList<BookNameOneof> OptionalRepeatedResourceNameOneofAsBookNameOneofs =>
            new gax::ResourceNameList<BookNameOneof>(OptionalRepeatedResourceNameOneof,
                str => BookNameOneof.Parse(str, true));

    }

    public partial class UpdateBookIndexRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

    public partial class UpdateBookRequest
    {
        /// <summary>
        /// <see cref="Google.Example.Library.V1.BookNameOneof"/>-typed view over the <see cref="Name"/> resource name property.
        /// </summary>
        public Google.Example.Library.V1.BookNameOneof BookNameOneof
        {
            get { return string.IsNullOrEmpty(Name) ? null : Google.Example.Library.V1.BookNameOneof.Parse(Name, true); }
            set { Name = value != null ? value.ToString() : ""; }
        }

    }

}
